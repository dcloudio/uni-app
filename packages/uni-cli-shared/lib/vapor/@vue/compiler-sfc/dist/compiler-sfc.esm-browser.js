/**
* @vue/compiler-sfc v3.5.14
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}

const EMPTY_OBJ = Object.freeze({}) ;
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$3 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$3.call(val, key);
const isArray$3 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction$1 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isSymbol$1 = (val) => typeof val === "symbol";
const isObject$2 = (val) => val !== null && typeof val === "object";
const objectToString$1 = Object.prototype.toString;
const toTypeString = (value) => objectToString$1.call(value);
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isReservedProp$1 = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelizeReplacer = (_, c) => c ? c.toUpperCase() : "";
const camelize = cacheStringFunction(
  (str) => str.replace(camelizeRE, camelizeReplacer)
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
  }
);
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
function genCacheKey(source, options) {
  return source + JSON.stringify(
    options,
    (_, val) => typeof val === "function" ? val.toString() : val
  );
}
function canSetValueDirectly(tagName) {
  return tagName !== "PROGRESS" && // custom elements may use _value internally
  !tagName.includes("-");
}

const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `NEED_HYDRATION`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `HOISTED`,
  [-2]: `BAIL`
};

const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};

const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
  start = Math.max(0, Math.min(start, source.length));
  end = Math.max(0, Math.min(end, source.length));
  if (start > end) return "";
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(
          `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
        );
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i) {
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(
            1,
            end > count ? lineLength - pad : end - start
          );
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}

function normalizeStyle(value) {
  if (isArray$3(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$1(value) || isObject$2(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  if (!styles) return "";
  if (isString$1(styles)) return styles;
  let ret = "";
  for (const key in styles) {
    const value = styles[key];
    if (isString$1(value) || typeof value === "number") {
      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$1(value)) {
    res = value;
  } else if (isArray$3(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$2(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}

const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);

const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isBooleanAttr = /* @__PURE__ */ makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
);
const isKnownMathMLAttr = /* @__PURE__ */ makeMap(
  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`
);
function shouldSetAsAttr(tagName, key) {
  if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
    return true;
  }
  if (key === "form") {
    return true;
  }
  if (key === "list" && tagName === "INPUT") {
    return true;
  }
  if (key === "type" && tagName === "TEXTAREA") {
    return true;
  }
  if ((key === "width" || key === "height") && (tagName === "IMG" || tagName === "VIDEO" || tagName === "CANVAS" || tagName === "SOURCE")) {
    return true;
  }
  return false;
}

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
  const str = "" + string;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index;
  let lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.slice(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escaped;
  }
  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function getEscapedCssVarName(key, doubleEscape) {
  return key.replace(
    cssVarNameEscapeSymbolsRE,
    (s) => doubleEscape ? s === '"' ? '\\\\\\"' : `\\\\${s}` : `\\${s}`
  );
}

const isRef = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  switch (typeof val) {
    case "string":
      return val;
    case "object":
      if (val) {
        if (isRef(val)) {
          return toDisplayString(val.value);
        } else if (isArray$3(val) || val.toString === objectToString$1 || !isFunction$1(val.toString)) {
          return JSON.stringify(val, replacer, 2);
        }
      }
    default:
      return val == null ? "" : String(val);
  }
};
const replacer = (_key, val) => {
  if (isRef(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol$1(val)) {
    return stringifySymbol(val);
  } else if (isObject$2(val) && !isArray$3(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol$1(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
  );
};

const FRAGMENT = Symbol(`Fragment` );
const TELEPORT = Symbol(`Teleport` );
const SUSPENSE = Symbol(`Suspense` );
const KEEP_ALIVE = Symbol(`KeepAlive` );
const BASE_TRANSITION = Symbol(
  `BaseTransition` 
);
const OPEN_BLOCK = Symbol(`openBlock` );
const CREATE_BLOCK = Symbol(`createBlock` );
const CREATE_ELEMENT_BLOCK = Symbol(
  `createElementBlock` 
);
const CREATE_VNODE = Symbol(`createVNode` );
const CREATE_ELEMENT_VNODE = Symbol(
  `createElementVNode` 
);
const CREATE_COMMENT = Symbol(
  `createCommentVNode` 
);
const CREATE_TEXT = Symbol(
  `createTextVNode` 
);
const CREATE_STATIC = Symbol(
  `createStaticVNode` 
);
const RESOLVE_COMPONENT = Symbol(
  `resolveComponent` 
);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(
  `resolveDynamicComponent` 
);
const RESOLVE_DIRECTIVE = Symbol(
  `resolveDirective` 
);
const RESOLVE_FILTER = Symbol(
  `resolveFilter` 
);
const WITH_DIRECTIVES = Symbol(
  `withDirectives` 
);
const RENDER_LIST = Symbol(`renderList` );
const RENDER_SLOT = Symbol(`renderSlot` );
const CREATE_SLOTS = Symbol(`createSlots` );
const TO_DISPLAY_STRING = Symbol(
  `toDisplayString` 
);
const MERGE_PROPS = Symbol(`mergeProps` );
const NORMALIZE_CLASS = Symbol(
  `normalizeClass` 
);
const NORMALIZE_STYLE = Symbol(
  `normalizeStyle` 
);
const NORMALIZE_PROPS = Symbol(
  `normalizeProps` 
);
const GUARD_REACTIVE_PROPS = Symbol(
  `guardReactiveProps` 
);
const TO_HANDLERS = Symbol(`toHandlers` );
const CAMELIZE = Symbol(`camelize` );
const CAPITALIZE = Symbol(`capitalize` );
const TO_HANDLER_KEY = Symbol(
  `toHandlerKey` 
);
const SET_BLOCK_TRACKING = Symbol(
  `setBlockTracking` 
);
const PUSH_SCOPE_ID = Symbol(`pushScopeId` );
const POP_SCOPE_ID = Symbol(`popScopeId` );
const WITH_CTX = Symbol(`withCtx` );
const UNREF = Symbol(`unref` );
const IS_REF = Symbol(`isRef` );
const WITH_MEMO = Symbol(`withMemo` );
const IS_MEMO_SAME = Symbol(`isMemoSame` );
const helperNameMap = {
  [FRAGMENT]: `Fragment`,
  [TELEPORT]: `Teleport`,
  [SUSPENSE]: `Suspense`,
  [KEEP_ALIVE]: `KeepAlive`,
  [BASE_TRANSITION]: `BaseTransition`,
  [OPEN_BLOCK]: `openBlock`,
  [CREATE_BLOCK]: `createBlock`,
  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
  [CREATE_VNODE]: `createVNode`,
  [CREATE_ELEMENT_VNODE]: `createElementVNode`,
  [CREATE_COMMENT]: `createCommentVNode`,
  [CREATE_TEXT]: `createTextVNode`,
  [CREATE_STATIC]: `createStaticVNode`,
  [RESOLVE_COMPONENT]: `resolveComponent`,
  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
  [RESOLVE_DIRECTIVE]: `resolveDirective`,
  [RESOLVE_FILTER]: `resolveFilter`,
  [WITH_DIRECTIVES]: `withDirectives`,
  [RENDER_LIST]: `renderList`,
  [RENDER_SLOT]: `renderSlot`,
  [CREATE_SLOTS]: `createSlots`,
  [TO_DISPLAY_STRING]: `toDisplayString`,
  [MERGE_PROPS]: `mergeProps`,
  [NORMALIZE_CLASS]: `normalizeClass`,
  [NORMALIZE_STYLE]: `normalizeStyle`,
  [NORMALIZE_PROPS]: `normalizeProps`,
  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
  [TO_HANDLERS]: `toHandlers`,
  [CAMELIZE]: `camelize`,
  [CAPITALIZE]: `capitalize`,
  [TO_HANDLER_KEY]: `toHandlerKey`,
  [SET_BLOCK_TRACKING]: `setBlockTracking`,
  [PUSH_SCOPE_ID]: `pushScopeId`,
  [POP_SCOPE_ID]: `popScopeId`,
  [WITH_CTX]: `withCtx`,
  [UNREF]: `unref`,
  [IS_REF]: `isRef`,
  [WITH_MEMO]: `withMemo`,
  [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}

const Namespaces = {
  "HTML": 0,
  "0": "HTML",
  "SVG": 1,
  "1": "SVG",
  "MATH_ML": 2,
  "2": "MATH_ML"
};
const NodeTypes = {
  "ROOT": 0,
  "0": "ROOT",
  "ELEMENT": 1,
  "1": "ELEMENT",
  "TEXT": 2,
  "2": "TEXT",
  "COMMENT": 3,
  "3": "COMMENT",
  "SIMPLE_EXPRESSION": 4,
  "4": "SIMPLE_EXPRESSION",
  "INTERPOLATION": 5,
  "5": "INTERPOLATION",
  "ATTRIBUTE": 6,
  "6": "ATTRIBUTE",
  "DIRECTIVE": 7,
  "7": "DIRECTIVE",
  "COMPOUND_EXPRESSION": 8,
  "8": "COMPOUND_EXPRESSION",
  "IF": 9,
  "9": "IF",
  "IF_BRANCH": 10,
  "10": "IF_BRANCH",
  "FOR": 11,
  "11": "FOR",
  "TEXT_CALL": 12,
  "12": "TEXT_CALL",
  "VNODE_CALL": 13,
  "13": "VNODE_CALL",
  "JS_CALL_EXPRESSION": 14,
  "14": "JS_CALL_EXPRESSION",
  "JS_OBJECT_EXPRESSION": 15,
  "15": "JS_OBJECT_EXPRESSION",
  "JS_PROPERTY": 16,
  "16": "JS_PROPERTY",
  "JS_ARRAY_EXPRESSION": 17,
  "17": "JS_ARRAY_EXPRESSION",
  "JS_FUNCTION_EXPRESSION": 18,
  "18": "JS_FUNCTION_EXPRESSION",
  "JS_CONDITIONAL_EXPRESSION": 19,
  "19": "JS_CONDITIONAL_EXPRESSION",
  "JS_CACHE_EXPRESSION": 20,
  "20": "JS_CACHE_EXPRESSION",
  "JS_BLOCK_STATEMENT": 21,
  "21": "JS_BLOCK_STATEMENT",
  "JS_TEMPLATE_LITERAL": 22,
  "22": "JS_TEMPLATE_LITERAL",
  "JS_IF_STATEMENT": 23,
  "23": "JS_IF_STATEMENT",
  "JS_ASSIGNMENT_EXPRESSION": 24,
  "24": "JS_ASSIGNMENT_EXPRESSION",
  "JS_SEQUENCE_EXPRESSION": 25,
  "25": "JS_SEQUENCE_EXPRESSION",
  "JS_RETURN_STATEMENT": 26,
  "26": "JS_RETURN_STATEMENT"
};
const ElementTypes = {
  "ELEMENT": 0,
  "0": "ELEMENT",
  "COMPONENT": 1,
  "1": "COMPONENT",
  "SLOT": 2,
  "2": "SLOT",
  "TEMPLATE": 3,
  "3": "TEMPLATE"
};
const ConstantTypes = {
  "NOT_CONSTANT": 0,
  "0": "NOT_CONSTANT",
  "CAN_SKIP_PATCH": 1,
  "1": "CAN_SKIP_PATCH",
  "CAN_CACHE": 2,
  "2": "CAN_CACHE",
  "CAN_STRINGIFY": 3,
  "3": "CAN_STRINGIFY"
};
const locStub = {
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 },
  source: ""
};
function createRoot(children, source = "") {
  return {
    type: 0,
    source,
    children,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: [],
    temps: 0,
    codegenNode: void 0,
    loc: locStub
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString$1(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: isString$1(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, needPauseTracking = false, inVOnce = false) {
  return {
    type: 20,
    index,
    value,
    needPauseTracking,
    inVOnce,
    needArraySpread: false,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}

// Generated using scripts/write-decode-map.ts
var htmlDecodeTree = new Uint16Array(
// prettier-ignore
"\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
    .split("")
    .map((c) => c.charCodeAt(0)));

// Generated using scripts/write-decode-map.ts
var xmlDecodeTree = new Uint16Array(
// prettier-ignore
"\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
    .split("")
    .map((c) => c.charCodeAt(0)));

// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
var _a$1;
const decodeMap = new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376],
]);
/**
 * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
 */
const fromCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
(_a$1 = String.fromCodePoint) !== null && _a$1 !== void 0 ? _a$1 : function (codePoint) {
    let output = "";
    if (codePoint > 0xffff) {
        codePoint -= 0x10000;
        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
        codePoint = 0xdc00 | (codePoint & 0x3ff);
    }
    output += String.fromCharCode(codePoint);
    return output;
};
/**
 * Replace the given code point with a replacement character if it is a
 * surrogate or is outside the valid range. Otherwise return the code
 * point unchanged.
 */
function replaceCodePoint(codePoint) {
    var _a;
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return 0xfffd;
    }
    return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
}

var CharCodes;
(function (CharCodes) {
    CharCodes[CharCodes["NUM"] = 35] = "NUM";
    CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
    CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
    CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
    CharCodes[CharCodes["NINE"] = 57] = "NINE";
    CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
    CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
    CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
    CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
    CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
    CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
/** Bit that needs to be set to convert an upper case ASCII character to lower case */
const TO_LOWER_BIT = 0b100000;
var BinTrieFlags;
(function (BinTrieFlags) {
    BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber$1(code) {
    return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||
        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F));
}
function isAsciiAlphaNumeric(code) {
    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
        isNumber$1(code));
}
/**
 * Checks if the given character is a valid end character for an entity in an attribute.
 *
 * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
 * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
 */
function isEntityInAttributeInvalidEnd(code) {
    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function (EntityDecoderState) {
    EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function (DecodingMode) {
    /** Entities in text nodes that can end with any character. */
    DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
    /** Only allow entities terminated with a semicolon. */
    DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
    /** Entities in attributes have limitations on ending characters. */
    DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
/**
 * Token decoder with support of writing partial entities.
 */
class EntityDecoder {
    constructor(
    /** The tree used to decode entities. */
    decodeTree, 
    /**
     * The function that is called when a codepoint is decoded.
     *
     * For multi-byte named entities, this will be called multiple times,
     * with the second codepoint, and the same `consumed` value.
     *
     * @param codepoint The decoded codepoint.
     * @param consumed The number of bytes consumed by the decoder.
     */
    emitCodePoint, 
    /** An object that is used to produce errors. */
    errors) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors;
        /** The current state of the decoder. */
        this.state = EntityDecoderState.EntityStart;
        /** Characters that were consumed while parsing an entity. */
        this.consumed = 1;
        /**
         * The result of the entity.
         *
         * Either the result index of a numeric entity, or the codepoint of a
         * numeric entity.
         */
        this.result = 0;
        /** The current index in the decode tree. */
        this.treeIndex = 0;
        /** The number of characters that were consumed in excess. */
        this.excess = 1;
        /** The mode in which the decoder is operating. */
        this.decodeMode = DecodingMode.Strict;
    }
    /** Resets the instance to make it reusable. */
    startEntity(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
    }
    /**
     * Write an entity to the decoder. This can be called multiple times with partial entities.
     * If the entity is incomplete, the decoder will return -1.
     *
     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
     * entity is incomplete, and resume when the next string is written.
     *
     * @param string The string containing the entity (or a continuation of the entity).
     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    write(str, offset) {
        switch (this.state) {
            case EntityDecoderState.EntityStart: {
                if (str.charCodeAt(offset) === CharCodes.NUM) {
                    this.state = EntityDecoderState.NumericStart;
                    this.consumed += 1;
                    return this.stateNumericStart(str, offset + 1);
                }
                this.state = EntityDecoderState.NamedEntity;
                return this.stateNamedEntity(str, offset);
            }
            case EntityDecoderState.NumericStart: {
                return this.stateNumericStart(str, offset);
            }
            case EntityDecoderState.NumericDecimal: {
                return this.stateNumericDecimal(str, offset);
            }
            case EntityDecoderState.NumericHex: {
                return this.stateNumericHex(str, offset);
            }
            case EntityDecoderState.NamedEntity: {
                return this.stateNamedEntity(str, offset);
            }
        }
    }
    /**
     * Switches between the numeric decimal and hexadecimal states.
     *
     * Equivalent to the `Numeric character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericStart(str, offset) {
        if (offset >= str.length) {
            return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
    }
    addToNumericResult(str, start, end, base) {
        if (start !== end) {
            const digitCount = end - start;
            this.result =
                this.result * Math.pow(base, digitCount) +
                    parseInt(str.substr(start, digitCount), base);
            this.consumed += digitCount;
        }
    }
    /**
     * Parses a hexadecimal numeric entity.
     *
     * Equivalent to the `Hexademical character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericHex(str, offset) {
        const startIdx = offset;
        while (offset < str.length) {
            const char = str.charCodeAt(offset);
            if (isNumber$1(char) || isHexadecimalCharacter(char)) {
                offset += 1;
            }
            else {
                this.addToNumericResult(str, startIdx, offset, 16);
                return this.emitNumericEntity(char, 3);
            }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
    }
    /**
     * Parses a decimal numeric entity.
     *
     * Equivalent to the `Decimal character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericDecimal(str, offset) {
        const startIdx = offset;
        while (offset < str.length) {
            const char = str.charCodeAt(offset);
            if (isNumber$1(char)) {
                offset += 1;
            }
            else {
                this.addToNumericResult(str, startIdx, offset, 10);
                return this.emitNumericEntity(char, 2);
            }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
    }
    /**
     * Validate and emit a numeric entity.
     *
     * Implements the logic from the `Hexademical character reference start
     * state` and `Numeric character reference end state` in the HTML spec.
     *
     * @param lastCp The last code point of the entity. Used to see if the
     *               entity was terminated with a semicolon.
     * @param expectedLength The minimum number of characters that should be
     *                       consumed. Used to validate that at least one digit
     *                       was consumed.
     * @returns The number of characters that were consumed.
     */
    emitNumericEntity(lastCp, expectedLength) {
        var _a;
        // Ensure we consumed at least one digit.
        if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
        }
        // Figure out if this is a legit end of the entity
        if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
        }
        else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
        }
        this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
        if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
                this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
    }
    /**
     * Parses a named entity.
     *
     * Equivalent to the `Named character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNamedEntity(str, offset) {
        const { decodeTree } = this;
        let current = decodeTree[this.treeIndex];
        // The mask is the number of bytes of the value, including the current byte.
        let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
            const char = str.charCodeAt(offset);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
                return this.result === 0 ||
                    // If we are parsing an attribute
                    (this.decodeMode === DecodingMode.Attribute &&
                        // We shouldn't have consumed any characters after the entity,
                        (valueLength === 0 ||
                            // And there should be no invalid characters.
                            isEntityInAttributeInvalidEnd(char)))
                    ? 0
                    : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            // If the branch is a value, store it and continue
            if (valueLength !== 0) {
                // If the entity is terminated by a semicolon, we are done.
                if (char === CharCodes.SEMI) {
                    return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
                }
                // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
                if (this.decodeMode !== DecodingMode.Strict) {
                    this.result = this.treeIndex;
                    this.consumed += this.excess;
                    this.excess = 0;
                }
            }
        }
        return -1;
    }
    /**
     * Emit a named entity that was not terminated with a semicolon.
     *
     * @returns The number of characters consumed.
     */
    emitNotTerminatedNamedEntity() {
        var _a;
        const { result, decodeTree } = this;
        const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
    }
    /**
     * Emit a named entity.
     *
     * @param result The index of the entity in the decode tree.
     * @param valueLength The number of bytes in the entity.
     * @param consumed The number of characters consumed.
     *
     * @returns The number of characters consumed.
     */
    emitNamedEntityData(result, valueLength, consumed) {
        const { decodeTree } = this;
        this.emitCodePoint(valueLength === 1
            ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
            : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
            // For multi-byte values, we need to emit the second byte.
            this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
    }
    /**
     * Signal to the parser that the end of the input was reached.
     *
     * Remaining data will be emitted and relevant errors will be produced.
     *
     * @returns The number of characters consumed.
     */
    end() {
        var _a;
        switch (this.state) {
            case EntityDecoderState.NamedEntity: {
                // Emit a named entity if we have one.
                return this.result !== 0 &&
                    (this.decodeMode !== DecodingMode.Attribute ||
                        this.result === this.treeIndex)
                    ? this.emitNotTerminatedNamedEntity()
                    : 0;
            }
            // Otherwise, emit a numeric entity if we have one.
            case EntityDecoderState.NumericDecimal: {
                return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
                return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                return 0;
            }
            case EntityDecoderState.EntityStart: {
                // Return 0 if we have no entity.
                return 0;
            }
        }
    }
}
/**
 * Creates a function that decodes entities in a string.
 *
 * @param decodeTree The decode tree.
 * @returns A function that decodes entities in a string.
 */
function getDecoder(decodeTree) {
    let ret = "";
    const decoder = new EntityDecoder(decodeTree, (str) => (ret += fromCodePoint(str)));
    return function decodeWithTrie(str, decodeMode) {
        let lastIndex = 0;
        let offset = 0;
        while ((offset = str.indexOf("&", offset)) >= 0) {
            ret += str.slice(lastIndex, offset);
            decoder.startEntity(decodeMode);
            const len = decoder.write(str, 
            // Skip the "&"
            offset + 1);
            if (len < 0) {
                lastIndex = offset + decoder.end();
                break;
            }
            lastIndex = offset + len;
            // If `len` is 0, skip the current `&` and continue.
            offset = len === 0 ? lastIndex + 1 : lastIndex;
        }
        const result = ret + str.slice(lastIndex);
        // Make sure we don't keep a reference to the final string.
        ret = "";
        return result;
    };
}
/**
 * Determines the branch of the current node that is taken given the current
 * character. This function is used to traverse the trie.
 *
 * @param decodeTree The trie.
 * @param current The current node.
 * @param nodeIdx The index right after the current node and its value.
 * @param char The current character.
 * @returns The index of the next node, or -1 if no branch is taken.
 */
function determineBranch(decodeTree, current, nodeIdx, char) {
    const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    // Case 1: Single branch encoded in jump offset
    if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    // Case 2: Multiple branches encoded in jump table
    if (jumpOffset) {
        const value = char - jumpOffset;
        return value < 0 || value >= branchCount
            ? -1
            : decodeTree[nodeIdx + value] - 1;
    }
    // Case 3: Multiple branches encoded in dictionary
    // Binary search for the character.
    let lo = nodeIdx;
    let hi = lo + branchCount - 1;
    while (lo <= hi) {
        const mid = (lo + hi) >>> 1;
        const midVal = decodeTree[mid];
        if (midVal < char) {
            lo = mid + 1;
        }
        else if (midVal > char) {
            hi = mid - 1;
        }
        else {
            return decodeTree[mid + branchCount];
        }
    }
    return -1;
}
const htmlDecoder = getDecoder(htmlDecodeTree);
getDecoder(xmlDecodeTree);
/**
 * Decodes an HTML string.
 *
 * @param str The string to decode.
 * @param mode The decoding mode.
 * @returns The decoded string.
 */
function decodeHTML(str, mode = DecodingMode.Legacy) {
    return htmlDecoder(str, mode);
}

const defaultDelimitersOpen = new Uint8Array([123, 123]);
const defaultDelimitersClose = new Uint8Array([125, 125]);
function isTagStartChar(c) {
  return c >= 97 && c <= 122 || c >= 65 && c <= 90;
}
function isWhitespace(c) {
  return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
}
function isEndOfTagSection(c) {
  return c === 47 || c === 62 || isWhitespace(c);
}
function toCharCodes(str) {
  const ret = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
const Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea
};
class Tokenizer {
  constructor(stack, cbs) {
    this.stack = stack;
    this.cbs = cbs;
    /** The current state the tokenizer is in. */
    this.state = 1;
    /** The read buffer. */
    this.buffer = "";
    /** The beginning of the section that is currently being read. */
    this.sectionStart = 0;
    /** The index within the buffer that we are currently looking at. */
    this.index = 0;
    /** The start of the last entity. */
    this.entityStart = 0;
    /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
    this.baseState = 1;
    /** For special parsing behavior inside of script and style tags. */
    this.inRCDATA = false;
    /** For disabling RCDATA tags handling */
    this.inXML = false;
    /** For disabling interpolation parsing in v-pre */
    this.inVPre = false;
    /** Record newline positions for fast line / column calculation */
    this.newlines = [];
    this.mode = 0;
    this.delimiterOpen = defaultDelimitersOpen;
    this.delimiterClose = defaultDelimitersClose;
    this.delimiterIndex = -1;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
    {
      this.entityDecoder = new EntityDecoder(
        htmlDecodeTree,
        (cp, consumed) => this.emitCodePoint(cp, consumed)
      );
    }
  }
  get inSFCRoot() {
    return this.mode === 2 && this.stack.length === 0;
  }
  reset() {
    this.state = 1;
    this.mode = 0;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = 1;
    this.inRCDATA = false;
    this.currentSequence = void 0;
    this.newlines.length = 0;
    this.delimiterOpen = defaultDelimitersOpen;
    this.delimiterClose = defaultDelimitersClose;
  }
  /**
   * Generate Position object with line / column information using recorded
   * newline positions. We know the index is always going to be an already
   * processed index, so all the newlines up to this index should have been
   * recorded.
   */
  getPos(index) {
    let line = 1;
    let column = index + 1;
    for (let i = this.newlines.length - 1; i >= 0; i--) {
      const newlineIndex = this.newlines[i];
      if (index > newlineIndex) {
        line = i + 2;
        column = index - newlineIndex;
        break;
      }
    }
    return {
      column,
      line,
      offset: index
    };
  }
  peek() {
    return this.buffer.charCodeAt(this.index + 1);
  }
  stateText(c) {
    if (c === 60) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = 5;
      this.sectionStart = this.index;
    } else if (c === 38) {
      this.startEntity();
    } else if (!this.inVPre && c === this.delimiterOpen[0]) {
      this.state = 2;
      this.delimiterIndex = 0;
      this.stateInterpolationOpen(c);
    }
  }
  stateInterpolationOpen(c) {
    if (c === this.delimiterOpen[this.delimiterIndex]) {
      if (this.delimiterIndex === this.delimiterOpen.length - 1) {
        const start = this.index + 1 - this.delimiterOpen.length;
        if (start > this.sectionStart) {
          this.cbs.ontext(this.sectionStart, start);
        }
        this.state = 3;
        this.sectionStart = start;
      } else {
        this.delimiterIndex++;
      }
    } else if (this.inRCDATA) {
      this.state = 32;
      this.stateInRCDATA(c);
    } else {
      this.state = 1;
      this.stateText(c);
    }
  }
  stateInterpolation(c) {
    if (c === this.delimiterClose[0]) {
      this.state = 4;
      this.delimiterIndex = 0;
      this.stateInterpolationClose(c);
    }
  }
  stateInterpolationClose(c) {
    if (c === this.delimiterClose[this.delimiterIndex]) {
      if (this.delimiterIndex === this.delimiterClose.length - 1) {
        this.cbs.oninterpolation(this.sectionStart, this.index + 1);
        if (this.inRCDATA) {
          this.state = 32;
        } else {
          this.state = 1;
        }
        this.sectionStart = this.index + 1;
      } else {
        this.delimiterIndex++;
      }
    } else {
      this.state = 3;
      this.stateInterpolation(c);
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.inRCDATA = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = 6;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> and <textarea>, also decode entities. */
  stateInRCDATA(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === 62 || isWhitespace(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        this.inRCDATA = false;
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
        if (c === 38) {
          this.startEntity();
        } else if (!this.inVPre && c === this.delimiterOpen[0]) {
          this.state = 2;
          this.delimiterIndex = 0;
          this.stateInterpolationOpen(c);
        }
      } else if (this.fastForwardTo(60)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === 60);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = 28;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = 23;
      this.stateInDeclaration(c);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length) {
      const cc = this.buffer.charCodeAt(this.index);
      if (cc === 10) {
        this.newlines.push(this.index);
      }
      if (cc === c) {
        return true;
      }
    }
    this.index = this.buffer.length - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index - 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index - 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = 1;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  startSpecial(sequence, offset) {
    this.enterRCDATA(sequence, offset);
    this.state = 31;
  }
  enterRCDATA(sequence, offset) {
    this.inRCDATA = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
  }
  stateBeforeTagName(c) {
    if (c === 33) {
      this.state = 22;
      this.sectionStart = this.index + 1;
    } else if (c === 63) {
      this.state = 24;
      this.sectionStart = this.index + 1;
    } else if (isTagStartChar(c)) {
      this.sectionStart = this.index;
      if (this.mode === 0) {
        this.state = 6;
      } else if (this.inSFCRoot) {
        this.state = 34;
      } else if (!this.inXML) {
        if (c === 116) {
          this.state = 30;
        } else {
          this.state = c === 115 ? 29 : 6;
        }
      } else {
        this.state = 6;
      }
    } else if (c === 47) {
      this.state = 8;
    } else {
      this.state = 1;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.handleTagName(c);
    }
  }
  stateInSFCRootTagName(c) {
    if (isEndOfTagSection(c)) {
      const tag = this.buffer.slice(this.sectionStart, this.index);
      if (tag !== "template") {
        this.enterRCDATA(toCharCodes(`</` + tag), 0);
      }
      this.handleTagName(c);
    }
  }
  handleTagName(c) {
    this.cbs.onopentagname(this.sectionStart, this.index);
    this.sectionStart = -1;
    this.state = 11;
    this.stateBeforeAttrName(c);
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace(c)) ; else if (c === 62) {
      {
        this.cbs.onerr(14, this.index);
      }
      this.state = 1;
      this.sectionStart = this.index + 1;
    } else {
      this.state = isTagStartChar(c) ? 9 : 27;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === 62 || isWhitespace(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = 10;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === 62) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttrName(c) {
    if (c === 62) {
      this.cbs.onopentagend(this.index);
      if (this.inRCDATA) {
        this.state = 32;
      } else {
        this.state = 1;
      }
      this.sectionStart = this.index + 1;
    } else if (c === 47) {
      this.state = 7;
      if (this.peek() !== 62) {
        this.cbs.onerr(22, this.index);
      }
    } else if (c === 60 && this.peek() === 47) {
      this.cbs.onopentagend(this.index);
      this.state = 5;
      this.sectionStart = this.index;
    } else if (!isWhitespace(c)) {
      if (c === 61) {
        this.cbs.onerr(
          19,
          this.index
        );
      }
      this.handleAttrStart(c);
    }
  }
  handleAttrStart(c) {
    if (c === 118 && this.peek() === 45) {
      this.state = 13;
      this.sectionStart = this.index;
    } else if (c === 46 || c === 58 || c === 64 || c === 35) {
      this.cbs.ondirname(this.index, this.index + 1);
      this.state = 14;
      this.sectionStart = this.index + 1;
    } else {
      this.state = 12;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === 62) {
      this.cbs.onselfclosingtag(this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
      this.inRCDATA = false;
    } else if (!isWhitespace(c)) {
      this.state = 11;
      this.stateBeforeAttrName(c);
    }
  }
  stateInAttrName(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 34 || c === 39 || c === 60) {
      this.cbs.onerr(
        17,
        this.index
      );
    }
  }
  stateInDirName(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 58) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.state = 14;
      this.sectionStart = this.index + 1;
    } else if (c === 46) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.state = 16;
      this.sectionStart = this.index + 1;
    }
  }
  stateInDirArg(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirarg(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 91) {
      this.state = 15;
    } else if (c === 46) {
      this.cbs.ondirarg(this.sectionStart, this.index);
      this.state = 16;
      this.sectionStart = this.index + 1;
    }
  }
  stateInDynamicDirArg(c) {
    if (c === 93) {
      this.state = 14;
    } else if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirarg(this.sectionStart, this.index + 1);
      this.handleAttrNameEnd(c);
      {
        this.cbs.onerr(
          27,
          this.index
        );
      }
    }
  }
  stateInDirModifier(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirmodifier(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 46) {
      this.cbs.ondirmodifier(this.sectionStart, this.index);
      this.sectionStart = this.index + 1;
    }
  }
  handleAttrNameEnd(c) {
    this.sectionStart = this.index;
    this.state = 17;
    this.cbs.onattribnameend(this.index);
    this.stateAfterAttrName(c);
  }
  stateAfterAttrName(c) {
    if (c === 61) {
      this.state = 18;
    } else if (c === 47 || c === 62) {
      this.cbs.onattribend(0, this.sectionStart);
      this.sectionStart = -1;
      this.state = 11;
      this.stateBeforeAttrName(c);
    } else if (!isWhitespace(c)) {
      this.cbs.onattribend(0, this.sectionStart);
      this.handleAttrStart(c);
    }
  }
  stateBeforeAttrValue(c) {
    if (c === 34) {
      this.state = 19;
      this.sectionStart = this.index + 1;
    } else if (c === 39) {
      this.state = 20;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c)) {
      this.sectionStart = this.index;
      this.state = 21;
      this.stateInAttrValueNoQuotes(c);
    }
  }
  handleInAttrValue(c, quote) {
    if (c === quote || false) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(
        quote === 34 ? 3 : 2,
        this.index + 1
      );
      this.state = 11;
    } else if (c === 38) {
      this.startEntity();
    }
  }
  stateInAttrValueDoubleQuotes(c) {
    this.handleInAttrValue(c, 34);
  }
  stateInAttrValueSingleQuotes(c) {
    this.handleInAttrValue(c, 39);
  }
  stateInAttrValueNoQuotes(c) {
    if (isWhitespace(c) || c === 62) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(1, this.index);
      this.state = 11;
      this.stateBeforeAttrName(c);
    } else if (c === 34 || c === 39 || c === 60 || c === 61 || c === 96) {
      this.cbs.onerr(
        18,
        this.index
      );
    } else if (c === 38) {
      this.startEntity();
    }
  }
  stateBeforeDeclaration(c) {
    if (c === 91) {
      this.state = 26;
      this.sequenceIndex = 0;
    } else {
      this.state = c === 45 ? 25 : 23;
    }
  }
  stateInDeclaration(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === 45) {
      this.state = 28;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = 23;
    }
  }
  stateInSpecialComment(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.cbs.oncomment(this.sectionStart, this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    if (c === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (c === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = 6;
      this.stateInTagName(c);
    }
  }
  stateBeforeSpecialT(c) {
    if (c === Sequences.TitleEnd[3]) {
      this.startSpecial(Sequences.TitleEnd, 4);
    } else if (c === Sequences.TextareaEnd[3]) {
      this.startSpecial(Sequences.TextareaEnd, 4);
    } else {
      this.state = 6;
      this.stateInTagName(c);
    }
  }
  startEntity() {
    {
      this.baseState = this.state;
      this.state = 33;
      this.entityStart = this.index;
      this.entityDecoder.startEntity(
        this.baseState === 1 || this.baseState === 32 ? DecodingMode.Legacy : DecodingMode.Attribute
      );
    }
  }
  stateInEntity() {
    {
      const length = this.entityDecoder.write(this.buffer, this.index);
      if (length >= 0) {
        this.state = this.baseState;
        if (length === 0) {
          this.index = this.entityStart;
        }
      } else {
        this.index = this.buffer.length - 1;
      }
    }
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse(input) {
    this.buffer = input;
    while (this.index < this.buffer.length) {
      const c = this.buffer.charCodeAt(this.index);
      if (c === 10) {
        this.newlines.push(this.index);
      }
      switch (this.state) {
        case 1: {
          this.stateText(c);
          break;
        }
        case 2: {
          this.stateInterpolationOpen(c);
          break;
        }
        case 3: {
          this.stateInterpolation(c);
          break;
        }
        case 4: {
          this.stateInterpolationClose(c);
          break;
        }
        case 31: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case 32: {
          this.stateInRCDATA(c);
          break;
        }
        case 26: {
          this.stateCDATASequence(c);
          break;
        }
        case 19: {
          this.stateInAttrValueDoubleQuotes(c);
          break;
        }
        case 12: {
          this.stateInAttrName(c);
          break;
        }
        case 13: {
          this.stateInDirName(c);
          break;
        }
        case 14: {
          this.stateInDirArg(c);
          break;
        }
        case 15: {
          this.stateInDynamicDirArg(c);
          break;
        }
        case 16: {
          this.stateInDirModifier(c);
          break;
        }
        case 28: {
          this.stateInCommentLike(c);
          break;
        }
        case 27: {
          this.stateInSpecialComment(c);
          break;
        }
        case 11: {
          this.stateBeforeAttrName(c);
          break;
        }
        case 6: {
          this.stateInTagName(c);
          break;
        }
        case 34: {
          this.stateInSFCRootTagName(c);
          break;
        }
        case 9: {
          this.stateInClosingTagName(c);
          break;
        }
        case 5: {
          this.stateBeforeTagName(c);
          break;
        }
        case 17: {
          this.stateAfterAttrName(c);
          break;
        }
        case 20: {
          this.stateInAttrValueSingleQuotes(c);
          break;
        }
        case 18: {
          this.stateBeforeAttrValue(c);
          break;
        }
        case 8: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case 10: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case 29: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case 30: {
          this.stateBeforeSpecialT(c);
          break;
        }
        case 21: {
          this.stateInAttrValueNoQuotes(c);
          break;
        }
        case 7: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case 23: {
          this.stateInDeclaration(c);
          break;
        }
        case 22: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case 25: {
          this.stateBeforeComment(c);
          break;
        }
        case 24: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case 33: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
    this.finish();
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.sectionStart !== this.index) {
      if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === 19 || this.state === 20 || this.state === 21) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  finish() {
    if (this.state === 33) {
      this.entityDecoder.end();
      this.state = this.baseState;
    }
    this.handleTrailingData();
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length;
    if (this.sectionStart >= endIndex) {
      return;
    }
    if (this.state === 28) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex);
      }
    } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9) ; else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitCodePoint(cp, consumed) {
    {
      if (this.baseState !== 1 && this.baseState !== 32) {
        if (this.sectionStart < this.entityStart) {
          this.cbs.onattribdata(this.sectionStart, this.entityStart);
        }
        this.sectionStart = this.entityStart + consumed;
        this.index = this.sectionStart - 1;
        this.cbs.onattribentity(
          fromCodePoint(cp),
          this.entityStart,
          this.sectionStart
        );
      } else {
        if (this.sectionStart < this.entityStart) {
          this.cbs.ontext(this.sectionStart, this.entityStart);
        }
        this.sectionStart = this.entityStart + consumed;
        this.index = this.sectionStart - 1;
        this.cbs.ontextentity(
          fromCodePoint(cp),
          this.entityStart,
          this.sectionStart
        );
      }
    }
  }
}

const CompilerDeprecationTypes = {
  "COMPILER_IS_ON_ELEMENT": "COMPILER_IS_ON_ELEMENT",
  "COMPILER_V_BIND_SYNC": "COMPILER_V_BIND_SYNC",
  "COMPILER_V_BIND_OBJECT_ORDER": "COMPILER_V_BIND_OBJECT_ORDER",
  "COMPILER_V_ON_NATIVE": "COMPILER_V_ON_NATIVE",
  "COMPILER_V_IF_V_FOR_PRECEDENCE": "COMPILER_V_IF_V_FOR_PRECEDENCE",
  "COMPILER_NATIVE_TEMPLATE": "COMPILER_NATIVE_TEMPLATE",
  "COMPILER_INLINE_TEMPLATE": "COMPILER_INLINE_TEMPLATE",
  "COMPILER_FILTERS": "COMPILER_FILTERS"
};
const deprecationData = {
  ["COMPILER_IS_ON_ELEMENT"]: {
    message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
  },
  ["COMPILER_V_BIND_SYNC"]: {
    message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
  },
  ["COMPILER_V_BIND_OBJECT_ORDER"]: {
    message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
  },
  ["COMPILER_V_ON_NATIVE"]: {
    message: `.native modifier for v-on has been removed as is no longer necessary.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
  },
  ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
    message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
  },
  ["COMPILER_NATIVE_TEMPLATE"]: {
    message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
  },
  ["COMPILER_INLINE_TEMPLATE"]: {
    message: `"inline-template" has been removed in Vue 3.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
  },
  ["COMPILER_FILTERS"]: {
    message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
  }
};
function getCompatValue(key, { compatConfig }) {
  const value = compatConfig && compatConfig[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  if (enabled) {
    warnDeprecation(key, context, loc, ...args);
  }
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc) err.loc = loc;
  context.onWarn(err);
}

function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
  console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = (messages || errorMessages$1)[code] + (additionalMessage || ``) ;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
const ErrorCodes = {
  "ABRUPT_CLOSING_OF_EMPTY_COMMENT": 0,
  "0": "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
  "CDATA_IN_HTML_CONTENT": 1,
  "1": "CDATA_IN_HTML_CONTENT",
  "DUPLICATE_ATTRIBUTE": 2,
  "2": "DUPLICATE_ATTRIBUTE",
  "END_TAG_WITH_ATTRIBUTES": 3,
  "3": "END_TAG_WITH_ATTRIBUTES",
  "END_TAG_WITH_TRAILING_SOLIDUS": 4,
  "4": "END_TAG_WITH_TRAILING_SOLIDUS",
  "EOF_BEFORE_TAG_NAME": 5,
  "5": "EOF_BEFORE_TAG_NAME",
  "EOF_IN_CDATA": 6,
  "6": "EOF_IN_CDATA",
  "EOF_IN_COMMENT": 7,
  "7": "EOF_IN_COMMENT",
  "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT": 8,
  "8": "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
  "EOF_IN_TAG": 9,
  "9": "EOF_IN_TAG",
  "INCORRECTLY_CLOSED_COMMENT": 10,
  "10": "INCORRECTLY_CLOSED_COMMENT",
  "INCORRECTLY_OPENED_COMMENT": 11,
  "11": "INCORRECTLY_OPENED_COMMENT",
  "INVALID_FIRST_CHARACTER_OF_TAG_NAME": 12,
  "12": "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
  "MISSING_ATTRIBUTE_VALUE": 13,
  "13": "MISSING_ATTRIBUTE_VALUE",
  "MISSING_END_TAG_NAME": 14,
  "14": "MISSING_END_TAG_NAME",
  "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES": 15,
  "15": "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
  "NESTED_COMMENT": 16,
  "16": "NESTED_COMMENT",
  "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME": 17,
  "17": "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
  "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE": 18,
  "18": "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
  "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME": 19,
  "19": "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
  "UNEXPECTED_NULL_CHARACTER": 20,
  "20": "UNEXPECTED_NULL_CHARACTER",
  "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME": 21,
  "21": "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
  "UNEXPECTED_SOLIDUS_IN_TAG": 22,
  "22": "UNEXPECTED_SOLIDUS_IN_TAG",
  "X_INVALID_END_TAG": 23,
  "23": "X_INVALID_END_TAG",
  "X_MISSING_END_TAG": 24,
  "24": "X_MISSING_END_TAG",
  "X_MISSING_INTERPOLATION_END": 25,
  "25": "X_MISSING_INTERPOLATION_END",
  "X_MISSING_DIRECTIVE_NAME": 26,
  "26": "X_MISSING_DIRECTIVE_NAME",
  "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END": 27,
  "27": "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
  "X_V_IF_NO_EXPRESSION": 28,
  "28": "X_V_IF_NO_EXPRESSION",
  "X_V_IF_SAME_KEY": 29,
  "29": "X_V_IF_SAME_KEY",
  "X_V_ELSE_NO_ADJACENT_IF": 30,
  "30": "X_V_ELSE_NO_ADJACENT_IF",
  "X_V_FOR_NO_EXPRESSION": 31,
  "31": "X_V_FOR_NO_EXPRESSION",
  "X_V_FOR_MALFORMED_EXPRESSION": 32,
  "32": "X_V_FOR_MALFORMED_EXPRESSION",
  "X_V_FOR_TEMPLATE_KEY_PLACEMENT": 33,
  "33": "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
  "X_V_BIND_NO_EXPRESSION": 34,
  "34": "X_V_BIND_NO_EXPRESSION",
  "X_V_ON_NO_EXPRESSION": 35,
  "35": "X_V_ON_NO_EXPRESSION",
  "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET": 36,
  "36": "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
  "X_V_SLOT_MIXED_SLOT_USAGE": 37,
  "37": "X_V_SLOT_MIXED_SLOT_USAGE",
  "X_V_SLOT_DUPLICATE_SLOT_NAMES": 38,
  "38": "X_V_SLOT_DUPLICATE_SLOT_NAMES",
  "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN": 39,
  "39": "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
  "X_V_SLOT_MISPLACED": 40,
  "40": "X_V_SLOT_MISPLACED",
  "X_V_MODEL_NO_EXPRESSION": 41,
  "41": "X_V_MODEL_NO_EXPRESSION",
  "X_V_MODEL_MALFORMED_EXPRESSION": 42,
  "42": "X_V_MODEL_MALFORMED_EXPRESSION",
  "X_V_MODEL_ON_SCOPE_VARIABLE": 43,
  "43": "X_V_MODEL_ON_SCOPE_VARIABLE",
  "X_V_MODEL_ON_PROPS": 44,
  "44": "X_V_MODEL_ON_PROPS",
  "X_INVALID_EXPRESSION": 45,
  "45": "X_INVALID_EXPRESSION",
  "X_KEEP_ALIVE_INVALID_CHILDREN": 46,
  "46": "X_KEEP_ALIVE_INVALID_CHILDREN",
  "X_PREFIX_ID_NOT_SUPPORTED": 47,
  "47": "X_PREFIX_ID_NOT_SUPPORTED",
  "X_MODULE_MODE_NOT_SUPPORTED": 48,
  "48": "X_MODULE_MODE_NOT_SUPPORTED",
  "X_CACHE_HANDLER_NOT_SUPPORTED": 49,
  "49": "X_CACHE_HANDLER_NOT_SUPPORTED",
  "X_SCOPE_ID_NOT_SUPPORTED": 50,
  "50": "X_SCOPE_ID_NOT_SUPPORTED",
  "X_VNODE_HOOKS": 51,
  "51": "X_VNODE_HOOKS",
  "X_V_BIND_INVALID_SAME_NAME_ARGUMENT": 52,
  "52": "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
  "__EXTEND_POINT__": 53,
  "53": "__EXTEND_POINT__"
};
const errorMessages$1 = {
  // parse errors
  [0]: "Illegal comment.",
  [1]: "CDATA section is allowed only in XML context.",
  [2]: "Duplicate attribute.",
  [3]: "End tag cannot have attributes.",
  [4]: "Illegal '/' in tags.",
  [5]: "Unexpected EOF in tag.",
  [6]: "Unexpected EOF in CDATA section.",
  [7]: "Unexpected EOF in comment.",
  [8]: "Unexpected EOF in script.",
  [9]: "Unexpected EOF in tag.",
  [10]: "Incorrectly closed comment.",
  [11]: "Incorrectly opened comment.",
  [12]: "Illegal tag name. Use '&lt;' to print '<'.",
  [13]: "Attribute value was expected.",
  [14]: "End tag name was expected.",
  [15]: "Whitespace was expected.",
  [16]: "Unexpected '<!--' in comment.",
  [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  [19]: "Attribute name cannot start with '='.",
  [21]: "'<?' is allowed only in XML context.",
  [20]: `Unexpected null character.`,
  [22]: "Illegal '/' in tags.",
  // Vue-specific parse errors
  [23]: "Invalid end tag.",
  [24]: "Element is missing end tag.",
  [25]: "Interpolation end sign was not found.",
  [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  [26]: "Legal directive name was expected.",
  // transform errors
  [28]: `v-if/v-else-if is missing expression.`,
  [29]: `v-if/else branches must use unique keys.`,
  [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
  [31]: `v-for is missing expression.`,
  [32]: `v-for has invalid expression.`,
  [33]: `<template v-for> key should be placed on the <template> tag.`,
  [34]: `v-bind is missing expression.`,
  [52]: `v-bind with same-name shorthand only allows static argument.`,
  [35]: `v-on is missing expression.`,
  [36]: `Unexpected custom directive on <slot> outlet.`,
  [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
  [38]: `Duplicate slot names found. `,
  [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
  [40]: `v-slot can only be used on components or <template> tags.`,
  [41]: `v-model is missing expression.`,
  [42]: `v-model value must be a valid JavaScript member expression.`,
  [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
  [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
  [45]: `Error parsing JavaScript expression: `,
  [46]: `<KeepAlive> expects exactly one child component.`,
  [51]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
  // generic errors
  [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
  [48]: `ES module mode is not supported in this build of compiler.`,
  [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
  [50]: `"scopeId" option is only supported in module mode.`,
  // just to fulfill types
  [53]: ``
};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			var isInstance = false;
      try {
        isInstance = this instanceof a;
      } catch {}
			if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var lib = {};

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;

	Object.defineProperty(lib, '__esModule', {
	  value: true
	});
	function _objectWithoutPropertiesLoose(r, e) {
	  if (null == r) return {};
	  var t = {};
	  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
	    if (-1 !== e.indexOf(n)) continue;
	    t[n] = r[n];
	  }
	  return t;
	}
	class Position {
	  constructor(line, col, index) {
	    this.line = void 0;
	    this.column = void 0;
	    this.index = void 0;
	    this.line = line;
	    this.column = col;
	    this.index = index;
	  }
	}
	class SourceLocation {
	  constructor(start, end) {
	    this.start = void 0;
	    this.end = void 0;
	    this.filename = void 0;
	    this.identifierName = void 0;
	    this.start = start;
	    this.end = end;
	  }
	}
	function createPositionWithColumnOffset(position, columnOffset) {
	  const {
	    line,
	    column,
	    index
	  } = position;
	  return new Position(line, column + columnOffset, index + columnOffset);
	}
	const code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
	var ModuleErrors = {
	  ImportMetaOutsideModule: {
	    message: `import.meta may appear only with 'sourceType: "module"'`,
	    code
	  },
	  ImportOutsideModule: {
	    message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
	    code
	  }
	};
	const NodeDescriptions = {
	  ArrayPattern: "array destructuring pattern",
	  AssignmentExpression: "assignment expression",
	  AssignmentPattern: "assignment expression",
	  ArrowFunctionExpression: "arrow function expression",
	  ConditionalExpression: "conditional expression",
	  CatchClause: "catch clause",
	  ForOfStatement: "for-of statement",
	  ForInStatement: "for-in statement",
	  ForStatement: "for-loop",
	  FormalParameters: "function parameter list",
	  Identifier: "identifier",
	  ImportSpecifier: "import specifier",
	  ImportDefaultSpecifier: "import default specifier",
	  ImportNamespaceSpecifier: "import namespace specifier",
	  ObjectPattern: "object destructuring pattern",
	  ParenthesizedExpression: "parenthesized expression",
	  RestElement: "rest element",
	  UpdateExpression: {
	    true: "prefix operation",
	    false: "postfix operation"
	  },
	  VariableDeclarator: "variable declaration",
	  YieldExpression: "yield expression"
	};
	const toNodeDescription = node => node.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];
	var StandardErrors = {
	  AccessorIsGenerator: ({
	    kind
	  }) => `A ${kind}ter cannot be a generator.`,
	  ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
	  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
	  AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
	  AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
	  AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
	  AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
	  AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
	  BadGetterArity: "A 'get' accessor must not have any formal parameters.",
	  BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
	  BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
	  ConstructorClassField: "Classes may not have a field named 'constructor'.",
	  ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
	  ConstructorIsAccessor: "Class constructor may not be an accessor.",
	  ConstructorIsAsync: "Constructor can't be an async function.",
	  ConstructorIsGenerator: "Constructor can't be a generator.",
	  DeclarationMissingInitializer: ({
	    kind
	  }) => `Missing initializer in ${kind} declaration.`,
	  DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
	  DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
	  DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
	  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
	  DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
	  DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
	  DecoratorStaticBlock: "Decorators can't be used with a static block.",
	  DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
	  DeletePrivateField: "Deleting a private field is not allowed.",
	  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
	  DuplicateConstructor: "Duplicate constructor in the same class.",
	  DuplicateDefaultExport: "Only one default export allowed per module.",
	  DuplicateExport: ({
	    exportName
	  }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
	  DuplicateProto: "Redefinition of __proto__ property.",
	  DuplicateRegExpFlags: "Duplicate regular expression flag.",
	  ElementAfterRest: "Rest element must be last element.",
	  EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
	  ExportBindingIsString: ({
	    localName,
	    exportName
	  }) => `A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
	  ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
	  ForInOfLoopInitializer: ({
	    type
	  }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
	  ForInUsing: "For-in loop may not start with 'using' declaration.",
	  ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
	  ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
	  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
	  IllegalBreakContinue: ({
	    type
	  }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
	  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
	  IllegalReturn: "'return' outside of function.",
	  ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
	  ImportBindingIsString: ({
	    importName
	  }) => `A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${importName}" as foo }\`?`,
	  ImportCallArity: `\`import()\` requires exactly one or two arguments.`,
	  ImportCallNotNewExpression: "Cannot use new with import(...).",
	  ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
	  ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
	  ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
	  ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
	  IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
	  InvalidBigIntLiteral: "Invalid BigIntLiteral.",
	  InvalidCodePoint: "Code point out of bounds.",
	  InvalidCoverInitializedName: "Invalid shorthand property initializer.",
	  InvalidDecimal: "Invalid decimal.",
	  InvalidDigit: ({
	    radix
	  }) => `Expected number in radix ${radix}.`,
	  InvalidEscapeSequence: "Bad character escape sequence.",
	  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
	  InvalidEscapedReservedWord: ({
	    reservedWord
	  }) => `Escape sequence in keyword ${reservedWord}.`,
	  InvalidIdentifier: ({
	    identifierName
	  }) => `Invalid identifier ${identifierName}.`,
	  InvalidLhs: ({
	    ancestor
	  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
	  InvalidLhsBinding: ({
	    ancestor
	  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
	  InvalidLhsOptionalChaining: ({
	    ancestor
	  }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
	  InvalidNumber: "Invalid number.",
	  InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
	  InvalidOrUnexpectedToken: ({
	    unexpected
	  }) => `Unexpected character '${unexpected}'.`,
	  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
	  InvalidPrivateFieldResolution: ({
	    identifierName
	  }) => `Private name #${identifierName} is not defined.`,
	  InvalidPropertyBindingPattern: "Binding member expression.",
	  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
	  InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
	  LabelRedeclaration: ({
	    labelName
	  }) => `Label '${labelName}' is already declared.`,
	  LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
	  LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
	  MalformedRegExpFlags: "Invalid regular expression flag.",
	  MissingClassName: "A class name is required.",
	  MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
	  MissingSemicolon: "Missing semicolon.",
	  MissingPlugin: ({
	    missingPlugin
	  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map(name => JSON.stringify(name)).join(", ")}.`,
	  MissingOneOfPlugins: ({
	    missingPlugin
	  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map(name => JSON.stringify(name)).join(", ")}.`,
	  MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
	  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
	  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
	  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
	  ModuleAttributesWithDuplicateKeys: ({
	    key
	  }) => `Duplicate key "${key}" is not allowed in module attributes.`,
	  ModuleExportNameHasLoneSurrogate: ({
	    surrogateCharCode
	  }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
	  ModuleExportUndefined: ({
	    localName
	  }) => `Export '${localName}' is not defined.`,
	  MultipleDefaultsInSwitch: "Multiple default clauses.",
	  NewlineAfterThrow: "Illegal newline after throw.",
	  NoCatchOrFinally: "Missing catch or finally clause.",
	  NumberIdentifier: "Identifier directly after number.",
	  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
	  ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
	  OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
	  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
	  OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
	  ParamDupe: "Argument name clash.",
	  PatternHasAccessor: "Object pattern can't contain getter or setter.",
	  PatternHasMethod: "Object pattern can't contain methods.",
	  PrivateInExpectedIn: ({
	    identifierName
	  }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
	  PrivateNameRedeclaration: ({
	    identifierName
	  }) => `Duplicate private name #${identifierName}.`,
	  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
	  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
	  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
	  RecordNoProto: "'__proto__' is not allowed in Record expressions.",
	  RestTrailingComma: "Unexpected trailing comma after rest element.",
	  SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
	  SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
	  SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
	  StaticPrototype: "Classes may not have static property named prototype.",
	  SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
	  SuperPrivateField: "Private fields can't be accessed on super.",
	  TrailingDecorator: "Decorators must be attached to a class element.",
	  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
	  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
	  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
	  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
	  UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
	  UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
	  UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
	  UnexpectedKeyword: ({
	    keyword
	  }) => `Unexpected keyword '${keyword}'.`,
	  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
	  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
	  UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
	  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
	  UnexpectedPrivateField: "Unexpected private name.",
	  UnexpectedReservedWord: ({
	    reservedWord
	  }) => `Unexpected reserved word '${reservedWord}'.`,
	  UnexpectedSuper: "'super' is only allowed in object methods and classes.",
	  UnexpectedToken: ({
	    expected,
	    unexpected
	  }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
	  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
	  UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.",
	  UnsupportedBind: "Binding should be performed on object property.",
	  UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
	  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
	  UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
	  UnsupportedMetaProperty: ({
	    target,
	    onlyValidPropertyName
	  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
	  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
	  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
	  UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
	  UnterminatedComment: "Unterminated comment.",
	  UnterminatedRegExp: "Unterminated regular expression.",
	  UnterminatedString: "Unterminated string constant.",
	  UnterminatedTemplate: "Unterminated template.",
	  UsingDeclarationExport: "Using declaration cannot be exported.",
	  UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
	  VarRedeclaration: ({
	    identifierName
	  }) => `Identifier '${identifierName}' has already been declared.`,
	  YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
	  YieldInParameter: "Yield expression is not allowed in formal parameters.",
	  YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
	  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
	};
	var StrictModeErrors = {
	  StrictDelete: "Deleting local variable in strict mode.",
	  StrictEvalArguments: ({
	    referenceName
	  }) => `Assigning to '${referenceName}' in strict mode.`,
	  StrictEvalArgumentsBinding: ({
	    bindingName
	  }) => `Binding '${bindingName}' in strict mode.`,
	  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
	  StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
	  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
	  StrictWith: "'with' in strict mode."
	};
	var ParseExpressionErrors = {
	  ParseExpressionEmptyInput: "Unexpected parseExpression() input: The input is empty or contains only comments.",
	  ParseExpressionExpectsEOF: ({
	    unexpected
	  }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \`${String.fromCodePoint(unexpected)}\`.`
	};
	const UnparenthesizedPipeBodyDescriptions = new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
	var PipelineOperatorErrors = Object.assign({
	  PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
	  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
	  PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
	  PipeTopicUnconfiguredToken: ({
	    token
	  }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
	  PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
	  PipeUnparenthesizedBody: ({
	    type
	  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
	    type
	  })}; please wrap it in parentheses.`
	}, {
	  PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
	  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
	  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
	  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
	  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
	  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
	});
	const _excluded = ["message"];
	function defineHidden(obj, key, value) {
	  Object.defineProperty(obj, key, {
	    enumerable: false,
	    configurable: true,
	    value
	  });
	}
	function toParseErrorConstructor({
	  toMessage,
	  code,
	  reasonCode,
	  syntaxPlugin
	}) {
	  const hasMissingPlugin = reasonCode === "MissingPlugin" || reasonCode === "MissingOneOfPlugins";
	  {
	    const oldReasonCodes = {
	      AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
	      AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
	      ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
	      SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
	      SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
	      SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
	    };
	    if (oldReasonCodes[reasonCode]) {
	      reasonCode = oldReasonCodes[reasonCode];
	    }
	  }
	  return function constructor(loc, details) {
	    const error = new SyntaxError();
	    error.code = code;
	    error.reasonCode = reasonCode;
	    error.loc = loc;
	    error.pos = loc.index;
	    error.syntaxPlugin = syntaxPlugin;
	    if (hasMissingPlugin) {
	      error.missingPlugin = details.missingPlugin;
	    }
	    defineHidden(error, "clone", function clone(overrides = {}) {
	      var _overrides$loc;
	      const {
	        line,
	        column,
	        index
	      } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
	      return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));
	    });
	    defineHidden(error, "details", details);
	    Object.defineProperty(error, "message", {
	      configurable: true,
	      get() {
	        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
	        this.message = message;
	        return message;
	      },
	      set(value) {
	        Object.defineProperty(this, "message", {
	          value,
	          writable: true
	        });
	      }
	    });
	    return error;
	  };
	}
	function ParseErrorEnum(argument, syntaxPlugin) {
	  if (Array.isArray(argument)) {
	    return parseErrorTemplates => ParseErrorEnum(parseErrorTemplates, argument[0]);
	  }
	  const ParseErrorConstructors = {};
	  for (const reasonCode of Object.keys(argument)) {
	    const template = argument[reasonCode];
	    const _ref = typeof template === "string" ? {
	        message: () => template
	      } : typeof template === "function" ? {
	        message: template
	      } : template,
	      {
	        message
	      } = _ref,
	      rest = _objectWithoutPropertiesLoose(_ref, _excluded);
	    const toMessage = typeof message === "string" ? () => message : message;
	    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
	      code: "BABEL_PARSER_SYNTAX_ERROR",
	      reasonCode,
	      toMessage
	    }, syntaxPlugin ? {
	      syntaxPlugin
	    } : {}, rest));
	  }
	  return ParseErrorConstructors;
	}
	const Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum(ParseExpressionErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
	function createDefaultOptions() {
	  return {
	    sourceType: "script",
	    sourceFilename: undefined,
	    startIndex: 0,
	    startColumn: 0,
	    startLine: 1,
	    allowAwaitOutsideFunction: false,
	    allowReturnOutsideFunction: false,
	    allowNewTargetOutsideFunction: false,
	    allowImportExportEverywhere: false,
	    allowSuperOutsideMethod: false,
	    allowUndeclaredExports: false,
	    allowYieldOutsideFunction: false,
	    plugins: [],
	    strictMode: null,
	    ranges: false,
	    tokens: false,
	    createImportExpressions: false,
	    createParenthesizedExpressions: false,
	    errorRecovery: false,
	    attachComment: true,
	    annexB: true
	  };
	}
	function getOptions(opts) {
	  const options = createDefaultOptions();
	  if (opts == null) {
	    return options;
	  }
	  if (opts.annexB != null && opts.annexB !== false) {
	    throw new Error("The `annexB` option can only be set to `false`.");
	  }
	  for (const key of Object.keys(options)) {
	    if (opts[key] != null) options[key] = opts[key];
	  }
	  if (options.startLine === 1) {
	    if (opts.startIndex == null && options.startColumn > 0) {
	      options.startIndex = options.startColumn;
	    } else if (opts.startColumn == null && options.startIndex > 0) {
	      options.startColumn = options.startIndex;
	    }
	  } else if (opts.startColumn == null || opts.startIndex == null) {
	    if (opts.startIndex != null) {
	      throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
	    }
	  }
	  return options;
	}
	const {
	  defineProperty
	} = Object;
	const toUnenumerable = (object, key) => {
	  if (object) {
	    defineProperty(object, key, {
	      enumerable: false,
	      value: object[key]
	    });
	  }
	};
	function toESTreeLocation(node) {
	  toUnenumerable(node.loc.start, "index");
	  toUnenumerable(node.loc.end, "index");
	  return node;
	}
	var estree = superClass => class ESTreeParserMixin extends superClass {
	  parse() {
	    const file = toESTreeLocation(super.parse());
	    if (this.optionFlags & 256) {
	      file.tokens = file.tokens.map(toESTreeLocation);
	    }
	    return file;
	  }
	  parseRegExpLiteral({
	    pattern,
	    flags
	  }) {
	    let regex = null;
	    try {
	      regex = new RegExp(pattern, flags);
	    } catch (_) {}
	    const node = this.estreeParseLiteral(regex);
	    node.regex = {
	      pattern,
	      flags
	    };
	    return node;
	  }
	  parseBigIntLiteral(value) {
	    let bigInt;
	    try {
	      bigInt = BigInt(value);
	    } catch (_unused) {
	      bigInt = null;
	    }
	    const node = this.estreeParseLiteral(bigInt);
	    node.bigint = String(node.value || value);
	    return node;
	  }
	  parseDecimalLiteral(value) {
	    const decimal = null;
	    const node = this.estreeParseLiteral(decimal);
	    node.decimal = String(node.value || value);
	    return node;
	  }
	  estreeParseLiteral(value) {
	    return this.parseLiteral(value, "Literal");
	  }
	  parseStringLiteral(value) {
	    return this.estreeParseLiteral(value);
	  }
	  parseNumericLiteral(value) {
	    return this.estreeParseLiteral(value);
	  }
	  parseNullLiteral() {
	    return this.estreeParseLiteral(null);
	  }
	  parseBooleanLiteral(value) {
	    return this.estreeParseLiteral(value);
	  }
	  estreeParseChainExpression(node, endLoc) {
	    const chain = this.startNodeAtNode(node);
	    chain.expression = node;
	    return this.finishNodeAt(chain, "ChainExpression", endLoc);
	  }
	  directiveToStmt(directive) {
	    const expression = directive.value;
	    delete directive.value;
	    this.castNodeTo(expression, "Literal");
	    expression.raw = expression.extra.raw;
	    expression.value = expression.extra.expressionValue;
	    const stmt = this.castNodeTo(directive, "ExpressionStatement");
	    stmt.expression = expression;
	    stmt.directive = expression.extra.rawValue;
	    delete expression.extra;
	    return stmt;
	  }
	  fillOptionalPropertiesForTSESLint(node) {}
	  cloneEstreeStringLiteral(node) {
	    const {
	      start,
	      end,
	      loc,
	      range,
	      raw,
	      value
	    } = node;
	    const cloned = Object.create(node.constructor.prototype);
	    cloned.type = "Literal";
	    cloned.start = start;
	    cloned.end = end;
	    cloned.loc = loc;
	    cloned.range = range;
	    cloned.raw = raw;
	    cloned.value = value;
	    return cloned;
	  }
	  initFunction(node, isAsync) {
	    super.initFunction(node, isAsync);
	    node.expression = false;
	  }
	  checkDeclaration(node) {
	    if (node != null && this.isObjectProperty(node)) {
	      this.checkDeclaration(node.value);
	    } else {
	      super.checkDeclaration(node);
	    }
	  }
	  getObjectOrClassMethodParams(method) {
	    return method.value.params;
	  }
	  isValidDirective(stmt) {
	    var _stmt$expression$extr;
	    return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
	  }
	  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
	    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
	    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));
	    node.body = directiveStatements.concat(node.body);
	    delete node.directives;
	  }
	  parsePrivateName() {
	    const node = super.parsePrivateName();
	    {
	      if (!this.getPluginOption("estree", "classFeatures")) {
	        return node;
	      }
	    }
	    return this.convertPrivateNameToPrivateIdentifier(node);
	  }
	  convertPrivateNameToPrivateIdentifier(node) {
	    const name = super.getPrivateNameSV(node);
	    node = node;
	    delete node.id;
	    node.name = name;
	    return this.castNodeTo(node, "PrivateIdentifier");
	  }
	  isPrivateName(node) {
	    {
	      if (!this.getPluginOption("estree", "classFeatures")) {
	        return super.isPrivateName(node);
	      }
	    }
	    return node.type === "PrivateIdentifier";
	  }
	  getPrivateNameSV(node) {
	    {
	      if (!this.getPluginOption("estree", "classFeatures")) {
	        return super.getPrivateNameSV(node);
	      }
	    }
	    return node.name;
	  }
	  parseLiteral(value, type) {
	    const node = super.parseLiteral(value, type);
	    node.raw = node.extra.raw;
	    delete node.extra;
	    return node;
	  }
	  parseFunctionBody(node, allowExpression, isMethod = false) {
	    super.parseFunctionBody(node, allowExpression, isMethod);
	    node.expression = node.body.type !== "BlockStatement";
	  }
	  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
	    let funcNode = this.startNode();
	    funcNode.kind = node.kind;
	    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
	    delete funcNode.kind;
	    const {
	      typeParameters
	    } = node;
	    if (typeParameters) {
	      delete node.typeParameters;
	      funcNode.typeParameters = typeParameters;
	      this.resetStartLocationFromNode(funcNode, typeParameters);
	    }
	    const valueNode = this.castNodeTo(funcNode, "FunctionExpression");
	    node.value = valueNode;
	    if (type === "ClassPrivateMethod") {
	      node.computed = false;
	    }
	    if (type === "ObjectMethod") {
	      if (node.kind === "method") {
	        node.kind = "init";
	      }
	      node.shorthand = false;
	      return this.finishNode(node, "Property");
	    } else {
	      return this.finishNode(node, "MethodDefinition");
	    }
	  }
	  nameIsConstructor(key) {
	    if (key.type === "Literal") return key.value === "constructor";
	    return super.nameIsConstructor(key);
	  }
	  parseClassProperty(...args) {
	    const propertyNode = super.parseClassProperty(...args);
	    {
	      if (!this.getPluginOption("estree", "classFeatures")) {
	        return propertyNode;
	      }
	    }
	    {
	      this.castNodeTo(propertyNode, "PropertyDefinition");
	    }
	    return propertyNode;
	  }
	  parseClassPrivateProperty(...args) {
	    const propertyNode = super.parseClassPrivateProperty(...args);
	    {
	      if (!this.getPluginOption("estree", "classFeatures")) {
	        return propertyNode;
	      }
	    }
	    {
	      this.castNodeTo(propertyNode, "PropertyDefinition");
	    }
	    propertyNode.computed = false;
	    return propertyNode;
	  }
	  parseClassAccessorProperty(node) {
	    const accessorPropertyNode = super.parseClassAccessorProperty(node);
	    {
	      if (!this.getPluginOption("estree", "classFeatures")) {
	        return accessorPropertyNode;
	      }
	    }
	    if (accessorPropertyNode.abstract && this.hasPlugin("typescript")) {
	      delete accessorPropertyNode.abstract;
	      this.castNodeTo(accessorPropertyNode, "TSAbstractAccessorProperty");
	    } else {
	      this.castNodeTo(accessorPropertyNode, "AccessorProperty");
	    }
	    return accessorPropertyNode;
	  }
	  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
	    const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
	    if (node) {
	      node.kind = "init";
	      this.castNodeTo(node, "Property");
	    }
	    return node;
	  }
	  finishObjectProperty(node) {
	    node.kind = "init";
	    return this.finishNode(node, "Property");
	  }
	  isValidLVal(type, isUnparenthesizedInAssign, binding) {
	    return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
	  }
	  isAssignable(node, isBinding) {
	    if (node != null && this.isObjectProperty(node)) {
	      return this.isAssignable(node.value, isBinding);
	    }
	    return super.isAssignable(node, isBinding);
	  }
	  toAssignable(node, isLHS = false) {
	    if (node != null && this.isObjectProperty(node)) {
	      const {
	        key,
	        value
	      } = node;
	      if (this.isPrivateName(key)) {
	        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
	      }
	      this.toAssignable(value, isLHS);
	    } else {
	      super.toAssignable(node, isLHS);
	    }
	  }
	  toAssignableObjectExpressionProp(prop, isLast, isLHS) {
	    if (prop.type === "Property" && (prop.kind === "get" || prop.kind === "set")) {
	      this.raise(Errors.PatternHasAccessor, prop.key);
	    } else if (prop.type === "Property" && prop.method) {
	      this.raise(Errors.PatternHasMethod, prop.key);
	    } else {
	      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
	    }
	  }
	  finishCallExpression(unfinished, optional) {
	    const node = super.finishCallExpression(unfinished, optional);
	    if (node.callee.type === "Import") {
	      var _ref, _ref2;
	      this.castNodeTo(node, "ImportExpression");
	      node.source = node.arguments[0];
	      node.options = (_ref = node.arguments[1]) != null ? _ref : null;
	      node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;
	      delete node.arguments;
	      delete node.callee;
	    } else if (node.type === "OptionalCallExpression") {
	      this.castNodeTo(node, "CallExpression");
	    } else {
	      node.optional = false;
	    }
	    return node;
	  }
	  toReferencedArguments(node) {
	    if (node.type === "ImportExpression") {
	      return;
	    }
	    super.toReferencedArguments(node);
	  }
	  parseExport(unfinished, decorators) {
	    const exportStartLoc = this.state.lastTokStartLoc;
	    const node = super.parseExport(unfinished, decorators);
	    switch (node.type) {
	      case "ExportAllDeclaration":
	        node.exported = null;
	        break;
	      case "ExportNamedDeclaration":
	        if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
	          this.castNodeTo(node, "ExportAllDeclaration");
	          node.exported = node.specifiers[0].exported;
	          delete node.specifiers;
	        }
	      case "ExportDefaultDeclaration":
	        {
	          var _declaration$decorato;
	          const {
	            declaration
	          } = node;
	          if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {
	            this.resetStartLocation(node, exportStartLoc);
	          }
	        }
	        break;
	    }
	    return node;
	  }
	  stopParseSubscript(base, state) {
	    const node = super.stopParseSubscript(base, state);
	    if (state.optionalChainMember) {
	      return this.estreeParseChainExpression(node, base.loc.end);
	    }
	    return node;
	  }
	  parseMember(base, startLoc, state, computed, optional) {
	    const node = super.parseMember(base, startLoc, state, computed, optional);
	    if (node.type === "OptionalMemberExpression") {
	      this.castNodeTo(node, "MemberExpression");
	    } else {
	      node.optional = false;
	    }
	    return node;
	  }
	  isOptionalMemberExpression(node) {
	    if (node.type === "ChainExpression") {
	      return node.expression.type === "MemberExpression";
	    }
	    return super.isOptionalMemberExpression(node);
	  }
	  hasPropertyAsPrivateName(node) {
	    if (node.type === "ChainExpression") {
	      node = node.expression;
	    }
	    return super.hasPropertyAsPrivateName(node);
	  }
	  isObjectProperty(node) {
	    return node.type === "Property" && node.kind === "init" && !node.method;
	  }
	  isObjectMethod(node) {
	    return node.type === "Property" && (node.method || node.kind === "get" || node.kind === "set");
	  }
	  castNodeTo(node, type) {
	    const result = super.castNodeTo(node, type);
	    this.fillOptionalPropertiesForTSESLint(result);
	    return result;
	  }
	  cloneIdentifier(node) {
	    const cloned = super.cloneIdentifier(node);
	    this.fillOptionalPropertiesForTSESLint(cloned);
	    return cloned;
	  }
	  cloneStringLiteral(node) {
	    if (node.type === "Literal") {
	      return this.cloneEstreeStringLiteral(node);
	    }
	    return super.cloneStringLiteral(node);
	  }
	  finishNodeAt(node, type, endLoc) {
	    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
	  }
	  finishNode(node, type) {
	    const result = super.finishNode(node, type);
	    this.fillOptionalPropertiesForTSESLint(result);
	    return result;
	  }
	  resetStartLocation(node, startLoc) {
	    super.resetStartLocation(node, startLoc);
	    toESTreeLocation(node);
	  }
	  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
	    super.resetEndLocation(node, endLoc);
	    toESTreeLocation(node);
	  }
	};
	class TokContext {
	  constructor(token, preserveSpace) {
	    this.token = void 0;
	    this.preserveSpace = void 0;
	    this.token = token;
	    this.preserveSpace = !!preserveSpace;
	  }
	}
	const types = {
	  brace: new TokContext("{"),
	  j_oTag: new TokContext("<tag"),
	  j_cTag: new TokContext("</tag"),
	  j_expr: new TokContext("<tag>...</tag>", true)
	};
	{
	  types.template = new TokContext("`", true);
	}
	const beforeExpr = true;
	const startsExpr = true;
	const isLoop = true;
	const isAssign = true;
	const prefix = true;
	const postfix = true;
	class ExportedTokenType {
	  constructor(label, conf = {}) {
	    this.label = void 0;
	    this.keyword = void 0;
	    this.beforeExpr = void 0;
	    this.startsExpr = void 0;
	    this.rightAssociative = void 0;
	    this.isLoop = void 0;
	    this.isAssign = void 0;
	    this.prefix = void 0;
	    this.postfix = void 0;
	    this.binop = void 0;
	    this.label = label;
	    this.keyword = conf.keyword;
	    this.beforeExpr = !!conf.beforeExpr;
	    this.startsExpr = !!conf.startsExpr;
	    this.rightAssociative = !!conf.rightAssociative;
	    this.isLoop = !!conf.isLoop;
	    this.isAssign = !!conf.isAssign;
	    this.prefix = !!conf.prefix;
	    this.postfix = !!conf.postfix;
	    this.binop = conf.binop != null ? conf.binop : null;
	    {
	      this.updateContext = null;
	    }
	  }
	}
	const keywords$1 = new Map();
	function createKeyword(name, options = {}) {
	  options.keyword = name;
	  const token = createToken(name, options);
	  keywords$1.set(name, token);
	  return token;
	}
	function createBinop(name, binop) {
	  return createToken(name, {
	    beforeExpr,
	    binop
	  });
	}
	let tokenTypeCounter = -1;
	const tokenTypes = [];
	const tokenLabels = [];
	const tokenBinops = [];
	const tokenBeforeExprs = [];
	const tokenStartsExprs = [];
	const tokenPrefixes = [];
	function createToken(name, options = {}) {
	  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
	  ++tokenTypeCounter;
	  tokenLabels.push(name);
	  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
	  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
	  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
	  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
	  tokenTypes.push(new ExportedTokenType(name, options));
	  return tokenTypeCounter;
	}
	function createKeywordLike(name, options = {}) {
	  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
	  ++tokenTypeCounter;
	  keywords$1.set(name, tokenTypeCounter);
	  tokenLabels.push(name);
	  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
	  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
	  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
	  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
	  tokenTypes.push(new ExportedTokenType("name", options));
	  return tokenTypeCounter;
	}
	const tt = {
	  bracketL: createToken("[", {
	    beforeExpr,
	    startsExpr
	  }),
	  bracketHashL: createToken("#[", {
	    beforeExpr,
	    startsExpr
	  }),
	  bracketBarL: createToken("[|", {
	    beforeExpr,
	    startsExpr
	  }),
	  bracketR: createToken("]"),
	  bracketBarR: createToken("|]"),
	  braceL: createToken("{", {
	    beforeExpr,
	    startsExpr
	  }),
	  braceBarL: createToken("{|", {
	    beforeExpr,
	    startsExpr
	  }),
	  braceHashL: createToken("#{", {
	    beforeExpr,
	    startsExpr
	  }),
	  braceR: createToken("}"),
	  braceBarR: createToken("|}"),
	  parenL: createToken("(", {
	    beforeExpr,
	    startsExpr
	  }),
	  parenR: createToken(")"),
	  comma: createToken(",", {
	    beforeExpr
	  }),
	  semi: createToken(";", {
	    beforeExpr
	  }),
	  colon: createToken(":", {
	    beforeExpr
	  }),
	  doubleColon: createToken("::", {
	    beforeExpr
	  }),
	  dot: createToken("."),
	  question: createToken("?", {
	    beforeExpr
	  }),
	  questionDot: createToken("?."),
	  arrow: createToken("=>", {
	    beforeExpr
	  }),
	  template: createToken("template"),
	  ellipsis: createToken("...", {
	    beforeExpr
	  }),
	  backQuote: createToken("`", {
	    startsExpr
	  }),
	  dollarBraceL: createToken("${", {
	    beforeExpr,
	    startsExpr
	  }),
	  templateTail: createToken("...`", {
	    startsExpr
	  }),
	  templateNonTail: createToken("...${", {
	    beforeExpr,
	    startsExpr
	  }),
	  at: createToken("@"),
	  hash: createToken("#", {
	    startsExpr
	  }),
	  interpreterDirective: createToken("#!..."),
	  eq: createToken("=", {
	    beforeExpr,
	    isAssign
	  }),
	  assign: createToken("_=", {
	    beforeExpr,
	    isAssign
	  }),
	  slashAssign: createToken("_=", {
	    beforeExpr,
	    isAssign
	  }),
	  xorAssign: createToken("_=", {
	    beforeExpr,
	    isAssign
	  }),
	  moduloAssign: createToken("_=", {
	    beforeExpr,
	    isAssign
	  }),
	  incDec: createToken("++/--", {
	    prefix,
	    postfix,
	    startsExpr
	  }),
	  bang: createToken("!", {
	    beforeExpr,
	    prefix,
	    startsExpr
	  }),
	  tilde: createToken("~", {
	    beforeExpr,
	    prefix,
	    startsExpr
	  }),
	  doubleCaret: createToken("^^", {
	    startsExpr
	  }),
	  doubleAt: createToken("@@", {
	    startsExpr
	  }),
	  pipeline: createBinop("|>", 0),
	  nullishCoalescing: createBinop("??", 1),
	  logicalOR: createBinop("||", 1),
	  logicalAND: createBinop("&&", 2),
	  bitwiseOR: createBinop("|", 3),
	  bitwiseXOR: createBinop("^", 4),
	  bitwiseAND: createBinop("&", 5),
	  equality: createBinop("==/!=/===/!==", 6),
	  lt: createBinop("</>/<=/>=", 7),
	  gt: createBinop("</>/<=/>=", 7),
	  relational: createBinop("</>/<=/>=", 7),
	  bitShift: createBinop("<</>>/>>>", 8),
	  bitShiftL: createBinop("<</>>/>>>", 8),
	  bitShiftR: createBinop("<</>>/>>>", 8),
	  plusMin: createToken("+/-", {
	    beforeExpr,
	    binop: 9,
	    prefix,
	    startsExpr
	  }),
	  modulo: createToken("%", {
	    binop: 10,
	    startsExpr
	  }),
	  star: createToken("*", {
	    binop: 10
	  }),
	  slash: createBinop("/", 10),
	  exponent: createToken("**", {
	    beforeExpr,
	    binop: 11,
	    rightAssociative: true
	  }),
	  _in: createKeyword("in", {
	    beforeExpr,
	    binop: 7
	  }),
	  _instanceof: createKeyword("instanceof", {
	    beforeExpr,
	    binop: 7
	  }),
	  _break: createKeyword("break"),
	  _case: createKeyword("case", {
	    beforeExpr
	  }),
	  _catch: createKeyword("catch"),
	  _continue: createKeyword("continue"),
	  _debugger: createKeyword("debugger"),
	  _default: createKeyword("default", {
	    beforeExpr
	  }),
	  _else: createKeyword("else", {
	    beforeExpr
	  }),
	  _finally: createKeyword("finally"),
	  _function: createKeyword("function", {
	    startsExpr
	  }),
	  _if: createKeyword("if"),
	  _return: createKeyword("return", {
	    beforeExpr
	  }),
	  _switch: createKeyword("switch"),
	  _throw: createKeyword("throw", {
	    beforeExpr,
	    prefix,
	    startsExpr
	  }),
	  _try: createKeyword("try"),
	  _var: createKeyword("var"),
	  _const: createKeyword("const"),
	  _with: createKeyword("with"),
	  _new: createKeyword("new", {
	    beforeExpr,
	    startsExpr
	  }),
	  _this: createKeyword("this", {
	    startsExpr
	  }),
	  _super: createKeyword("super", {
	    startsExpr
	  }),
	  _class: createKeyword("class", {
	    startsExpr
	  }),
	  _extends: createKeyword("extends", {
	    beforeExpr
	  }),
	  _export: createKeyword("export"),
	  _import: createKeyword("import", {
	    startsExpr
	  }),
	  _null: createKeyword("null", {
	    startsExpr
	  }),
	  _true: createKeyword("true", {
	    startsExpr
	  }),
	  _false: createKeyword("false", {
	    startsExpr
	  }),
	  _typeof: createKeyword("typeof", {
	    beforeExpr,
	    prefix,
	    startsExpr
	  }),
	  _void: createKeyword("void", {
	    beforeExpr,
	    prefix,
	    startsExpr
	  }),
	  _delete: createKeyword("delete", {
	    beforeExpr,
	    prefix,
	    startsExpr
	  }),
	  _do: createKeyword("do", {
	    isLoop,
	    beforeExpr
	  }),
	  _for: createKeyword("for", {
	    isLoop
	  }),
	  _while: createKeyword("while", {
	    isLoop
	  }),
	  _as: createKeywordLike("as", {
	    startsExpr
	  }),
	  _assert: createKeywordLike("assert", {
	    startsExpr
	  }),
	  _async: createKeywordLike("async", {
	    startsExpr
	  }),
	  _await: createKeywordLike("await", {
	    startsExpr
	  }),
	  _defer: createKeywordLike("defer", {
	    startsExpr
	  }),
	  _from: createKeywordLike("from", {
	    startsExpr
	  }),
	  _get: createKeywordLike("get", {
	    startsExpr
	  }),
	  _let: createKeywordLike("let", {
	    startsExpr
	  }),
	  _meta: createKeywordLike("meta", {
	    startsExpr
	  }),
	  _of: createKeywordLike("of", {
	    startsExpr
	  }),
	  _sent: createKeywordLike("sent", {
	    startsExpr
	  }),
	  _set: createKeywordLike("set", {
	    startsExpr
	  }),
	  _source: createKeywordLike("source", {
	    startsExpr
	  }),
	  _static: createKeywordLike("static", {
	    startsExpr
	  }),
	  _using: createKeywordLike("using", {
	    startsExpr
	  }),
	  _yield: createKeywordLike("yield", {
	    startsExpr
	  }),
	  _asserts: createKeywordLike("asserts", {
	    startsExpr
	  }),
	  _checks: createKeywordLike("checks", {
	    startsExpr
	  }),
	  _exports: createKeywordLike("exports", {
	    startsExpr
	  }),
	  _global: createKeywordLike("global", {
	    startsExpr
	  }),
	  _implements: createKeywordLike("implements", {
	    startsExpr
	  }),
	  _intrinsic: createKeywordLike("intrinsic", {
	    startsExpr
	  }),
	  _infer: createKeywordLike("infer", {
	    startsExpr
	  }),
	  _is: createKeywordLike("is", {
	    startsExpr
	  }),
	  _mixins: createKeywordLike("mixins", {
	    startsExpr
	  }),
	  _proto: createKeywordLike("proto", {
	    startsExpr
	  }),
	  _require: createKeywordLike("require", {
	    startsExpr
	  }),
	  _satisfies: createKeywordLike("satisfies", {
	    startsExpr
	  }),
	  _keyof: createKeywordLike("keyof", {
	    startsExpr
	  }),
	  _readonly: createKeywordLike("readonly", {
	    startsExpr
	  }),
	  _unique: createKeywordLike("unique", {
	    startsExpr
	  }),
	  _abstract: createKeywordLike("abstract", {
	    startsExpr
	  }),
	  _declare: createKeywordLike("declare", {
	    startsExpr
	  }),
	  _enum: createKeywordLike("enum", {
	    startsExpr
	  }),
	  _module: createKeywordLike("module", {
	    startsExpr
	  }),
	  _namespace: createKeywordLike("namespace", {
	    startsExpr
	  }),
	  _interface: createKeywordLike("interface", {
	    startsExpr
	  }),
	  _type: createKeywordLike("type", {
	    startsExpr
	  }),
	  _opaque: createKeywordLike("opaque", {
	    startsExpr
	  }),
	  name: createToken("name", {
	    startsExpr
	  }),
	  placeholder: createToken("%%", {
	    startsExpr: true
	  }),
	  string: createToken("string", {
	    startsExpr
	  }),
	  num: createToken("num", {
	    startsExpr
	  }),
	  bigint: createToken("bigint", {
	    startsExpr
	  }),
	  decimal: createToken("decimal", {
	    startsExpr
	  }),
	  regexp: createToken("regexp", {
	    startsExpr
	  }),
	  privateName: createToken("#name", {
	    startsExpr
	  }),
	  eof: createToken("eof"),
	  jsxName: createToken("jsxName"),
	  jsxText: createToken("jsxText", {
	    beforeExpr: true
	  }),
	  jsxTagStart: createToken("jsxTagStart", {
	    startsExpr: true
	  }),
	  jsxTagEnd: createToken("jsxTagEnd")
	};
	function tokenIsIdentifier(token) {
	  return token >= 93 && token <= 133;
	}
	function tokenKeywordOrIdentifierIsKeyword(token) {
	  return token <= 92;
	}
	function tokenIsKeywordOrIdentifier(token) {
	  return token >= 58 && token <= 133;
	}
	function tokenIsLiteralPropertyName(token) {
	  return token >= 58 && token <= 137;
	}
	function tokenComesBeforeExpression(token) {
	  return tokenBeforeExprs[token];
	}
	function tokenCanStartExpression(token) {
	  return tokenStartsExprs[token];
	}
	function tokenIsAssignment(token) {
	  return token >= 29 && token <= 33;
	}
	function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
	  return token >= 129 && token <= 131;
	}
	function tokenIsLoop(token) {
	  return token >= 90 && token <= 92;
	}
	function tokenIsKeyword(token) {
	  return token >= 58 && token <= 92;
	}
	function tokenIsOperator(token) {
	  return token >= 39 && token <= 59;
	}
	function tokenIsPostfix(token) {
	  return token === 34;
	}
	function tokenIsPrefix(token) {
	  return tokenPrefixes[token];
	}
	function tokenIsTSTypeOperator(token) {
	  return token >= 121 && token <= 123;
	}
	function tokenIsTSDeclarationStart(token) {
	  return token >= 124 && token <= 130;
	}
	function tokenLabelName(token) {
	  return tokenLabels[token];
	}
	function tokenOperatorPrecedence(token) {
	  return tokenBinops[token];
	}
	function tokenIsRightAssociative(token) {
	  return token === 57;
	}
	function tokenIsTemplate(token) {
	  return token >= 24 && token <= 25;
	}
	function getExportedToken(token) {
	  return tokenTypes[token];
	}
	{
	  tokenTypes[8].updateContext = context => {
	    context.pop();
	  };
	  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {
	    context.push(types.brace);
	  };
	  tokenTypes[22].updateContext = context => {
	    if (context[context.length - 1] === types.template) {
	      context.pop();
	    } else {
	      context.push(types.template);
	    }
	  };
	  tokenTypes[143].updateContext = context => {
	    context.push(types.j_expr, types.j_oTag);
	  };
	}
	let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c8a\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7cd\ua7d0\ua7d1\ua7d3\ua7d5-\ua7dc\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
	let nonASCIIidentifierChars = "\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0897-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65";
	const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
	const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
	const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
	function isInAstralSet(code, set) {
	  let pos = 0x10000;
	  for (let i = 0, length = set.length; i < length; i += 2) {
	    pos += set[i];
	    if (pos > code) return false;
	    pos += set[i + 1];
	    if (pos >= code) return true;
	  }
	  return false;
	}
	function isIdentifierStart(code) {
	  if (code < 65) return code === 36;
	  if (code <= 90) return true;
	  if (code < 97) return code === 95;
	  if (code <= 122) return true;
	  if (code <= 0xffff) {
	    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
	  }
	  return isInAstralSet(code, astralIdentifierStartCodes);
	}
	function isIdentifierChar(code) {
	  if (code < 48) return code === 36;
	  if (code < 58) return true;
	  if (code < 65) return false;
	  if (code <= 90) return true;
	  if (code < 97) return code === 95;
	  if (code <= 122) return true;
	  if (code <= 0xffff) {
	    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
	  }
	  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
	}
	const reservedWords = {
	  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
	  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
	  strictBind: ["eval", "arguments"]
	};
	const keywords = new Set(reservedWords.keyword);
	const reservedWordsStrictSet = new Set(reservedWords.strict);
	const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
	function isReservedWord(word, inModule) {
	  return inModule && word === "await" || word === "enum";
	}
	function isStrictReservedWord(word, inModule) {
	  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
	}
	function isStrictBindOnlyReservedWord(word) {
	  return reservedWordsStrictBindSet.has(word);
	}
	function isStrictBindReservedWord(word, inModule) {
	  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
	}
	function isKeyword(word) {
	  return keywords.has(word);
	}
	function isIteratorStart(current, next, next2) {
	  return current === 64 && next === 64 && isIdentifierStart(next2);
	}
	const reservedWordLikeSet = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
	function canBeReservedWord(word) {
	  return reservedWordLikeSet.has(word);
	}
	class Scope {
	  constructor(flags) {
	    this.flags = 0;
	    this.names = new Map();
	    this.firstLexicalName = "";
	    this.flags = flags;
	  }
	}
	class ScopeHandler {
	  constructor(parser, inModule) {
	    this.parser = void 0;
	    this.scopeStack = [];
	    this.inModule = void 0;
	    this.undefinedExports = new Map();
	    this.parser = parser;
	    this.inModule = inModule;
	  }
	  get inTopLevel() {
	    return (this.currentScope().flags & 1) > 0;
	  }
	  get inFunction() {
	    return (this.currentVarScopeFlags() & 2) > 0;
	  }
	  get allowSuper() {
	    return (this.currentThisScopeFlags() & 16) > 0;
	  }
	  get allowDirectSuper() {
	    return (this.currentThisScopeFlags() & 32) > 0;
	  }
	  get inClass() {
	    return (this.currentThisScopeFlags() & 64) > 0;
	  }
	  get inClassAndNotInNonArrowFunction() {
	    const flags = this.currentThisScopeFlags();
	    return (flags & 64) > 0 && (flags & 2) === 0;
	  }
	  get inStaticBlock() {
	    for (let i = this.scopeStack.length - 1;; i--) {
	      const {
	        flags
	      } = this.scopeStack[i];
	      if (flags & 128) {
	        return true;
	      }
	      if (flags & (643 | 64)) {
	        return false;
	      }
	    }
	  }
	  get inNonArrowFunction() {
	    return (this.currentThisScopeFlags() & 2) > 0;
	  }
	  get inBareCaseStatement() {
	    return (this.currentScope().flags & 256) > 0;
	  }
	  get treatFunctionsAsVar() {
	    return this.treatFunctionsAsVarInScope(this.currentScope());
	  }
	  createScope(flags) {
	    return new Scope(flags);
	  }
	  enter(flags) {
	    this.scopeStack.push(this.createScope(flags));
	  }
	  exit() {
	    const scope = this.scopeStack.pop();
	    return scope.flags;
	  }
	  treatFunctionsAsVarInScope(scope) {
	    return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
	  }
	  declareName(name, bindingType, loc) {
	    let scope = this.currentScope();
	    if (bindingType & 8 || bindingType & 16) {
	      this.checkRedeclarationInScope(scope, name, bindingType, loc);
	      let type = scope.names.get(name) || 0;
	      if (bindingType & 16) {
	        type = type | 4;
	      } else {
	        if (!scope.firstLexicalName) {
	          scope.firstLexicalName = name;
	        }
	        type = type | 2;
	      }
	      scope.names.set(name, type);
	      if (bindingType & 8) {
	        this.maybeExportDefined(scope, name);
	      }
	    } else if (bindingType & 4) {
	      for (let i = this.scopeStack.length - 1; i >= 0; --i) {
	        scope = this.scopeStack[i];
	        this.checkRedeclarationInScope(scope, name, bindingType, loc);
	        scope.names.set(name, (scope.names.get(name) || 0) | 1);
	        this.maybeExportDefined(scope, name);
	        if (scope.flags & 643) break;
	      }
	    }
	    if (this.parser.inModule && scope.flags & 1) {
	      this.undefinedExports.delete(name);
	    }
	  }
	  maybeExportDefined(scope, name) {
	    if (this.parser.inModule && scope.flags & 1) {
	      this.undefinedExports.delete(name);
	    }
	  }
	  checkRedeclarationInScope(scope, name, bindingType, loc) {
	    if (this.isRedeclaredInScope(scope, name, bindingType)) {
	      this.parser.raise(Errors.VarRedeclaration, loc, {
	        identifierName: name
	      });
	    }
	  }
	  isRedeclaredInScope(scope, name, bindingType) {
	    if (!(bindingType & 1)) return false;
	    if (bindingType & 8) {
	      return scope.names.has(name);
	    }
	    const type = scope.names.get(name);
	    if (bindingType & 16) {
	      return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;
	    }
	    return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;
	  }
	  checkLocalExport(id) {
	    const {
	      name
	    } = id;
	    const topLevelScope = this.scopeStack[0];
	    if (!topLevelScope.names.has(name)) {
	      this.undefinedExports.set(name, id.loc.start);
	    }
	  }
	  currentScope() {
	    return this.scopeStack[this.scopeStack.length - 1];
	  }
	  currentVarScopeFlags() {
	    for (let i = this.scopeStack.length - 1;; i--) {
	      const {
	        flags
	      } = this.scopeStack[i];
	      if (flags & 643) {
	        return flags;
	      }
	    }
	  }
	  currentThisScopeFlags() {
	    for (let i = this.scopeStack.length - 1;; i--) {
	      const {
	        flags
	      } = this.scopeStack[i];
	      if (flags & (643 | 64) && !(flags & 4)) {
	        return flags;
	      }
	    }
	  }
	}
	class FlowScope extends Scope {
	  constructor(...args) {
	    super(...args);
	    this.declareFunctions = new Set();
	  }
	}
	class FlowScopeHandler extends ScopeHandler {
	  createScope(flags) {
	    return new FlowScope(flags);
	  }
	  declareName(name, bindingType, loc) {
	    const scope = this.currentScope();
	    if (bindingType & 2048) {
	      this.checkRedeclarationInScope(scope, name, bindingType, loc);
	      this.maybeExportDefined(scope, name);
	      scope.declareFunctions.add(name);
	      return;
	    }
	    super.declareName(name, bindingType, loc);
	  }
	  isRedeclaredInScope(scope, name, bindingType) {
	    if (super.isRedeclaredInScope(scope, name, bindingType)) return true;
	    if (bindingType & 2048 && !scope.declareFunctions.has(name)) {
	      const type = scope.names.get(name);
	      return (type & 4) > 0 || (type & 2) > 0;
	    }
	    return false;
	  }
	  checkLocalExport(id) {
	    if (!this.scopeStack[0].declareFunctions.has(id.name)) {
	      super.checkLocalExport(id);
	    }
	  }
	}
	const reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
	const FlowErrors = ParseErrorEnum`flow`({
	  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
	  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
	  AssignReservedType: ({
	    reservedType
	  }) => `Cannot overwrite reserved type ${reservedType}.`,
	  DeclareClassElement: "The `declare` modifier can only appear on class fields.",
	  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
	  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
	  EnumBooleanMemberNotInitialized: ({
	    memberName,
	    enumName
	  }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
	  EnumDuplicateMemberName: ({
	    memberName,
	    enumName
	  }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
	  EnumInconsistentMemberValues: ({
	    enumName
	  }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
	  EnumInvalidExplicitType: ({
	    invalidEnumType,
	    enumName
	  }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
	  EnumInvalidExplicitTypeUnknownSupplied: ({
	    enumName
	  }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
	  EnumInvalidMemberInitializerPrimaryType: ({
	    enumName,
	    memberName,
	    explicitType
	  }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
	  EnumInvalidMemberInitializerSymbolType: ({
	    enumName,
	    memberName
	  }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
	  EnumInvalidMemberInitializerUnknownType: ({
	    enumName,
	    memberName
	  }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
	  EnumInvalidMemberName: ({
	    enumName,
	    memberName,
	    suggestion
	  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
	  EnumNumberMemberNotInitialized: ({
	    enumName,
	    memberName
	  }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
	  EnumStringMemberInconsistentlyInitialized: ({
	    enumName
	  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
	  GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
	  ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
	  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
	  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
	  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
	  InexactVariance: "Explicit inexact syntax cannot have variance.",
	  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
	  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
	  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
	  NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
	  PatternIsOptional: Object.assign({
	    message: "A binding pattern parameter cannot be optional in an implementation signature."
	  }, {
	    reasonCode: "OptionalBindingPattern"
	  }),
	  SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
	  SpreadVariance: "Spread properties cannot have variance.",
	  ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
	  ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
	  ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
	  ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
	  ThisParamNoDefault: "The `this` parameter may not have a default value.",
	  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
	  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
	  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
	  UnexpectedReservedType: ({
	    reservedType
	  }) => `Unexpected reserved type ${reservedType}.`,
	  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
	  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
	  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
	  UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
	  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
	  UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
	  UnsupportedDeclareExportKind: ({
	    unsupportedExportKind,
	    suggestion
	  }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
	  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
	  UnterminatedFlowComment: "Unterminated flow-comment."
	});
	function isEsModuleType(bodyElement) {
	  return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
	}
	function hasTypeImportKind(node) {
	  return node.importKind === "type" || node.importKind === "typeof";
	}
	const exportSuggestions = {
	  const: "declare export var",
	  let: "declare export var",
	  type: "export type",
	  interface: "export interface"
	};
	function partition(list, test) {
	  const list1 = [];
	  const list2 = [];
	  for (let i = 0; i < list.length; i++) {
	    (test(list[i], i, list) ? list1 : list2).push(list[i]);
	  }
	  return [list1, list2];
	}
	const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
	var flow = superClass => class FlowParserMixin extends superClass {
	  constructor(...args) {
	    super(...args);
	    this.flowPragma = undefined;
	  }
	  getScopeHandler() {
	    return FlowScopeHandler;
	  }
	  shouldParseTypes() {
	    return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
	  }
	  finishToken(type, val) {
	    if (type !== 134 && type !== 13 && type !== 28) {
	      if (this.flowPragma === undefined) {
	        this.flowPragma = null;
	      }
	    }
	    super.finishToken(type, val);
	  }
	  addComment(comment) {
	    if (this.flowPragma === undefined) {
	      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
	      if (!matches) ;else if (matches[1] === "flow") {
	        this.flowPragma = "flow";
	      } else if (matches[1] === "noflow") {
	        this.flowPragma = "noflow";
	      } else {
	        throw new Error("Unexpected flow pragma");
	      }
	    }
	    super.addComment(comment);
	  }
	  flowParseTypeInitialiser(tok) {
	    const oldInType = this.state.inType;
	    this.state.inType = true;
	    this.expect(tok || 14);
	    const type = this.flowParseType();
	    this.state.inType = oldInType;
	    return type;
	  }
	  flowParsePredicate() {
	    const node = this.startNode();
	    const moduloLoc = this.state.startLoc;
	    this.next();
	    this.expectContextual(110);
	    if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {
	      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);
	    }
	    if (this.eat(10)) {
	      node.value = super.parseExpression();
	      this.expect(11);
	      return this.finishNode(node, "DeclaredPredicate");
	    } else {
	      return this.finishNode(node, "InferredPredicate");
	    }
	  }
	  flowParseTypeAndPredicateInitialiser() {
	    const oldInType = this.state.inType;
	    this.state.inType = true;
	    this.expect(14);
	    let type = null;
	    let predicate = null;
	    if (this.match(54)) {
	      this.state.inType = oldInType;
	      predicate = this.flowParsePredicate();
	    } else {
	      type = this.flowParseType();
	      this.state.inType = oldInType;
	      if (this.match(54)) {
	        predicate = this.flowParsePredicate();
	      }
	    }
	    return [type, predicate];
	  }
	  flowParseDeclareClass(node) {
	    this.next();
	    this.flowParseInterfaceish(node, true);
	    return this.finishNode(node, "DeclareClass");
	  }
	  flowParseDeclareFunction(node) {
	    this.next();
	    const id = node.id = this.parseIdentifier();
	    const typeNode = this.startNode();
	    const typeContainer = this.startNode();
	    if (this.match(47)) {
	      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
	    } else {
	      typeNode.typeParameters = null;
	    }
	    this.expect(10);
	    const tmp = this.flowParseFunctionTypeParams();
	    typeNode.params = tmp.params;
	    typeNode.rest = tmp.rest;
	    typeNode.this = tmp._this;
	    this.expect(11);
	    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
	    typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
	    id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
	    this.resetEndLocation(id);
	    this.semicolon();
	    this.scope.declareName(node.id.name, 2048, node.id.loc.start);
	    return this.finishNode(node, "DeclareFunction");
	  }
	  flowParseDeclare(node, insideModule) {
	    if (this.match(80)) {
	      return this.flowParseDeclareClass(node);
	    } else if (this.match(68)) {
	      return this.flowParseDeclareFunction(node);
	    } else if (this.match(74)) {
	      return this.flowParseDeclareVariable(node);
	    } else if (this.eatContextual(127)) {
	      if (this.match(16)) {
	        return this.flowParseDeclareModuleExports(node);
	      } else {
	        if (insideModule) {
	          this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);
	        }
	        return this.flowParseDeclareModule(node);
	      }
	    } else if (this.isContextual(130)) {
	      return this.flowParseDeclareTypeAlias(node);
	    } else if (this.isContextual(131)) {
	      return this.flowParseDeclareOpaqueType(node);
	    } else if (this.isContextual(129)) {
	      return this.flowParseDeclareInterface(node);
	    } else if (this.match(82)) {
	      return this.flowParseDeclareExportDeclaration(node, insideModule);
	    } else {
	      this.unexpected();
	    }
	  }
	  flowParseDeclareVariable(node) {
	    this.next();
	    node.id = this.flowParseTypeAnnotatableIdentifier(true);
	    this.scope.declareName(node.id.name, 5, node.id.loc.start);
	    this.semicolon();
	    return this.finishNode(node, "DeclareVariable");
	  }
	  flowParseDeclareModule(node) {
	    this.scope.enter(0);
	    if (this.match(134)) {
	      node.id = super.parseExprAtom();
	    } else {
	      node.id = this.parseIdentifier();
	    }
	    const bodyNode = node.body = this.startNode();
	    const body = bodyNode.body = [];
	    this.expect(5);
	    while (!this.match(8)) {
	      let bodyNode = this.startNode();
	      if (this.match(83)) {
	        this.next();
	        if (!this.isContextual(130) && !this.match(87)) {
	          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
	        }
	        super.parseImport(bodyNode);
	      } else {
	        this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
	        bodyNode = this.flowParseDeclare(bodyNode, true);
	      }
	      body.push(bodyNode);
	    }
	    this.scope.exit();
	    this.expect(8);
	    this.finishNode(bodyNode, "BlockStatement");
	    let kind = null;
	    let hasModuleExport = false;
	    body.forEach(bodyElement => {
	      if (isEsModuleType(bodyElement)) {
	        if (kind === "CommonJS") {
	          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
	        }
	        kind = "ES";
	      } else if (bodyElement.type === "DeclareModuleExports") {
	        if (hasModuleExport) {
	          this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);
	        }
	        if (kind === "ES") {
	          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
	        }
	        kind = "CommonJS";
	        hasModuleExport = true;
	      }
	    });
	    node.kind = kind || "CommonJS";
	    return this.finishNode(node, "DeclareModule");
	  }
	  flowParseDeclareExportDeclaration(node, insideModule) {
	    this.expect(82);
	    if (this.eat(65)) {
	      if (this.match(68) || this.match(80)) {
	        node.declaration = this.flowParseDeclare(this.startNode());
	      } else {
	        node.declaration = this.flowParseType();
	        this.semicolon();
	      }
	      node.default = true;
	      return this.finishNode(node, "DeclareExportDeclaration");
	    } else {
	      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
	        const label = this.state.value;
	        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
	          unsupportedExportKind: label,
	          suggestion: exportSuggestions[label]
	        });
	      }
	      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
	        node.declaration = this.flowParseDeclare(this.startNode());
	        node.default = false;
	        return this.finishNode(node, "DeclareExportDeclaration");
	      } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
	        node = this.parseExport(node, null);
	        if (node.type === "ExportNamedDeclaration") {
	          node.default = false;
	          delete node.exportKind;
	          return this.castNodeTo(node, "DeclareExportDeclaration");
	        } else {
	          return this.castNodeTo(node, "DeclareExportAllDeclaration");
	        }
	      }
	    }
	    this.unexpected();
	  }
	  flowParseDeclareModuleExports(node) {
	    this.next();
	    this.expectContextual(111);
	    node.typeAnnotation = this.flowParseTypeAnnotation();
	    this.semicolon();
	    return this.finishNode(node, "DeclareModuleExports");
	  }
	  flowParseDeclareTypeAlias(node) {
	    this.next();
	    const finished = this.flowParseTypeAlias(node);
	    this.castNodeTo(finished, "DeclareTypeAlias");
	    return finished;
	  }
	  flowParseDeclareOpaqueType(node) {
	    this.next();
	    const finished = this.flowParseOpaqueType(node, true);
	    this.castNodeTo(finished, "DeclareOpaqueType");
	    return finished;
	  }
	  flowParseDeclareInterface(node) {
	    this.next();
	    this.flowParseInterfaceish(node, false);
	    return this.finishNode(node, "DeclareInterface");
	  }
	  flowParseInterfaceish(node, isClass) {
	    node.id = this.flowParseRestrictedIdentifier(!isClass, true);
	    this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);
	    if (this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterDeclaration();
	    } else {
	      node.typeParameters = null;
	    }
	    node.extends = [];
	    if (this.eat(81)) {
	      do {
	        node.extends.push(this.flowParseInterfaceExtends());
	      } while (!isClass && this.eat(12));
	    }
	    if (isClass) {
	      node.implements = [];
	      node.mixins = [];
	      if (this.eatContextual(117)) {
	        do {
	          node.mixins.push(this.flowParseInterfaceExtends());
	        } while (this.eat(12));
	      }
	      if (this.eatContextual(113)) {
	        do {
	          node.implements.push(this.flowParseInterfaceExtends());
	        } while (this.eat(12));
	      }
	    }
	    node.body = this.flowParseObjectType({
	      allowStatic: isClass,
	      allowExact: false,
	      allowSpread: false,
	      allowProto: isClass,
	      allowInexact: false
	    });
	  }
	  flowParseInterfaceExtends() {
	    const node = this.startNode();
	    node.id = this.flowParseQualifiedTypeIdentifier();
	    if (this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterInstantiation();
	    } else {
	      node.typeParameters = null;
	    }
	    return this.finishNode(node, "InterfaceExtends");
	  }
	  flowParseInterface(node) {
	    this.flowParseInterfaceish(node, false);
	    return this.finishNode(node, "InterfaceDeclaration");
	  }
	  checkNotUnderscore(word) {
	    if (word === "_") {
	      this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
	    }
	  }
	  checkReservedType(word, startLoc, declaration) {
	    if (!reservedTypes.has(word)) return;
	    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
	      reservedType: word
	    });
	  }
	  flowParseRestrictedIdentifier(liberal, declaration) {
	    this.checkReservedType(this.state.value, this.state.startLoc, declaration);
	    return this.parseIdentifier(liberal);
	  }
	  flowParseTypeAlias(node) {
	    node.id = this.flowParseRestrictedIdentifier(false, true);
	    this.scope.declareName(node.id.name, 8201, node.id.loc.start);
	    if (this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterDeclaration();
	    } else {
	      node.typeParameters = null;
	    }
	    node.right = this.flowParseTypeInitialiser(29);
	    this.semicolon();
	    return this.finishNode(node, "TypeAlias");
	  }
	  flowParseOpaqueType(node, declare) {
	    this.expectContextual(130);
	    node.id = this.flowParseRestrictedIdentifier(true, true);
	    this.scope.declareName(node.id.name, 8201, node.id.loc.start);
	    if (this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterDeclaration();
	    } else {
	      node.typeParameters = null;
	    }
	    node.supertype = null;
	    if (this.match(14)) {
	      node.supertype = this.flowParseTypeInitialiser(14);
	    }
	    node.impltype = null;
	    if (!declare) {
	      node.impltype = this.flowParseTypeInitialiser(29);
	    }
	    this.semicolon();
	    return this.finishNode(node, "OpaqueType");
	  }
	  flowParseTypeParameter(requireDefault = false) {
	    const nodeStartLoc = this.state.startLoc;
	    const node = this.startNode();
	    const variance = this.flowParseVariance();
	    const ident = this.flowParseTypeAnnotatableIdentifier();
	    node.name = ident.name;
	    node.variance = variance;
	    node.bound = ident.typeAnnotation;
	    if (this.match(29)) {
	      this.eat(29);
	      node.default = this.flowParseType();
	    } else {
	      if (requireDefault) {
	        this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);
	      }
	    }
	    return this.finishNode(node, "TypeParameter");
	  }
	  flowParseTypeParameterDeclaration() {
	    const oldInType = this.state.inType;
	    const node = this.startNode();
	    node.params = [];
	    this.state.inType = true;
	    if (this.match(47) || this.match(143)) {
	      this.next();
	    } else {
	      this.unexpected();
	    }
	    let defaultRequired = false;
	    do {
	      const typeParameter = this.flowParseTypeParameter(defaultRequired);
	      node.params.push(typeParameter);
	      if (typeParameter.default) {
	        defaultRequired = true;
	      }
	      if (!this.match(48)) {
	        this.expect(12);
	      }
	    } while (!this.match(48));
	    this.expect(48);
	    this.state.inType = oldInType;
	    return this.finishNode(node, "TypeParameterDeclaration");
	  }
	  flowInTopLevelContext(cb) {
	    if (this.curContext() !== types.brace) {
	      const oldContext = this.state.context;
	      this.state.context = [oldContext[0]];
	      try {
	        return cb();
	      } finally {
	        this.state.context = oldContext;
	      }
	    } else {
	      return cb();
	    }
	  }
	  flowParseTypeParameterInstantiationInExpression() {
	    if (this.reScan_lt() !== 47) return;
	    return this.flowParseTypeParameterInstantiation();
	  }
	  flowParseTypeParameterInstantiation() {
	    const node = this.startNode();
	    const oldInType = this.state.inType;
	    this.state.inType = true;
	    node.params = [];
	    this.flowInTopLevelContext(() => {
	      this.expect(47);
	      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
	      this.state.noAnonFunctionType = false;
	      while (!this.match(48)) {
	        node.params.push(this.flowParseType());
	        if (!this.match(48)) {
	          this.expect(12);
	        }
	      }
	      this.state.noAnonFunctionType = oldNoAnonFunctionType;
	    });
	    this.state.inType = oldInType;
	    if (!this.state.inType && this.curContext() === types.brace) {
	      this.reScan_lt_gt();
	    }
	    this.expect(48);
	    return this.finishNode(node, "TypeParameterInstantiation");
	  }
	  flowParseTypeParameterInstantiationCallOrNew() {
	    if (this.reScan_lt() !== 47) return;
	    const node = this.startNode();
	    const oldInType = this.state.inType;
	    node.params = [];
	    this.state.inType = true;
	    this.expect(47);
	    while (!this.match(48)) {
	      node.params.push(this.flowParseTypeOrImplicitInstantiation());
	      if (!this.match(48)) {
	        this.expect(12);
	      }
	    }
	    this.expect(48);
	    this.state.inType = oldInType;
	    return this.finishNode(node, "TypeParameterInstantiation");
	  }
	  flowParseInterfaceType() {
	    const node = this.startNode();
	    this.expectContextual(129);
	    node.extends = [];
	    if (this.eat(81)) {
	      do {
	        node.extends.push(this.flowParseInterfaceExtends());
	      } while (this.eat(12));
	    }
	    node.body = this.flowParseObjectType({
	      allowStatic: false,
	      allowExact: false,
	      allowSpread: false,
	      allowProto: false,
	      allowInexact: false
	    });
	    return this.finishNode(node, "InterfaceTypeAnnotation");
	  }
	  flowParseObjectPropertyKey() {
	    return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);
	  }
	  flowParseObjectTypeIndexer(node, isStatic, variance) {
	    node.static = isStatic;
	    if (this.lookahead().type === 14) {
	      node.id = this.flowParseObjectPropertyKey();
	      node.key = this.flowParseTypeInitialiser();
	    } else {
	      node.id = null;
	      node.key = this.flowParseType();
	    }
	    this.expect(3);
	    node.value = this.flowParseTypeInitialiser();
	    node.variance = variance;
	    return this.finishNode(node, "ObjectTypeIndexer");
	  }
	  flowParseObjectTypeInternalSlot(node, isStatic) {
	    node.static = isStatic;
	    node.id = this.flowParseObjectPropertyKey();
	    this.expect(3);
	    this.expect(3);
	    if (this.match(47) || this.match(10)) {
	      node.method = true;
	      node.optional = false;
	      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
	    } else {
	      node.method = false;
	      if (this.eat(17)) {
	        node.optional = true;
	      }
	      node.value = this.flowParseTypeInitialiser();
	    }
	    return this.finishNode(node, "ObjectTypeInternalSlot");
	  }
	  flowParseObjectTypeMethodish(node) {
	    node.params = [];
	    node.rest = null;
	    node.typeParameters = null;
	    node.this = null;
	    if (this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterDeclaration();
	    }
	    this.expect(10);
	    if (this.match(78)) {
	      node.this = this.flowParseFunctionTypeParam(true);
	      node.this.name = null;
	      if (!this.match(11)) {
	        this.expect(12);
	      }
	    }
	    while (!this.match(11) && !this.match(21)) {
	      node.params.push(this.flowParseFunctionTypeParam(false));
	      if (!this.match(11)) {
	        this.expect(12);
	      }
	    }
	    if (this.eat(21)) {
	      node.rest = this.flowParseFunctionTypeParam(false);
	    }
	    this.expect(11);
	    node.returnType = this.flowParseTypeInitialiser();
	    return this.finishNode(node, "FunctionTypeAnnotation");
	  }
	  flowParseObjectTypeCallProperty(node, isStatic) {
	    const valueNode = this.startNode();
	    node.static = isStatic;
	    node.value = this.flowParseObjectTypeMethodish(valueNode);
	    return this.finishNode(node, "ObjectTypeCallProperty");
	  }
	  flowParseObjectType({
	    allowStatic,
	    allowExact,
	    allowSpread,
	    allowProto,
	    allowInexact
	  }) {
	    const oldInType = this.state.inType;
	    this.state.inType = true;
	    const nodeStart = this.startNode();
	    nodeStart.callProperties = [];
	    nodeStart.properties = [];
	    nodeStart.indexers = [];
	    nodeStart.internalSlots = [];
	    let endDelim;
	    let exact;
	    let inexact = false;
	    if (allowExact && this.match(6)) {
	      this.expect(6);
	      endDelim = 9;
	      exact = true;
	    } else {
	      this.expect(5);
	      endDelim = 8;
	      exact = false;
	    }
	    nodeStart.exact = exact;
	    while (!this.match(endDelim)) {
	      let isStatic = false;
	      let protoStartLoc = null;
	      let inexactStartLoc = null;
	      const node = this.startNode();
	      if (allowProto && this.isContextual(118)) {
	        const lookahead = this.lookahead();
	        if (lookahead.type !== 14 && lookahead.type !== 17) {
	          this.next();
	          protoStartLoc = this.state.startLoc;
	          allowStatic = false;
	        }
	      }
	      if (allowStatic && this.isContextual(106)) {
	        const lookahead = this.lookahead();
	        if (lookahead.type !== 14 && lookahead.type !== 17) {
	          this.next();
	          isStatic = true;
	        }
	      }
	      const variance = this.flowParseVariance();
	      if (this.eat(0)) {
	        if (protoStartLoc != null) {
	          this.unexpected(protoStartLoc);
	        }
	        if (this.eat(0)) {
	          if (variance) {
	            this.unexpected(variance.loc.start);
	          }
	          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
	        } else {
	          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
	        }
	      } else if (this.match(10) || this.match(47)) {
	        if (protoStartLoc != null) {
	          this.unexpected(protoStartLoc);
	        }
	        if (variance) {
	          this.unexpected(variance.loc.start);
	        }
	        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
	      } else {
	        let kind = "init";
	        if (this.isContextual(99) || this.isContextual(104)) {
	          const lookahead = this.lookahead();
	          if (tokenIsLiteralPropertyName(lookahead.type)) {
	            kind = this.state.value;
	            this.next();
	          }
	        }
	        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
	        if (propOrInexact === null) {
	          inexact = true;
	          inexactStartLoc = this.state.lastTokStartLoc;
	        } else {
	          nodeStart.properties.push(propOrInexact);
	        }
	      }
	      this.flowObjectTypeSemicolon();
	      if (inexactStartLoc && !this.match(8) && !this.match(9)) {
	        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
	      }
	    }
	    this.expect(endDelim);
	    if (allowSpread) {
	      nodeStart.inexact = inexact;
	    }
	    const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
	    this.state.inType = oldInType;
	    return out;
	  }
	  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
	    if (this.eat(21)) {
	      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
	      if (isInexactToken) {
	        if (!allowSpread) {
	          this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);
	        } else if (!allowInexact) {
	          this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);
	        }
	        if (variance) {
	          this.raise(FlowErrors.InexactVariance, variance);
	        }
	        return null;
	      }
	      if (!allowSpread) {
	        this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);
	      }
	      if (protoStartLoc != null) {
	        this.unexpected(protoStartLoc);
	      }
	      if (variance) {
	        this.raise(FlowErrors.SpreadVariance, variance);
	      }
	      node.argument = this.flowParseType();
	      return this.finishNode(node, "ObjectTypeSpreadProperty");
	    } else {
	      node.key = this.flowParseObjectPropertyKey();
	      node.static = isStatic;
	      node.proto = protoStartLoc != null;
	      node.kind = kind;
	      let optional = false;
	      if (this.match(47) || this.match(10)) {
	        node.method = true;
	        if (protoStartLoc != null) {
	          this.unexpected(protoStartLoc);
	        }
	        if (variance) {
	          this.unexpected(variance.loc.start);
	        }
	        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
	        if (kind === "get" || kind === "set") {
	          this.flowCheckGetterSetterParams(node);
	        }
	        if (!allowSpread && node.key.name === "constructor" && node.value.this) {
	          this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);
	        }
	      } else {
	        if (kind !== "init") this.unexpected();
	        node.method = false;
	        if (this.eat(17)) {
	          optional = true;
	        }
	        node.value = this.flowParseTypeInitialiser();
	        node.variance = variance;
	      }
	      node.optional = optional;
	      return this.finishNode(node, "ObjectTypeProperty");
	    }
	  }
	  flowCheckGetterSetterParams(property) {
	    const paramCount = property.kind === "get" ? 0 : 1;
	    const length = property.value.params.length + (property.value.rest ? 1 : 0);
	    if (property.value.this) {
	      this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);
	    }
	    if (length !== paramCount) {
	      this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property);
	    }
	    if (property.kind === "set" && property.value.rest) {
	      this.raise(Errors.BadSetterRestParameter, property);
	    }
	  }
	  flowObjectTypeSemicolon() {
	    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
	      this.unexpected();
	    }
	  }
	  flowParseQualifiedTypeIdentifier(startLoc, id) {
	    startLoc != null ? startLoc : startLoc = this.state.startLoc;
	    let node = id || this.flowParseRestrictedIdentifier(true);
	    while (this.eat(16)) {
	      const node2 = this.startNodeAt(startLoc);
	      node2.qualification = node;
	      node2.id = this.flowParseRestrictedIdentifier(true);
	      node = this.finishNode(node2, "QualifiedTypeIdentifier");
	    }
	    return node;
	  }
	  flowParseGenericType(startLoc, id) {
	    const node = this.startNodeAt(startLoc);
	    node.typeParameters = null;
	    node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
	    if (this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterInstantiation();
	    }
	    return this.finishNode(node, "GenericTypeAnnotation");
	  }
	  flowParseTypeofType() {
	    const node = this.startNode();
	    this.expect(87);
	    node.argument = this.flowParsePrimaryType();
	    return this.finishNode(node, "TypeofTypeAnnotation");
	  }
	  flowParseTupleType() {
	    const node = this.startNode();
	    node.types = [];
	    this.expect(0);
	    while (this.state.pos < this.length && !this.match(3)) {
	      node.types.push(this.flowParseType());
	      if (this.match(3)) break;
	      this.expect(12);
	    }
	    this.expect(3);
	    return this.finishNode(node, "TupleTypeAnnotation");
	  }
	  flowParseFunctionTypeParam(first) {
	    let name = null;
	    let optional = false;
	    let typeAnnotation = null;
	    const node = this.startNode();
	    const lh = this.lookahead();
	    const isThis = this.state.type === 78;
	    if (lh.type === 14 || lh.type === 17) {
	      if (isThis && !first) {
	        this.raise(FlowErrors.ThisParamMustBeFirst, node);
	      }
	      name = this.parseIdentifier(isThis);
	      if (this.eat(17)) {
	        optional = true;
	        if (isThis) {
	          this.raise(FlowErrors.ThisParamMayNotBeOptional, node);
	        }
	      }
	      typeAnnotation = this.flowParseTypeInitialiser();
	    } else {
	      typeAnnotation = this.flowParseType();
	    }
	    node.name = name;
	    node.optional = optional;
	    node.typeAnnotation = typeAnnotation;
	    return this.finishNode(node, "FunctionTypeParam");
	  }
	  reinterpretTypeAsFunctionTypeParam(type) {
	    const node = this.startNodeAt(type.loc.start);
	    node.name = null;
	    node.optional = false;
	    node.typeAnnotation = type;
	    return this.finishNode(node, "FunctionTypeParam");
	  }
	  flowParseFunctionTypeParams(params = []) {
	    let rest = null;
	    let _this = null;
	    if (this.match(78)) {
	      _this = this.flowParseFunctionTypeParam(true);
	      _this.name = null;
	      if (!this.match(11)) {
	        this.expect(12);
	      }
	    }
	    while (!this.match(11) && !this.match(21)) {
	      params.push(this.flowParseFunctionTypeParam(false));
	      if (!this.match(11)) {
	        this.expect(12);
	      }
	    }
	    if (this.eat(21)) {
	      rest = this.flowParseFunctionTypeParam(false);
	    }
	    return {
	      params,
	      rest,
	      _this
	    };
	  }
	  flowIdentToTypeAnnotation(startLoc, node, id) {
	    switch (id.name) {
	      case "any":
	        return this.finishNode(node, "AnyTypeAnnotation");
	      case "bool":
	      case "boolean":
	        return this.finishNode(node, "BooleanTypeAnnotation");
	      case "mixed":
	        return this.finishNode(node, "MixedTypeAnnotation");
	      case "empty":
	        return this.finishNode(node, "EmptyTypeAnnotation");
	      case "number":
	        return this.finishNode(node, "NumberTypeAnnotation");
	      case "string":
	        return this.finishNode(node, "StringTypeAnnotation");
	      case "symbol":
	        return this.finishNode(node, "SymbolTypeAnnotation");
	      default:
	        this.checkNotUnderscore(id.name);
	        return this.flowParseGenericType(startLoc, id);
	    }
	  }
	  flowParsePrimaryType() {
	    const startLoc = this.state.startLoc;
	    const node = this.startNode();
	    let tmp;
	    let type;
	    let isGroupedType = false;
	    const oldNoAnonFunctionType = this.state.noAnonFunctionType;
	    switch (this.state.type) {
	      case 5:
	        return this.flowParseObjectType({
	          allowStatic: false,
	          allowExact: false,
	          allowSpread: true,
	          allowProto: false,
	          allowInexact: true
	        });
	      case 6:
	        return this.flowParseObjectType({
	          allowStatic: false,
	          allowExact: true,
	          allowSpread: true,
	          allowProto: false,
	          allowInexact: false
	        });
	      case 0:
	        this.state.noAnonFunctionType = false;
	        type = this.flowParseTupleType();
	        this.state.noAnonFunctionType = oldNoAnonFunctionType;
	        return type;
	      case 47:
	        {
	          const node = this.startNode();
	          node.typeParameters = this.flowParseTypeParameterDeclaration();
	          this.expect(10);
	          tmp = this.flowParseFunctionTypeParams();
	          node.params = tmp.params;
	          node.rest = tmp.rest;
	          node.this = tmp._this;
	          this.expect(11);
	          this.expect(19);
	          node.returnType = this.flowParseType();
	          return this.finishNode(node, "FunctionTypeAnnotation");
	        }
	      case 10:
	        {
	          const node = this.startNode();
	          this.next();
	          if (!this.match(11) && !this.match(21)) {
	            if (tokenIsIdentifier(this.state.type) || this.match(78)) {
	              const token = this.lookahead().type;
	              isGroupedType = token !== 17 && token !== 14;
	            } else {
	              isGroupedType = true;
	            }
	          }
	          if (isGroupedType) {
	            this.state.noAnonFunctionType = false;
	            type = this.flowParseType();
	            this.state.noAnonFunctionType = oldNoAnonFunctionType;
	            if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
	              this.expect(11);
	              return type;
	            } else {
	              this.eat(12);
	            }
	          }
	          if (type) {
	            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
	          } else {
	            tmp = this.flowParseFunctionTypeParams();
	          }
	          node.params = tmp.params;
	          node.rest = tmp.rest;
	          node.this = tmp._this;
	          this.expect(11);
	          this.expect(19);
	          node.returnType = this.flowParseType();
	          node.typeParameters = null;
	          return this.finishNode(node, "FunctionTypeAnnotation");
	        }
	      case 134:
	        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
	      case 85:
	      case 86:
	        node.value = this.match(85);
	        this.next();
	        return this.finishNode(node, "BooleanLiteralTypeAnnotation");
	      case 53:
	        if (this.state.value === "-") {
	          this.next();
	          if (this.match(135)) {
	            return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
	          }
	          if (this.match(136)) {
	            return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
	          }
	          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
	        }
	        this.unexpected();
	        return;
	      case 135:
	        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
	      case 136:
	        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
	      case 88:
	        this.next();
	        return this.finishNode(node, "VoidTypeAnnotation");
	      case 84:
	        this.next();
	        return this.finishNode(node, "NullLiteralTypeAnnotation");
	      case 78:
	        this.next();
	        return this.finishNode(node, "ThisTypeAnnotation");
	      case 55:
	        this.next();
	        return this.finishNode(node, "ExistsTypeAnnotation");
	      case 87:
	        return this.flowParseTypeofType();
	      default:
	        if (tokenIsKeyword(this.state.type)) {
	          const label = tokenLabelName(this.state.type);
	          this.next();
	          return super.createIdentifier(node, label);
	        } else if (tokenIsIdentifier(this.state.type)) {
	          if (this.isContextual(129)) {
	            return this.flowParseInterfaceType();
	          }
	          return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
	        }
	    }
	    this.unexpected();
	  }
	  flowParsePostfixType() {
	    const startLoc = this.state.startLoc;
	    let type = this.flowParsePrimaryType();
	    let seenOptionalIndexedAccess = false;
	    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
	      const node = this.startNodeAt(startLoc);
	      const optional = this.eat(18);
	      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
	      this.expect(0);
	      if (!optional && this.match(3)) {
	        node.elementType = type;
	        this.next();
	        type = this.finishNode(node, "ArrayTypeAnnotation");
	      } else {
	        node.objectType = type;
	        node.indexType = this.flowParseType();
	        this.expect(3);
	        if (seenOptionalIndexedAccess) {
	          node.optional = optional;
	          type = this.finishNode(node, "OptionalIndexedAccessType");
	        } else {
	          type = this.finishNode(node, "IndexedAccessType");
	        }
	      }
	    }
	    return type;
	  }
	  flowParsePrefixType() {
	    const node = this.startNode();
	    if (this.eat(17)) {
	      node.typeAnnotation = this.flowParsePrefixType();
	      return this.finishNode(node, "NullableTypeAnnotation");
	    } else {
	      return this.flowParsePostfixType();
	    }
	  }
	  flowParseAnonFunctionWithoutParens() {
	    const param = this.flowParsePrefixType();
	    if (!this.state.noAnonFunctionType && this.eat(19)) {
	      const node = this.startNodeAt(param.loc.start);
	      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
	      node.rest = null;
	      node.this = null;
	      node.returnType = this.flowParseType();
	      node.typeParameters = null;
	      return this.finishNode(node, "FunctionTypeAnnotation");
	    }
	    return param;
	  }
	  flowParseIntersectionType() {
	    const node = this.startNode();
	    this.eat(45);
	    const type = this.flowParseAnonFunctionWithoutParens();
	    node.types = [type];
	    while (this.eat(45)) {
	      node.types.push(this.flowParseAnonFunctionWithoutParens());
	    }
	    return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
	  }
	  flowParseUnionType() {
	    const node = this.startNode();
	    this.eat(43);
	    const type = this.flowParseIntersectionType();
	    node.types = [type];
	    while (this.eat(43)) {
	      node.types.push(this.flowParseIntersectionType());
	    }
	    return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
	  }
	  flowParseType() {
	    const oldInType = this.state.inType;
	    this.state.inType = true;
	    const type = this.flowParseUnionType();
	    this.state.inType = oldInType;
	    return type;
	  }
	  flowParseTypeOrImplicitInstantiation() {
	    if (this.state.type === 132 && this.state.value === "_") {
	      const startLoc = this.state.startLoc;
	      const node = this.parseIdentifier();
	      return this.flowParseGenericType(startLoc, node);
	    } else {
	      return this.flowParseType();
	    }
	  }
	  flowParseTypeAnnotation() {
	    const node = this.startNode();
	    node.typeAnnotation = this.flowParseTypeInitialiser();
	    return this.finishNode(node, "TypeAnnotation");
	  }
	  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
	    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
	    if (this.match(14)) {
	      ident.typeAnnotation = this.flowParseTypeAnnotation();
	      this.resetEndLocation(ident);
	    }
	    return ident;
	  }
	  typeCastToParameter(node) {
	    node.expression.typeAnnotation = node.typeAnnotation;
	    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
	    return node.expression;
	  }
	  flowParseVariance() {
	    let variance = null;
	    if (this.match(53)) {
	      variance = this.startNode();
	      if (this.state.value === "+") {
	        variance.kind = "plus";
	      } else {
	        variance.kind = "minus";
	      }
	      this.next();
	      return this.finishNode(variance, "Variance");
	    }
	    return variance;
	  }
	  parseFunctionBody(node, allowExpressionBody, isMethod = false) {
	    if (allowExpressionBody) {
	      this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
	      return;
	    }
	    super.parseFunctionBody(node, false, isMethod);
	  }
	  parseFunctionBodyAndFinish(node, type, isMethod = false) {
	    if (this.match(14)) {
	      const typeNode = this.startNode();
	      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
	      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
	    }
	    return super.parseFunctionBodyAndFinish(node, type, isMethod);
	  }
	  parseStatementLike(flags) {
	    if (this.state.strict && this.isContextual(129)) {
	      const lookahead = this.lookahead();
	      if (tokenIsKeywordOrIdentifier(lookahead.type)) {
	        const node = this.startNode();
	        this.next();
	        return this.flowParseInterface(node);
	      }
	    } else if (this.isContextual(126)) {
	      const node = this.startNode();
	      this.next();
	      return this.flowParseEnumDeclaration(node);
	    }
	    const stmt = super.parseStatementLike(flags);
	    if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
	      this.flowPragma = null;
	    }
	    return stmt;
	  }
	  parseExpressionStatement(node, expr, decorators) {
	    if (expr.type === "Identifier") {
	      if (expr.name === "declare") {
	        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
	          return this.flowParseDeclare(node);
	        }
	      } else if (tokenIsIdentifier(this.state.type)) {
	        if (expr.name === "interface") {
	          return this.flowParseInterface(node);
	        } else if (expr.name === "type") {
	          return this.flowParseTypeAlias(node);
	        } else if (expr.name === "opaque") {
	          return this.flowParseOpaqueType(node, false);
	        }
	      }
	    }
	    return super.parseExpressionStatement(node, expr, decorators);
	  }
	  shouldParseExportDeclaration() {
	    const {
	      type
	    } = this.state;
	    if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
	      return !this.state.containsEsc;
	    }
	    return super.shouldParseExportDeclaration();
	  }
	  isExportDefaultSpecifier() {
	    const {
	      type
	    } = this.state;
	    if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
	      return this.state.containsEsc;
	    }
	    return super.isExportDefaultSpecifier();
	  }
	  parseExportDefaultExpression() {
	    if (this.isContextual(126)) {
	      const node = this.startNode();
	      this.next();
	      return this.flowParseEnumDeclaration(node);
	    }
	    return super.parseExportDefaultExpression();
	  }
	  parseConditional(expr, startLoc, refExpressionErrors) {
	    if (!this.match(17)) return expr;
	    if (this.state.maybeInArrowParameters) {
	      const nextCh = this.lookaheadCharCode();
	      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
	        this.setOptionalParametersError(refExpressionErrors);
	        return expr;
	      }
	    }
	    this.expect(17);
	    const state = this.state.clone();
	    const originalNoArrowAt = this.state.noArrowAt;
	    const node = this.startNodeAt(startLoc);
	    let {
	      consequent,
	      failed
	    } = this.tryParseConditionalConsequent();
	    let [valid, invalid] = this.getArrowLikeExpressions(consequent);
	    if (failed || invalid.length > 0) {
	      const noArrowAt = [...originalNoArrowAt];
	      if (invalid.length > 0) {
	        this.state = state;
	        this.state.noArrowAt = noArrowAt;
	        for (let i = 0; i < invalid.length; i++) {
	          noArrowAt.push(invalid[i].start);
	        }
	        ({
	          consequent,
	          failed
	        } = this.tryParseConditionalConsequent());
	        [valid, invalid] = this.getArrowLikeExpressions(consequent);
	      }
	      if (failed && valid.length > 1) {
	        this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);
	      }
	      if (failed && valid.length === 1) {
	        this.state = state;
	        noArrowAt.push(valid[0].start);
	        this.state.noArrowAt = noArrowAt;
	        ({
	          consequent,
	          failed
	        } = this.tryParseConditionalConsequent());
	      }
	    }
	    this.getArrowLikeExpressions(consequent, true);
	    this.state.noArrowAt = originalNoArrowAt;
	    this.expect(14);
	    node.test = expr;
	    node.consequent = consequent;
	    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));
	    return this.finishNode(node, "ConditionalExpression");
	  }
	  tryParseConditionalConsequent() {
	    this.state.noArrowParamsConversionAt.push(this.state.start);
	    const consequent = this.parseMaybeAssignAllowIn();
	    const failed = !this.match(14);
	    this.state.noArrowParamsConversionAt.pop();
	    return {
	      consequent,
	      failed
	    };
	  }
	  getArrowLikeExpressions(node, disallowInvalid) {
	    const stack = [node];
	    const arrows = [];
	    while (stack.length !== 0) {
	      const node = stack.pop();
	      if (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") {
	        if (node.typeParameters || !node.returnType) {
	          this.finishArrowValidation(node);
	        } else {
	          arrows.push(node);
	        }
	        stack.push(node.body);
	      } else if (node.type === "ConditionalExpression") {
	        stack.push(node.consequent);
	        stack.push(node.alternate);
	      }
	    }
	    if (disallowInvalid) {
	      arrows.forEach(node => this.finishArrowValidation(node));
	      return [arrows, []];
	    }
	    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));
	  }
	  finishArrowValidation(node) {
	    var _node$extra;
	    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
	    this.scope.enter(2 | 4);
	    super.checkParams(node, false, true);
	    this.scope.exit();
	  }
	  forwardNoArrowParamsConversionAt(node, parse) {
	    let result;
	    if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
	      this.state.noArrowParamsConversionAt.push(this.state.start);
	      result = parse();
	      this.state.noArrowParamsConversionAt.pop();
	    } else {
	      result = parse();
	    }
	    return result;
	  }
	  parseParenItem(node, startLoc) {
	    const newNode = super.parseParenItem(node, startLoc);
	    if (this.eat(17)) {
	      newNode.optional = true;
	      this.resetEndLocation(node);
	    }
	    if (this.match(14)) {
	      const typeCastNode = this.startNodeAt(startLoc);
	      typeCastNode.expression = newNode;
	      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
	      return this.finishNode(typeCastNode, "TypeCastExpression");
	    }
	    return newNode;
	  }
	  assertModuleNodeAllowed(node) {
	    if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
	      return;
	    }
	    super.assertModuleNodeAllowed(node);
	  }
	  parseExportDeclaration(node) {
	    if (this.isContextual(130)) {
	      node.exportKind = "type";
	      const declarationNode = this.startNode();
	      this.next();
	      if (this.match(5)) {
	        node.specifiers = this.parseExportSpecifiers(true);
	        super.parseExportFrom(node);
	        return null;
	      } else {
	        return this.flowParseTypeAlias(declarationNode);
	      }
	    } else if (this.isContextual(131)) {
	      node.exportKind = "type";
	      const declarationNode = this.startNode();
	      this.next();
	      return this.flowParseOpaqueType(declarationNode, false);
	    } else if (this.isContextual(129)) {
	      node.exportKind = "type";
	      const declarationNode = this.startNode();
	      this.next();
	      return this.flowParseInterface(declarationNode);
	    } else if (this.isContextual(126)) {
	      node.exportKind = "value";
	      const declarationNode = this.startNode();
	      this.next();
	      return this.flowParseEnumDeclaration(declarationNode);
	    } else {
	      return super.parseExportDeclaration(node);
	    }
	  }
	  eatExportStar(node) {
	    if (super.eatExportStar(node)) return true;
	    if (this.isContextual(130) && this.lookahead().type === 55) {
	      node.exportKind = "type";
	      this.next();
	      this.next();
	      return true;
	    }
	    return false;
	  }
	  maybeParseExportNamespaceSpecifier(node) {
	    const {
	      startLoc
	    } = this.state;
	    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
	    if (hasNamespace && node.exportKind === "type") {
	      this.unexpected(startLoc);
	    }
	    return hasNamespace;
	  }
	  parseClassId(node, isStatement, optionalId) {
	    super.parseClassId(node, isStatement, optionalId);
	    if (this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterDeclaration();
	    }
	  }
	  parseClassMember(classBody, member, state) {
	    const {
	      startLoc
	    } = this.state;
	    if (this.isContextual(125)) {
	      if (super.parseClassMemberFromModifier(classBody, member)) {
	        return;
	      }
	      member.declare = true;
	    }
	    super.parseClassMember(classBody, member, state);
	    if (member.declare) {
	      if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
	        this.raise(FlowErrors.DeclareClassElement, startLoc);
	      } else if (member.value) {
	        this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);
	      }
	    }
	  }
	  isIterator(word) {
	    return word === "iterator" || word === "asyncIterator";
	  }
	  readIterator() {
	    const word = super.readWord1();
	    const fullWord = "@@" + word;
	    if (!this.isIterator(word) || !this.state.inType) {
	      this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
	        identifierName: fullWord
	      });
	    }
	    this.finishToken(132, fullWord);
	  }
	  getTokenFromCode(code) {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (code === 123 && next === 124) {
	      this.finishOp(6, 2);
	    } else if (this.state.inType && (code === 62 || code === 60)) {
	      this.finishOp(code === 62 ? 48 : 47, 1);
	    } else if (this.state.inType && code === 63) {
	      if (next === 46) {
	        this.finishOp(18, 2);
	      } else {
	        this.finishOp(17, 1);
	      }
	    } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {
	      this.state.pos += 2;
	      this.readIterator();
	    } else {
	      super.getTokenFromCode(code);
	    }
	  }
	  isAssignable(node, isBinding) {
	    if (node.type === "TypeCastExpression") {
	      return this.isAssignable(node.expression, isBinding);
	    } else {
	      return super.isAssignable(node, isBinding);
	    }
	  }
	  toAssignable(node, isLHS = false) {
	    if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
	      node.left = this.typeCastToParameter(node.left);
	    }
	    super.toAssignable(node, isLHS);
	  }
	  toAssignableList(exprList, trailingCommaLoc, isLHS) {
	    for (let i = 0; i < exprList.length; i++) {
	      const expr = exprList[i];
	      if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
	        exprList[i] = this.typeCastToParameter(expr);
	      }
	    }
	    super.toAssignableList(exprList, trailingCommaLoc, isLHS);
	  }
	  toReferencedList(exprList, isParenthesizedExpr) {
	    for (let i = 0; i < exprList.length; i++) {
	      var _expr$extra;
	      const expr = exprList[i];
	      if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
	        this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
	      }
	    }
	    return exprList;
	  }
	  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
	    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
	    if (canBePattern && !this.state.maybeInArrowParameters) {
	      this.toReferencedList(node.elements);
	    }
	    return node;
	  }
	  isValidLVal(type, isParenthesized, binding) {
	    return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
	  }
	  parseClassProperty(node) {
	    if (this.match(14)) {
	      node.typeAnnotation = this.flowParseTypeAnnotation();
	    }
	    return super.parseClassProperty(node);
	  }
	  parseClassPrivateProperty(node) {
	    if (this.match(14)) {
	      node.typeAnnotation = this.flowParseTypeAnnotation();
	    }
	    return super.parseClassPrivateProperty(node);
	  }
	  isClassMethod() {
	    return this.match(47) || super.isClassMethod();
	  }
	  isClassProperty() {
	    return this.match(14) || super.isClassProperty();
	  }
	  isNonstaticConstructor(method) {
	    return !this.match(14) && super.isNonstaticConstructor(method);
	  }
	  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
	    if (method.variance) {
	      this.unexpected(method.variance.loc.start);
	    }
	    delete method.variance;
	    if (this.match(47)) {
	      method.typeParameters = this.flowParseTypeParameterDeclaration();
	    }
	    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
	    if (method.params && isConstructor) {
	      const params = method.params;
	      if (params.length > 0 && this.isThisParam(params[0])) {
	        this.raise(FlowErrors.ThisParamBannedInConstructor, method);
	      }
	    } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
	      const params = method.value.params;
	      if (params.length > 0 && this.isThisParam(params[0])) {
	        this.raise(FlowErrors.ThisParamBannedInConstructor, method);
	      }
	    }
	  }
	  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
	    if (method.variance) {
	      this.unexpected(method.variance.loc.start);
	    }
	    delete method.variance;
	    if (this.match(47)) {
	      method.typeParameters = this.flowParseTypeParameterDeclaration();
	    }
	    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
	  }
	  parseClassSuper(node) {
	    super.parseClassSuper(node);
	    if (node.superClass && (this.match(47) || this.match(51))) {
	      {
	        node.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression();
	      }
	    }
	    if (this.isContextual(113)) {
	      this.next();
	      const implemented = node.implements = [];
	      do {
	        const node = this.startNode();
	        node.id = this.flowParseRestrictedIdentifier(true);
	        if (this.match(47)) {
	          node.typeParameters = this.flowParseTypeParameterInstantiation();
	        } else {
	          node.typeParameters = null;
	        }
	        implemented.push(this.finishNode(node, "ClassImplements"));
	      } while (this.eat(12));
	    }
	  }
	  checkGetterSetterParams(method) {
	    super.checkGetterSetterParams(method);
	    const params = this.getObjectOrClassMethodParams(method);
	    if (params.length > 0) {
	      const param = params[0];
	      if (this.isThisParam(param) && method.kind === "get") {
	        this.raise(FlowErrors.GetterMayNotHaveThisParam, param);
	      } else if (this.isThisParam(param)) {
	        this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
	      }
	    }
	  }
	  parsePropertyNamePrefixOperator(node) {
	    node.variance = this.flowParseVariance();
	  }
	  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
	    if (prop.variance) {
	      this.unexpected(prop.variance.loc.start);
	    }
	    delete prop.variance;
	    let typeParameters;
	    if (this.match(47) && !isAccessor) {
	      typeParameters = this.flowParseTypeParameterDeclaration();
	      if (!this.match(10)) this.unexpected();
	    }
	    const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
	    if (typeParameters) {
	      (result.value || result).typeParameters = typeParameters;
	    }
	    return result;
	  }
	  parseFunctionParamType(param) {
	    if (this.eat(17)) {
	      if (param.type !== "Identifier") {
	        this.raise(FlowErrors.PatternIsOptional, param);
	      }
	      if (this.isThisParam(param)) {
	        this.raise(FlowErrors.ThisParamMayNotBeOptional, param);
	      }
	      param.optional = true;
	    }
	    if (this.match(14)) {
	      param.typeAnnotation = this.flowParseTypeAnnotation();
	    } else if (this.isThisParam(param)) {
	      this.raise(FlowErrors.ThisParamAnnotationRequired, param);
	    }
	    if (this.match(29) && this.isThisParam(param)) {
	      this.raise(FlowErrors.ThisParamNoDefault, param);
	    }
	    this.resetEndLocation(param);
	    return param;
	  }
	  parseMaybeDefault(startLoc, left) {
	    const node = super.parseMaybeDefault(startLoc, left);
	    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
	      this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);
	    }
	    return node;
	  }
	  checkImportReflection(node) {
	    super.checkImportReflection(node);
	    if (node.module && node.importKind !== "value") {
	      this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
	    }
	  }
	  parseImportSpecifierLocal(node, specifier, type) {
	    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
	    node.specifiers.push(this.finishImportSpecifier(specifier, type));
	  }
	  isPotentialImportPhase(isExport) {
	    if (super.isPotentialImportPhase(isExport)) return true;
	    if (this.isContextual(130)) {
	      if (!isExport) return true;
	      const ch = this.lookaheadCharCode();
	      return ch === 123 || ch === 42;
	    }
	    return !isExport && this.isContextual(87);
	  }
	  applyImportPhase(node, isExport, phase, loc) {
	    super.applyImportPhase(node, isExport, phase, loc);
	    if (isExport) {
	      if (!phase && this.match(65)) {
	        return;
	      }
	      node.exportKind = phase === "type" ? phase : "value";
	    } else {
	      if (phase === "type" && this.match(55)) this.unexpected();
	      node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
	    }
	  }
	  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
	    const firstIdent = specifier.imported;
	    let specifierTypeKind = null;
	    if (firstIdent.type === "Identifier") {
	      if (firstIdent.name === "type") {
	        specifierTypeKind = "type";
	      } else if (firstIdent.name === "typeof") {
	        specifierTypeKind = "typeof";
	      }
	    }
	    let isBinding = false;
	    if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
	      const as_ident = this.parseIdentifier(true);
	      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
	        specifier.imported = as_ident;
	        specifier.importKind = specifierTypeKind;
	        specifier.local = this.cloneIdentifier(as_ident);
	      } else {
	        specifier.imported = firstIdent;
	        specifier.importKind = null;
	        specifier.local = this.parseIdentifier();
	      }
	    } else {
	      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
	        specifier.imported = this.parseIdentifier(true);
	        specifier.importKind = specifierTypeKind;
	      } else {
	        if (importedIsString) {
	          throw this.raise(Errors.ImportBindingIsString, specifier, {
	            importName: firstIdent.value
	          });
	        }
	        specifier.imported = firstIdent;
	        specifier.importKind = null;
	      }
	      if (this.eatContextual(93)) {
	        specifier.local = this.parseIdentifier();
	      } else {
	        isBinding = true;
	        specifier.local = this.cloneIdentifier(specifier.imported);
	      }
	    }
	    const specifierIsTypeImport = hasTypeImportKind(specifier);
	    if (isInTypeOnlyImport && specifierIsTypeImport) {
	      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);
	    }
	    if (isInTypeOnlyImport || specifierIsTypeImport) {
	      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
	    }
	    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
	      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
	    }
	    return this.finishImportSpecifier(specifier, "ImportSpecifier");
	  }
	  parseBindingAtom() {
	    switch (this.state.type) {
	      case 78:
	        return this.parseIdentifier(true);
	      default:
	        return super.parseBindingAtom();
	    }
	  }
	  parseFunctionParams(node, isConstructor) {
	    const kind = node.kind;
	    if (kind !== "get" && kind !== "set" && this.match(47)) {
	      node.typeParameters = this.flowParseTypeParameterDeclaration();
	    }
	    super.parseFunctionParams(node, isConstructor);
	  }
	  parseVarId(decl, kind) {
	    super.parseVarId(decl, kind);
	    if (this.match(14)) {
	      decl.id.typeAnnotation = this.flowParseTypeAnnotation();
	      this.resetEndLocation(decl.id);
	    }
	  }
	  parseAsyncArrowFromCallExpression(node, call) {
	    if (this.match(14)) {
	      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
	      this.state.noAnonFunctionType = true;
	      node.returnType = this.flowParseTypeAnnotation();
	      this.state.noAnonFunctionType = oldNoAnonFunctionType;
	    }
	    return super.parseAsyncArrowFromCallExpression(node, call);
	  }
	  shouldParseAsyncArrow() {
	    return this.match(14) || super.shouldParseAsyncArrow();
	  }
	  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
	    var _jsx;
	    let state = null;
	    let jsx;
	    if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
	      state = this.state.clone();
	      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
	      if (!jsx.error) return jsx.node;
	      const {
	        context
	      } = this.state;
	      const currentContext = context[context.length - 1];
	      if (currentContext === types.j_oTag || currentContext === types.j_expr) {
	        context.pop();
	      }
	    }
	    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {
	      var _jsx2, _jsx3;
	      state = state || this.state.clone();
	      let typeParameters;
	      const arrow = this.tryParse(abort => {
	        var _arrowExpression$extr;
	        typeParameters = this.flowParseTypeParameterDeclaration();
	        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
	          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
	          this.resetStartLocationFromNode(result, typeParameters);
	          return result;
	        });
	        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();
	        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);
	        if (expr.type !== "ArrowFunctionExpression") abort();
	        expr.typeParameters = typeParameters;
	        this.resetStartLocationFromNode(expr, typeParameters);
	        return arrowExpression;
	      }, state);
	      let arrowExpression = null;
	      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
	        if (!arrow.error && !arrow.aborted) {
	          if (arrow.node.async) {
	            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);
	          }
	          return arrow.node;
	        }
	        arrowExpression = arrow.node;
	      }
	      if ((_jsx2 = jsx) != null && _jsx2.node) {
	        this.state = jsx.failState;
	        return jsx.node;
	      }
	      if (arrowExpression) {
	        this.state = arrow.failState;
	        return arrowExpression;
	      }
	      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
	      if (arrow.thrown) throw arrow.error;
	      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
	    }
	    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
	  }
	  parseArrow(node) {
	    if (this.match(14)) {
	      const result = this.tryParse(() => {
	        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
	        this.state.noAnonFunctionType = true;
	        const typeNode = this.startNode();
	        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
	        this.state.noAnonFunctionType = oldNoAnonFunctionType;
	        if (this.canInsertSemicolon()) this.unexpected();
	        if (!this.match(19)) this.unexpected();
	        return typeNode;
	      });
	      if (result.thrown) return null;
	      if (result.error) this.state = result.failState;
	      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
	    }
	    return super.parseArrow(node);
	  }
	  shouldParseArrow(params) {
	    return this.match(14) || super.shouldParseArrow(params);
	  }
	  setArrowFunctionParameters(node, params) {
	    if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
	      node.params = params;
	    } else {
	      super.setArrowFunctionParameters(node, params);
	    }
	  }
	  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
	    if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
	      return;
	    }
	    for (let i = 0; i < node.params.length; i++) {
	      if (this.isThisParam(node.params[i]) && i > 0) {
	        this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);
	      }
	    }
	    super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
	  }
	  parseParenAndDistinguishExpression(canBeArrow) {
	    return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
	  }
	  parseSubscripts(base, startLoc, noCalls) {
	    if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {
	      this.next();
	      const node = this.startNodeAt(startLoc);
	      node.callee = base;
	      node.arguments = super.parseCallExpressionArguments(11);
	      base = this.finishNode(node, "CallExpression");
	    } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
	      const state = this.state.clone();
	      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
	      if (!arrow.error && !arrow.aborted) return arrow.node;
	      const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
	      if (result.node && !result.error) return result.node;
	      if (arrow.node) {
	        this.state = arrow.failState;
	        return arrow.node;
	      }
	      if (result.node) {
	        this.state = result.failState;
	        return result.node;
	      }
	      throw arrow.error || result.error;
	    }
	    return super.parseSubscripts(base, startLoc, noCalls);
	  }
	  parseSubscript(base, startLoc, noCalls, subscriptState) {
	    if (this.match(18) && this.isLookaheadToken_lt()) {
	      subscriptState.optionalChainMember = true;
	      if (noCalls) {
	        subscriptState.stop = true;
	        return base;
	      }
	      this.next();
	      const node = this.startNodeAt(startLoc);
	      node.callee = base;
	      node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
	      this.expect(10);
	      node.arguments = this.parseCallExpressionArguments(11);
	      node.optional = true;
	      return this.finishCallExpression(node, true);
	    } else if (!noCalls && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
	      const node = this.startNodeAt(startLoc);
	      node.callee = base;
	      const result = this.tryParse(() => {
	        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
	        this.expect(10);
	        node.arguments = super.parseCallExpressionArguments(11);
	        if (subscriptState.optionalChainMember) {
	          node.optional = false;
	        }
	        return this.finishCallExpression(node, subscriptState.optionalChainMember);
	      });
	      if (result.node) {
	        if (result.error) this.state = result.failState;
	        return result.node;
	      }
	    }
	    return super.parseSubscript(base, startLoc, noCalls, subscriptState);
	  }
	  parseNewCallee(node) {
	    super.parseNewCallee(node);
	    let targs = null;
	    if (this.shouldParseTypes() && this.match(47)) {
	      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
	    }
	    node.typeArguments = targs;
	  }
	  parseAsyncArrowWithTypeParameters(startLoc) {
	    const node = this.startNodeAt(startLoc);
	    this.parseFunctionParams(node, false);
	    if (!this.parseArrow(node)) return;
	    return super.parseArrowExpression(node, undefined, true);
	  }
	  readToken_mult_modulo(code) {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (code === 42 && next === 47 && this.state.hasFlowComment) {
	      this.state.hasFlowComment = false;
	      this.state.pos += 2;
	      this.nextToken();
	      return;
	    }
	    super.readToken_mult_modulo(code);
	  }
	  readToken_pipe_amp(code) {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (code === 124 && next === 125) {
	      this.finishOp(9, 2);
	      return;
	    }
	    super.readToken_pipe_amp(code);
	  }
	  parseTopLevel(file, program) {
	    const fileNode = super.parseTopLevel(file, program);
	    if (this.state.hasFlowComment) {
	      this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());
	    }
	    return fileNode;
	  }
	  skipBlockComment() {
	    if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
	      if (this.state.hasFlowComment) {
	        throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
	      }
	      this.hasFlowCommentCompletion();
	      const commentSkip = this.skipFlowComment();
	      if (commentSkip) {
	        this.state.pos += commentSkip;
	        this.state.hasFlowComment = true;
	      }
	      return;
	    }
	    return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
	  }
	  skipFlowComment() {
	    const {
	      pos
	    } = this.state;
	    let shiftToFirstNonWhiteSpace = 2;
	    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
	      shiftToFirstNonWhiteSpace++;
	    }
	    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
	    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
	    if (ch2 === 58 && ch3 === 58) {
	      return shiftToFirstNonWhiteSpace + 2;
	    }
	    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
	      return shiftToFirstNonWhiteSpace + 12;
	    }
	    if (ch2 === 58 && ch3 !== 58) {
	      return shiftToFirstNonWhiteSpace;
	    }
	    return false;
	  }
	  hasFlowCommentCompletion() {
	    const end = this.input.indexOf("*/", this.state.pos);
	    if (end === -1) {
	      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
	    }
	  }
	  flowEnumErrorBooleanMemberNotInitialized(loc, {
	    enumName,
	    memberName
	  }) {
	    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
	      memberName,
	      enumName
	    });
	  }
	  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
	    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);
	  }
	  flowEnumErrorNumberMemberNotInitialized(loc, details) {
	    this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
	  }
	  flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
	    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);
	  }
	  flowEnumMemberInit() {
	    const startLoc = this.state.startLoc;
	    const endOfInit = () => this.match(12) || this.match(8);
	    switch (this.state.type) {
	      case 135:
	        {
	          const literal = this.parseNumericLiteral(this.state.value);
	          if (endOfInit()) {
	            return {
	              type: "number",
	              loc: literal.loc.start,
	              value: literal
	            };
	          }
	          return {
	            type: "invalid",
	            loc: startLoc
	          };
	        }
	      case 134:
	        {
	          const literal = this.parseStringLiteral(this.state.value);
	          if (endOfInit()) {
	            return {
	              type: "string",
	              loc: literal.loc.start,
	              value: literal
	            };
	          }
	          return {
	            type: "invalid",
	            loc: startLoc
	          };
	        }
	      case 85:
	      case 86:
	        {
	          const literal = this.parseBooleanLiteral(this.match(85));
	          if (endOfInit()) {
	            return {
	              type: "boolean",
	              loc: literal.loc.start,
	              value: literal
	            };
	          }
	          return {
	            type: "invalid",
	            loc: startLoc
	          };
	        }
	      default:
	        return {
	          type: "invalid",
	          loc: startLoc
	        };
	    }
	  }
	  flowEnumMemberRaw() {
	    const loc = this.state.startLoc;
	    const id = this.parseIdentifier(true);
	    const init = this.eat(29) ? this.flowEnumMemberInit() : {
	      type: "none",
	      loc
	    };
	    return {
	      id,
	      init
	    };
	  }
	  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
	    const {
	      explicitType
	    } = context;
	    if (explicitType === null) {
	      return;
	    }
	    if (explicitType !== expectedType) {
	      this.flowEnumErrorInvalidMemberInitializer(loc, context);
	    }
	  }
	  flowEnumMembers({
	    enumName,
	    explicitType
	  }) {
	    const seenNames = new Set();
	    const members = {
	      booleanMembers: [],
	      numberMembers: [],
	      stringMembers: [],
	      defaultedMembers: []
	    };
	    let hasUnknownMembers = false;
	    while (!this.match(8)) {
	      if (this.eat(21)) {
	        hasUnknownMembers = true;
	        break;
	      }
	      const memberNode = this.startNode();
	      const {
	        id,
	        init
	      } = this.flowEnumMemberRaw();
	      const memberName = id.name;
	      if (memberName === "") {
	        continue;
	      }
	      if (/^[a-z]/.test(memberName)) {
	        this.raise(FlowErrors.EnumInvalidMemberName, id, {
	          memberName,
	          suggestion: memberName[0].toUpperCase() + memberName.slice(1),
	          enumName
	        });
	      }
	      if (seenNames.has(memberName)) {
	        this.raise(FlowErrors.EnumDuplicateMemberName, id, {
	          memberName,
	          enumName
	        });
	      }
	      seenNames.add(memberName);
	      const context = {
	        enumName,
	        explicitType,
	        memberName
	      };
	      memberNode.id = id;
	      switch (init.type) {
	        case "boolean":
	          {
	            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
	            memberNode.init = init.value;
	            members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
	            break;
	          }
	        case "number":
	          {
	            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
	            memberNode.init = init.value;
	            members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
	            break;
	          }
	        case "string":
	          {
	            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
	            memberNode.init = init.value;
	            members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
	            break;
	          }
	        case "invalid":
	          {
	            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
	          }
	        case "none":
	          {
	            switch (explicitType) {
	              case "boolean":
	                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
	                break;
	              case "number":
	                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
	                break;
	              default:
	                members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
	            }
	          }
	      }
	      if (!this.match(8)) {
	        this.expect(12);
	      }
	    }
	    return {
	      members,
	      hasUnknownMembers
	    };
	  }
	  flowEnumStringMembers(initializedMembers, defaultedMembers, {
	    enumName
	  }) {
	    if (initializedMembers.length === 0) {
	      return defaultedMembers;
	    } else if (defaultedMembers.length === 0) {
	      return initializedMembers;
	    } else if (defaultedMembers.length > initializedMembers.length) {
	      for (const member of initializedMembers) {
	        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
	          enumName
	        });
	      }
	      return defaultedMembers;
	    } else {
	      for (const member of defaultedMembers) {
	        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
	          enumName
	        });
	      }
	      return initializedMembers;
	    }
	  }
	  flowEnumParseExplicitType({
	    enumName
	  }) {
	    if (!this.eatContextual(102)) return null;
	    if (!tokenIsIdentifier(this.state.type)) {
	      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
	        enumName
	      });
	    }
	    const {
	      value
	    } = this.state;
	    this.next();
	    if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
	      this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
	        enumName,
	        invalidEnumType: value
	      });
	    }
	    return value;
	  }
	  flowEnumBody(node, id) {
	    const enumName = id.name;
	    const nameLoc = id.loc.start;
	    const explicitType = this.flowEnumParseExplicitType({
	      enumName
	    });
	    this.expect(5);
	    const {
	      members,
	      hasUnknownMembers
	    } = this.flowEnumMembers({
	      enumName,
	      explicitType
	    });
	    node.hasUnknownMembers = hasUnknownMembers;
	    switch (explicitType) {
	      case "boolean":
	        node.explicitType = true;
	        node.members = members.booleanMembers;
	        this.expect(8);
	        return this.finishNode(node, "EnumBooleanBody");
	      case "number":
	        node.explicitType = true;
	        node.members = members.numberMembers;
	        this.expect(8);
	        return this.finishNode(node, "EnumNumberBody");
	      case "string":
	        node.explicitType = true;
	        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
	          enumName
	        });
	        this.expect(8);
	        return this.finishNode(node, "EnumStringBody");
	      case "symbol":
	        node.members = members.defaultedMembers;
	        this.expect(8);
	        return this.finishNode(node, "EnumSymbolBody");
	      default:
	        {
	          const empty = () => {
	            node.members = [];
	            this.expect(8);
	            return this.finishNode(node, "EnumStringBody");
	          };
	          node.explicitType = false;
	          const boolsLen = members.booleanMembers.length;
	          const numsLen = members.numberMembers.length;
	          const strsLen = members.stringMembers.length;
	          const defaultedLen = members.defaultedMembers.length;
	          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
	            return empty();
	          } else if (!boolsLen && !numsLen) {
	            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
	              enumName
	            });
	            this.expect(8);
	            return this.finishNode(node, "EnumStringBody");
	          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
	            for (const member of members.defaultedMembers) {
	              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
	                enumName,
	                memberName: member.id.name
	              });
	            }
	            node.members = members.booleanMembers;
	            this.expect(8);
	            return this.finishNode(node, "EnumBooleanBody");
	          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
	            for (const member of members.defaultedMembers) {
	              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
	                enumName,
	                memberName: member.id.name
	              });
	            }
	            node.members = members.numberMembers;
	            this.expect(8);
	            return this.finishNode(node, "EnumNumberBody");
	          } else {
	            this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
	              enumName
	            });
	            return empty();
	          }
	        }
	    }
	  }
	  flowParseEnumDeclaration(node) {
	    const id = this.parseIdentifier();
	    node.id = id;
	    node.body = this.flowEnumBody(this.startNode(), id);
	    return this.finishNode(node, "EnumDeclaration");
	  }
	  jsxParseOpeningElementAfterName(node) {
	    if (this.shouldParseTypes()) {
	      if (this.match(47) || this.match(51)) {
	        node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
	      }
	    }
	    return super.jsxParseOpeningElementAfterName(node);
	  }
	  isLookaheadToken_lt() {
	    const next = this.nextTokenStart();
	    if (this.input.charCodeAt(next) === 60) {
	      const afterNext = this.input.charCodeAt(next + 1);
	      return afterNext !== 60 && afterNext !== 61;
	    }
	    return false;
	  }
	  reScan_lt_gt() {
	    const {
	      type
	    } = this.state;
	    if (type === 47) {
	      this.state.pos -= 1;
	      this.readToken_lt();
	    } else if (type === 48) {
	      this.state.pos -= 1;
	      this.readToken_gt();
	    }
	  }
	  reScan_lt() {
	    const {
	      type
	    } = this.state;
	    if (type === 51) {
	      this.state.pos -= 2;
	      this.finishOp(47, 1);
	      return 47;
	    }
	    return type;
	  }
	  maybeUnwrapTypeCastExpression(node) {
	    return node.type === "TypeCastExpression" ? node.expression : node;
	  }
	};
	const entities = {
	  __proto__: null,
	  quot: "\u0022",
	  amp: "&",
	  apos: "\u0027",
	  lt: "<",
	  gt: ">",
	  nbsp: "\u00A0",
	  iexcl: "\u00A1",
	  cent: "\u00A2",
	  pound: "\u00A3",
	  curren: "\u00A4",
	  yen: "\u00A5",
	  brvbar: "\u00A6",
	  sect: "\u00A7",
	  uml: "\u00A8",
	  copy: "\u00A9",
	  ordf: "\u00AA",
	  laquo: "\u00AB",
	  not: "\u00AC",
	  shy: "\u00AD",
	  reg: "\u00AE",
	  macr: "\u00AF",
	  deg: "\u00B0",
	  plusmn: "\u00B1",
	  sup2: "\u00B2",
	  sup3: "\u00B3",
	  acute: "\u00B4",
	  micro: "\u00B5",
	  para: "\u00B6",
	  middot: "\u00B7",
	  cedil: "\u00B8",
	  sup1: "\u00B9",
	  ordm: "\u00BA",
	  raquo: "\u00BB",
	  frac14: "\u00BC",
	  frac12: "\u00BD",
	  frac34: "\u00BE",
	  iquest: "\u00BF",
	  Agrave: "\u00C0",
	  Aacute: "\u00C1",
	  Acirc: "\u00C2",
	  Atilde: "\u00C3",
	  Auml: "\u00C4",
	  Aring: "\u00C5",
	  AElig: "\u00C6",
	  Ccedil: "\u00C7",
	  Egrave: "\u00C8",
	  Eacute: "\u00C9",
	  Ecirc: "\u00CA",
	  Euml: "\u00CB",
	  Igrave: "\u00CC",
	  Iacute: "\u00CD",
	  Icirc: "\u00CE",
	  Iuml: "\u00CF",
	  ETH: "\u00D0",
	  Ntilde: "\u00D1",
	  Ograve: "\u00D2",
	  Oacute: "\u00D3",
	  Ocirc: "\u00D4",
	  Otilde: "\u00D5",
	  Ouml: "\u00D6",
	  times: "\u00D7",
	  Oslash: "\u00D8",
	  Ugrave: "\u00D9",
	  Uacute: "\u00DA",
	  Ucirc: "\u00DB",
	  Uuml: "\u00DC",
	  Yacute: "\u00DD",
	  THORN: "\u00DE",
	  szlig: "\u00DF",
	  agrave: "\u00E0",
	  aacute: "\u00E1",
	  acirc: "\u00E2",
	  atilde: "\u00E3",
	  auml: "\u00E4",
	  aring: "\u00E5",
	  aelig: "\u00E6",
	  ccedil: "\u00E7",
	  egrave: "\u00E8",
	  eacute: "\u00E9",
	  ecirc: "\u00EA",
	  euml: "\u00EB",
	  igrave: "\u00EC",
	  iacute: "\u00ED",
	  icirc: "\u00EE",
	  iuml: "\u00EF",
	  eth: "\u00F0",
	  ntilde: "\u00F1",
	  ograve: "\u00F2",
	  oacute: "\u00F3",
	  ocirc: "\u00F4",
	  otilde: "\u00F5",
	  ouml: "\u00F6",
	  divide: "\u00F7",
	  oslash: "\u00F8",
	  ugrave: "\u00F9",
	  uacute: "\u00FA",
	  ucirc: "\u00FB",
	  uuml: "\u00FC",
	  yacute: "\u00FD",
	  thorn: "\u00FE",
	  yuml: "\u00FF",
	  OElig: "\u0152",
	  oelig: "\u0153",
	  Scaron: "\u0160",
	  scaron: "\u0161",
	  Yuml: "\u0178",
	  fnof: "\u0192",
	  circ: "\u02C6",
	  tilde: "\u02DC",
	  Alpha: "\u0391",
	  Beta: "\u0392",
	  Gamma: "\u0393",
	  Delta: "\u0394",
	  Epsilon: "\u0395",
	  Zeta: "\u0396",
	  Eta: "\u0397",
	  Theta: "\u0398",
	  Iota: "\u0399",
	  Kappa: "\u039A",
	  Lambda: "\u039B",
	  Mu: "\u039C",
	  Nu: "\u039D",
	  Xi: "\u039E",
	  Omicron: "\u039F",
	  Pi: "\u03A0",
	  Rho: "\u03A1",
	  Sigma: "\u03A3",
	  Tau: "\u03A4",
	  Upsilon: "\u03A5",
	  Phi: "\u03A6",
	  Chi: "\u03A7",
	  Psi: "\u03A8",
	  Omega: "\u03A9",
	  alpha: "\u03B1",
	  beta: "\u03B2",
	  gamma: "\u03B3",
	  delta: "\u03B4",
	  epsilon: "\u03B5",
	  zeta: "\u03B6",
	  eta: "\u03B7",
	  theta: "\u03B8",
	  iota: "\u03B9",
	  kappa: "\u03BA",
	  lambda: "\u03BB",
	  mu: "\u03BC",
	  nu: "\u03BD",
	  xi: "\u03BE",
	  omicron: "\u03BF",
	  pi: "\u03C0",
	  rho: "\u03C1",
	  sigmaf: "\u03C2",
	  sigma: "\u03C3",
	  tau: "\u03C4",
	  upsilon: "\u03C5",
	  phi: "\u03C6",
	  chi: "\u03C7",
	  psi: "\u03C8",
	  omega: "\u03C9",
	  thetasym: "\u03D1",
	  upsih: "\u03D2",
	  piv: "\u03D6",
	  ensp: "\u2002",
	  emsp: "\u2003",
	  thinsp: "\u2009",
	  zwnj: "\u200C",
	  zwj: "\u200D",
	  lrm: "\u200E",
	  rlm: "\u200F",
	  ndash: "\u2013",
	  mdash: "\u2014",
	  lsquo: "\u2018",
	  rsquo: "\u2019",
	  sbquo: "\u201A",
	  ldquo: "\u201C",
	  rdquo: "\u201D",
	  bdquo: "\u201E",
	  dagger: "\u2020",
	  Dagger: "\u2021",
	  bull: "\u2022",
	  hellip: "\u2026",
	  permil: "\u2030",
	  prime: "\u2032",
	  Prime: "\u2033",
	  lsaquo: "\u2039",
	  rsaquo: "\u203A",
	  oline: "\u203E",
	  frasl: "\u2044",
	  euro: "\u20AC",
	  image: "\u2111",
	  weierp: "\u2118",
	  real: "\u211C",
	  trade: "\u2122",
	  alefsym: "\u2135",
	  larr: "\u2190",
	  uarr: "\u2191",
	  rarr: "\u2192",
	  darr: "\u2193",
	  harr: "\u2194",
	  crarr: "\u21B5",
	  lArr: "\u21D0",
	  uArr: "\u21D1",
	  rArr: "\u21D2",
	  dArr: "\u21D3",
	  hArr: "\u21D4",
	  forall: "\u2200",
	  part: "\u2202",
	  exist: "\u2203",
	  empty: "\u2205",
	  nabla: "\u2207",
	  isin: "\u2208",
	  notin: "\u2209",
	  ni: "\u220B",
	  prod: "\u220F",
	  sum: "\u2211",
	  minus: "\u2212",
	  lowast: "\u2217",
	  radic: "\u221A",
	  prop: "\u221D",
	  infin: "\u221E",
	  ang: "\u2220",
	  and: "\u2227",
	  or: "\u2228",
	  cap: "\u2229",
	  cup: "\u222A",
	  int: "\u222B",
	  there4: "\u2234",
	  sim: "\u223C",
	  cong: "\u2245",
	  asymp: "\u2248",
	  ne: "\u2260",
	  equiv: "\u2261",
	  le: "\u2264",
	  ge: "\u2265",
	  sub: "\u2282",
	  sup: "\u2283",
	  nsub: "\u2284",
	  sube: "\u2286",
	  supe: "\u2287",
	  oplus: "\u2295",
	  otimes: "\u2297",
	  perp: "\u22A5",
	  sdot: "\u22C5",
	  lceil: "\u2308",
	  rceil: "\u2309",
	  lfloor: "\u230A",
	  rfloor: "\u230B",
	  lang: "\u2329",
	  rang: "\u232A",
	  loz: "\u25CA",
	  spades: "\u2660",
	  clubs: "\u2663",
	  hearts: "\u2665",
	  diams: "\u2666"
	};
	const lineBreak = /\r\n|[\r\n\u2028\u2029]/;
	const lineBreakG = new RegExp(lineBreak.source, "g");
	function isNewLine(code) {
	  switch (code) {
	    case 10:
	    case 13:
	    case 8232:
	    case 8233:
	      return true;
	    default:
	      return false;
	  }
	}
	function hasNewLine(input, start, end) {
	  for (let i = start; i < end; i++) {
	    if (isNewLine(input.charCodeAt(i))) {
	      return true;
	    }
	  }
	  return false;
	}
	const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
	const skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
	function isWhitespace(code) {
	  switch (code) {
	    case 0x0009:
	    case 0x000b:
	    case 0x000c:
	    case 32:
	    case 160:
	    case 5760:
	    case 0x2000:
	    case 0x2001:
	    case 0x2002:
	    case 0x2003:
	    case 0x2004:
	    case 0x2005:
	    case 0x2006:
	    case 0x2007:
	    case 0x2008:
	    case 0x2009:
	    case 0x200a:
	    case 0x202f:
	    case 0x205f:
	    case 0x3000:
	    case 0xfeff:
	      return true;
	    default:
	      return false;
	  }
	}
	const JsxErrors = ParseErrorEnum`jsx`({
	  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
	  MissingClosingTagElement: ({
	    openingTagName
	  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
	  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
	  UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
	  UnexpectedToken: ({
	    unexpected,
	    HTMLEntity
	  }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
	  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
	  UnterminatedJsxContent: "Unterminated JSX contents.",
	  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
	});
	function isFragment(object) {
	  return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
	}
	function getQualifiedJSXName(object) {
	  if (object.type === "JSXIdentifier") {
	    return object.name;
	  }
	  if (object.type === "JSXNamespacedName") {
	    return object.namespace.name + ":" + object.name.name;
	  }
	  if (object.type === "JSXMemberExpression") {
	    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
	  }
	  throw new Error("Node had unexpected type: " + object.type);
	}
	var jsx = superClass => class JSXParserMixin extends superClass {
	  jsxReadToken() {
	    let out = "";
	    let chunkStart = this.state.pos;
	    for (;;) {
	      if (this.state.pos >= this.length) {
	        throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
	      }
	      const ch = this.input.charCodeAt(this.state.pos);
	      switch (ch) {
	        case 60:
	        case 123:
	          if (this.state.pos === this.state.start) {
	            if (ch === 60 && this.state.canStartJSXElement) {
	              ++this.state.pos;
	              this.finishToken(143);
	            } else {
	              super.getTokenFromCode(ch);
	            }
	            return;
	          }
	          out += this.input.slice(chunkStart, this.state.pos);
	          this.finishToken(142, out);
	          return;
	        case 38:
	          out += this.input.slice(chunkStart, this.state.pos);
	          out += this.jsxReadEntity();
	          chunkStart = this.state.pos;
	          break;
	        case 62:
	        case 125:
	        default:
	          if (isNewLine(ch)) {
	            out += this.input.slice(chunkStart, this.state.pos);
	            out += this.jsxReadNewLine(true);
	            chunkStart = this.state.pos;
	          } else {
	            ++this.state.pos;
	          }
	      }
	    }
	  }
	  jsxReadNewLine(normalizeCRLF) {
	    const ch = this.input.charCodeAt(this.state.pos);
	    let out;
	    ++this.state.pos;
	    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
	      ++this.state.pos;
	      out = normalizeCRLF ? "\n" : "\r\n";
	    } else {
	      out = String.fromCharCode(ch);
	    }
	    ++this.state.curLine;
	    this.state.lineStart = this.state.pos;
	    return out;
	  }
	  jsxReadString(quote) {
	    let out = "";
	    let chunkStart = ++this.state.pos;
	    for (;;) {
	      if (this.state.pos >= this.length) {
	        throw this.raise(Errors.UnterminatedString, this.state.startLoc);
	      }
	      const ch = this.input.charCodeAt(this.state.pos);
	      if (ch === quote) break;
	      if (ch === 38) {
	        out += this.input.slice(chunkStart, this.state.pos);
	        out += this.jsxReadEntity();
	        chunkStart = this.state.pos;
	      } else if (isNewLine(ch)) {
	        out += this.input.slice(chunkStart, this.state.pos);
	        out += this.jsxReadNewLine(false);
	        chunkStart = this.state.pos;
	      } else {
	        ++this.state.pos;
	      }
	    }
	    out += this.input.slice(chunkStart, this.state.pos++);
	    this.finishToken(134, out);
	  }
	  jsxReadEntity() {
	    const startPos = ++this.state.pos;
	    if (this.codePointAtPos(this.state.pos) === 35) {
	      ++this.state.pos;
	      let radix = 10;
	      if (this.codePointAtPos(this.state.pos) === 120) {
	        radix = 16;
	        ++this.state.pos;
	      }
	      const codePoint = this.readInt(radix, undefined, false, "bail");
	      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
	        ++this.state.pos;
	        return String.fromCodePoint(codePoint);
	      }
	    } else {
	      let count = 0;
	      let semi = false;
	      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {
	        ++this.state.pos;
	      }
	      if (semi) {
	        const desc = this.input.slice(startPos, this.state.pos);
	        const entity = entities[desc];
	        ++this.state.pos;
	        if (entity) {
	          return entity;
	        }
	      }
	    }
	    this.state.pos = startPos;
	    return "&";
	  }
	  jsxReadWord() {
	    let ch;
	    const start = this.state.pos;
	    do {
	      ch = this.input.charCodeAt(++this.state.pos);
	    } while (isIdentifierChar(ch) || ch === 45);
	    this.finishToken(141, this.input.slice(start, this.state.pos));
	  }
	  jsxParseIdentifier() {
	    const node = this.startNode();
	    if (this.match(141)) {
	      node.name = this.state.value;
	    } else if (tokenIsKeyword(this.state.type)) {
	      node.name = tokenLabelName(this.state.type);
	    } else {
	      this.unexpected();
	    }
	    this.next();
	    return this.finishNode(node, "JSXIdentifier");
	  }
	  jsxParseNamespacedName() {
	    const startLoc = this.state.startLoc;
	    const name = this.jsxParseIdentifier();
	    if (!this.eat(14)) return name;
	    const node = this.startNodeAt(startLoc);
	    node.namespace = name;
	    node.name = this.jsxParseIdentifier();
	    return this.finishNode(node, "JSXNamespacedName");
	  }
	  jsxParseElementName() {
	    const startLoc = this.state.startLoc;
	    let node = this.jsxParseNamespacedName();
	    if (node.type === "JSXNamespacedName") {
	      return node;
	    }
	    while (this.eat(16)) {
	      const newNode = this.startNodeAt(startLoc);
	      newNode.object = node;
	      newNode.property = this.jsxParseIdentifier();
	      node = this.finishNode(newNode, "JSXMemberExpression");
	    }
	    return node;
	  }
	  jsxParseAttributeValue() {
	    let node;
	    switch (this.state.type) {
	      case 5:
	        node = this.startNode();
	        this.setContext(types.brace);
	        this.next();
	        node = this.jsxParseExpressionContainer(node, types.j_oTag);
	        if (node.expression.type === "JSXEmptyExpression") {
	          this.raise(JsxErrors.AttributeIsEmpty, node);
	        }
	        return node;
	      case 143:
	      case 134:
	        return this.parseExprAtom();
	      default:
	        throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
	    }
	  }
	  jsxParseEmptyExpression() {
	    const node = this.startNodeAt(this.state.lastTokEndLoc);
	    return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
	  }
	  jsxParseSpreadChild(node) {
	    this.next();
	    node.expression = this.parseExpression();
	    this.setContext(types.j_expr);
	    this.state.canStartJSXElement = true;
	    this.expect(8);
	    return this.finishNode(node, "JSXSpreadChild");
	  }
	  jsxParseExpressionContainer(node, previousContext) {
	    if (this.match(8)) {
	      node.expression = this.jsxParseEmptyExpression();
	    } else {
	      const expression = this.parseExpression();
	      node.expression = expression;
	    }
	    this.setContext(previousContext);
	    this.state.canStartJSXElement = true;
	    this.expect(8);
	    return this.finishNode(node, "JSXExpressionContainer");
	  }
	  jsxParseAttribute() {
	    const node = this.startNode();
	    if (this.match(5)) {
	      this.setContext(types.brace);
	      this.next();
	      this.expect(21);
	      node.argument = this.parseMaybeAssignAllowIn();
	      this.setContext(types.j_oTag);
	      this.state.canStartJSXElement = true;
	      this.expect(8);
	      return this.finishNode(node, "JSXSpreadAttribute");
	    }
	    node.name = this.jsxParseNamespacedName();
	    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
	    return this.finishNode(node, "JSXAttribute");
	  }
	  jsxParseOpeningElementAt(startLoc) {
	    const node = this.startNodeAt(startLoc);
	    if (this.eat(144)) {
	      return this.finishNode(node, "JSXOpeningFragment");
	    }
	    node.name = this.jsxParseElementName();
	    return this.jsxParseOpeningElementAfterName(node);
	  }
	  jsxParseOpeningElementAfterName(node) {
	    const attributes = [];
	    while (!this.match(56) && !this.match(144)) {
	      attributes.push(this.jsxParseAttribute());
	    }
	    node.attributes = attributes;
	    node.selfClosing = this.eat(56);
	    this.expect(144);
	    return this.finishNode(node, "JSXOpeningElement");
	  }
	  jsxParseClosingElementAt(startLoc) {
	    const node = this.startNodeAt(startLoc);
	    if (this.eat(144)) {
	      return this.finishNode(node, "JSXClosingFragment");
	    }
	    node.name = this.jsxParseElementName();
	    this.expect(144);
	    return this.finishNode(node, "JSXClosingElement");
	  }
	  jsxParseElementAt(startLoc) {
	    const node = this.startNodeAt(startLoc);
	    const children = [];
	    const openingElement = this.jsxParseOpeningElementAt(startLoc);
	    let closingElement = null;
	    if (!openingElement.selfClosing) {
	      contents: for (;;) {
	        switch (this.state.type) {
	          case 143:
	            startLoc = this.state.startLoc;
	            this.next();
	            if (this.eat(56)) {
	              closingElement = this.jsxParseClosingElementAt(startLoc);
	              break contents;
	            }
	            children.push(this.jsxParseElementAt(startLoc));
	            break;
	          case 142:
	            children.push(this.parseLiteral(this.state.value, "JSXText"));
	            break;
	          case 5:
	            {
	              const node = this.startNode();
	              this.setContext(types.brace);
	              this.next();
	              if (this.match(21)) {
	                children.push(this.jsxParseSpreadChild(node));
	              } else {
	                children.push(this.jsxParseExpressionContainer(node, types.j_expr));
	              }
	              break;
	            }
	          default:
	            this.unexpected();
	        }
	      }
	      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
	        this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
	      } else if (!isFragment(openingElement) && isFragment(closingElement)) {
	        this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
	          openingTagName: getQualifiedJSXName(openingElement.name)
	        });
	      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
	        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
	          this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
	            openingTagName: getQualifiedJSXName(openingElement.name)
	          });
	        }
	      }
	    }
	    if (isFragment(openingElement)) {
	      node.openingFragment = openingElement;
	      node.closingFragment = closingElement;
	    } else {
	      node.openingElement = openingElement;
	      node.closingElement = closingElement;
	    }
	    node.children = children;
	    if (this.match(47)) {
	      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
	    }
	    return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
	  }
	  jsxParseElement() {
	    const startLoc = this.state.startLoc;
	    this.next();
	    return this.jsxParseElementAt(startLoc);
	  }
	  setContext(newContext) {
	    const {
	      context
	    } = this.state;
	    context[context.length - 1] = newContext;
	  }
	  parseExprAtom(refExpressionErrors) {
	    if (this.match(143)) {
	      return this.jsxParseElement();
	    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
	      this.replaceToken(143);
	      return this.jsxParseElement();
	    } else {
	      return super.parseExprAtom(refExpressionErrors);
	    }
	  }
	  skipSpace() {
	    const curContext = this.curContext();
	    if (!curContext.preserveSpace) super.skipSpace();
	  }
	  getTokenFromCode(code) {
	    const context = this.curContext();
	    if (context === types.j_expr) {
	      this.jsxReadToken();
	      return;
	    }
	    if (context === types.j_oTag || context === types.j_cTag) {
	      if (isIdentifierStart(code)) {
	        this.jsxReadWord();
	        return;
	      }
	      if (code === 62) {
	        ++this.state.pos;
	        this.finishToken(144);
	        return;
	      }
	      if ((code === 34 || code === 39) && context === types.j_oTag) {
	        this.jsxReadString(code);
	        return;
	      }
	    }
	    if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
	      ++this.state.pos;
	      this.finishToken(143);
	      return;
	    }
	    super.getTokenFromCode(code);
	  }
	  updateContext(prevType) {
	    const {
	      context,
	      type
	    } = this.state;
	    if (type === 56 && prevType === 143) {
	      context.splice(-2, 2, types.j_cTag);
	      this.state.canStartJSXElement = false;
	    } else if (type === 143) {
	      context.push(types.j_oTag);
	    } else if (type === 144) {
	      const out = context[context.length - 1];
	      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
	        context.pop();
	        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
	      } else {
	        this.setContext(types.j_expr);
	        this.state.canStartJSXElement = true;
	      }
	    } else {
	      this.state.canStartJSXElement = tokenComesBeforeExpression(type);
	    }
	  }
	};
	class TypeScriptScope extends Scope {
	  constructor(...args) {
	    super(...args);
	    this.tsNames = new Map();
	  }
	}
	class TypeScriptScopeHandler extends ScopeHandler {
	  constructor(...args) {
	    super(...args);
	    this.importsStack = [];
	  }
	  createScope(flags) {
	    this.importsStack.push(new Set());
	    return new TypeScriptScope(flags);
	  }
	  enter(flags) {
	    if (flags === 512) {
	      this.importsStack.push(new Set());
	    }
	    super.enter(flags);
	  }
	  exit() {
	    const flags = super.exit();
	    if (flags === 512) {
	      this.importsStack.pop();
	    }
	    return flags;
	  }
	  hasImport(name, allowShadow) {
	    const len = this.importsStack.length;
	    if (this.importsStack[len - 1].has(name)) {
	      return true;
	    }
	    if (!allowShadow && len > 1) {
	      for (let i = 0; i < len - 1; i++) {
	        if (this.importsStack[i].has(name)) return true;
	      }
	    }
	    return false;
	  }
	  declareName(name, bindingType, loc) {
	    if (bindingType & 4096) {
	      if (this.hasImport(name, true)) {
	        this.parser.raise(Errors.VarRedeclaration, loc, {
	          identifierName: name
	        });
	      }
	      this.importsStack[this.importsStack.length - 1].add(name);
	      return;
	    }
	    const scope = this.currentScope();
	    let type = scope.tsNames.get(name) || 0;
	    if (bindingType & 1024) {
	      this.maybeExportDefined(scope, name);
	      scope.tsNames.set(name, type | 16);
	      return;
	    }
	    super.declareName(name, bindingType, loc);
	    if (bindingType & 2) {
	      if (!(bindingType & 1)) {
	        this.checkRedeclarationInScope(scope, name, bindingType, loc);
	        this.maybeExportDefined(scope, name);
	      }
	      type = type | 1;
	    }
	    if (bindingType & 256) {
	      type = type | 2;
	    }
	    if (bindingType & 512) {
	      type = type | 4;
	    }
	    if (bindingType & 128) {
	      type = type | 8;
	    }
	    if (type) scope.tsNames.set(name, type);
	  }
	  isRedeclaredInScope(scope, name, bindingType) {
	    const type = scope.tsNames.get(name);
	    if ((type & 2) > 0) {
	      if (bindingType & 256) {
	        const isConst = !!(bindingType & 512);
	        const wasConst = (type & 4) > 0;
	        return isConst !== wasConst;
	      }
	      return true;
	    }
	    if (bindingType & 128 && (type & 8) > 0) {
	      if (scope.names.get(name) & 2) {
	        return !!(bindingType & 1);
	      } else {
	        return false;
	      }
	    }
	    if (bindingType & 2 && (type & 1) > 0) {
	      return true;
	    }
	    return super.isRedeclaredInScope(scope, name, bindingType);
	  }
	  checkLocalExport(id) {
	    const {
	      name
	    } = id;
	    if (this.hasImport(name)) return;
	    const len = this.scopeStack.length;
	    for (let i = len - 1; i >= 0; i--) {
	      const scope = this.scopeStack[i];
	      const type = scope.tsNames.get(name);
	      if ((type & 1) > 0 || (type & 16) > 0) {
	        return;
	      }
	    }
	    super.checkLocalExport(id);
	  }
	}
	class ProductionParameterHandler {
	  constructor() {
	    this.stacks = [];
	  }
	  enter(flags) {
	    this.stacks.push(flags);
	  }
	  exit() {
	    this.stacks.pop();
	  }
	  currentFlags() {
	    return this.stacks[this.stacks.length - 1];
	  }
	  get hasAwait() {
	    return (this.currentFlags() & 2) > 0;
	  }
	  get hasYield() {
	    return (this.currentFlags() & 1) > 0;
	  }
	  get hasReturn() {
	    return (this.currentFlags() & 4) > 0;
	  }
	  get hasIn() {
	    return (this.currentFlags() & 8) > 0;
	  }
	}
	function functionFlags(isAsync, isGenerator) {
	  return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
	}
	class BaseParser {
	  constructor() {
	    this.sawUnambiguousESM = false;
	    this.ambiguousScriptDifferentAst = false;
	  }
	  sourceToOffsetPos(sourcePos) {
	    return sourcePos + this.startIndex;
	  }
	  offsetToSourcePos(offsetPos) {
	    return offsetPos - this.startIndex;
	  }
	  hasPlugin(pluginConfig) {
	    if (typeof pluginConfig === "string") {
	      return this.plugins.has(pluginConfig);
	    } else {
	      const [pluginName, pluginOptions] = pluginConfig;
	      if (!this.hasPlugin(pluginName)) {
	        return false;
	      }
	      const actualOptions = this.plugins.get(pluginName);
	      for (const key of Object.keys(pluginOptions)) {
	        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
	          return false;
	        }
	      }
	      return true;
	    }
	  }
	  getPluginOption(plugin, name) {
	    var _this$plugins$get;
	    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
	  }
	}
	function setTrailingComments(node, comments) {
	  if (node.trailingComments === undefined) {
	    node.trailingComments = comments;
	  } else {
	    node.trailingComments.unshift(...comments);
	  }
	}
	function setLeadingComments(node, comments) {
	  if (node.leadingComments === undefined) {
	    node.leadingComments = comments;
	  } else {
	    node.leadingComments.unshift(...comments);
	  }
	}
	function setInnerComments(node, comments) {
	  if (node.innerComments === undefined) {
	    node.innerComments = comments;
	  } else {
	    node.innerComments.unshift(...comments);
	  }
	}
	function adjustInnerComments(node, elements, commentWS) {
	  let lastElement = null;
	  let i = elements.length;
	  while (lastElement === null && i > 0) {
	    lastElement = elements[--i];
	  }
	  if (lastElement === null || lastElement.start > commentWS.start) {
	    setInnerComments(node, commentWS.comments);
	  } else {
	    setTrailingComments(lastElement, commentWS.comments);
	  }
	}
	class CommentsParser extends BaseParser {
	  addComment(comment) {
	    if (this.filename) comment.loc.filename = this.filename;
	    const {
	      commentsLen
	    } = this.state;
	    if (this.comments.length !== commentsLen) {
	      this.comments.length = commentsLen;
	    }
	    this.comments.push(comment);
	    this.state.commentsLen++;
	  }
	  processComment(node) {
	    const {
	      commentStack
	    } = this.state;
	    const commentStackLength = commentStack.length;
	    if (commentStackLength === 0) return;
	    let i = commentStackLength - 1;
	    const lastCommentWS = commentStack[i];
	    if (lastCommentWS.start === node.end) {
	      lastCommentWS.leadingNode = node;
	      i--;
	    }
	    const {
	      start: nodeStart
	    } = node;
	    for (; i >= 0; i--) {
	      const commentWS = commentStack[i];
	      const commentEnd = commentWS.end;
	      if (commentEnd > nodeStart) {
	        commentWS.containingNode = node;
	        this.finalizeComment(commentWS);
	        commentStack.splice(i, 1);
	      } else {
	        if (commentEnd === nodeStart) {
	          commentWS.trailingNode = node;
	        }
	        break;
	      }
	    }
	  }
	  finalizeComment(commentWS) {
	    var _node$options;
	    const {
	      comments
	    } = commentWS;
	    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
	      if (commentWS.leadingNode !== null) {
	        setTrailingComments(commentWS.leadingNode, comments);
	      }
	      if (commentWS.trailingNode !== null) {
	        setLeadingComments(commentWS.trailingNode, comments);
	      }
	    } else {
	      const {
	        containingNode: node,
	        start: commentStart
	      } = commentWS;
	      if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {
	        switch (node.type) {
	          case "ObjectExpression":
	          case "ObjectPattern":
	          case "RecordExpression":
	            adjustInnerComments(node, node.properties, commentWS);
	            break;
	          case "CallExpression":
	          case "OptionalCallExpression":
	            adjustInnerComments(node, node.arguments, commentWS);
	            break;
	          case "ImportExpression":
	            adjustInnerComments(node, [node.source, (_node$options = node.options) != null ? _node$options : null], commentWS);
	            break;
	          case "FunctionDeclaration":
	          case "FunctionExpression":
	          case "ArrowFunctionExpression":
	          case "ObjectMethod":
	          case "ClassMethod":
	          case "ClassPrivateMethod":
	            adjustInnerComments(node, node.params, commentWS);
	            break;
	          case "ArrayExpression":
	          case "ArrayPattern":
	          case "TupleExpression":
	            adjustInnerComments(node, node.elements, commentWS);
	            break;
	          case "ExportNamedDeclaration":
	          case "ImportDeclaration":
	            adjustInnerComments(node, node.specifiers, commentWS);
	            break;
	          case "TSEnumDeclaration":
	            {
	              adjustInnerComments(node, node.members, commentWS);
	            }
	            break;
	          case "TSEnumBody":
	            adjustInnerComments(node, node.members, commentWS);
	            break;
	          default:
	            {
	              setInnerComments(node, comments);
	            }
	        }
	      } else {
	        setInnerComments(node, comments);
	      }
	    }
	  }
	  finalizeRemainingComments() {
	    const {
	      commentStack
	    } = this.state;
	    for (let i = commentStack.length - 1; i >= 0; i--) {
	      this.finalizeComment(commentStack[i]);
	    }
	    this.state.commentStack = [];
	  }
	  resetPreviousNodeTrailingComments(node) {
	    const {
	      commentStack
	    } = this.state;
	    const {
	      length
	    } = commentStack;
	    if (length === 0) return;
	    const commentWS = commentStack[length - 1];
	    if (commentWS.leadingNode === node) {
	      commentWS.leadingNode = null;
	    }
	  }
	  takeSurroundingComments(node, start, end) {
	    const {
	      commentStack
	    } = this.state;
	    const commentStackLength = commentStack.length;
	    if (commentStackLength === 0) return;
	    let i = commentStackLength - 1;
	    for (; i >= 0; i--) {
	      const commentWS = commentStack[i];
	      const commentEnd = commentWS.end;
	      const commentStart = commentWS.start;
	      if (commentStart === end) {
	        commentWS.leadingNode = node;
	      } else if (commentEnd === start) {
	        commentWS.trailingNode = node;
	      } else if (commentEnd < start) {
	        break;
	      }
	    }
	  }
	}
	class State {
	  constructor() {
	    this.flags = 1024;
	    this.startIndex = void 0;
	    this.curLine = void 0;
	    this.lineStart = void 0;
	    this.startLoc = void 0;
	    this.endLoc = void 0;
	    this.errors = [];
	    this.potentialArrowAt = -1;
	    this.noArrowAt = [];
	    this.noArrowParamsConversionAt = [];
	    this.topicContext = {
	      maxNumOfResolvableTopics: 0,
	      maxTopicIndex: null
	    };
	    this.labels = [];
	    this.commentsLen = 0;
	    this.commentStack = [];
	    this.pos = 0;
	    this.type = 140;
	    this.value = null;
	    this.start = 0;
	    this.end = 0;
	    this.lastTokEndLoc = null;
	    this.lastTokStartLoc = null;
	    this.context = [types.brace];
	    this.firstInvalidTemplateEscapePos = null;
	    this.strictErrors = new Map();
	    this.tokensLength = 0;
	  }
	  get strict() {
	    return (this.flags & 1) > 0;
	  }
	  set strict(v) {
	    if (v) this.flags |= 1;else this.flags &= -2;
	  }
	  init({
	    strictMode,
	    sourceType,
	    startIndex,
	    startLine,
	    startColumn
	  }) {
	    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
	    this.startIndex = startIndex;
	    this.curLine = startLine;
	    this.lineStart = -startColumn;
	    this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);
	  }
	  get maybeInArrowParameters() {
	    return (this.flags & 2) > 0;
	  }
	  set maybeInArrowParameters(v) {
	    if (v) this.flags |= 2;else this.flags &= -3;
	  }
	  get inType() {
	    return (this.flags & 4) > 0;
	  }
	  set inType(v) {
	    if (v) this.flags |= 4;else this.flags &= -5;
	  }
	  get noAnonFunctionType() {
	    return (this.flags & 8) > 0;
	  }
	  set noAnonFunctionType(v) {
	    if (v) this.flags |= 8;else this.flags &= -9;
	  }
	  get hasFlowComment() {
	    return (this.flags & 16) > 0;
	  }
	  set hasFlowComment(v) {
	    if (v) this.flags |= 16;else this.flags &= -17;
	  }
	  get isAmbientContext() {
	    return (this.flags & 32) > 0;
	  }
	  set isAmbientContext(v) {
	    if (v) this.flags |= 32;else this.flags &= -33;
	  }
	  get inAbstractClass() {
	    return (this.flags & 64) > 0;
	  }
	  set inAbstractClass(v) {
	    if (v) this.flags |= 64;else this.flags &= -65;
	  }
	  get inDisallowConditionalTypesContext() {
	    return (this.flags & 128) > 0;
	  }
	  set inDisallowConditionalTypesContext(v) {
	    if (v) this.flags |= 128;else this.flags &= -129;
	  }
	  get soloAwait() {
	    return (this.flags & 256) > 0;
	  }
	  set soloAwait(v) {
	    if (v) this.flags |= 256;else this.flags &= -257;
	  }
	  get inFSharpPipelineDirectBody() {
	    return (this.flags & 512) > 0;
	  }
	  set inFSharpPipelineDirectBody(v) {
	    if (v) this.flags |= 512;else this.flags &= -513;
	  }
	  get canStartJSXElement() {
	    return (this.flags & 1024) > 0;
	  }
	  set canStartJSXElement(v) {
	    if (v) this.flags |= 1024;else this.flags &= -1025;
	  }
	  get containsEsc() {
	    return (this.flags & 2048) > 0;
	  }
	  set containsEsc(v) {
	    if (v) this.flags |= 2048;else this.flags &= -2049;
	  }
	  get hasTopLevelAwait() {
	    return (this.flags & 4096) > 0;
	  }
	  set hasTopLevelAwait(v) {
	    if (v) this.flags |= 4096;else this.flags &= -4097;
	  }
	  curPosition() {
	    return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
	  }
	  clone() {
	    const state = new State();
	    state.flags = this.flags;
	    state.startIndex = this.startIndex;
	    state.curLine = this.curLine;
	    state.lineStart = this.lineStart;
	    state.startLoc = this.startLoc;
	    state.endLoc = this.endLoc;
	    state.errors = this.errors.slice();
	    state.potentialArrowAt = this.potentialArrowAt;
	    state.noArrowAt = this.noArrowAt.slice();
	    state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
	    state.topicContext = this.topicContext;
	    state.labels = this.labels.slice();
	    state.commentsLen = this.commentsLen;
	    state.commentStack = this.commentStack.slice();
	    state.pos = this.pos;
	    state.type = this.type;
	    state.value = this.value;
	    state.start = this.start;
	    state.end = this.end;
	    state.lastTokEndLoc = this.lastTokEndLoc;
	    state.lastTokStartLoc = this.lastTokStartLoc;
	    state.context = this.context.slice();
	    state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
	    state.strictErrors = this.strictErrors;
	    state.tokensLength = this.tokensLength;
	    return state;
	  }
	}
	var _isDigit = function isDigit(code) {
	  return code >= 48 && code <= 57;
	};
	const forbiddenNumericSeparatorSiblings = {
	  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
	  hex: new Set([46, 88, 95, 120])
	};
	const isAllowedNumericSeparatorSibling = {
	  bin: ch => ch === 48 || ch === 49,
	  oct: ch => ch >= 48 && ch <= 55,
	  dec: ch => ch >= 48 && ch <= 57,
	  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
	};
	function readStringContents(type, input, pos, lineStart, curLine, errors) {
	  const initialPos = pos;
	  const initialLineStart = lineStart;
	  const initialCurLine = curLine;
	  let out = "";
	  let firstInvalidLoc = null;
	  let chunkStart = pos;
	  const {
	    length
	  } = input;
	  for (;;) {
	    if (pos >= length) {
	      errors.unterminated(initialPos, initialLineStart, initialCurLine);
	      out += input.slice(chunkStart, pos);
	      break;
	    }
	    const ch = input.charCodeAt(pos);
	    if (isStringEnd(type, ch, input, pos)) {
	      out += input.slice(chunkStart, pos);
	      break;
	    }
	    if (ch === 92) {
	      out += input.slice(chunkStart, pos);
	      const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
	      if (res.ch === null && !firstInvalidLoc) {
	        firstInvalidLoc = {
	          pos,
	          lineStart,
	          curLine
	        };
	      } else {
	        out += res.ch;
	      }
	      ({
	        pos,
	        lineStart,
	        curLine
	      } = res);
	      chunkStart = pos;
	    } else if (ch === 8232 || ch === 8233) {
	      ++pos;
	      ++curLine;
	      lineStart = pos;
	    } else if (ch === 10 || ch === 13) {
	      if (type === "template") {
	        out += input.slice(chunkStart, pos) + "\n";
	        ++pos;
	        if (ch === 13 && input.charCodeAt(pos) === 10) {
	          ++pos;
	        }
	        ++curLine;
	        chunkStart = lineStart = pos;
	      } else {
	        errors.unterminated(initialPos, initialLineStart, initialCurLine);
	      }
	    } else {
	      ++pos;
	    }
	  }
	  return {
	    pos,
	    str: out,
	    firstInvalidLoc,
	    lineStart,
	    curLine,
	    containsInvalid: !!firstInvalidLoc
	  };
	}
	function isStringEnd(type, ch, input, pos) {
	  if (type === "template") {
	    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
	  }
	  return ch === (type === "double" ? 34 : 39);
	}
	function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
	  const throwOnInvalid = !inTemplate;
	  pos++;
	  const res = ch => ({
	    pos,
	    ch,
	    lineStart,
	    curLine
	  });
	  const ch = input.charCodeAt(pos++);
	  switch (ch) {
	    case 110:
	      return res("\n");
	    case 114:
	      return res("\r");
	    case 120:
	      {
	        let code;
	        ({
	          code,
	          pos
	        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
	        return res(code === null ? null : String.fromCharCode(code));
	      }
	    case 117:
	      {
	        let code;
	        ({
	          code,
	          pos
	        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
	        return res(code === null ? null : String.fromCodePoint(code));
	      }
	    case 116:
	      return res("\t");
	    case 98:
	      return res("\b");
	    case 118:
	      return res("\u000b");
	    case 102:
	      return res("\f");
	    case 13:
	      if (input.charCodeAt(pos) === 10) {
	        ++pos;
	      }
	    case 10:
	      lineStart = pos;
	      ++curLine;
	    case 8232:
	    case 8233:
	      return res("");
	    case 56:
	    case 57:
	      if (inTemplate) {
	        return res(null);
	      } else {
	        errors.strictNumericEscape(pos - 1, lineStart, curLine);
	      }
	    default:
	      if (ch >= 48 && ch <= 55) {
	        const startPos = pos - 1;
	        const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
	        let octalStr = match[0];
	        let octal = parseInt(octalStr, 8);
	        if (octal > 255) {
	          octalStr = octalStr.slice(0, -1);
	          octal = parseInt(octalStr, 8);
	        }
	        pos += octalStr.length - 1;
	        const next = input.charCodeAt(pos);
	        if (octalStr !== "0" || next === 56 || next === 57) {
	          if (inTemplate) {
	            return res(null);
	          } else {
	            errors.strictNumericEscape(startPos, lineStart, curLine);
	          }
	        }
	        return res(String.fromCharCode(octal));
	      }
	      return res(String.fromCharCode(ch));
	  }
	}
	function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
	  const initialPos = pos;
	  let n;
	  ({
	    n,
	    pos
	  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
	  if (n === null) {
	    if (throwOnInvalid) {
	      errors.invalidEscapeSequence(initialPos, lineStart, curLine);
	    } else {
	      pos = initialPos - 1;
	    }
	  }
	  return {
	    code: n,
	    pos
	  };
	}
	function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
	  const start = pos;
	  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
	  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
	  let invalid = false;
	  let total = 0;
	  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	    const code = input.charCodeAt(pos);
	    let val;
	    if (code === 95 && allowNumSeparator !== "bail") {
	      const prev = input.charCodeAt(pos - 1);
	      const next = input.charCodeAt(pos + 1);
	      if (!allowNumSeparator) {
	        if (bailOnError) return {
	          n: null,
	          pos
	        };
	        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
	      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
	        if (bailOnError) return {
	          n: null,
	          pos
	        };
	        errors.unexpectedNumericSeparator(pos, lineStart, curLine);
	      }
	      ++pos;
	      continue;
	    }
	    if (code >= 97) {
	      val = code - 97 + 10;
	    } else if (code >= 65) {
	      val = code - 65 + 10;
	    } else if (_isDigit(code)) {
	      val = code - 48;
	    } else {
	      val = Infinity;
	    }
	    if (val >= radix) {
	      if (val <= 9 && bailOnError) {
	        return {
	          n: null,
	          pos
	        };
	      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
	        val = 0;
	      } else if (forceLen) {
	        val = 0;
	        invalid = true;
	      } else {
	        break;
	      }
	    }
	    ++pos;
	    total = total * radix + val;
	  }
	  if (pos === start || len != null && pos - start !== len || invalid) {
	    return {
	      n: null,
	      pos
	    };
	  }
	  return {
	    n: total,
	    pos
	  };
	}
	function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
	  const ch = input.charCodeAt(pos);
	  let code;
	  if (ch === 123) {
	    ++pos;
	    ({
	      code,
	      pos
	    } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
	    ++pos;
	    if (code !== null && code > 0x10ffff) {
	      if (throwOnInvalid) {
	        errors.invalidCodePoint(pos, lineStart, curLine);
	      } else {
	        return {
	          code: null,
	          pos
	        };
	      }
	    }
	  } else {
	    ({
	      code,
	      pos
	    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
	  }
	  return {
	    code,
	    pos
	  };
	}
	function buildPosition(pos, lineStart, curLine) {
	  return new Position(curLine, pos - lineStart, pos);
	}
	const VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);
	class Token {
	  constructor(state) {
	    const startIndex = state.startIndex || 0;
	    this.type = state.type;
	    this.value = state.value;
	    this.start = startIndex + state.start;
	    this.end = startIndex + state.end;
	    this.loc = new SourceLocation(state.startLoc, state.endLoc);
	  }
	}
	class Tokenizer extends CommentsParser {
	  constructor(options, input) {
	    super();
	    this.isLookahead = void 0;
	    this.tokens = [];
	    this.errorHandlers_readInt = {
	      invalidDigit: (pos, lineStart, curLine, radix) => {
	        if (!(this.optionFlags & 2048)) return false;
	        this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
	          radix
	        });
	        return true;
	      },
	      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
	      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
	    };
	    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
	      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
	      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
	    });
	    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
	      strictNumericEscape: (pos, lineStart, curLine) => {
	        this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
	      },
	      unterminated: (pos, lineStart, curLine) => {
	        throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
	      }
	    });
	    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
	      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
	      unterminated: (pos, lineStart, curLine) => {
	        throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
	      }
	    });
	    this.state = new State();
	    this.state.init(options);
	    this.input = input;
	    this.length = input.length;
	    this.comments = [];
	    this.isLookahead = false;
	  }
	  pushToken(token) {
	    this.tokens.length = this.state.tokensLength;
	    this.tokens.push(token);
	    ++this.state.tokensLength;
	  }
	  next() {
	    this.checkKeywordEscapes();
	    if (this.optionFlags & 256) {
	      this.pushToken(new Token(this.state));
	    }
	    this.state.lastTokEndLoc = this.state.endLoc;
	    this.state.lastTokStartLoc = this.state.startLoc;
	    this.nextToken();
	  }
	  eat(type) {
	    if (this.match(type)) {
	      this.next();
	      return true;
	    } else {
	      return false;
	    }
	  }
	  match(type) {
	    return this.state.type === type;
	  }
	  createLookaheadState(state) {
	    return {
	      pos: state.pos,
	      value: null,
	      type: state.type,
	      start: state.start,
	      end: state.end,
	      context: [this.curContext()],
	      inType: state.inType,
	      startLoc: state.startLoc,
	      lastTokEndLoc: state.lastTokEndLoc,
	      curLine: state.curLine,
	      lineStart: state.lineStart,
	      curPosition: state.curPosition
	    };
	  }
	  lookahead() {
	    const old = this.state;
	    this.state = this.createLookaheadState(old);
	    this.isLookahead = true;
	    this.nextToken();
	    this.isLookahead = false;
	    const curr = this.state;
	    this.state = old;
	    return curr;
	  }
	  nextTokenStart() {
	    return this.nextTokenStartSince(this.state.pos);
	  }
	  nextTokenStartSince(pos) {
	    skipWhiteSpace.lastIndex = pos;
	    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
	  }
	  lookaheadCharCode() {
	    return this.lookaheadCharCodeSince(this.state.pos);
	  }
	  lookaheadCharCodeSince(pos) {
	    return this.input.charCodeAt(this.nextTokenStartSince(pos));
	  }
	  nextTokenInLineStart() {
	    return this.nextTokenInLineStartSince(this.state.pos);
	  }
	  nextTokenInLineStartSince(pos) {
	    skipWhiteSpaceInLine.lastIndex = pos;
	    return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
	  }
	  lookaheadInLineCharCode() {
	    return this.input.charCodeAt(this.nextTokenInLineStart());
	  }
	  codePointAtPos(pos) {
	    let cp = this.input.charCodeAt(pos);
	    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {
	      const trail = this.input.charCodeAt(pos);
	      if ((trail & 0xfc00) === 0xdc00) {
	        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
	      }
	    }
	    return cp;
	  }
	  setStrict(strict) {
	    this.state.strict = strict;
	    if (strict) {
	      this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));
	      this.state.strictErrors.clear();
	    }
	  }
	  curContext() {
	    return this.state.context[this.state.context.length - 1];
	  }
	  nextToken() {
	    this.skipSpace();
	    this.state.start = this.state.pos;
	    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
	    if (this.state.pos >= this.length) {
	      this.finishToken(140);
	      return;
	    }
	    this.getTokenFromCode(this.codePointAtPos(this.state.pos));
	  }
	  skipBlockComment(commentEnd) {
	    let startLoc;
	    if (!this.isLookahead) startLoc = this.state.curPosition();
	    const start = this.state.pos;
	    const end = this.input.indexOf(commentEnd, start + 2);
	    if (end === -1) {
	      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
	    }
	    this.state.pos = end + commentEnd.length;
	    lineBreakG.lastIndex = start + 2;
	    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
	      ++this.state.curLine;
	      this.state.lineStart = lineBreakG.lastIndex;
	    }
	    if (this.isLookahead) return;
	    const comment = {
	      type: "CommentBlock",
	      value: this.input.slice(start + 2, end),
	      start: this.sourceToOffsetPos(start),
	      end: this.sourceToOffsetPos(end + commentEnd.length),
	      loc: new SourceLocation(startLoc, this.state.curPosition())
	    };
	    if (this.optionFlags & 256) this.pushToken(comment);
	    return comment;
	  }
	  skipLineComment(startSkip) {
	    const start = this.state.pos;
	    let startLoc;
	    if (!this.isLookahead) startLoc = this.state.curPosition();
	    let ch = this.input.charCodeAt(this.state.pos += startSkip);
	    if (this.state.pos < this.length) {
	      while (!isNewLine(ch) && ++this.state.pos < this.length) {
	        ch = this.input.charCodeAt(this.state.pos);
	      }
	    }
	    if (this.isLookahead) return;
	    const end = this.state.pos;
	    const value = this.input.slice(start + startSkip, end);
	    const comment = {
	      type: "CommentLine",
	      value,
	      start: this.sourceToOffsetPos(start),
	      end: this.sourceToOffsetPos(end),
	      loc: new SourceLocation(startLoc, this.state.curPosition())
	    };
	    if (this.optionFlags & 256) this.pushToken(comment);
	    return comment;
	  }
	  skipSpace() {
	    const spaceStart = this.state.pos;
	    const comments = this.optionFlags & 4096 ? [] : null;
	    loop: while (this.state.pos < this.length) {
	      const ch = this.input.charCodeAt(this.state.pos);
	      switch (ch) {
	        case 32:
	        case 160:
	        case 9:
	          ++this.state.pos;
	          break;
	        case 13:
	          if (this.input.charCodeAt(this.state.pos + 1) === 10) {
	            ++this.state.pos;
	          }
	        case 10:
	        case 8232:
	        case 8233:
	          ++this.state.pos;
	          ++this.state.curLine;
	          this.state.lineStart = this.state.pos;
	          break;
	        case 47:
	          switch (this.input.charCodeAt(this.state.pos + 1)) {
	            case 42:
	              {
	                const comment = this.skipBlockComment("*/");
	                if (comment !== undefined) {
	                  this.addComment(comment);
	                  comments == null || comments.push(comment);
	                }
	                break;
	              }
	            case 47:
	              {
	                const comment = this.skipLineComment(2);
	                if (comment !== undefined) {
	                  this.addComment(comment);
	                  comments == null || comments.push(comment);
	                }
	                break;
	              }
	            default:
	              break loop;
	          }
	          break;
	        default:
	          if (isWhitespace(ch)) {
	            ++this.state.pos;
	          } else if (ch === 45 && !this.inModule && this.optionFlags & 8192) {
	            const pos = this.state.pos;
	            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
	              const comment = this.skipLineComment(3);
	              if (comment !== undefined) {
	                this.addComment(comment);
	                comments == null || comments.push(comment);
	              }
	            } else {
	              break loop;
	            }
	          } else if (ch === 60 && !this.inModule && this.optionFlags & 8192) {
	            const pos = this.state.pos;
	            if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
	              const comment = this.skipLineComment(4);
	              if (comment !== undefined) {
	                this.addComment(comment);
	                comments == null || comments.push(comment);
	              }
	            } else {
	              break loop;
	            }
	          } else {
	            break loop;
	          }
	      }
	    }
	    if ((comments == null ? void 0 : comments.length) > 0) {
	      const end = this.state.pos;
	      const commentWhitespace = {
	        start: this.sourceToOffsetPos(spaceStart),
	        end: this.sourceToOffsetPos(end),
	        comments,
	        leadingNode: null,
	        trailingNode: null,
	        containingNode: null
	      };
	      this.state.commentStack.push(commentWhitespace);
	    }
	  }
	  finishToken(type, val) {
	    this.state.end = this.state.pos;
	    this.state.endLoc = this.state.curPosition();
	    const prevType = this.state.type;
	    this.state.type = type;
	    this.state.value = val;
	    if (!this.isLookahead) {
	      this.updateContext(prevType);
	    }
	  }
	  replaceToken(type) {
	    this.state.type = type;
	    this.updateContext();
	  }
	  readToken_numberSign() {
	    if (this.state.pos === 0 && this.readToken_interpreter()) {
	      return;
	    }
	    const nextPos = this.state.pos + 1;
	    const next = this.codePointAtPos(nextPos);
	    if (next >= 48 && next <= 57) {
	      throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
	    }
	    if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
	      this.expectPlugin("recordAndTuple");
	      if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
	        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
	      }
	      this.state.pos += 2;
	      if (next === 123) {
	        this.finishToken(7);
	      } else {
	        this.finishToken(1);
	      }
	    } else if (isIdentifierStart(next)) {
	      ++this.state.pos;
	      this.finishToken(139, this.readWord1(next));
	    } else if (next === 92) {
	      ++this.state.pos;
	      this.finishToken(139, this.readWord1());
	    } else {
	      this.finishOp(27, 1);
	    }
	  }
	  readToken_dot() {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (next >= 48 && next <= 57) {
	      this.readNumber(true);
	      return;
	    }
	    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
	      this.state.pos += 3;
	      this.finishToken(21);
	    } else {
	      ++this.state.pos;
	      this.finishToken(16);
	    }
	  }
	  readToken_slash() {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (next === 61) {
	      this.finishOp(31, 2);
	    } else {
	      this.finishOp(56, 1);
	    }
	  }
	  readToken_interpreter() {
	    if (this.state.pos !== 0 || this.length < 2) return false;
	    let ch = this.input.charCodeAt(this.state.pos + 1);
	    if (ch !== 33) return false;
	    const start = this.state.pos;
	    this.state.pos += 1;
	    while (!isNewLine(ch) && ++this.state.pos < this.length) {
	      ch = this.input.charCodeAt(this.state.pos);
	    }
	    const value = this.input.slice(start + 2, this.state.pos);
	    this.finishToken(28, value);
	    return true;
	  }
	  readToken_mult_modulo(code) {
	    let type = code === 42 ? 55 : 54;
	    let width = 1;
	    let next = this.input.charCodeAt(this.state.pos + 1);
	    if (code === 42 && next === 42) {
	      width++;
	      next = this.input.charCodeAt(this.state.pos + 2);
	      type = 57;
	    }
	    if (next === 61 && !this.state.inType) {
	      width++;
	      type = code === 37 ? 33 : 30;
	    }
	    this.finishOp(type, width);
	  }
	  readToken_pipe_amp(code) {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (next === code) {
	      if (this.input.charCodeAt(this.state.pos + 2) === 61) {
	        this.finishOp(30, 3);
	      } else {
	        this.finishOp(code === 124 ? 41 : 42, 2);
	      }
	      return;
	    }
	    if (code === 124) {
	      if (next === 62) {
	        this.finishOp(39, 2);
	        return;
	      }
	      if (this.hasPlugin("recordAndTuple") && next === 125) {
	        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
	          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
	        }
	        this.state.pos += 2;
	        this.finishToken(9);
	        return;
	      }
	      if (this.hasPlugin("recordAndTuple") && next === 93) {
	        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
	          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
	        }
	        this.state.pos += 2;
	        this.finishToken(4);
	        return;
	      }
	    }
	    if (next === 61) {
	      this.finishOp(30, 2);
	      return;
	    }
	    this.finishOp(code === 124 ? 43 : 45, 1);
	  }
	  readToken_caret() {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (next === 61 && !this.state.inType) {
	      this.finishOp(32, 2);
	    } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
	      proposal: "hack",
	      topicToken: "^^"
	    }])) {
	      this.finishOp(37, 2);
	      const lookaheadCh = this.input.codePointAt(this.state.pos);
	      if (lookaheadCh === 94) {
	        this.unexpected();
	      }
	    } else {
	      this.finishOp(44, 1);
	    }
	  }
	  readToken_atSign() {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (next === 64 && this.hasPlugin(["pipelineOperator", {
	      proposal: "hack",
	      topicToken: "@@"
	    }])) {
	      this.finishOp(38, 2);
	    } else {
	      this.finishOp(26, 1);
	    }
	  }
	  readToken_plus_min(code) {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (next === code) {
	      this.finishOp(34, 2);
	      return;
	    }
	    if (next === 61) {
	      this.finishOp(30, 2);
	    } else {
	      this.finishOp(53, 1);
	    }
	  }
	  readToken_lt() {
	    const {
	      pos
	    } = this.state;
	    const next = this.input.charCodeAt(pos + 1);
	    if (next === 60) {
	      if (this.input.charCodeAt(pos + 2) === 61) {
	        this.finishOp(30, 3);
	        return;
	      }
	      this.finishOp(51, 2);
	      return;
	    }
	    if (next === 61) {
	      this.finishOp(49, 2);
	      return;
	    }
	    this.finishOp(47, 1);
	  }
	  readToken_gt() {
	    const {
	      pos
	    } = this.state;
	    const next = this.input.charCodeAt(pos + 1);
	    if (next === 62) {
	      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
	      if (this.input.charCodeAt(pos + size) === 61) {
	        this.finishOp(30, size + 1);
	        return;
	      }
	      this.finishOp(52, size);
	      return;
	    }
	    if (next === 61) {
	      this.finishOp(49, 2);
	      return;
	    }
	    this.finishOp(48, 1);
	  }
	  readToken_eq_excl(code) {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    if (next === 61) {
	      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
	      return;
	    }
	    if (code === 61 && next === 62) {
	      this.state.pos += 2;
	      this.finishToken(19);
	      return;
	    }
	    this.finishOp(code === 61 ? 29 : 35, 1);
	  }
	  readToken_question() {
	    const next = this.input.charCodeAt(this.state.pos + 1);
	    const next2 = this.input.charCodeAt(this.state.pos + 2);
	    if (next === 63) {
	      if (next2 === 61) {
	        this.finishOp(30, 3);
	      } else {
	        this.finishOp(40, 2);
	      }
	    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
	      this.state.pos += 2;
	      this.finishToken(18);
	    } else {
	      ++this.state.pos;
	      this.finishToken(17);
	    }
	  }
	  getTokenFromCode(code) {
	    switch (code) {
	      case 46:
	        this.readToken_dot();
	        return;
	      case 40:
	        ++this.state.pos;
	        this.finishToken(10);
	        return;
	      case 41:
	        ++this.state.pos;
	        this.finishToken(11);
	        return;
	      case 59:
	        ++this.state.pos;
	        this.finishToken(13);
	        return;
	      case 44:
	        ++this.state.pos;
	        this.finishToken(12);
	        return;
	      case 91:
	        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
	          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
	            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
	          }
	          this.state.pos += 2;
	          this.finishToken(2);
	        } else {
	          ++this.state.pos;
	          this.finishToken(0);
	        }
	        return;
	      case 93:
	        ++this.state.pos;
	        this.finishToken(3);
	        return;
	      case 123:
	        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
	          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
	            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
	          }
	          this.state.pos += 2;
	          this.finishToken(6);
	        } else {
	          ++this.state.pos;
	          this.finishToken(5);
	        }
	        return;
	      case 125:
	        ++this.state.pos;
	        this.finishToken(8);
	        return;
	      case 58:
	        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
	          this.finishOp(15, 2);
	        } else {
	          ++this.state.pos;
	          this.finishToken(14);
	        }
	        return;
	      case 63:
	        this.readToken_question();
	        return;
	      case 96:
	        this.readTemplateToken();
	        return;
	      case 48:
	        {
	          const next = this.input.charCodeAt(this.state.pos + 1);
	          if (next === 120 || next === 88) {
	            this.readRadixNumber(16);
	            return;
	          }
	          if (next === 111 || next === 79) {
	            this.readRadixNumber(8);
	            return;
	          }
	          if (next === 98 || next === 66) {
	            this.readRadixNumber(2);
	            return;
	          }
	        }
	      case 49:
	      case 50:
	      case 51:
	      case 52:
	      case 53:
	      case 54:
	      case 55:
	      case 56:
	      case 57:
	        this.readNumber(false);
	        return;
	      case 34:
	      case 39:
	        this.readString(code);
	        return;
	      case 47:
	        this.readToken_slash();
	        return;
	      case 37:
	      case 42:
	        this.readToken_mult_modulo(code);
	        return;
	      case 124:
	      case 38:
	        this.readToken_pipe_amp(code);
	        return;
	      case 94:
	        this.readToken_caret();
	        return;
	      case 43:
	      case 45:
	        this.readToken_plus_min(code);
	        return;
	      case 60:
	        this.readToken_lt();
	        return;
	      case 62:
	        this.readToken_gt();
	        return;
	      case 61:
	      case 33:
	        this.readToken_eq_excl(code);
	        return;
	      case 126:
	        this.finishOp(36, 1);
	        return;
	      case 64:
	        this.readToken_atSign();
	        return;
	      case 35:
	        this.readToken_numberSign();
	        return;
	      case 92:
	        this.readWord();
	        return;
	      default:
	        if (isIdentifierStart(code)) {
	          this.readWord(code);
	          return;
	        }
	    }
	    throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
	      unexpected: String.fromCodePoint(code)
	    });
	  }
	  finishOp(type, size) {
	    const str = this.input.slice(this.state.pos, this.state.pos + size);
	    this.state.pos += size;
	    this.finishToken(type, str);
	  }
	  readRegexp() {
	    const startLoc = this.state.startLoc;
	    const start = this.state.start + 1;
	    let escaped, inClass;
	    let {
	      pos
	    } = this.state;
	    for (;; ++pos) {
	      if (pos >= this.length) {
	        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
	      }
	      const ch = this.input.charCodeAt(pos);
	      if (isNewLine(ch)) {
	        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
	      }
	      if (escaped) {
	        escaped = false;
	      } else {
	        if (ch === 91) {
	          inClass = true;
	        } else if (ch === 93 && inClass) {
	          inClass = false;
	        } else if (ch === 47 && !inClass) {
	          break;
	        }
	        escaped = ch === 92;
	      }
	    }
	    const content = this.input.slice(start, pos);
	    ++pos;
	    let mods = "";
	    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
	    while (pos < this.length) {
	      const cp = this.codePointAtPos(pos);
	      const char = String.fromCharCode(cp);
	      if (VALID_REGEX_FLAGS.has(cp)) {
	        if (cp === 118) {
	          if (mods.includes("u")) {
	            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
	          }
	        } else if (cp === 117) {
	          if (mods.includes("v")) {
	            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
	          }
	        }
	        if (mods.includes(char)) {
	          this.raise(Errors.DuplicateRegExpFlags, nextPos());
	        }
	      } else if (isIdentifierChar(cp) || cp === 92) {
	        this.raise(Errors.MalformedRegExpFlags, nextPos());
	      } else {
	        break;
	      }
	      ++pos;
	      mods += char;
	    }
	    this.state.pos = pos;
	    this.finishToken(138, {
	      pattern: content,
	      flags: mods
	    });
	  }
	  readInt(radix, len, forceLen = false, allowNumSeparator = true) {
	    const {
	      n,
	      pos
	    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
	    this.state.pos = pos;
	    return n;
	  }
	  readRadixNumber(radix) {
	    const start = this.state.pos;
	    const startLoc = this.state.curPosition();
	    let isBigInt = false;
	    this.state.pos += 2;
	    const val = this.readInt(radix);
	    if (val == null) {
	      this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
	        radix
	      });
	    }
	    const next = this.input.charCodeAt(this.state.pos);
	    if (next === 110) {
	      ++this.state.pos;
	      isBigInt = true;
	    } else if (next === 109) {
	      throw this.raise(Errors.InvalidDecimal, startLoc);
	    }
	    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
	      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
	    }
	    if (isBigInt) {
	      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
	      this.finishToken(136, str);
	      return;
	    }
	    this.finishToken(135, val);
	  }
	  readNumber(startsWithDot) {
	    const start = this.state.pos;
	    const startLoc = this.state.curPosition();
	    let isFloat = false;
	    let isBigInt = false;
	    let hasExponent = false;
	    let isOctal = false;
	    if (!startsWithDot && this.readInt(10) === null) {
	      this.raise(Errors.InvalidNumber, this.state.curPosition());
	    }
	    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
	    if (hasLeadingZero) {
	      const integer = this.input.slice(start, this.state.pos);
	      this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
	      if (!this.state.strict) {
	        const underscorePos = integer.indexOf("_");
	        if (underscorePos > 0) {
	          this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
	        }
	      }
	      isOctal = hasLeadingZero && !/[89]/.test(integer);
	    }
	    let next = this.input.charCodeAt(this.state.pos);
	    if (next === 46 && !isOctal) {
	      ++this.state.pos;
	      this.readInt(10);
	      isFloat = true;
	      next = this.input.charCodeAt(this.state.pos);
	    }
	    if ((next === 69 || next === 101) && !isOctal) {
	      next = this.input.charCodeAt(++this.state.pos);
	      if (next === 43 || next === 45) {
	        ++this.state.pos;
	      }
	      if (this.readInt(10) === null) {
	        this.raise(Errors.InvalidOrMissingExponent, startLoc);
	      }
	      isFloat = true;
	      hasExponent = true;
	      next = this.input.charCodeAt(this.state.pos);
	    }
	    if (next === 110) {
	      if (isFloat || hasLeadingZero) {
	        this.raise(Errors.InvalidBigIntLiteral, startLoc);
	      }
	      ++this.state.pos;
	      isBigInt = true;
	    }
	    if (next === 109) {
	      this.expectPlugin("decimal", this.state.curPosition());
	      if (hasExponent || hasLeadingZero) {
	        this.raise(Errors.InvalidDecimal, startLoc);
	      }
	      ++this.state.pos;
	      var isDecimal = true;
	    }
	    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
	      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
	    }
	    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
	    if (isBigInt) {
	      this.finishToken(136, str);
	      return;
	    }
	    if (isDecimal) {
	      this.finishToken(137, str);
	      return;
	    }
	    const val = isOctal ? parseInt(str, 8) : parseFloat(str);
	    this.finishToken(135, val);
	  }
	  readCodePoint(throwOnInvalid) {
	    const {
	      code,
	      pos
	    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
	    this.state.pos = pos;
	    return code;
	  }
	  readString(quote) {
	    const {
	      str,
	      pos,
	      curLine,
	      lineStart
	    } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
	    this.state.pos = pos + 1;
	    this.state.lineStart = lineStart;
	    this.state.curLine = curLine;
	    this.finishToken(134, str);
	  }
	  readTemplateContinuation() {
	    if (!this.match(8)) {
	      this.unexpected(null, 8);
	    }
	    this.state.pos--;
	    this.readTemplateToken();
	  }
	  readTemplateToken() {
	    const opening = this.input[this.state.pos];
	    const {
	      str,
	      firstInvalidLoc,
	      pos,
	      curLine,
	      lineStart
	    } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
	    this.state.pos = pos + 1;
	    this.state.lineStart = lineStart;
	    this.state.curLine = curLine;
	    if (firstInvalidLoc) {
	      this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));
	    }
	    if (this.input.codePointAt(pos) === 96) {
	      this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
	    } else {
	      this.state.pos++;
	      this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
	    }
	  }
	  recordStrictModeErrors(toParseError, at) {
	    const index = at.index;
	    if (this.state.strict && !this.state.strictErrors.has(index)) {
	      this.raise(toParseError, at);
	    } else {
	      this.state.strictErrors.set(index, [toParseError, at]);
	    }
	  }
	  readWord1(firstCode) {
	    this.state.containsEsc = false;
	    let word = "";
	    const start = this.state.pos;
	    let chunkStart = this.state.pos;
	    if (firstCode !== undefined) {
	      this.state.pos += firstCode <= 0xffff ? 1 : 2;
	    }
	    while (this.state.pos < this.length) {
	      const ch = this.codePointAtPos(this.state.pos);
	      if (isIdentifierChar(ch)) {
	        this.state.pos += ch <= 0xffff ? 1 : 2;
	      } else if (ch === 92) {
	        this.state.containsEsc = true;
	        word += this.input.slice(chunkStart, this.state.pos);
	        const escStart = this.state.curPosition();
	        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
	        if (this.input.charCodeAt(++this.state.pos) !== 117) {
	          this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
	          chunkStart = this.state.pos - 1;
	          continue;
	        }
	        ++this.state.pos;
	        const esc = this.readCodePoint(true);
	        if (esc !== null) {
	          if (!identifierCheck(esc)) {
	            this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
	          }
	          word += String.fromCodePoint(esc);
	        }
	        chunkStart = this.state.pos;
	      } else {
	        break;
	      }
	    }
	    return word + this.input.slice(chunkStart, this.state.pos);
	  }
	  readWord(firstCode) {
	    const word = this.readWord1(firstCode);
	    const type = keywords$1.get(word);
	    if (type !== undefined) {
	      this.finishToken(type, tokenLabelName(type));
	    } else {
	      this.finishToken(132, word);
	    }
	  }
	  checkKeywordEscapes() {
	    const {
	      type
	    } = this.state;
	    if (tokenIsKeyword(type) && this.state.containsEsc) {
	      this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
	        reservedWord: tokenLabelName(type)
	      });
	    }
	  }
	  raise(toParseError, at, details = {}) {
	    const loc = at instanceof Position ? at : at.loc.start;
	    const error = toParseError(loc, details);
	    if (!(this.optionFlags & 2048)) throw error;
	    if (!this.isLookahead) this.state.errors.push(error);
	    return error;
	  }
	  raiseOverwrite(toParseError, at, details = {}) {
	    const loc = at instanceof Position ? at : at.loc.start;
	    const pos = loc.index;
	    const errors = this.state.errors;
	    for (let i = errors.length - 1; i >= 0; i--) {
	      const error = errors[i];
	      if (error.loc.index === pos) {
	        return errors[i] = toParseError(loc, details);
	      }
	      if (error.loc.index < pos) break;
	    }
	    return this.raise(toParseError, at, details);
	  }
	  updateContext(prevType) {}
	  unexpected(loc, type) {
	    throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
	      expected: type ? tokenLabelName(type) : null
	    });
	  }
	  expectPlugin(pluginName, loc) {
	    if (this.hasPlugin(pluginName)) {
	      return true;
	    }
	    throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
	      missingPlugin: [pluginName]
	    });
	  }
	  expectOnePlugin(pluginNames) {
	    if (!pluginNames.some(name => this.hasPlugin(name))) {
	      throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
	        missingPlugin: pluginNames
	      });
	    }
	  }
	  errorBuilder(error) {
	    return (pos, lineStart, curLine) => {
	      this.raise(error, buildPosition(pos, lineStart, curLine));
	    };
	  }
	}
	class ClassScope {
	  constructor() {
	    this.privateNames = new Set();
	    this.loneAccessors = new Map();
	    this.undefinedPrivateNames = new Map();
	  }
	}
	class ClassScopeHandler {
	  constructor(parser) {
	    this.parser = void 0;
	    this.stack = [];
	    this.undefinedPrivateNames = new Map();
	    this.parser = parser;
	  }
	  current() {
	    return this.stack[this.stack.length - 1];
	  }
	  enter() {
	    this.stack.push(new ClassScope());
	  }
	  exit() {
	    const oldClassScope = this.stack.pop();
	    const current = this.current();
	    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
	      if (current) {
	        if (!current.undefinedPrivateNames.has(name)) {
	          current.undefinedPrivateNames.set(name, loc);
	        }
	      } else {
	        this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
	          identifierName: name
	        });
	      }
	    }
	  }
	  declarePrivateName(name, elementType, loc) {
	    const {
	      privateNames,
	      loneAccessors,
	      undefinedPrivateNames
	    } = this.current();
	    let redefined = privateNames.has(name);
	    if (elementType & 3) {
	      const accessor = redefined && loneAccessors.get(name);
	      if (accessor) {
	        const oldStatic = accessor & 4;
	        const newStatic = elementType & 4;
	        const oldKind = accessor & 3;
	        const newKind = elementType & 3;
	        redefined = oldKind === newKind || oldStatic !== newStatic;
	        if (!redefined) loneAccessors.delete(name);
	      } else if (!redefined) {
	        loneAccessors.set(name, elementType);
	      }
	    }
	    if (redefined) {
	      this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
	        identifierName: name
	      });
	    }
	    privateNames.add(name);
	    undefinedPrivateNames.delete(name);
	  }
	  usePrivateName(name, loc) {
	    let classScope;
	    for (classScope of this.stack) {
	      if (classScope.privateNames.has(name)) return;
	    }
	    if (classScope) {
	      classScope.undefinedPrivateNames.set(name, loc);
	    } else {
	      this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
	        identifierName: name
	      });
	    }
	  }
	}
	class ExpressionScope {
	  constructor(type = 0) {
	    this.type = type;
	  }
	  canBeArrowParameterDeclaration() {
	    return this.type === 2 || this.type === 1;
	  }
	  isCertainlyParameterDeclaration() {
	    return this.type === 3;
	  }
	}
	class ArrowHeadParsingScope extends ExpressionScope {
	  constructor(type) {
	    super(type);
	    this.declarationErrors = new Map();
	  }
	  recordDeclarationError(ParsingErrorClass, at) {
	    const index = at.index;
	    this.declarationErrors.set(index, [ParsingErrorClass, at]);
	  }
	  clearDeclarationError(index) {
	    this.declarationErrors.delete(index);
	  }
	  iterateErrors(iterator) {
	    this.declarationErrors.forEach(iterator);
	  }
	}
	class ExpressionScopeHandler {
	  constructor(parser) {
	    this.parser = void 0;
	    this.stack = [new ExpressionScope()];
	    this.parser = parser;
	  }
	  enter(scope) {
	    this.stack.push(scope);
	  }
	  exit() {
	    this.stack.pop();
	  }
	  recordParameterInitializerError(toParseError, node) {
	    const origin = node.loc.start;
	    const {
	      stack
	    } = this;
	    let i = stack.length - 1;
	    let scope = stack[i];
	    while (!scope.isCertainlyParameterDeclaration()) {
	      if (scope.canBeArrowParameterDeclaration()) {
	        scope.recordDeclarationError(toParseError, origin);
	      } else {
	        return;
	      }
	      scope = stack[--i];
	    }
	    this.parser.raise(toParseError, origin);
	  }
	  recordArrowParameterBindingError(error, node) {
	    const {
	      stack
	    } = this;
	    const scope = stack[stack.length - 1];
	    const origin = node.loc.start;
	    if (scope.isCertainlyParameterDeclaration()) {
	      this.parser.raise(error, origin);
	    } else if (scope.canBeArrowParameterDeclaration()) {
	      scope.recordDeclarationError(error, origin);
	    } else {
	      return;
	    }
	  }
	  recordAsyncArrowParametersError(at) {
	    const {
	      stack
	    } = this;
	    let i = stack.length - 1;
	    let scope = stack[i];
	    while (scope.canBeArrowParameterDeclaration()) {
	      if (scope.type === 2) {
	        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);
	      }
	      scope = stack[--i];
	    }
	  }
	  validateAsPattern() {
	    const {
	      stack
	    } = this;
	    const currentScope = stack[stack.length - 1];
	    if (!currentScope.canBeArrowParameterDeclaration()) return;
	    currentScope.iterateErrors(([toParseError, loc]) => {
	      this.parser.raise(toParseError, loc);
	      let i = stack.length - 2;
	      let scope = stack[i];
	      while (scope.canBeArrowParameterDeclaration()) {
	        scope.clearDeclarationError(loc.index);
	        scope = stack[--i];
	      }
	    });
	  }
	}
	function newParameterDeclarationScope() {
	  return new ExpressionScope(3);
	}
	function newArrowHeadScope() {
	  return new ArrowHeadParsingScope(1);
	}
	function newAsyncArrowScope() {
	  return new ArrowHeadParsingScope(2);
	}
	function newExpressionScope() {
	  return new ExpressionScope();
	}
	class UtilParser extends Tokenizer {
	  addExtra(node, key, value, enumerable = true) {
	    if (!node) return;
	    let {
	      extra
	    } = node;
	    if (extra == null) {
	      extra = {};
	      node.extra = extra;
	    }
	    if (enumerable) {
	      extra[key] = value;
	    } else {
	      Object.defineProperty(extra, key, {
	        enumerable,
	        value
	      });
	    }
	  }
	  isContextual(token) {
	    return this.state.type === token && !this.state.containsEsc;
	  }
	  isUnparsedContextual(nameStart, name) {
	    const nameEnd = nameStart + name.length;
	    if (this.input.slice(nameStart, nameEnd) === name) {
	      const nextCh = this.input.charCodeAt(nameEnd);
	      return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);
	    }
	    return false;
	  }
	  isLookaheadContextual(name) {
	    const next = this.nextTokenStart();
	    return this.isUnparsedContextual(next, name);
	  }
	  eatContextual(token) {
	    if (this.isContextual(token)) {
	      this.next();
	      return true;
	    }
	    return false;
	  }
	  expectContextual(token, toParseError) {
	    if (!this.eatContextual(token)) {
	      if (toParseError != null) {
	        throw this.raise(toParseError, this.state.startLoc);
	      }
	      this.unexpected(null, token);
	    }
	  }
	  canInsertSemicolon() {
	    return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
	  }
	  hasPrecedingLineBreak() {
	    return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
	  }
	  hasFollowingLineBreak() {
	    return hasNewLine(this.input, this.state.end, this.nextTokenStart());
	  }
	  isLineTerminator() {
	    return this.eat(13) || this.canInsertSemicolon();
	  }
	  semicolon(allowAsi = true) {
	    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
	    this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
	  }
	  expect(type, loc) {
	    if (!this.eat(type)) {
	      this.unexpected(loc, type);
	    }
	  }
	  tryParse(fn, oldState = this.state.clone()) {
	    const abortSignal = {
	      node: null
	    };
	    try {
	      const node = fn((node = null) => {
	        abortSignal.node = node;
	        throw abortSignal;
	      });
	      if (this.state.errors.length > oldState.errors.length) {
	        const failState = this.state;
	        this.state = oldState;
	        this.state.tokensLength = failState.tokensLength;
	        return {
	          node,
	          error: failState.errors[oldState.errors.length],
	          thrown: false,
	          aborted: false,
	          failState
	        };
	      }
	      return {
	        node,
	        error: null,
	        thrown: false,
	        aborted: false,
	        failState: null
	      };
	    } catch (error) {
	      const failState = this.state;
	      this.state = oldState;
	      if (error instanceof SyntaxError) {
	        return {
	          node: null,
	          error,
	          thrown: true,
	          aborted: false,
	          failState
	        };
	      }
	      if (error === abortSignal) {
	        return {
	          node: abortSignal.node,
	          error: null,
	          thrown: false,
	          aborted: true,
	          failState
	        };
	      }
	      throw error;
	    }
	  }
	  checkExpressionErrors(refExpressionErrors, andThrow) {
	    if (!refExpressionErrors) return false;
	    const {
	      shorthandAssignLoc,
	      doubleProtoLoc,
	      privateKeyLoc,
	      optionalParametersLoc
	    } = refExpressionErrors;
	    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
	    if (!andThrow) {
	      return hasErrors;
	    }
	    if (shorthandAssignLoc != null) {
	      this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
	    }
	    if (doubleProtoLoc != null) {
	      this.raise(Errors.DuplicateProto, doubleProtoLoc);
	    }
	    if (privateKeyLoc != null) {
	      this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
	    }
	    if (optionalParametersLoc != null) {
	      this.unexpected(optionalParametersLoc);
	    }
	  }
	  isLiteralPropertyName() {
	    return tokenIsLiteralPropertyName(this.state.type);
	  }
	  isPrivateName(node) {
	    return node.type === "PrivateName";
	  }
	  getPrivateNameSV(node) {
	    return node.id.name;
	  }
	  hasPropertyAsPrivateName(node) {
	    return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
	  }
	  isObjectProperty(node) {
	    return node.type === "ObjectProperty";
	  }
	  isObjectMethod(node) {
	    return node.type === "ObjectMethod";
	  }
	  initializeScopes(inModule = this.options.sourceType === "module") {
	    const oldLabels = this.state.labels;
	    this.state.labels = [];
	    const oldExportedIdentifiers = this.exportedIdentifiers;
	    this.exportedIdentifiers = new Set();
	    const oldInModule = this.inModule;
	    this.inModule = inModule;
	    const oldScope = this.scope;
	    const ScopeHandler = this.getScopeHandler();
	    this.scope = new ScopeHandler(this, inModule);
	    const oldProdParam = this.prodParam;
	    this.prodParam = new ProductionParameterHandler();
	    const oldClassScope = this.classScope;
	    this.classScope = new ClassScopeHandler(this);
	    const oldExpressionScope = this.expressionScope;
	    this.expressionScope = new ExpressionScopeHandler(this);
	    return () => {
	      this.state.labels = oldLabels;
	      this.exportedIdentifiers = oldExportedIdentifiers;
	      this.inModule = oldInModule;
	      this.scope = oldScope;
	      this.prodParam = oldProdParam;
	      this.classScope = oldClassScope;
	      this.expressionScope = oldExpressionScope;
	    };
	  }
	  enterInitialScopes() {
	    let paramFlags = 0;
	    if (this.inModule) {
	      paramFlags |= 2;
	    }
	    if (this.optionFlags & 32) {
	      paramFlags |= 1;
	    }
	    this.scope.enter(1);
	    this.prodParam.enter(paramFlags);
	  }
	  checkDestructuringPrivate(refExpressionErrors) {
	    const {
	      privateKeyLoc
	    } = refExpressionErrors;
	    if (privateKeyLoc !== null) {
	      this.expectPlugin("destructuringPrivate", privateKeyLoc);
	    }
	  }
	}
	class ExpressionErrors {
	  constructor() {
	    this.shorthandAssignLoc = null;
	    this.doubleProtoLoc = null;
	    this.privateKeyLoc = null;
	    this.optionalParametersLoc = null;
	  }
	}
	class Node {
	  constructor(parser, pos, loc) {
	    this.type = "";
	    this.start = pos;
	    this.end = 0;
	    this.loc = new SourceLocation(loc);
	    if ((parser == null ? void 0 : parser.optionFlags) & 128) this.range = [pos, 0];
	    if (parser != null && parser.filename) this.loc.filename = parser.filename;
	  }
	}
	const NodePrototype = Node.prototype;
	{
	  NodePrototype.__clone = function () {
	    const newNode = new Node(undefined, this.start, this.loc.start);
	    const keys = Object.keys(this);
	    for (let i = 0, length = keys.length; i < length; i++) {
	      const key = keys[i];
	      if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
	        newNode[key] = this[key];
	      }
	    }
	    return newNode;
	  };
	}
	class NodeUtils extends UtilParser {
	  startNode() {
	    const loc = this.state.startLoc;
	    return new Node(this, loc.index, loc);
	  }
	  startNodeAt(loc) {
	    return new Node(this, loc.index, loc);
	  }
	  startNodeAtNode(type) {
	    return this.startNodeAt(type.loc.start);
	  }
	  finishNode(node, type) {
	    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
	  }
	  finishNodeAt(node, type, endLoc) {
	    node.type = type;
	    node.end = endLoc.index;
	    node.loc.end = endLoc;
	    if (this.optionFlags & 128) node.range[1] = endLoc.index;
	    if (this.optionFlags & 4096) {
	      this.processComment(node);
	    }
	    return node;
	  }
	  resetStartLocation(node, startLoc) {
	    node.start = startLoc.index;
	    node.loc.start = startLoc;
	    if (this.optionFlags & 128) node.range[0] = startLoc.index;
	  }
	  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
	    node.end = endLoc.index;
	    node.loc.end = endLoc;
	    if (this.optionFlags & 128) node.range[1] = endLoc.index;
	  }
	  resetStartLocationFromNode(node, locationNode) {
	    this.resetStartLocation(node, locationNode.loc.start);
	  }
	  castNodeTo(node, type) {
	    node.type = type;
	    return node;
	  }
	  cloneIdentifier(node) {
	    const {
	      type,
	      start,
	      end,
	      loc,
	      range,
	      name
	    } = node;
	    const cloned = Object.create(NodePrototype);
	    cloned.type = type;
	    cloned.start = start;
	    cloned.end = end;
	    cloned.loc = loc;
	    cloned.range = range;
	    cloned.name = name;
	    if (node.extra) cloned.extra = node.extra;
	    return cloned;
	  }
	  cloneStringLiteral(node) {
	    const {
	      type,
	      start,
	      end,
	      loc,
	      range,
	      extra
	    } = node;
	    const cloned = Object.create(NodePrototype);
	    cloned.type = type;
	    cloned.start = start;
	    cloned.end = end;
	    cloned.loc = loc;
	    cloned.range = range;
	    cloned.extra = extra;
	    cloned.value = node.value;
	    return cloned;
	  }
	}
	const unwrapParenthesizedExpression = node => {
	  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
	};
	class LValParser extends NodeUtils {
	  toAssignable(node, isLHS = false) {
	    var _node$extra, _node$extra3;
	    let parenthesized = undefined;
	    if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
	      parenthesized = unwrapParenthesizedExpression(node);
	      if (isLHS) {
	        if (parenthesized.type === "Identifier") {
	          this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);
	        } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
	          this.raise(Errors.InvalidParenthesizedAssignment, node);
	        }
	      } else {
	        this.raise(Errors.InvalidParenthesizedAssignment, node);
	      }
	    }
	    switch (node.type) {
	      case "Identifier":
	      case "ObjectPattern":
	      case "ArrayPattern":
	      case "AssignmentPattern":
	      case "RestElement":
	        break;
	      case "ObjectExpression":
	        this.castNodeTo(node, "ObjectPattern");
	        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
	          var _node$extra2;
	          const prop = node.properties[i];
	          const isLast = i === last;
	          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
	          if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
	            this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
	          }
	        }
	        break;
	      case "ObjectProperty":
	        {
	          const {
	            key,
	            value
	          } = node;
	          if (this.isPrivateName(key)) {
	            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
	          }
	          this.toAssignable(value, isLHS);
	          break;
	        }
	      case "SpreadElement":
	        {
	          throw new Error("Internal @babel/parser error (this is a bug, please report it)." + " SpreadElement should be converted by .toAssignable's caller.");
	        }
	      case "ArrayExpression":
	        this.castNodeTo(node, "ArrayPattern");
	        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
	        break;
	      case "AssignmentExpression":
	        if (node.operator !== "=") {
	          this.raise(Errors.MissingEqInAssignment, node.left.loc.end);
	        }
	        this.castNodeTo(node, "AssignmentPattern");
	        delete node.operator;
	        this.toAssignable(node.left, isLHS);
	        break;
	      case "ParenthesizedExpression":
	        this.toAssignable(parenthesized, isLHS);
	        break;
	    }
	  }
	  toAssignableObjectExpressionProp(prop, isLast, isLHS) {
	    if (prop.type === "ObjectMethod") {
	      this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
	    } else if (prop.type === "SpreadElement") {
	      this.castNodeTo(prop, "RestElement");
	      const arg = prop.argument;
	      this.checkToRestConversion(arg, false);
	      this.toAssignable(arg, isLHS);
	      if (!isLast) {
	        this.raise(Errors.RestTrailingComma, prop);
	      }
	    } else {
	      this.toAssignable(prop, isLHS);
	    }
	  }
	  toAssignableList(exprList, trailingCommaLoc, isLHS) {
	    const end = exprList.length - 1;
	    for (let i = 0; i <= end; i++) {
	      const elt = exprList[i];
	      if (!elt) continue;
	      this.toAssignableListItem(exprList, i, isLHS);
	      if (elt.type === "RestElement") {
	        if (i < end) {
	          this.raise(Errors.RestTrailingComma, elt);
	        } else if (trailingCommaLoc) {
	          this.raise(Errors.RestTrailingComma, trailingCommaLoc);
	        }
	      }
	    }
	  }
	  toAssignableListItem(exprList, index, isLHS) {
	    const node = exprList[index];
	    if (node.type === "SpreadElement") {
	      this.castNodeTo(node, "RestElement");
	      const arg = node.argument;
	      this.checkToRestConversion(arg, true);
	      this.toAssignable(arg, isLHS);
	    } else {
	      this.toAssignable(node, isLHS);
	    }
	  }
	  isAssignable(node, isBinding) {
	    switch (node.type) {
	      case "Identifier":
	      case "ObjectPattern":
	      case "ArrayPattern":
	      case "AssignmentPattern":
	      case "RestElement":
	        return true;
	      case "ObjectExpression":
	        {
	          const last = node.properties.length - 1;
	          return node.properties.every((prop, i) => {
	            return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
	          });
	        }
	      case "ObjectProperty":
	        return this.isAssignable(node.value);
	      case "SpreadElement":
	        return this.isAssignable(node.argument);
	      case "ArrayExpression":
	        return node.elements.every(element => element === null || this.isAssignable(element));
	      case "AssignmentExpression":
	        return node.operator === "=";
	      case "ParenthesizedExpression":
	        return this.isAssignable(node.expression);
	      case "MemberExpression":
	      case "OptionalMemberExpression":
	        return !isBinding;
	      default:
	        return false;
	    }
	  }
	  toReferencedList(exprList, isParenthesizedExpr) {
	    return exprList;
	  }
	  toReferencedListDeep(exprList, isParenthesizedExpr) {
	    this.toReferencedList(exprList, isParenthesizedExpr);
	    for (const expr of exprList) {
	      if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
	        this.toReferencedListDeep(expr.elements);
	      }
	    }
	  }
	  parseSpread(refExpressionErrors) {
	    const node = this.startNode();
	    this.next();
	    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);
	    return this.finishNode(node, "SpreadElement");
	  }
	  parseRestBinding() {
	    const node = this.startNode();
	    this.next();
	    node.argument = this.parseBindingAtom();
	    return this.finishNode(node, "RestElement");
	  }
	  parseBindingAtom() {
	    switch (this.state.type) {
	      case 0:
	        {
	          const node = this.startNode();
	          this.next();
	          node.elements = this.parseBindingList(3, 93, 1);
	          return this.finishNode(node, "ArrayPattern");
	        }
	      case 5:
	        return this.parseObjectLike(8, true);
	    }
	    return this.parseIdentifier();
	  }
	  parseBindingList(close, closeCharCode, flags) {
	    const allowEmpty = flags & 1;
	    const elts = [];
	    let first = true;
	    while (!this.eat(close)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12);
	      }
	      if (allowEmpty && this.match(12)) {
	        elts.push(null);
	      } else if (this.eat(close)) {
	        break;
	      } else if (this.match(21)) {
	        let rest = this.parseRestBinding();
	        if (this.hasPlugin("flow") || flags & 2) {
	          rest = this.parseFunctionParamType(rest);
	        }
	        elts.push(rest);
	        if (!this.checkCommaAfterRest(closeCharCode)) {
	          this.expect(close);
	          break;
	        }
	      } else {
	        const decorators = [];
	        if (flags & 2) {
	          if (this.match(26) && this.hasPlugin("decorators")) {
	            this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
	          }
	          while (this.match(26)) {
	            decorators.push(this.parseDecorator());
	          }
	        }
	        elts.push(this.parseBindingElement(flags, decorators));
	      }
	    }
	    return elts;
	  }
	  parseBindingRestProperty(prop) {
	    this.next();
	    prop.argument = this.parseIdentifier();
	    this.checkCommaAfterRest(125);
	    return this.finishNode(prop, "RestElement");
	  }
	  parseBindingProperty() {
	    const {
	      type,
	      startLoc
	    } = this.state;
	    if (type === 21) {
	      return this.parseBindingRestProperty(this.startNode());
	    }
	    const prop = this.startNode();
	    if (type === 139) {
	      this.expectPlugin("destructuringPrivate", startLoc);
	      this.classScope.usePrivateName(this.state.value, startLoc);
	      prop.key = this.parsePrivateName();
	    } else {
	      this.parsePropertyName(prop);
	    }
	    prop.method = false;
	    return this.parseObjPropValue(prop, startLoc, false, false, true, false);
	  }
	  parseBindingElement(flags, decorators) {
	    const left = this.parseMaybeDefault();
	    if (this.hasPlugin("flow") || flags & 2) {
	      this.parseFunctionParamType(left);
	    }
	    if (decorators.length) {
	      left.decorators = decorators;
	      this.resetStartLocationFromNode(left, decorators[0]);
	    }
	    const elt = this.parseMaybeDefault(left.loc.start, left);
	    return elt;
	  }
	  parseFunctionParamType(param) {
	    return param;
	  }
	  parseMaybeDefault(startLoc, left) {
	    startLoc != null ? startLoc : startLoc = this.state.startLoc;
	    left = left != null ? left : this.parseBindingAtom();
	    if (!this.eat(29)) return left;
	    const node = this.startNodeAt(startLoc);
	    node.left = left;
	    node.right = this.parseMaybeAssignAllowIn();
	    return this.finishNode(node, "AssignmentPattern");
	  }
	  isValidLVal(type, isUnparenthesizedInAssign, binding) {
	    switch (type) {
	      case "AssignmentPattern":
	        return "left";
	      case "RestElement":
	        return "argument";
	      case "ObjectProperty":
	        return "value";
	      case "ParenthesizedExpression":
	        return "expression";
	      case "ArrayPattern":
	        return "elements";
	      case "ObjectPattern":
	        return "properties";
	    }
	    return false;
	  }
	  isOptionalMemberExpression(expression) {
	    return expression.type === "OptionalMemberExpression";
	  }
	  checkLVal(expression, ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false) {
	    var _expression$extra;
	    const type = expression.type;
	    if (this.isObjectMethod(expression)) return;
	    const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
	    if (isOptionalMemberExpression || type === "MemberExpression") {
	      if (isOptionalMemberExpression) {
	        this.expectPlugin("optionalChainingAssign", expression.loc.start);
	        if (ancestor.type !== "AssignmentExpression") {
	          this.raise(Errors.InvalidLhsOptionalChaining, expression, {
	            ancestor
	          });
	        }
	      }
	      if (binding !== 64) {
	        this.raise(Errors.InvalidPropertyBindingPattern, expression);
	      }
	      return;
	    }
	    if (type === "Identifier") {
	      this.checkIdentifier(expression, binding, strictModeChanged);
	      const {
	        name
	      } = expression;
	      if (checkClashes) {
	        if (checkClashes.has(name)) {
	          this.raise(Errors.ParamDupe, expression);
	        } else {
	          checkClashes.add(name);
	        }
	      }
	      return;
	    }
	    const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
	    if (validity === true) return;
	    if (validity === false) {
	      const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
	      this.raise(ParseErrorClass, expression, {
	        ancestor
	      });
	      return;
	    }
	    let key, isParenthesizedExpression;
	    if (typeof validity === "string") {
	      key = validity;
	      isParenthesizedExpression = type === "ParenthesizedExpression";
	    } else {
	      [key, isParenthesizedExpression] = validity;
	    }
	    const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
	      type
	    } : ancestor;
	    const val = expression[key];
	    if (Array.isArray(val)) {
	      for (const child of val) {
	        if (child) {
	          this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
	        }
	      }
	    } else if (val) {
	      this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
	    }
	  }
	  checkIdentifier(at, bindingType, strictModeChanged = false) {
	    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
	      if (bindingType === 64) {
	        this.raise(Errors.StrictEvalArguments, at, {
	          referenceName: at.name
	        });
	      } else {
	        this.raise(Errors.StrictEvalArgumentsBinding, at, {
	          bindingName: at.name
	        });
	      }
	    }
	    if (bindingType & 8192 && at.name === "let") {
	      this.raise(Errors.LetInLexicalBinding, at);
	    }
	    if (!(bindingType & 64)) {
	      this.declareNameFromIdentifier(at, bindingType);
	    }
	  }
	  declareNameFromIdentifier(identifier, binding) {
	    this.scope.declareName(identifier.name, binding, identifier.loc.start);
	  }
	  checkToRestConversion(node, allowPattern) {
	    switch (node.type) {
	      case "ParenthesizedExpression":
	        this.checkToRestConversion(node.expression, allowPattern);
	        break;
	      case "Identifier":
	      case "MemberExpression":
	        break;
	      case "ArrayExpression":
	      case "ObjectExpression":
	        if (allowPattern) break;
	      default:
	        this.raise(Errors.InvalidRestAssignmentPattern, node);
	    }
	  }
	  checkCommaAfterRest(close) {
	    if (!this.match(12)) {
	      return false;
	    }
	    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
	    return true;
	  }
	}
	function nonNull(x) {
	  if (x == null) {
	    throw new Error(`Unexpected ${x} value.`);
	  }
	  return x;
	}
	function assert(x) {
	  if (!x) {
	    throw new Error("Assert fail");
	  }
	}
	const TSErrors = ParseErrorEnum`typescript`({
	  AbstractMethodHasImplementation: ({
	    methodName
	  }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
	  AbstractPropertyHasInitializer: ({
	    propertyName
	  }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
	  AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
	  AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
	  AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
	  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
	  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
	  ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
	  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
	  DeclareAccessor: ({
	    kind
	  }) => `'declare' is not allowed in ${kind}ters.`,
	  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
	  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
	  DuplicateAccessibilityModifier: ({
	    modifier
	  }) => `Accessibility modifier already seen: '${modifier}'.`,
	  DuplicateModifier: ({
	    modifier
	  }) => `Duplicate modifier: '${modifier}'.`,
	  EmptyHeritageClauseType: ({
	    token
	  }) => `'${token}' list cannot be empty.`,
	  EmptyTypeArguments: "Type argument list cannot be empty.",
	  EmptyTypeParameters: "Type parameter list cannot be empty.",
	  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
	  ImportAliasHasImportType: "An import alias can not use 'import type'.",
	  ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
	  IncompatibleModifiers: ({
	    modifiers
	  }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
	  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
	  IndexSignatureHasAccessibility: ({
	    modifier
	  }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
	  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
	  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
	  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
	  InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
	  InvalidHeritageClauseType: ({
	    token
	  }) => `'${token}' list can only include identifiers or qualified-names with optional type arguments.`,
	  InvalidModifierOnAwaitUsingDeclaration: modifier => `'${modifier}' modifier cannot appear on an await using declaration.`,
	  InvalidModifierOnTypeMember: ({
	    modifier
	  }) => `'${modifier}' modifier cannot appear on a type member.`,
	  InvalidModifierOnTypeParameter: ({
	    modifier
	  }) => `'${modifier}' modifier cannot appear on a type parameter.`,
	  InvalidModifierOnTypeParameterPositions: ({
	    modifier
	  }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
	  InvalidModifierOnUsingDeclaration: modifier => `'${modifier}' modifier cannot appear on a using declaration.`,
	  InvalidModifiersOrder: ({
	    orderedModifiers
	  }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
	  InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. " + "You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
	  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
	  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
	  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
	  NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.",
	  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
	  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
	  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
	  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
	  PrivateElementHasAccessibility: ({
	    modifier
	  }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
	  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
	  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
	  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
	  SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
	  SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
	  SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
	  SingleTypeParameterWithoutTrailingComma: ({
	    typeParameterName
	  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
	  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
	  TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
	  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
	  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
	  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
	  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
	  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
	  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
	  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
	  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
	  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
	  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
	  UnsupportedSignatureParameterKind: ({
	    type
	  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
	});
	function keywordTypeFromName(value) {
	  switch (value) {
	    case "any":
	      return "TSAnyKeyword";
	    case "boolean":
	      return "TSBooleanKeyword";
	    case "bigint":
	      return "TSBigIntKeyword";
	    case "never":
	      return "TSNeverKeyword";
	    case "number":
	      return "TSNumberKeyword";
	    case "object":
	      return "TSObjectKeyword";
	    case "string":
	      return "TSStringKeyword";
	    case "symbol":
	      return "TSSymbolKeyword";
	    case "undefined":
	      return "TSUndefinedKeyword";
	    case "unknown":
	      return "TSUnknownKeyword";
	    default:
	      return undefined;
	  }
	}
	function tsIsAccessModifier(modifier) {
	  return modifier === "private" || modifier === "public" || modifier === "protected";
	}
	function tsIsVarianceAnnotations(modifier) {
	  return modifier === "in" || modifier === "out";
	}
	var typescript = superClass => class TypeScriptParserMixin extends superClass {
	  constructor(...args) {
	    super(...args);
	    this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
	      allowedModifiers: ["in", "out"],
	      disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
	      errorTemplate: TSErrors.InvalidModifierOnTypeParameter
	    });
	    this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
	      allowedModifiers: ["const"],
	      disallowedModifiers: ["in", "out"],
	      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
	    });
	    this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
	      allowedModifiers: ["in", "out", "const"],
	      disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
	      errorTemplate: TSErrors.InvalidModifierOnTypeParameter
	    });
	  }
	  getScopeHandler() {
	    return TypeScriptScopeHandler;
	  }
	  tsIsIdentifier() {
	    return tokenIsIdentifier(this.state.type);
	  }
	  tsTokenCanFollowModifier() {
	    return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
	  }
	  tsNextTokenOnSameLineAndCanFollowModifier() {
	    this.next();
	    if (this.hasPrecedingLineBreak()) {
	      return false;
	    }
	    return this.tsTokenCanFollowModifier();
	  }
	  tsNextTokenCanFollowModifier() {
	    if (this.match(106)) {
	      this.next();
	      return this.tsTokenCanFollowModifier();
	    }
	    return this.tsNextTokenOnSameLineAndCanFollowModifier();
	  }
	  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {
	    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
	      return undefined;
	    }
	    const modifier = this.state.value;
	    if (allowedModifiers.includes(modifier)) {
	      if (hasSeenStaticModifier && this.match(106)) {
	        return undefined;
	      }
	      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
	        return undefined;
	      }
	      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
	        return modifier;
	      }
	    }
	    return undefined;
	  }
	  tsParseModifiers({
	    allowedModifiers,
	    disallowedModifiers,
	    stopOnStartOfClassStaticBlock,
	    errorTemplate = TSErrors.InvalidModifierOnTypeMember
	  }, modified) {
	    const enforceOrder = (loc, modifier, before, after) => {
	      if (modifier === before && modified[after]) {
	        this.raise(TSErrors.InvalidModifiersOrder, loc, {
	          orderedModifiers: [before, after]
	        });
	      }
	    };
	    const incompatible = (loc, modifier, mod1, mod2) => {
	      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
	        this.raise(TSErrors.IncompatibleModifiers, loc, {
	          modifiers: [mod1, mod2]
	        });
	      }
	    };
	    for (;;) {
	      const {
	        startLoc
	      } = this.state;
	      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock, modified.static);
	      if (!modifier) break;
	      if (tsIsAccessModifier(modifier)) {
	        if (modified.accessibility) {
	          this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
	            modifier
	          });
	        } else {
	          enforceOrder(startLoc, modifier, modifier, "override");
	          enforceOrder(startLoc, modifier, modifier, "static");
	          enforceOrder(startLoc, modifier, modifier, "readonly");
	          modified.accessibility = modifier;
	        }
	      } else if (tsIsVarianceAnnotations(modifier)) {
	        if (modified[modifier]) {
	          this.raise(TSErrors.DuplicateModifier, startLoc, {
	            modifier
	          });
	        }
	        modified[modifier] = true;
	        enforceOrder(startLoc, modifier, "in", "out");
	      } else {
	        if (hasOwnProperty.call(modified, modifier)) {
	          this.raise(TSErrors.DuplicateModifier, startLoc, {
	            modifier
	          });
	        } else {
	          enforceOrder(startLoc, modifier, "static", "readonly");
	          enforceOrder(startLoc, modifier, "static", "override");
	          enforceOrder(startLoc, modifier, "override", "readonly");
	          enforceOrder(startLoc, modifier, "abstract", "override");
	          incompatible(startLoc, modifier, "declare", "override");
	          incompatible(startLoc, modifier, "static", "abstract");
	        }
	        modified[modifier] = true;
	      }
	      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
	        this.raise(errorTemplate, startLoc, {
	          modifier
	        });
	      }
	    }
	  }
	  tsIsListTerminator(kind) {
	    switch (kind) {
	      case "EnumMembers":
	      case "TypeMembers":
	        return this.match(8);
	      case "HeritageClauseElement":
	        return this.match(5);
	      case "TupleElementTypes":
	        return this.match(3);
	      case "TypeParametersOrArguments":
	        return this.match(48);
	    }
	  }
	  tsParseList(kind, parseElement) {
	    const result = [];
	    while (!this.tsIsListTerminator(kind)) {
	      result.push(parseElement());
	    }
	    return result;
	  }
	  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
	    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
	  }
	  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
	    const result = [];
	    let trailingCommaPos = -1;
	    for (;;) {
	      if (this.tsIsListTerminator(kind)) {
	        break;
	      }
	      trailingCommaPos = -1;
	      const element = parseElement();
	      if (element == null) {
	        return undefined;
	      }
	      result.push(element);
	      if (this.eat(12)) {
	        trailingCommaPos = this.state.lastTokStartLoc.index;
	        continue;
	      }
	      if (this.tsIsListTerminator(kind)) {
	        break;
	      }
	      if (expectSuccess) {
	        this.expect(12);
	      }
	      return undefined;
	    }
	    if (refTrailingCommaPos) {
	      refTrailingCommaPos.value = trailingCommaPos;
	    }
	    return result;
	  }
	  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
	    if (!skipFirstToken) {
	      if (bracket) {
	        this.expect(0);
	      } else {
	        this.expect(47);
	      }
	    }
	    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
	    if (bracket) {
	      this.expect(3);
	    } else {
	      this.expect(48);
	    }
	    return result;
	  }
	  tsParseImportType() {
	    const node = this.startNode();
	    this.expect(83);
	    this.expect(10);
	    if (!this.match(134)) {
	      this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
	      {
	        node.argument = super.parseExprAtom();
	      }
	    } else {
	      {
	        node.argument = this.parseStringLiteral(this.state.value);
	      }
	    }
	    if (this.eat(12)) {
	      node.options = this.tsParseImportTypeOptions();
	    } else {
	      node.options = null;
	    }
	    this.expect(11);
	    if (this.eat(16)) {
	      node.qualifier = this.tsParseEntityName(1 | 2);
	    }
	    if (this.match(47)) {
	      {
	        node.typeParameters = this.tsParseTypeArguments();
	      }
	    }
	    return this.finishNode(node, "TSImportType");
	  }
	  tsParseImportTypeOptions() {
	    const node = this.startNode();
	    this.expect(5);
	    const withProperty = this.startNode();
	    if (this.isContextual(76)) {
	      withProperty.method = false;
	      withProperty.key = this.parseIdentifier(true);
	      withProperty.computed = false;
	      withProperty.shorthand = false;
	    } else {
	      this.unexpected(null, 76);
	    }
	    this.expect(14);
	    withProperty.value = this.tsParseImportTypeWithPropertyValue();
	    node.properties = [this.finishObjectProperty(withProperty)];
	    this.expect(8);
	    return this.finishNode(node, "ObjectExpression");
	  }
	  tsParseImportTypeWithPropertyValue() {
	    const node = this.startNode();
	    const properties = [];
	    this.expect(5);
	    while (!this.match(8)) {
	      const type = this.state.type;
	      if (tokenIsIdentifier(type) || type === 134) {
	        properties.push(super.parsePropertyDefinition(null));
	      } else {
	        this.unexpected();
	      }
	      this.eat(12);
	    }
	    node.properties = properties;
	    this.next();
	    return this.finishNode(node, "ObjectExpression");
	  }
	  tsParseEntityName(flags) {
	    let entity;
	    if (flags & 1 && this.match(78)) {
	      if (flags & 2) {
	        entity = this.parseIdentifier(true);
	      } else {
	        const node = this.startNode();
	        this.next();
	        entity = this.finishNode(node, "ThisExpression");
	      }
	    } else {
	      entity = this.parseIdentifier(!!(flags & 1));
	    }
	    while (this.eat(16)) {
	      const node = this.startNodeAtNode(entity);
	      node.left = entity;
	      node.right = this.parseIdentifier(!!(flags & 1));
	      entity = this.finishNode(node, "TSQualifiedName");
	    }
	    return entity;
	  }
	  tsParseTypeReference() {
	    const node = this.startNode();
	    node.typeName = this.tsParseEntityName(1);
	    if (!this.hasPrecedingLineBreak() && this.match(47)) {
	      {
	        node.typeParameters = this.tsParseTypeArguments();
	      }
	    }
	    return this.finishNode(node, "TSTypeReference");
	  }
	  tsParseThisTypePredicate(lhs) {
	    this.next();
	    const node = this.startNodeAtNode(lhs);
	    node.parameterName = lhs;
	    node.typeAnnotation = this.tsParseTypeAnnotation(false);
	    node.asserts = false;
	    return this.finishNode(node, "TSTypePredicate");
	  }
	  tsParseThisTypeNode() {
	    const node = this.startNode();
	    this.next();
	    return this.finishNode(node, "TSThisType");
	  }
	  tsParseTypeQuery() {
	    const node = this.startNode();
	    this.expect(87);
	    if (this.match(83)) {
	      node.exprName = this.tsParseImportType();
	    } else {
	      {
	        node.exprName = this.tsParseEntityName(1 | 2);
	      }
	    }
	    if (!this.hasPrecedingLineBreak() && this.match(47)) {
	      {
	        node.typeParameters = this.tsParseTypeArguments();
	      }
	    }
	    return this.finishNode(node, "TSTypeQuery");
	  }
	  tsParseTypeParameter(parseModifiers) {
	    const node = this.startNode();
	    parseModifiers(node);
	    node.name = this.tsParseTypeParameterName();
	    node.constraint = this.tsEatThenParseType(81);
	    node.default = this.tsEatThenParseType(29);
	    return this.finishNode(node, "TSTypeParameter");
	  }
	  tsTryParseTypeParameters(parseModifiers) {
	    if (this.match(47)) {
	      return this.tsParseTypeParameters(parseModifiers);
	    }
	  }
	  tsParseTypeParameters(parseModifiers) {
	    const node = this.startNode();
	    if (this.match(47) || this.match(143)) {
	      this.next();
	    } else {
	      this.unexpected();
	    }
	    const refTrailingCommaPos = {
	      value: -1
	    };
	    node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
	    if (node.params.length === 0) {
	      this.raise(TSErrors.EmptyTypeParameters, node);
	    }
	    if (refTrailingCommaPos.value !== -1) {
	      this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
	    }
	    return this.finishNode(node, "TSTypeParameterDeclaration");
	  }
	  tsFillSignature(returnToken, signature) {
	    const returnTokenRequired = returnToken === 19;
	    const paramsKey = "parameters";
	    const returnTypeKey = "typeAnnotation";
	    signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
	    this.expect(10);
	    signature[paramsKey] = this.tsParseBindingListForSignature();
	    if (returnTokenRequired) {
	      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
	    } else if (this.match(returnToken)) {
	      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
	    }
	  }
	  tsParseBindingListForSignature() {
	    const list = super.parseBindingList(11, 41, 2);
	    for (const pattern of list) {
	      const {
	        type
	      } = pattern;
	      if (type === "AssignmentPattern" || type === "TSParameterProperty") {
	        this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
	          type
	        });
	      }
	    }
	    return list;
	  }
	  tsParseTypeMemberSemicolon() {
	    if (!this.eat(12) && !this.isLineTerminator()) {
	      this.expect(13);
	    }
	  }
	  tsParseSignatureMember(kind, node) {
	    this.tsFillSignature(14, node);
	    this.tsParseTypeMemberSemicolon();
	    return this.finishNode(node, kind);
	  }
	  tsIsUnambiguouslyIndexSignature() {
	    this.next();
	    if (tokenIsIdentifier(this.state.type)) {
	      this.next();
	      return this.match(14);
	    }
	    return false;
	  }
	  tsTryParseIndexSignature(node) {
	    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
	      return;
	    }
	    this.expect(0);
	    const id = this.parseIdentifier();
	    id.typeAnnotation = this.tsParseTypeAnnotation();
	    this.resetEndLocation(id);
	    this.expect(3);
	    node.parameters = [id];
	    const type = this.tsTryParseTypeAnnotation();
	    if (type) node.typeAnnotation = type;
	    this.tsParseTypeMemberSemicolon();
	    return this.finishNode(node, "TSIndexSignature");
	  }
	  tsParsePropertyOrMethodSignature(node, readonly) {
	    if (this.eat(17)) node.optional = true;
	    if (this.match(10) || this.match(47)) {
	      if (readonly) {
	        this.raise(TSErrors.ReadonlyForMethodSignature, node);
	      }
	      const method = node;
	      if (method.kind && this.match(47)) {
	        this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());
	      }
	      this.tsFillSignature(14, method);
	      this.tsParseTypeMemberSemicolon();
	      const paramsKey = "parameters";
	      const returnTypeKey = "typeAnnotation";
	      if (method.kind === "get") {
	        if (method[paramsKey].length > 0) {
	          this.raise(Errors.BadGetterArity, this.state.curPosition());
	          if (this.isThisParam(method[paramsKey][0])) {
	            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
	          }
	        }
	      } else if (method.kind === "set") {
	        if (method[paramsKey].length !== 1) {
	          this.raise(Errors.BadSetterArity, this.state.curPosition());
	        } else {
	          const firstParameter = method[paramsKey][0];
	          if (this.isThisParam(firstParameter)) {
	            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
	          }
	          if (firstParameter.type === "Identifier" && firstParameter.optional) {
	            this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());
	          }
	          if (firstParameter.type === "RestElement") {
	            this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
	          }
	        }
	        if (method[returnTypeKey]) {
	          this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);
	        }
	      } else {
	        method.kind = "method";
	      }
	      return this.finishNode(method, "TSMethodSignature");
	    } else {
	      const property = node;
	      if (readonly) property.readonly = true;
	      const type = this.tsTryParseTypeAnnotation();
	      if (type) property.typeAnnotation = type;
	      this.tsParseTypeMemberSemicolon();
	      return this.finishNode(property, "TSPropertySignature");
	    }
	  }
	  tsParseTypeMember() {
	    const node = this.startNode();
	    if (this.match(10) || this.match(47)) {
	      return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
	    }
	    if (this.match(77)) {
	      const id = this.startNode();
	      this.next();
	      if (this.match(10) || this.match(47)) {
	        return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
	      } else {
	        node.key = this.createIdentifier(id, "new");
	        return this.tsParsePropertyOrMethodSignature(node, false);
	      }
	    }
	    this.tsParseModifiers({
	      allowedModifiers: ["readonly"],
	      disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
	    }, node);
	    const idx = this.tsTryParseIndexSignature(node);
	    if (idx) {
	      return idx;
	    }
	    super.parsePropertyName(node);
	    if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
	      node.kind = node.key.name;
	      super.parsePropertyName(node);
	      if (!this.match(10) && !this.match(47)) {
	        this.unexpected(null, 10);
	      }
	    }
	    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
	  }
	  tsParseTypeLiteral() {
	    const node = this.startNode();
	    node.members = this.tsParseObjectTypeMembers();
	    return this.finishNode(node, "TSTypeLiteral");
	  }
	  tsParseObjectTypeMembers() {
	    this.expect(5);
	    const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
	    this.expect(8);
	    return members;
	  }
	  tsIsStartOfMappedType() {
	    this.next();
	    if (this.eat(53)) {
	      return this.isContextual(122);
	    }
	    if (this.isContextual(122)) {
	      this.next();
	    }
	    if (!this.match(0)) {
	      return false;
	    }
	    this.next();
	    if (!this.tsIsIdentifier()) {
	      return false;
	    }
	    this.next();
	    return this.match(58);
	  }
	  tsParseMappedType() {
	    const node = this.startNode();
	    this.expect(5);
	    if (this.match(53)) {
	      node.readonly = this.state.value;
	      this.next();
	      this.expectContextual(122);
	    } else if (this.eatContextual(122)) {
	      node.readonly = true;
	    }
	    this.expect(0);
	    {
	      const typeParameter = this.startNode();
	      typeParameter.name = this.tsParseTypeParameterName();
	      typeParameter.constraint = this.tsExpectThenParseType(58);
	      node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
	    }
	    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
	    this.expect(3);
	    if (this.match(53)) {
	      node.optional = this.state.value;
	      this.next();
	      this.expect(17);
	    } else if (this.eat(17)) {
	      node.optional = true;
	    }
	    node.typeAnnotation = this.tsTryParseType();
	    this.semicolon();
	    this.expect(8);
	    return this.finishNode(node, "TSMappedType");
	  }
	  tsParseTupleType() {
	    const node = this.startNode();
	    node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
	    let seenOptionalElement = false;
	    node.elementTypes.forEach(elementNode => {
	      const {
	        type
	      } = elementNode;
	      if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
	        this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
	      }
	      seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
	    });
	    return this.finishNode(node, "TSTupleType");
	  }
	  tsParseTupleElementType() {
	    const restStartLoc = this.state.startLoc;
	    const rest = this.eat(21);
	    const {
	      startLoc
	    } = this.state;
	    let labeled;
	    let label;
	    let optional;
	    let type;
	    const isWord = tokenIsKeywordOrIdentifier(this.state.type);
	    const chAfterWord = isWord ? this.lookaheadCharCode() : null;
	    if (chAfterWord === 58) {
	      labeled = true;
	      optional = false;
	      label = this.parseIdentifier(true);
	      this.expect(14);
	      type = this.tsParseType();
	    } else if (chAfterWord === 63) {
	      optional = true;
	      const wordName = this.state.value;
	      const typeOrLabel = this.tsParseNonArrayType();
	      if (this.lookaheadCharCode() === 58) {
	        labeled = true;
	        label = this.createIdentifier(this.startNodeAt(startLoc), wordName);
	        this.expect(17);
	        this.expect(14);
	        type = this.tsParseType();
	      } else {
	        labeled = false;
	        type = typeOrLabel;
	        this.expect(17);
	      }
	    } else {
	      type = this.tsParseType();
	      optional = this.eat(17);
	      labeled = this.eat(14);
	    }
	    if (labeled) {
	      let labeledNode;
	      if (label) {
	        labeledNode = this.startNodeAt(startLoc);
	        labeledNode.optional = optional;
	        labeledNode.label = label;
	        labeledNode.elementType = type;
	        if (this.eat(17)) {
	          labeledNode.optional = true;
	          this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
	        }
	      } else {
	        labeledNode = this.startNodeAt(startLoc);
	        labeledNode.optional = optional;
	        this.raise(TSErrors.InvalidTupleMemberLabel, type);
	        labeledNode.label = type;
	        labeledNode.elementType = this.tsParseType();
	      }
	      type = this.finishNode(labeledNode, "TSNamedTupleMember");
	    } else if (optional) {
	      const optionalTypeNode = this.startNodeAt(startLoc);
	      optionalTypeNode.typeAnnotation = type;
	      type = this.finishNode(optionalTypeNode, "TSOptionalType");
	    }
	    if (rest) {
	      const restNode = this.startNodeAt(restStartLoc);
	      restNode.typeAnnotation = type;
	      type = this.finishNode(restNode, "TSRestType");
	    }
	    return type;
	  }
	  tsParseParenthesizedType() {
	    const node = this.startNode();
	    this.expect(10);
	    node.typeAnnotation = this.tsParseType();
	    this.expect(11);
	    return this.finishNode(node, "TSParenthesizedType");
	  }
	  tsParseFunctionOrConstructorType(type, abstract) {
	    const node = this.startNode();
	    if (type === "TSConstructorType") {
	      node.abstract = !!abstract;
	      if (abstract) this.next();
	      this.next();
	    }
	    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
	    return this.finishNode(node, type);
	  }
	  tsParseLiteralTypeNode() {
	    const node = this.startNode();
	    switch (this.state.type) {
	      case 135:
	      case 136:
	      case 134:
	      case 85:
	      case 86:
	        node.literal = super.parseExprAtom();
	        break;
	      default:
	        this.unexpected();
	    }
	    return this.finishNode(node, "TSLiteralType");
	  }
	  tsParseTemplateLiteralType() {
	    {
	      const node = this.startNode();
	      node.literal = super.parseTemplate(false);
	      return this.finishNode(node, "TSLiteralType");
	    }
	  }
	  parseTemplateSubstitution() {
	    if (this.state.inType) return this.tsParseType();
	    return super.parseTemplateSubstitution();
	  }
	  tsParseThisTypeOrThisTypePredicate() {
	    const thisKeyword = this.tsParseThisTypeNode();
	    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
	      return this.tsParseThisTypePredicate(thisKeyword);
	    } else {
	      return thisKeyword;
	    }
	  }
	  tsParseNonArrayType() {
	    switch (this.state.type) {
	      case 134:
	      case 135:
	      case 136:
	      case 85:
	      case 86:
	        return this.tsParseLiteralTypeNode();
	      case 53:
	        if (this.state.value === "-") {
	          const node = this.startNode();
	          const nextToken = this.lookahead();
	          if (nextToken.type !== 135 && nextToken.type !== 136) {
	            this.unexpected();
	          }
	          node.literal = this.parseMaybeUnary();
	          return this.finishNode(node, "TSLiteralType");
	        }
	        break;
	      case 78:
	        return this.tsParseThisTypeOrThisTypePredicate();
	      case 87:
	        return this.tsParseTypeQuery();
	      case 83:
	        return this.tsParseImportType();
	      case 5:
	        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
	      case 0:
	        return this.tsParseTupleType();
	      case 10:
	        return this.tsParseParenthesizedType();
	      case 25:
	      case 24:
	        return this.tsParseTemplateLiteralType();
	      default:
	        {
	          const {
	            type
	          } = this.state;
	          if (tokenIsIdentifier(type) || type === 88 || type === 84) {
	            const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
	            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {
	              const node = this.startNode();
	              this.next();
	              return this.finishNode(node, nodeType);
	            }
	            return this.tsParseTypeReference();
	          }
	        }
	    }
	    this.unexpected();
	  }
	  tsParseArrayTypeOrHigher() {
	    const {
	      startLoc
	    } = this.state;
	    let type = this.tsParseNonArrayType();
	    while (!this.hasPrecedingLineBreak() && this.eat(0)) {
	      if (this.match(3)) {
	        const node = this.startNodeAt(startLoc);
	        node.elementType = type;
	        this.expect(3);
	        type = this.finishNode(node, "TSArrayType");
	      } else {
	        const node = this.startNodeAt(startLoc);
	        node.objectType = type;
	        node.indexType = this.tsParseType();
	        this.expect(3);
	        type = this.finishNode(node, "TSIndexedAccessType");
	      }
	    }
	    return type;
	  }
	  tsParseTypeOperator() {
	    const node = this.startNode();
	    const operator = this.state.value;
	    this.next();
	    node.operator = operator;
	    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
	    if (operator === "readonly") {
	      this.tsCheckTypeAnnotationForReadOnly(node);
	    }
	    return this.finishNode(node, "TSTypeOperator");
	  }
	  tsCheckTypeAnnotationForReadOnly(node) {
	    switch (node.typeAnnotation.type) {
	      case "TSTupleType":
	      case "TSArrayType":
	        return;
	      default:
	        this.raise(TSErrors.UnexpectedReadonly, node);
	    }
	  }
	  tsParseInferType() {
	    const node = this.startNode();
	    this.expectContextual(115);
	    const typeParameter = this.startNode();
	    typeParameter.name = this.tsParseTypeParameterName();
	    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
	    node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
	    return this.finishNode(node, "TSInferType");
	  }
	  tsParseConstraintForInferType() {
	    if (this.eat(81)) {
	      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
	      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
	        return constraint;
	      }
	    }
	  }
	  tsParseTypeOperatorOrHigher() {
	    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
	    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
	  }
	  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
	    const node = this.startNode();
	    const hasLeadingOperator = this.eat(operator);
	    const types = [];
	    do {
	      types.push(parseConstituentType());
	    } while (this.eat(operator));
	    if (types.length === 1 && !hasLeadingOperator) {
	      return types[0];
	    }
	    node.types = types;
	    return this.finishNode(node, kind);
	  }
	  tsParseIntersectionTypeOrHigher() {
	    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
	  }
	  tsParseUnionTypeOrHigher() {
	    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
	  }
	  tsIsStartOfFunctionType() {
	    if (this.match(47)) {
	      return true;
	    }
	    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
	  }
	  tsSkipParameterStart() {
	    if (tokenIsIdentifier(this.state.type) || this.match(78)) {
	      this.next();
	      return true;
	    }
	    if (this.match(5)) {
	      const {
	        errors
	      } = this.state;
	      const previousErrorCount = errors.length;
	      try {
	        this.parseObjectLike(8, true);
	        return errors.length === previousErrorCount;
	      } catch (_unused) {
	        return false;
	      }
	    }
	    if (this.match(0)) {
	      this.next();
	      const {
	        errors
	      } = this.state;
	      const previousErrorCount = errors.length;
	      try {
	        super.parseBindingList(3, 93, 1);
	        return errors.length === previousErrorCount;
	      } catch (_unused2) {
	        return false;
	      }
	    }
	    return false;
	  }
	  tsIsUnambiguouslyStartOfFunctionType() {
	    this.next();
	    if (this.match(11) || this.match(21)) {
	      return true;
	    }
	    if (this.tsSkipParameterStart()) {
	      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
	        return true;
	      }
	      if (this.match(11)) {
	        this.next();
	        if (this.match(19)) {
	          return true;
	        }
	      }
	    }
	    return false;
	  }
	  tsParseTypeOrTypePredicateAnnotation(returnToken) {
	    return this.tsInType(() => {
	      const t = this.startNode();
	      this.expect(returnToken);
	      const node = this.startNode();
	      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
	      if (asserts && this.match(78)) {
	        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
	        if (thisTypePredicate.type === "TSThisType") {
	          node.parameterName = thisTypePredicate;
	          node.asserts = true;
	          node.typeAnnotation = null;
	          thisTypePredicate = this.finishNode(node, "TSTypePredicate");
	        } else {
	          this.resetStartLocationFromNode(thisTypePredicate, node);
	          thisTypePredicate.asserts = true;
	        }
	        t.typeAnnotation = thisTypePredicate;
	        return this.finishNode(t, "TSTypeAnnotation");
	      }
	      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
	      if (!typePredicateVariable) {
	        if (!asserts) {
	          return this.tsParseTypeAnnotation(false, t);
	        }
	        node.parameterName = this.parseIdentifier();
	        node.asserts = asserts;
	        node.typeAnnotation = null;
	        t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
	        return this.finishNode(t, "TSTypeAnnotation");
	      }
	      const type = this.tsParseTypeAnnotation(false);
	      node.parameterName = typePredicateVariable;
	      node.typeAnnotation = type;
	      node.asserts = asserts;
	      t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
	      return this.finishNode(t, "TSTypeAnnotation");
	    });
	  }
	  tsTryParseTypeOrTypePredicateAnnotation() {
	    if (this.match(14)) {
	      return this.tsParseTypeOrTypePredicateAnnotation(14);
	    }
	  }
	  tsTryParseTypeAnnotation() {
	    if (this.match(14)) {
	      return this.tsParseTypeAnnotation();
	    }
	  }
	  tsTryParseType() {
	    return this.tsEatThenParseType(14);
	  }
	  tsParseTypePredicatePrefix() {
	    const id = this.parseIdentifier();
	    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
	      this.next();
	      return id;
	    }
	  }
	  tsParseTypePredicateAsserts() {
	    if (this.state.type !== 109) {
	      return false;
	    }
	    const containsEsc = this.state.containsEsc;
	    this.next();
	    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
	      return false;
	    }
	    if (containsEsc) {
	      this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
	        reservedWord: "asserts"
	      });
	    }
	    return true;
	  }
	  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
	    this.tsInType(() => {
	      if (eatColon) this.expect(14);
	      t.typeAnnotation = this.tsParseType();
	    });
	    return this.finishNode(t, "TSTypeAnnotation");
	  }
	  tsParseType() {
	    assert(this.state.inType);
	    const type = this.tsParseNonConditionalType();
	    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
	      return type;
	    }
	    const node = this.startNodeAtNode(type);
	    node.checkType = type;
	    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
	    this.expect(17);
	    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
	    this.expect(14);
	    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
	    return this.finishNode(node, "TSConditionalType");
	  }
	  isAbstractConstructorSignature() {
	    return this.isContextual(124) && this.lookahead().type === 77;
	  }
	  tsParseNonConditionalType() {
	    if (this.tsIsStartOfFunctionType()) {
	      return this.tsParseFunctionOrConstructorType("TSFunctionType");
	    }
	    if (this.match(77)) {
	      return this.tsParseFunctionOrConstructorType("TSConstructorType");
	    } else if (this.isAbstractConstructorSignature()) {
	      return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
	    }
	    return this.tsParseUnionTypeOrHigher();
	  }
	  tsParseTypeAssertion() {
	    if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
	      this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
	    }
	    const node = this.startNode();
	    node.typeAnnotation = this.tsInType(() => {
	      this.next();
	      return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
	    });
	    this.expect(48);
	    node.expression = this.parseMaybeUnary();
	    return this.finishNode(node, "TSTypeAssertion");
	  }
	  tsParseHeritageClause(token) {
	    const originalStartLoc = this.state.startLoc;
	    const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
	      {
	        const node = this.startNode();
	        node.expression = this.tsParseEntityName(1 | 2);
	        if (this.match(47)) {
	          node.typeParameters = this.tsParseTypeArguments();
	        }
	        return this.finishNode(node, "TSExpressionWithTypeArguments");
	      }
	    });
	    if (!delimitedList.length) {
	      this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
	        token
	      });
	    }
	    return delimitedList;
	  }
	  tsParseInterfaceDeclaration(node, properties = {}) {
	    if (this.hasFollowingLineBreak()) return null;
	    this.expectContextual(129);
	    if (properties.declare) node.declare = true;
	    if (tokenIsIdentifier(this.state.type)) {
	      node.id = this.parseIdentifier();
	      this.checkIdentifier(node.id, 130);
	    } else {
	      node.id = null;
	      this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
	    }
	    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
	    if (this.eat(81)) {
	      node.extends = this.tsParseHeritageClause("extends");
	    }
	    const body = this.startNode();
	    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
	    node.body = this.finishNode(body, "TSInterfaceBody");
	    return this.finishNode(node, "TSInterfaceDeclaration");
	  }
	  tsParseTypeAliasDeclaration(node) {
	    node.id = this.parseIdentifier();
	    this.checkIdentifier(node.id, 2);
	    node.typeAnnotation = this.tsInType(() => {
	      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
	      this.expect(29);
	      if (this.isContextual(114) && this.lookahead().type !== 16) {
	        const node = this.startNode();
	        this.next();
	        return this.finishNode(node, "TSIntrinsicKeyword");
	      }
	      return this.tsParseType();
	    });
	    this.semicolon();
	    return this.finishNode(node, "TSTypeAliasDeclaration");
	  }
	  tsInTopLevelContext(cb) {
	    if (this.curContext() !== types.brace) {
	      const oldContext = this.state.context;
	      this.state.context = [oldContext[0]];
	      try {
	        return cb();
	      } finally {
	        this.state.context = oldContext;
	      }
	    } else {
	      return cb();
	    }
	  }
	  tsInType(cb) {
	    const oldInType = this.state.inType;
	    this.state.inType = true;
	    try {
	      return cb();
	    } finally {
	      this.state.inType = oldInType;
	    }
	  }
	  tsInDisallowConditionalTypesContext(cb) {
	    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
	    this.state.inDisallowConditionalTypesContext = true;
	    try {
	      return cb();
	    } finally {
	      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
	    }
	  }
	  tsInAllowConditionalTypesContext(cb) {
	    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
	    this.state.inDisallowConditionalTypesContext = false;
	    try {
	      return cb();
	    } finally {
	      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
	    }
	  }
	  tsEatThenParseType(token) {
	    if (this.match(token)) {
	      return this.tsNextThenParseType();
	    }
	  }
	  tsExpectThenParseType(token) {
	    return this.tsInType(() => {
	      this.expect(token);
	      return this.tsParseType();
	    });
	  }
	  tsNextThenParseType() {
	    return this.tsInType(() => {
	      this.next();
	      return this.tsParseType();
	    });
	  }
	  tsParseEnumMember() {
	    const node = this.startNode();
	    node.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
	    if (this.eat(29)) {
	      node.initializer = super.parseMaybeAssignAllowIn();
	    }
	    return this.finishNode(node, "TSEnumMember");
	  }
	  tsParseEnumDeclaration(node, properties = {}) {
	    if (properties.const) node.const = true;
	    if (properties.declare) node.declare = true;
	    this.expectContextual(126);
	    node.id = this.parseIdentifier();
	    this.checkIdentifier(node.id, node.const ? 8971 : 8459);
	    {
	      this.expect(5);
	      node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
	      this.expect(8);
	    }
	    return this.finishNode(node, "TSEnumDeclaration");
	  }
	  tsParseEnumBody() {
	    const node = this.startNode();
	    this.expect(5);
	    node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
	    this.expect(8);
	    return this.finishNode(node, "TSEnumBody");
	  }
	  tsParseModuleBlock() {
	    const node = this.startNode();
	    this.scope.enter(0);
	    this.expect(5);
	    super.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);
	    this.scope.exit();
	    return this.finishNode(node, "TSModuleBlock");
	  }
	  tsParseModuleOrNamespaceDeclaration(node, nested = false) {
	    node.id = this.parseIdentifier();
	    if (!nested) {
	      this.checkIdentifier(node.id, 1024);
	    }
	    if (this.eat(16)) {
	      const inner = this.startNode();
	      this.tsParseModuleOrNamespaceDeclaration(inner, true);
	      node.body = inner;
	    } else {
	      this.scope.enter(512);
	      this.prodParam.enter(0);
	      node.body = this.tsParseModuleBlock();
	      this.prodParam.exit();
	      this.scope.exit();
	    }
	    return this.finishNode(node, "TSModuleDeclaration");
	  }
	  tsParseAmbientExternalModuleDeclaration(node) {
	    if (this.isContextual(112)) {
	      node.kind = "global";
	      {
	        node.global = true;
	      }
	      node.id = this.parseIdentifier();
	    } else if (this.match(134)) {
	      node.kind = "module";
	      node.id = super.parseStringLiteral(this.state.value);
	    } else {
	      this.unexpected();
	    }
	    if (this.match(5)) {
	      this.scope.enter(512);
	      this.prodParam.enter(0);
	      node.body = this.tsParseModuleBlock();
	      this.prodParam.exit();
	      this.scope.exit();
	    } else {
	      this.semicolon();
	    }
	    return this.finishNode(node, "TSModuleDeclaration");
	  }
	  tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
	    {
	      node.isExport = isExport || false;
	    }
	    node.id = maybeDefaultIdentifier || this.parseIdentifier();
	    this.checkIdentifier(node.id, 4096);
	    this.expect(29);
	    const moduleReference = this.tsParseModuleReference();
	    if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
	      this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
	    }
	    node.moduleReference = moduleReference;
	    this.semicolon();
	    return this.finishNode(node, "TSImportEqualsDeclaration");
	  }
	  tsIsExternalModuleReference() {
	    return this.isContextual(119) && this.lookaheadCharCode() === 40;
	  }
	  tsParseModuleReference() {
	    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
	  }
	  tsParseExternalModuleReference() {
	    const node = this.startNode();
	    this.expectContextual(119);
	    this.expect(10);
	    if (!this.match(134)) {
	      this.unexpected();
	    }
	    node.expression = super.parseExprAtom();
	    this.expect(11);
	    this.sawUnambiguousESM = true;
	    return this.finishNode(node, "TSExternalModuleReference");
	  }
	  tsLookAhead(f) {
	    const state = this.state.clone();
	    const res = f();
	    this.state = state;
	    return res;
	  }
	  tsTryParseAndCatch(f) {
	    const result = this.tryParse(abort => f() || abort());
	    if (result.aborted || !result.node) return;
	    if (result.error) this.state = result.failState;
	    return result.node;
	  }
	  tsTryParse(f) {
	    const state = this.state.clone();
	    const result = f();
	    if (result !== undefined && result !== false) {
	      return result;
	    }
	    this.state = state;
	  }
	  tsTryParseDeclare(node) {
	    if (this.isLineTerminator()) {
	      return;
	    }
	    const startType = this.state.type;
	    return this.tsInAmbientContext(() => {
	      switch (startType) {
	        case 68:
	          node.declare = true;
	          return super.parseFunctionStatement(node, false, false);
	        case 80:
	          node.declare = true;
	          return this.parseClass(node, true, false);
	        case 126:
	          return this.tsParseEnumDeclaration(node, {
	            declare: true
	          });
	        case 112:
	          return this.tsParseAmbientExternalModuleDeclaration(node);
	        case 100:
	          if (this.state.containsEsc) {
	            return;
	          }
	        case 75:
	        case 74:
	          if (!this.match(75) || !this.isLookaheadContextual("enum")) {
	            node.declare = true;
	            return this.parseVarStatement(node, this.state.value, true);
	          }
	          this.expect(75);
	          return this.tsParseEnumDeclaration(node, {
	            const: true,
	            declare: true
	          });
	        case 107:
	          if (this.hasPlugin("explicitResourceManagement") && this.isUsing()) {
	            this.raise(TSErrors.InvalidModifierOnUsingDeclaration, this.state.startLoc, "declare");
	            node.declare = true;
	            return this.parseVarStatement(node, "using", true);
	          }
	          break;
	        case 96:
	          if (this.hasPlugin("explicitResourceManagement") && this.isAwaitUsing()) {
	            this.raise(TSErrors.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, "declare");
	            node.declare = true;
	            this.next();
	            return this.parseVarStatement(node, "await using", true);
	          }
	          break;
	        case 129:
	          {
	            const result = this.tsParseInterfaceDeclaration(node, {
	              declare: true
	            });
	            if (result) return result;
	          }
	        default:
	          if (tokenIsIdentifier(startType)) {
	            return this.tsParseDeclaration(node, this.state.value, true, null);
	          }
	      }
	    });
	  }
	  tsTryParseExportDeclaration() {
	    return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
	  }
	  tsParseExpressionStatement(node, expr, decorators) {
	    switch (expr.name) {
	      case "declare":
	        {
	          const declaration = this.tsTryParseDeclare(node);
	          if (declaration) {
	            declaration.declare = true;
	          }
	          return declaration;
	        }
	      case "global":
	        if (this.match(5)) {
	          this.scope.enter(512);
	          this.prodParam.enter(0);
	          const mod = node;
	          mod.kind = "global";
	          {
	            node.global = true;
	          }
	          mod.id = expr;
	          mod.body = this.tsParseModuleBlock();
	          this.scope.exit();
	          this.prodParam.exit();
	          return this.finishNode(mod, "TSModuleDeclaration");
	        }
	        break;
	      default:
	        return this.tsParseDeclaration(node, expr.name, false, decorators);
	    }
	  }
	  tsParseDeclaration(node, value, next, decorators) {
	    switch (value) {
	      case "abstract":
	        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
	          return this.tsParseAbstractDeclaration(node, decorators);
	        }
	        break;
	      case "module":
	        if (this.tsCheckLineTerminator(next)) {
	          if (this.match(134)) {
	            return this.tsParseAmbientExternalModuleDeclaration(node);
	          } else if (tokenIsIdentifier(this.state.type)) {
	            node.kind = "module";
	            return this.tsParseModuleOrNamespaceDeclaration(node);
	          }
	        }
	        break;
	      case "namespace":
	        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
	          node.kind = "namespace";
	          return this.tsParseModuleOrNamespaceDeclaration(node);
	        }
	        break;
	      case "type":
	        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
	          return this.tsParseTypeAliasDeclaration(node);
	        }
	        break;
	    }
	  }
	  tsCheckLineTerminator(next) {
	    if (next) {
	      if (this.hasFollowingLineBreak()) return false;
	      this.next();
	      return true;
	    }
	    return !this.isLineTerminator();
	  }
	  tsTryParseGenericAsyncArrowFunction(startLoc) {
	    if (!this.match(47)) return;
	    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	    this.state.maybeInArrowParameters = true;
	    const res = this.tsTryParseAndCatch(() => {
	      const node = this.startNodeAt(startLoc);
	      node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
	      super.parseFunctionParams(node);
	      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
	      this.expect(19);
	      return node;
	    });
	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    if (!res) return;
	    return super.parseArrowExpression(res, null, true);
	  }
	  tsParseTypeArgumentsInExpression() {
	    if (this.reScan_lt() !== 47) return;
	    return this.tsParseTypeArguments();
	  }
	  tsParseTypeArguments() {
	    const node = this.startNode();
	    node.params = this.tsInType(() => this.tsInTopLevelContext(() => {
	      this.expect(47);
	      return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
	    }));
	    if (node.params.length === 0) {
	      this.raise(TSErrors.EmptyTypeArguments, node);
	    } else if (!this.state.inType && this.curContext() === types.brace) {
	      this.reScan_lt_gt();
	    }
	    this.expect(48);
	    return this.finishNode(node, "TSTypeParameterInstantiation");
	  }
	  tsIsDeclarationStart() {
	    return tokenIsTSDeclarationStart(this.state.type);
	  }
	  isExportDefaultSpecifier() {
	    if (this.tsIsDeclarationStart()) return false;
	    return super.isExportDefaultSpecifier();
	  }
	  parseBindingElement(flags, decorators) {
	    const startLoc = decorators.length ? decorators[0].loc.start : this.state.startLoc;
	    const modified = {};
	    this.tsParseModifiers({
	      allowedModifiers: ["public", "private", "protected", "override", "readonly"]
	    }, modified);
	    const accessibility = modified.accessibility;
	    const override = modified.override;
	    const readonly = modified.readonly;
	    if (!(flags & 4) && (accessibility || readonly || override)) {
	      this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
	    }
	    const left = this.parseMaybeDefault();
	    if (flags & 2) {
	      this.parseFunctionParamType(left);
	    }
	    const elt = this.parseMaybeDefault(left.loc.start, left);
	    if (accessibility || readonly || override) {
	      const pp = this.startNodeAt(startLoc);
	      if (decorators.length) {
	        pp.decorators = decorators;
	      }
	      if (accessibility) pp.accessibility = accessibility;
	      if (readonly) pp.readonly = readonly;
	      if (override) pp.override = override;
	      if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
	        this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
	      }
	      pp.parameter = elt;
	      return this.finishNode(pp, "TSParameterProperty");
	    }
	    if (decorators.length) {
	      left.decorators = decorators;
	    }
	    return elt;
	  }
	  isSimpleParameter(node) {
	    return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
	  }
	  tsDisallowOptionalPattern(node) {
	    for (const param of node.params) {
	      if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
	        this.raise(TSErrors.PatternIsOptional, param);
	      }
	    }
	  }
	  setArrowFunctionParameters(node, params, trailingCommaLoc) {
	    super.setArrowFunctionParameters(node, params, trailingCommaLoc);
	    this.tsDisallowOptionalPattern(node);
	  }
	  parseFunctionBodyAndFinish(node, type, isMethod = false) {
	    if (this.match(14)) {
	      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
	    }
	    const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : undefined;
	    if (bodilessType && !this.match(5) && this.isLineTerminator()) {
	      return this.finishNode(node, bodilessType);
	    }
	    if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
	      this.raise(TSErrors.DeclareFunctionHasImplementation, node);
	      if (node.declare) {
	        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
	      }
	    }
	    this.tsDisallowOptionalPattern(node);
	    return super.parseFunctionBodyAndFinish(node, type, isMethod);
	  }
	  registerFunctionStatementId(node) {
	    if (!node.body && node.id) {
	      this.checkIdentifier(node.id, 1024);
	    } else {
	      super.registerFunctionStatementId(node);
	    }
	  }
	  tsCheckForInvalidTypeCasts(items) {
	    items.forEach(node => {
	      if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
	        this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
	      }
	    });
	  }
	  toReferencedList(exprList, isInParens) {
	    this.tsCheckForInvalidTypeCasts(exprList);
	    return exprList;
	  }
	  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
	    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
	    if (node.type === "ArrayExpression") {
	      this.tsCheckForInvalidTypeCasts(node.elements);
	    }
	    return node;
	  }
	  parseSubscript(base, startLoc, noCalls, state) {
	    if (!this.hasPrecedingLineBreak() && this.match(35)) {
	      this.state.canStartJSXElement = false;
	      this.next();
	      const nonNullExpression = this.startNodeAt(startLoc);
	      nonNullExpression.expression = base;
	      return this.finishNode(nonNullExpression, "TSNonNullExpression");
	    }
	    let isOptionalCall = false;
	    if (this.match(18) && this.lookaheadCharCode() === 60) {
	      if (noCalls) {
	        state.stop = true;
	        return base;
	      }
	      state.optionalChainMember = isOptionalCall = true;
	      this.next();
	    }
	    if (this.match(47) || this.match(51)) {
	      let missingParenErrorLoc;
	      const result = this.tsTryParseAndCatch(() => {
	        if (!noCalls && this.atPossibleAsyncArrow(base)) {
	          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
	          if (asyncArrowFn) {
	            return asyncArrowFn;
	          }
	        }
	        const typeArguments = this.tsParseTypeArgumentsInExpression();
	        if (!typeArguments) return;
	        if (isOptionalCall && !this.match(10)) {
	          missingParenErrorLoc = this.state.curPosition();
	          return;
	        }
	        if (tokenIsTemplate(this.state.type)) {
	          const result = super.parseTaggedTemplateExpression(base, startLoc, state);
	          {
	            result.typeParameters = typeArguments;
	          }
	          return result;
	        }
	        if (!noCalls && this.eat(10)) {
	          const node = this.startNodeAt(startLoc);
	          node.callee = base;
	          node.arguments = this.parseCallExpressionArguments(11);
	          this.tsCheckForInvalidTypeCasts(node.arguments);
	          {
	            node.typeParameters = typeArguments;
	          }
	          if (state.optionalChainMember) {
	            node.optional = isOptionalCall;
	          }
	          return this.finishCallExpression(node, state.optionalChainMember);
	        }
	        const tokenType = this.state.type;
	        if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
	          return;
	        }
	        const node = this.startNodeAt(startLoc);
	        node.expression = base;
	        {
	          node.typeParameters = typeArguments;
	        }
	        return this.finishNode(node, "TSInstantiationExpression");
	      });
	      if (missingParenErrorLoc) {
	        this.unexpected(missingParenErrorLoc, 10);
	      }
	      if (result) {
	        if (result.type === "TSInstantiationExpression") {
	          if (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) {
	            this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
	          }
	          if (!this.match(16) && !this.match(18)) {
	            result.expression = super.stopParseSubscript(base, state);
	          }
	        }
	        return result;
	      }
	    }
	    return super.parseSubscript(base, startLoc, noCalls, state);
	  }
	  parseNewCallee(node) {
	    var _callee$extra;
	    super.parseNewCallee(node);
	    const {
	      callee
	    } = node;
	    if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
	      {
	        node.typeParameters = callee.typeParameters;
	      }
	      node.callee = callee.expression;
	    }
	  }
	  parseExprOp(left, leftStartLoc, minPrec) {
	    let isSatisfies;
	    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
	      const node = this.startNodeAt(leftStartLoc);
	      node.expression = left;
	      node.typeAnnotation = this.tsInType(() => {
	        this.next();
	        if (this.match(75)) {
	          if (isSatisfies) {
	            this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
	              keyword: "const"
	            });
	          }
	          return this.tsParseTypeReference();
	        }
	        return this.tsParseType();
	      });
	      this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
	      this.reScan_lt_gt();
	      return this.parseExprOp(node, leftStartLoc, minPrec);
	    }
	    return super.parseExprOp(left, leftStartLoc, minPrec);
	  }
	  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
	    if (!this.state.isAmbientContext) {
	      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
	    }
	  }
	  checkImportReflection(node) {
	    super.checkImportReflection(node);
	    if (node.module && node.importKind !== "value") {
	      this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
	    }
	  }
	  checkDuplicateExports() {}
	  isPotentialImportPhase(isExport) {
	    if (super.isPotentialImportPhase(isExport)) return true;
	    if (this.isContextual(130)) {
	      const ch = this.lookaheadCharCode();
	      return isExport ? ch === 123 || ch === 42 : ch !== 61;
	    }
	    return !isExport && this.isContextual(87);
	  }
	  applyImportPhase(node, isExport, phase, loc) {
	    super.applyImportPhase(node, isExport, phase, loc);
	    if (isExport) {
	      node.exportKind = phase === "type" ? "type" : "value";
	    } else {
	      node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
	    }
	  }
	  parseImport(node) {
	    if (this.match(134)) {
	      node.importKind = "value";
	      return super.parseImport(node);
	    }
	    let importNode;
	    if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
	      node.importKind = "value";
	      return this.tsParseImportEqualsDeclaration(node);
	    } else if (this.isContextual(130)) {
	      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
	      if (this.lookaheadCharCode() === 61) {
	        return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
	      } else {
	        importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
	      }
	    } else {
	      importNode = super.parseImport(node);
	    }
	    if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
	      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
	    }
	    return importNode;
	  }
	  parseExport(node, decorators) {
	    if (this.match(83)) {
	      const nodeImportEquals = node;
	      this.next();
	      let maybeDefaultIdentifier = null;
	      if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
	        maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
	      } else {
	        nodeImportEquals.importKind = "value";
	      }
	      const declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);
	      {
	        return declaration;
	      }
	    } else if (this.eat(29)) {
	      const assign = node;
	      assign.expression = super.parseExpression();
	      this.semicolon();
	      this.sawUnambiguousESM = true;
	      return this.finishNode(assign, "TSExportAssignment");
	    } else if (this.eatContextual(93)) {
	      const decl = node;
	      this.expectContextual(128);
	      decl.id = this.parseIdentifier();
	      this.semicolon();
	      return this.finishNode(decl, "TSNamespaceExportDeclaration");
	    } else {
	      return super.parseExport(node, decorators);
	    }
	  }
	  isAbstractClass() {
	    return this.isContextual(124) && this.lookahead().type === 80;
	  }
	  parseExportDefaultExpression() {
	    if (this.isAbstractClass()) {
	      const cls = this.startNode();
	      this.next();
	      cls.abstract = true;
	      return this.parseClass(cls, true, true);
	    }
	    if (this.match(129)) {
	      const result = this.tsParseInterfaceDeclaration(this.startNode());
	      if (result) return result;
	    }
	    return super.parseExportDefaultExpression();
	  }
	  parseVarStatement(node, kind, allowMissingInitializer = false) {
	    const {
	      isAmbientContext
	    } = this.state;
	    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
	    if (!isAmbientContext) return declaration;
	    for (const {
	      id,
	      init
	    } of declaration.declarations) {
	      if (!init) continue;
	      if (kind === "var" || kind === "let" || !!id.typeAnnotation) {
	        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
	      } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
	        this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
	      }
	    }
	    return declaration;
	  }
	  parseStatementContent(flags, decorators) {
	    if (this.match(75) && this.isLookaheadContextual("enum")) {
	      const node = this.startNode();
	      this.expect(75);
	      return this.tsParseEnumDeclaration(node, {
	        const: true
	      });
	    }
	    if (this.isContextual(126)) {
	      return this.tsParseEnumDeclaration(this.startNode());
	    }
	    if (this.isContextual(129)) {
	      const result = this.tsParseInterfaceDeclaration(this.startNode());
	      if (result) return result;
	    }
	    return super.parseStatementContent(flags, decorators);
	  }
	  parseAccessModifier() {
	    return this.tsParseModifier(["public", "protected", "private"]);
	  }
	  tsHasSomeModifiers(member, modifiers) {
	    return modifiers.some(modifier => {
	      if (tsIsAccessModifier(modifier)) {
	        return member.accessibility === modifier;
	      }
	      return !!member[modifier];
	    });
	  }
	  tsIsStartOfStaticBlocks() {
	    return this.isContextual(106) && this.lookaheadCharCode() === 123;
	  }
	  parseClassMember(classBody, member, state) {
	    const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
	    this.tsParseModifiers({
	      allowedModifiers: modifiers,
	      disallowedModifiers: ["in", "out"],
	      stopOnStartOfClassStaticBlock: true,
	      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
	    }, member);
	    const callParseClassMemberWithIsStatic = () => {
	      if (this.tsIsStartOfStaticBlocks()) {
	        this.next();
	        this.next();
	        if (this.tsHasSomeModifiers(member, modifiers)) {
	          this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());
	        }
	        super.parseClassStaticBlock(classBody, member);
	      } else {
	        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
	      }
	    };
	    if (member.declare) {
	      this.tsInAmbientContext(callParseClassMemberWithIsStatic);
	    } else {
	      callParseClassMemberWithIsStatic();
	    }
	  }
	  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
	    const idx = this.tsTryParseIndexSignature(member);
	    if (idx) {
	      classBody.body.push(idx);
	      if (member.abstract) {
	        this.raise(TSErrors.IndexSignatureHasAbstract, member);
	      }
	      if (member.accessibility) {
	        this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
	          modifier: member.accessibility
	        });
	      }
	      if (member.declare) {
	        this.raise(TSErrors.IndexSignatureHasDeclare, member);
	      }
	      if (member.override) {
	        this.raise(TSErrors.IndexSignatureHasOverride, member);
	      }
	      return;
	    }
	    if (!this.state.inAbstractClass && member.abstract) {
	      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
	    }
	    if (member.override) {
	      if (!state.hadSuperClass) {
	        this.raise(TSErrors.OverrideNotInSubClass, member);
	      }
	    }
	    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
	  }
	  parsePostMemberNameModifiers(methodOrProp) {
	    const optional = this.eat(17);
	    if (optional) methodOrProp.optional = true;
	    if (methodOrProp.readonly && this.match(10)) {
	      this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
	    }
	    if (methodOrProp.declare && this.match(10)) {
	      this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
	    }
	  }
	  parseExpressionStatement(node, expr, decorators) {
	    const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : undefined;
	    return decl || super.parseExpressionStatement(node, expr, decorators);
	  }
	  shouldParseExportDeclaration() {
	    if (this.tsIsDeclarationStart()) return true;
	    return super.shouldParseExportDeclaration();
	  }
	  parseConditional(expr, startLoc, refExpressionErrors) {
	    if (!this.match(17)) return expr;
	    if (this.state.maybeInArrowParameters) {
	      const nextCh = this.lookaheadCharCode();
	      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
	        this.setOptionalParametersError(refExpressionErrors);
	        return expr;
	      }
	    }
	    return super.parseConditional(expr, startLoc, refExpressionErrors);
	  }
	  parseParenItem(node, startLoc) {
	    const newNode = super.parseParenItem(node, startLoc);
	    if (this.eat(17)) {
	      newNode.optional = true;
	      this.resetEndLocation(node);
	    }
	    if (this.match(14)) {
	      const typeCastNode = this.startNodeAt(startLoc);
	      typeCastNode.expression = node;
	      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
	      return this.finishNode(typeCastNode, "TSTypeCastExpression");
	    }
	    return node;
	  }
	  parseExportDeclaration(node) {
	    if (!this.state.isAmbientContext && this.isContextual(125)) {
	      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
	    }
	    const startLoc = this.state.startLoc;
	    const isDeclare = this.eatContextual(125);
	    if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
	      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
	    }
	    const isIdentifier = tokenIsIdentifier(this.state.type);
	    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
	    if (!declaration) return null;
	    if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
	      node.exportKind = "type";
	    }
	    if (isDeclare && declaration.type !== "TSImportEqualsDeclaration") {
	      this.resetStartLocation(declaration, startLoc);
	      declaration.declare = true;
	    }
	    return declaration;
	  }
	  parseClassId(node, isStatement, optionalId, bindingType) {
	    if ((!isStatement || optionalId) && this.isContextual(113)) {
	      return;
	    }
	    super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);
	    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
	    if (typeParameters) node.typeParameters = typeParameters;
	  }
	  parseClassPropertyAnnotation(node) {
	    if (!node.optional) {
	      if (this.eat(35)) {
	        node.definite = true;
	      } else if (this.eat(17)) {
	        node.optional = true;
	      }
	    }
	    const type = this.tsTryParseTypeAnnotation();
	    if (type) node.typeAnnotation = type;
	  }
	  parseClassProperty(node) {
	    this.parseClassPropertyAnnotation(node);
	    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
	      this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
	    }
	    if (node.abstract && this.match(29)) {
	      const {
	        key
	      } = node;
	      this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
	        propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
	      });
	    }
	    return super.parseClassProperty(node);
	  }
	  parseClassPrivateProperty(node) {
	    if (node.abstract) {
	      this.raise(TSErrors.PrivateElementHasAbstract, node);
	    }
	    if (node.accessibility) {
	      this.raise(TSErrors.PrivateElementHasAccessibility, node, {
	        modifier: node.accessibility
	      });
	    }
	    this.parseClassPropertyAnnotation(node);
	    return super.parseClassPrivateProperty(node);
	  }
	  parseClassAccessorProperty(node) {
	    this.parseClassPropertyAnnotation(node);
	    if (node.optional) {
	      this.raise(TSErrors.AccessorCannotBeOptional, node);
	    }
	    return super.parseClassAccessorProperty(node);
	  }
	  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
	    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
	    if (typeParameters && isConstructor) {
	      this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
	    }
	    const {
	      declare = false,
	      kind
	    } = method;
	    if (declare && (kind === "get" || kind === "set")) {
	      this.raise(TSErrors.DeclareAccessor, method, {
	        kind
	      });
	    }
	    if (typeParameters) method.typeParameters = typeParameters;
	    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
	  }
	  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
	    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
	    if (typeParameters) method.typeParameters = typeParameters;
	    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
	  }
	  declareClassPrivateMethodInScope(node, kind) {
	    if (node.type === "TSDeclareMethod") return;
	    if (node.type === "MethodDefinition" && node.value.body == null) {
	      return;
	    }
	    super.declareClassPrivateMethodInScope(node, kind);
	  }
	  parseClassSuper(node) {
	    super.parseClassSuper(node);
	    if (node.superClass && (this.match(47) || this.match(51))) {
	      {
	        node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
	      }
	    }
	    if (this.eatContextual(113)) {
	      node.implements = this.tsParseHeritageClause("implements");
	    }
	  }
	  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
	    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
	    if (typeParameters) prop.typeParameters = typeParameters;
	    return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
	  }
	  parseFunctionParams(node, isConstructor) {
	    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
	    if (typeParameters) node.typeParameters = typeParameters;
	    super.parseFunctionParams(node, isConstructor);
	  }
	  parseVarId(decl, kind) {
	    super.parseVarId(decl, kind);
	    if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
	      decl.definite = true;
	    }
	    const type = this.tsTryParseTypeAnnotation();
	    if (type) {
	      decl.id.typeAnnotation = type;
	      this.resetEndLocation(decl.id);
	    }
	  }
	  parseAsyncArrowFromCallExpression(node, call) {
	    if (this.match(14)) {
	      node.returnType = this.tsParseTypeAnnotation();
	    }
	    return super.parseAsyncArrowFromCallExpression(node, call);
	  }
	  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
	    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
	    let state;
	    let jsx;
	    let typeCast;
	    if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
	      state = this.state.clone();
	      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
	      if (!jsx.error) return jsx.node;
	      const {
	        context
	      } = this.state;
	      const currentContext = context[context.length - 1];
	      if (currentContext === types.j_oTag || currentContext === types.j_expr) {
	        context.pop();
	      }
	    }
	    if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {
	      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
	    }
	    if (!state || state === this.state) state = this.state.clone();
	    let typeParameters;
	    const arrow = this.tryParse(abort => {
	      var _expr$extra, _typeParameters;
	      typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
	      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
	      if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
	        abort();
	      }
	      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
	        this.resetStartLocationFromNode(expr, typeParameters);
	      }
	      expr.typeParameters = typeParameters;
	      return expr;
	    }, state);
	    if (!arrow.error && !arrow.aborted) {
	      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
	      return arrow.node;
	    }
	    if (!jsx) {
	      assert(!this.hasPlugin("jsx"));
	      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
	      if (!typeCast.error) return typeCast.node;
	    }
	    if ((_jsx2 = jsx) != null && _jsx2.node) {
	      this.state = jsx.failState;
	      return jsx.node;
	    }
	    if (arrow.node) {
	      this.state = arrow.failState;
	      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
	      return arrow.node;
	    }
	    if ((_typeCast = typeCast) != null && _typeCast.node) {
	      this.state = typeCast.failState;
	      return typeCast.node;
	    }
	    throw ((_jsx3 = jsx) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
	  }
	  reportReservedArrowTypeParam(node) {
	    var _node$extra2;
	    if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra2 = node.extra) != null && _node$extra2.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
	      this.raise(TSErrors.ReservedArrowTypeParam, node);
	    }
	  }
	  parseMaybeUnary(refExpressionErrors, sawUnary) {
	    if (!this.hasPlugin("jsx") && this.match(47)) {
	      return this.tsParseTypeAssertion();
	    }
	    return super.parseMaybeUnary(refExpressionErrors, sawUnary);
	  }
	  parseArrow(node) {
	    if (this.match(14)) {
	      const result = this.tryParse(abort => {
	        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
	        if (this.canInsertSemicolon() || !this.match(19)) abort();
	        return returnType;
	      });
	      if (result.aborted) return;
	      if (!result.thrown) {
	        if (result.error) this.state = result.failState;
	        node.returnType = result.node;
	      }
	    }
	    return super.parseArrow(node);
	  }
	  parseFunctionParamType(param) {
	    if (this.eat(17)) {
	      param.optional = true;
	    }
	    const type = this.tsTryParseTypeAnnotation();
	    if (type) param.typeAnnotation = type;
	    this.resetEndLocation(param);
	    return param;
	  }
	  isAssignable(node, isBinding) {
	    switch (node.type) {
	      case "TSTypeCastExpression":
	        return this.isAssignable(node.expression, isBinding);
	      case "TSParameterProperty":
	        return true;
	      default:
	        return super.isAssignable(node, isBinding);
	    }
	  }
	  toAssignable(node, isLHS = false) {
	    switch (node.type) {
	      case "ParenthesizedExpression":
	        this.toAssignableParenthesizedExpression(node, isLHS);
	        break;
	      case "TSAsExpression":
	      case "TSSatisfiesExpression":
	      case "TSNonNullExpression":
	      case "TSTypeAssertion":
	        if (isLHS) {
	          this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);
	        } else {
	          this.raise(TSErrors.UnexpectedTypeCastInParameter, node);
	        }
	        this.toAssignable(node.expression, isLHS);
	        break;
	      case "AssignmentExpression":
	        if (!isLHS && node.left.type === "TSTypeCastExpression") {
	          node.left = this.typeCastToParameter(node.left);
	        }
	      default:
	        super.toAssignable(node, isLHS);
	    }
	  }
	  toAssignableParenthesizedExpression(node, isLHS) {
	    switch (node.expression.type) {
	      case "TSAsExpression":
	      case "TSSatisfiesExpression":
	      case "TSNonNullExpression":
	      case "TSTypeAssertion":
	      case "ParenthesizedExpression":
	        this.toAssignable(node.expression, isLHS);
	        break;
	      default:
	        super.toAssignable(node, isLHS);
	    }
	  }
	  checkToRestConversion(node, allowPattern) {
	    switch (node.type) {
	      case "TSAsExpression":
	      case "TSSatisfiesExpression":
	      case "TSTypeAssertion":
	      case "TSNonNullExpression":
	        this.checkToRestConversion(node.expression, false);
	        break;
	      default:
	        super.checkToRestConversion(node, allowPattern);
	    }
	  }
	  isValidLVal(type, isUnparenthesizedInAssign, binding) {
	    switch (type) {
	      case "TSTypeCastExpression":
	        return true;
	      case "TSParameterProperty":
	        return "parameter";
	      case "TSNonNullExpression":
	        return "expression";
	      case "TSAsExpression":
	      case "TSSatisfiesExpression":
	      case "TSTypeAssertion":
	        return (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true];
	      default:
	        return super.isValidLVal(type, isUnparenthesizedInAssign, binding);
	    }
	  }
	  parseBindingAtom() {
	    if (this.state.type === 78) {
	      return this.parseIdentifier(true);
	    }
	    return super.parseBindingAtom();
	  }
	  parseMaybeDecoratorArguments(expr, startLoc) {
	    if (this.match(47) || this.match(51)) {
	      const typeArguments = this.tsParseTypeArgumentsInExpression();
	      if (this.match(10)) {
	        const call = super.parseMaybeDecoratorArguments(expr, startLoc);
	        {
	          call.typeParameters = typeArguments;
	        }
	        return call;
	      }
	      this.unexpected(null, 10);
	    }
	    return super.parseMaybeDecoratorArguments(expr, startLoc);
	  }
	  checkCommaAfterRest(close) {
	    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
	      this.next();
	      return false;
	    }
	    return super.checkCommaAfterRest(close);
	  }
	  isClassMethod() {
	    return this.match(47) || super.isClassMethod();
	  }
	  isClassProperty() {
	    return this.match(35) || this.match(14) || super.isClassProperty();
	  }
	  parseMaybeDefault(startLoc, left) {
	    const node = super.parseMaybeDefault(startLoc, left);
	    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
	      this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);
	    }
	    return node;
	  }
	  getTokenFromCode(code) {
	    if (this.state.inType) {
	      if (code === 62) {
	        this.finishOp(48, 1);
	        return;
	      }
	      if (code === 60) {
	        this.finishOp(47, 1);
	        return;
	      }
	    }
	    super.getTokenFromCode(code);
	  }
	  reScan_lt_gt() {
	    const {
	      type
	    } = this.state;
	    if (type === 47) {
	      this.state.pos -= 1;
	      this.readToken_lt();
	    } else if (type === 48) {
	      this.state.pos -= 1;
	      this.readToken_gt();
	    }
	  }
	  reScan_lt() {
	    const {
	      type
	    } = this.state;
	    if (type === 51) {
	      this.state.pos -= 2;
	      this.finishOp(47, 1);
	      return 47;
	    }
	    return type;
	  }
	  toAssignableListItem(exprList, index, isLHS) {
	    const node = exprList[index];
	    if (node.type === "TSTypeCastExpression") {
	      exprList[index] = this.typeCastToParameter(node);
	    }
	    super.toAssignableListItem(exprList, index, isLHS);
	  }
	  typeCastToParameter(node) {
	    node.expression.typeAnnotation = node.typeAnnotation;
	    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
	    return node.expression;
	  }
	  shouldParseArrow(params) {
	    if (this.match(14)) {
	      return params.every(expr => this.isAssignable(expr, true));
	    }
	    return super.shouldParseArrow(params);
	  }
	  shouldParseAsyncArrow() {
	    return this.match(14) || super.shouldParseAsyncArrow();
	  }
	  canHaveLeadingDecorator() {
	    return super.canHaveLeadingDecorator() || this.isAbstractClass();
	  }
	  jsxParseOpeningElementAfterName(node) {
	    if (this.match(47) || this.match(51)) {
	      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
	      if (typeArguments) {
	        {
	          node.typeParameters = typeArguments;
	        }
	      }
	    }
	    return super.jsxParseOpeningElementAfterName(node);
	  }
	  getGetterSetterExpectedParamCount(method) {
	    const baseCount = super.getGetterSetterExpectedParamCount(method);
	    const params = this.getObjectOrClassMethodParams(method);
	    const firstParam = params[0];
	    const hasContextParam = firstParam && this.isThisParam(firstParam);
	    return hasContextParam ? baseCount + 1 : baseCount;
	  }
	  parseCatchClauseParam() {
	    const param = super.parseCatchClauseParam();
	    const type = this.tsTryParseTypeAnnotation();
	    if (type) {
	      param.typeAnnotation = type;
	      this.resetEndLocation(param);
	    }
	    return param;
	  }
	  tsInAmbientContext(cb) {
	    const {
	      isAmbientContext: oldIsAmbientContext,
	      strict: oldStrict
	    } = this.state;
	    this.state.isAmbientContext = true;
	    this.state.strict = false;
	    try {
	      return cb();
	    } finally {
	      this.state.isAmbientContext = oldIsAmbientContext;
	      this.state.strict = oldStrict;
	    }
	  }
	  parseClass(node, isStatement, optionalId) {
	    const oldInAbstractClass = this.state.inAbstractClass;
	    this.state.inAbstractClass = !!node.abstract;
	    try {
	      return super.parseClass(node, isStatement, optionalId);
	    } finally {
	      this.state.inAbstractClass = oldInAbstractClass;
	    }
	  }
	  tsParseAbstractDeclaration(node, decorators) {
	    if (this.match(80)) {
	      node.abstract = true;
	      return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
	    } else if (this.isContextual(129)) {
	      if (!this.hasFollowingLineBreak()) {
	        node.abstract = true;
	        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifier, node);
	        return this.tsParseInterfaceDeclaration(node);
	      }
	    } else {
	      this.unexpected(null, 80);
	    }
	  }
	  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
	    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
	    if (method.abstract || method.type === "TSAbstractMethodDefinition") {
	      const hasEstreePlugin = this.hasPlugin("estree");
	      const methodFn = hasEstreePlugin ? method.value : method;
	      if (methodFn.body) {
	        const {
	          key
	        } = method;
	        this.raise(TSErrors.AbstractMethodHasImplementation, method, {
	          methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
	        });
	      }
	    }
	    return method;
	  }
	  tsParseTypeParameterName() {
	    const typeName = this.parseIdentifier();
	    return typeName.name;
	  }
	  shouldParseAsAmbientContext() {
	    return !!this.getPluginOption("typescript", "dts");
	  }
	  parse() {
	    if (this.shouldParseAsAmbientContext()) {
	      this.state.isAmbientContext = true;
	    }
	    return super.parse();
	  }
	  getExpression() {
	    if (this.shouldParseAsAmbientContext()) {
	      this.state.isAmbientContext = true;
	    }
	    return super.getExpression();
	  }
	  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
	    if (!isString && isMaybeTypeOnly) {
	      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
	      return this.finishNode(node, "ExportSpecifier");
	    }
	    node.exportKind = "value";
	    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
	  }
	  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
	    if (!importedIsString && isMaybeTypeOnly) {
	      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
	      return this.finishNode(specifier, "ImportSpecifier");
	    }
	    specifier.importKind = "value";
	    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
	  }
	  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
	    const leftOfAsKey = isImport ? "imported" : "local";
	    const rightOfAsKey = isImport ? "local" : "exported";
	    let leftOfAs = node[leftOfAsKey];
	    let rightOfAs;
	    let hasTypeSpecifier = false;
	    let canParseAsKeyword = true;
	    const loc = leftOfAs.loc.start;
	    if (this.isContextual(93)) {
	      const firstAs = this.parseIdentifier();
	      if (this.isContextual(93)) {
	        const secondAs = this.parseIdentifier();
	        if (tokenIsKeywordOrIdentifier(this.state.type)) {
	          hasTypeSpecifier = true;
	          leftOfAs = firstAs;
	          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
	          canParseAsKeyword = false;
	        } else {
	          rightOfAs = secondAs;
	          canParseAsKeyword = false;
	        }
	      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
	        canParseAsKeyword = false;
	        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
	      } else {
	        hasTypeSpecifier = true;
	        leftOfAs = firstAs;
	      }
	    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
	      hasTypeSpecifier = true;
	      if (isImport) {
	        leftOfAs = this.parseIdentifier(true);
	        if (!this.isContextual(93)) {
	          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
	        }
	      } else {
	        leftOfAs = this.parseModuleExportName();
	      }
	    }
	    if (hasTypeSpecifier && isInTypeOnlyImportExport) {
	      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
	    }
	    node[leftOfAsKey] = leftOfAs;
	    node[rightOfAsKey] = rightOfAs;
	    const kindKey = isImport ? "importKind" : "exportKind";
	    node[kindKey] = hasTypeSpecifier ? "type" : "value";
	    if (canParseAsKeyword && this.eatContextual(93)) {
	      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
	    }
	    if (!node[rightOfAsKey]) {
	      node[rightOfAsKey] = this.cloneIdentifier(node[leftOfAsKey]);
	    }
	    if (isImport) {
	      this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
	    }
	  }
	  fillOptionalPropertiesForTSESLint(node) {
	    var _node$directive, _node$decorators, _node$optional, _node$typeAnnotation, _node$accessibility, _node$decorators2, _node$override, _node$readonly, _node$static, _node$declare, _node$returnType, _node$typeParameters, _node$optional2, _node$optional3, _node$accessibility2, _node$readonly2, _node$static2, _node$declare2, _node$definite, _node$readonly3, _node$typeAnnotation2, _node$accessibility3, _node$decorators3, _node$override2, _node$optional4, _node$id, _node$abstract, _node$declare3, _node$decorators4, _node$implements, _node$superTypeArgume, _node$typeParameters2, _node$declare4, _node$definite2, _node$const, _node$declare5, _node$computed, _node$qualifier, _node$options, _node$declare6, _node$extends, _node$declare7, _node$global, _node$const2, _node$in, _node$out;
	    switch (node.type) {
	      case "ExpressionStatement":
	        (_node$directive = node.directive) != null ? _node$directive : node.directive = undefined;
	        return;
	      case "RestElement":
	        node.value = undefined;
	      case "Identifier":
	      case "ArrayPattern":
	      case "AssignmentPattern":
	      case "ObjectPattern":
	        (_node$decorators = node.decorators) != null ? _node$decorators : node.decorators = [];
	        (_node$optional = node.optional) != null ? _node$optional : node.optional = false;
	        (_node$typeAnnotation = node.typeAnnotation) != null ? _node$typeAnnotation : node.typeAnnotation = undefined;
	        return;
	      case "TSParameterProperty":
	        (_node$accessibility = node.accessibility) != null ? _node$accessibility : node.accessibility = undefined;
	        (_node$decorators2 = node.decorators) != null ? _node$decorators2 : node.decorators = [];
	        (_node$override = node.override) != null ? _node$override : node.override = false;
	        (_node$readonly = node.readonly) != null ? _node$readonly : node.readonly = false;
	        (_node$static = node.static) != null ? _node$static : node.static = false;
	        return;
	      case "TSEmptyBodyFunctionExpression":
	        node.body = null;
	      case "TSDeclareFunction":
	      case "FunctionDeclaration":
	      case "FunctionExpression":
	      case "ClassMethod":
	      case "ClassPrivateMethod":
	        (_node$declare = node.declare) != null ? _node$declare : node.declare = false;
	        (_node$returnType = node.returnType) != null ? _node$returnType : node.returnType = undefined;
	        (_node$typeParameters = node.typeParameters) != null ? _node$typeParameters : node.typeParameters = undefined;
	        return;
	      case "Property":
	        (_node$optional2 = node.optional) != null ? _node$optional2 : node.optional = false;
	        return;
	      case "TSMethodSignature":
	      case "TSPropertySignature":
	        (_node$optional3 = node.optional) != null ? _node$optional3 : node.optional = false;
	      case "TSIndexSignature":
	        (_node$accessibility2 = node.accessibility) != null ? _node$accessibility2 : node.accessibility = undefined;
	        (_node$readonly2 = node.readonly) != null ? _node$readonly2 : node.readonly = false;
	        (_node$static2 = node.static) != null ? _node$static2 : node.static = false;
	        return;
	      case "TSAbstractPropertyDefinition":
	      case "PropertyDefinition":
	      case "TSAbstractAccessorProperty":
	      case "AccessorProperty":
	        (_node$declare2 = node.declare) != null ? _node$declare2 : node.declare = false;
	        (_node$definite = node.definite) != null ? _node$definite : node.definite = false;
	        (_node$readonly3 = node.readonly) != null ? _node$readonly3 : node.readonly = false;
	        (_node$typeAnnotation2 = node.typeAnnotation) != null ? _node$typeAnnotation2 : node.typeAnnotation = undefined;
	      case "TSAbstractMethodDefinition":
	      case "MethodDefinition":
	        (_node$accessibility3 = node.accessibility) != null ? _node$accessibility3 : node.accessibility = undefined;
	        (_node$decorators3 = node.decorators) != null ? _node$decorators3 : node.decorators = [];
	        (_node$override2 = node.override) != null ? _node$override2 : node.override = false;
	        (_node$optional4 = node.optional) != null ? _node$optional4 : node.optional = false;
	        return;
	      case "ClassExpression":
	        (_node$id = node.id) != null ? _node$id : node.id = null;
	      case "ClassDeclaration":
	        (_node$abstract = node.abstract) != null ? _node$abstract : node.abstract = false;
	        (_node$declare3 = node.declare) != null ? _node$declare3 : node.declare = false;
	        (_node$decorators4 = node.decorators) != null ? _node$decorators4 : node.decorators = [];
	        (_node$implements = node.implements) != null ? _node$implements : node.implements = [];
	        (_node$superTypeArgume = node.superTypeArguments) != null ? _node$superTypeArgume : node.superTypeArguments = undefined;
	        (_node$typeParameters2 = node.typeParameters) != null ? _node$typeParameters2 : node.typeParameters = undefined;
	        return;
	      case "TSTypeAliasDeclaration":
	      case "VariableDeclaration":
	        (_node$declare4 = node.declare) != null ? _node$declare4 : node.declare = false;
	        return;
	      case "VariableDeclarator":
	        (_node$definite2 = node.definite) != null ? _node$definite2 : node.definite = false;
	        return;
	      case "TSEnumDeclaration":
	        (_node$const = node.const) != null ? _node$const : node.const = false;
	        (_node$declare5 = node.declare) != null ? _node$declare5 : node.declare = false;
	        return;
	      case "TSEnumMember":
	        (_node$computed = node.computed) != null ? _node$computed : node.computed = false;
	        return;
	      case "TSImportType":
	        (_node$qualifier = node.qualifier) != null ? _node$qualifier : node.qualifier = null;
	        (_node$options = node.options) != null ? _node$options : node.options = null;
	        return;
	      case "TSInterfaceDeclaration":
	        (_node$declare6 = node.declare) != null ? _node$declare6 : node.declare = false;
	        (_node$extends = node.extends) != null ? _node$extends : node.extends = [];
	        return;
	      case "TSModuleDeclaration":
	        (_node$declare7 = node.declare) != null ? _node$declare7 : node.declare = false;
	        (_node$global = node.global) != null ? _node$global : node.global = node.kind === "global";
	        return;
	      case "TSTypeParameter":
	        (_node$const2 = node.const) != null ? _node$const2 : node.const = false;
	        (_node$in = node.in) != null ? _node$in : node.in = false;
	        (_node$out = node.out) != null ? _node$out : node.out = false;
	        return;
	    }
	  }
	};
	function isPossiblyLiteralEnum(expression) {
	  if (expression.type !== "MemberExpression") return false;
	  const {
	    computed,
	    property
	  } = expression;
	  if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
	    return false;
	  }
	  return isUncomputedMemberExpressionChain(expression.object);
	}
	function isValidAmbientConstInitializer(expression, estree) {
	  var _expression$extra;
	  const {
	    type
	  } = expression;
	  if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
	    return false;
	  }
	  if (estree) {
	    if (type === "Literal") {
	      const {
	        value
	      } = expression;
	      if (typeof value === "string" || typeof value === "boolean") {
	        return true;
	      }
	    }
	  } else {
	    if (type === "StringLiteral" || type === "BooleanLiteral") {
	      return true;
	    }
	  }
	  if (isNumber(expression, estree) || isNegativeNumber(expression, estree)) {
	    return true;
	  }
	  if (type === "TemplateLiteral" && expression.expressions.length === 0) {
	    return true;
	  }
	  if (isPossiblyLiteralEnum(expression)) {
	    return true;
	  }
	  return false;
	}
	function isNumber(expression, estree) {
	  if (estree) {
	    return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
	  }
	  return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
	}
	function isNegativeNumber(expression, estree) {
	  if (expression.type === "UnaryExpression") {
	    const {
	      operator,
	      argument
	    } = expression;
	    if (operator === "-" && isNumber(argument, estree)) {
	      return true;
	    }
	  }
	  return false;
	}
	function isUncomputedMemberExpressionChain(expression) {
	  if (expression.type === "Identifier") return true;
	  if (expression.type !== "MemberExpression" || expression.computed) {
	    return false;
	  }
	  return isUncomputedMemberExpressionChain(expression.object);
	}
	const PlaceholderErrors = ParseErrorEnum`placeholders`({
	  ClassNameIsRequired: "A class name is required.",
	  UnexpectedSpace: "Unexpected space in placeholder."
	});
	var placeholders = superClass => class PlaceholdersParserMixin extends superClass {
	  parsePlaceholder(expectedNode) {
	    if (this.match(133)) {
	      const node = this.startNode();
	      this.next();
	      this.assertNoSpace();
	      node.name = super.parseIdentifier(true);
	      this.assertNoSpace();
	      this.expect(133);
	      return this.finishPlaceholder(node, expectedNode);
	    }
	  }
	  finishPlaceholder(node, expectedNode) {
	    let placeholder = node;
	    if (!placeholder.expectedNode || !placeholder.type) {
	      placeholder = this.finishNode(placeholder, "Placeholder");
	    }
	    placeholder.expectedNode = expectedNode;
	    return placeholder;
	  }
	  getTokenFromCode(code) {
	    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
	      this.finishOp(133, 2);
	    } else {
	      super.getTokenFromCode(code);
	    }
	  }
	  parseExprAtom(refExpressionErrors) {
	    return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
	  }
	  parseIdentifier(liberal) {
	    return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
	  }
	  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
	    if (word !== undefined) {
	      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
	    }
	  }
	  cloneIdentifier(node) {
	    const cloned = super.cloneIdentifier(node);
	    if (cloned.type === "Placeholder") {
	      cloned.expectedNode = node.expectedNode;
	    }
	    return cloned;
	  }
	  cloneStringLiteral(node) {
	    if (node.type === "Placeholder") {
	      return this.cloneIdentifier(node);
	    }
	    return super.cloneStringLiteral(node);
	  }
	  parseBindingAtom() {
	    return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
	  }
	  isValidLVal(type, isParenthesized, binding) {
	    return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
	  }
	  toAssignable(node, isLHS) {
	    if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
	      node.expectedNode = "Pattern";
	    } else {
	      super.toAssignable(node, isLHS);
	    }
	  }
	  chStartsBindingIdentifier(ch, pos) {
	    if (super.chStartsBindingIdentifier(ch, pos)) {
	      return true;
	    }
	    const nextToken = this.lookahead();
	    if (nextToken.type === 133) {
	      return true;
	    }
	    return false;
	  }
	  verifyBreakContinue(node, isBreak) {
	    if (node.label && node.label.type === "Placeholder") return;
	    super.verifyBreakContinue(node, isBreak);
	  }
	  parseExpressionStatement(node, expr) {
	    var _expr$extra;
	    if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
	      return super.parseExpressionStatement(node, expr);
	    }
	    if (this.match(14)) {
	      const stmt = node;
	      stmt.label = this.finishPlaceholder(expr, "Identifier");
	      this.next();
	      stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
	      return this.finishNode(stmt, "LabeledStatement");
	    }
	    this.semicolon();
	    const stmtPlaceholder = node;
	    stmtPlaceholder.name = expr.name;
	    return this.finishPlaceholder(stmtPlaceholder, "Statement");
	  }
	  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
	    return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
	  }
	  parseFunctionId(requireId) {
	    return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
	  }
	  parseClass(node, isStatement, optionalId) {
	    const type = isStatement ? "ClassDeclaration" : "ClassExpression";
	    this.next();
	    const oldStrict = this.state.strict;
	    const placeholder = this.parsePlaceholder("Identifier");
	    if (placeholder) {
	      if (this.match(81) || this.match(133) || this.match(5)) {
	        node.id = placeholder;
	      } else if (optionalId || !isStatement) {
	        node.id = null;
	        node.body = this.finishPlaceholder(placeholder, "ClassBody");
	        return this.finishNode(node, type);
	      } else {
	        throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
	      }
	    } else {
	      this.parseClassId(node, isStatement, optionalId);
	    }
	    super.parseClassSuper(node);
	    node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
	    return this.finishNode(node, type);
	  }
	  parseExport(node, decorators) {
	    const placeholder = this.parsePlaceholder("Identifier");
	    if (!placeholder) return super.parseExport(node, decorators);
	    const node2 = node;
	    if (!this.isContextual(98) && !this.match(12)) {
	      node2.specifiers = [];
	      node2.source = null;
	      node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
	      return this.finishNode(node2, "ExportNamedDeclaration");
	    }
	    this.expectPlugin("exportDefaultFrom");
	    const specifier = this.startNode();
	    specifier.exported = placeholder;
	    node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
	    return super.parseExport(node2, decorators);
	  }
	  isExportDefaultSpecifier() {
	    if (this.match(65)) {
	      const next = this.nextTokenStart();
	      if (this.isUnparsedContextual(next, "from")) {
	        if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {
	          return true;
	        }
	      }
	    }
	    return super.isExportDefaultSpecifier();
	  }
	  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
	    var _specifiers;
	    if ((_specifiers = node.specifiers) != null && _specifiers.length) {
	      return true;
	    }
	    return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
	  }
	  checkExport(node) {
	    const {
	      specifiers
	    } = node;
	    if (specifiers != null && specifiers.length) {
	      node.specifiers = specifiers.filter(node => node.exported.type === "Placeholder");
	    }
	    super.checkExport(node);
	    node.specifiers = specifiers;
	  }
	  parseImport(node) {
	    const placeholder = this.parsePlaceholder("Identifier");
	    if (!placeholder) return super.parseImport(node);
	    node.specifiers = [];
	    if (!this.isContextual(98) && !this.match(12)) {
	      node.source = this.finishPlaceholder(placeholder, "StringLiteral");
	      this.semicolon();
	      return this.finishNode(node, "ImportDeclaration");
	    }
	    const specifier = this.startNodeAtNode(placeholder);
	    specifier.local = placeholder;
	    node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
	    if (this.eat(12)) {
	      const hasStarImport = this.maybeParseStarImportSpecifier(node);
	      if (!hasStarImport) this.parseNamedImportSpecifiers(node);
	    }
	    this.expectContextual(98);
	    node.source = this.parseImportSource();
	    this.semicolon();
	    return this.finishNode(node, "ImportDeclaration");
	  }
	  parseImportSource() {
	    return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
	  }
	  assertNoSpace() {
	    if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {
	      this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
	    }
	  }
	};
	var v8intrinsic = superClass => class V8IntrinsicMixin extends superClass {
	  parseV8Intrinsic() {
	    if (this.match(54)) {
	      const v8IntrinsicStartLoc = this.state.startLoc;
	      const node = this.startNode();
	      this.next();
	      if (tokenIsIdentifier(this.state.type)) {
	        const name = this.parseIdentifierName();
	        const identifier = this.createIdentifier(node, name);
	        this.castNodeTo(identifier, "V8IntrinsicIdentifier");
	        if (this.match(10)) {
	          return identifier;
	        }
	      }
	      this.unexpected(v8IntrinsicStartLoc);
	    }
	  }
	  parseExprAtom(refExpressionErrors) {
	    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
	  }
	};
	const PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
	const TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
	function validatePlugins(pluginsMap) {
	  if (pluginsMap.has("decorators")) {
	    if (pluginsMap.has("decorators-legacy")) {
	      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
	    }
	    const decoratorsBeforeExport = pluginsMap.get("decorators").decoratorsBeforeExport;
	    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
	      throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
	    }
	    const allowCallParenthesized = pluginsMap.get("decorators").allowCallParenthesized;
	    if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
	      throw new Error("'allowCallParenthesized' must be a boolean.");
	    }
	  }
	  if (pluginsMap.has("flow") && pluginsMap.has("typescript")) {
	    throw new Error("Cannot combine flow and typescript plugins.");
	  }
	  if (pluginsMap.has("placeholders") && pluginsMap.has("v8intrinsic")) {
	    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
	  }
	  if (pluginsMap.has("pipelineOperator")) {
	    var _pluginsMap$get2;
	    const proposal = pluginsMap.get("pipelineOperator").proposal;
	    if (!PIPELINE_PROPOSALS.includes(proposal)) {
	      const proposalList = PIPELINE_PROPOSALS.map(p => `"${p}"`).join(", ");
	      throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
	    }
	    if (proposal === "hack") {
	      if (pluginsMap.has("placeholders")) {
	        throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
	      }
	      if (pluginsMap.has("v8intrinsic")) {
	        throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
	      }
	      const topicToken = pluginsMap.get("pipelineOperator").topicToken;
	      if (!TOPIC_TOKENS.includes(topicToken)) {
	        const tokenList = TOPIC_TOKENS.map(t => `"${t}"`).join(", ");
	        throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
	      }
	      {
	        var _pluginsMap$get;
	        if (topicToken === "#" && ((_pluginsMap$get = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get.syntaxType) === "hash") {
	          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
	        }
	      }
	    } else if (proposal === "smart" && ((_pluginsMap$get2 = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get2.syntaxType) === "hash") {
	      throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
	    }
	  }
	  if (pluginsMap.has("moduleAttributes")) {
	    {
	      if (pluginsMap.has("deprecatedImportAssert") || pluginsMap.has("importAssertions")) {
	        throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
	      }
	      const moduleAttributesVersionPluginOption = pluginsMap.get("moduleAttributes").version;
	      if (moduleAttributesVersionPluginOption !== "may-2020") {
	        throw new Error("The 'moduleAttributes' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is 'may-2020'.");
	      }
	    }
	  }
	  if (pluginsMap.has("importAssertions")) {
	    if (pluginsMap.has("deprecatedImportAssert")) {
	      throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
	    }
	  }
	  if (!pluginsMap.has("deprecatedImportAssert") && pluginsMap.has("importAttributes") && pluginsMap.get("importAttributes").deprecatedAssertSyntax) {
	    {
	      pluginsMap.set("deprecatedImportAssert", {});
	    }
	  }
	  if (pluginsMap.has("recordAndTuple")) {
	    {
	      const syntaxType = pluginsMap.get("recordAndTuple").syntaxType;
	      if (syntaxType != null) {
	        const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
	        if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {
	          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(", "));
	        }
	      }
	    }
	  }
	  if (pluginsMap.has("asyncDoExpressions") && !pluginsMap.has("doExpressions")) {
	    const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
	    error.missingPlugins = "doExpressions";
	    throw error;
	  }
	  if (pluginsMap.has("optionalChainingAssign") && pluginsMap.get("optionalChainingAssign").version !== "2023-07") {
	    throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is '2023-07'.");
	  }
	}
	const mixinPlugins = {
	  estree,
	  jsx,
	  flow,
	  typescript,
	  v8intrinsic,
	  placeholders
	};
	const mixinPluginNames = Object.keys(mixinPlugins);
	class ExpressionParser extends LValParser {
	  checkProto(prop, isRecord, sawProto, refExpressionErrors) {
	    if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
	      return sawProto;
	    }
	    const key = prop.key;
	    const name = key.type === "Identifier" ? key.name : key.value;
	    if (name === "__proto__") {
	      if (isRecord) {
	        this.raise(Errors.RecordNoProto, key);
	        return true;
	      }
	      if (sawProto) {
	        if (refExpressionErrors) {
	          if (refExpressionErrors.doubleProtoLoc === null) {
	            refExpressionErrors.doubleProtoLoc = key.loc.start;
	          }
	        } else {
	          this.raise(Errors.DuplicateProto, key);
	        }
	      }
	      return true;
	    }
	    return sawProto;
	  }
	  shouldExitDescending(expr, potentialArrowAt) {
	    return expr.type === "ArrowFunctionExpression" && this.offsetToSourcePos(expr.start) === potentialArrowAt;
	  }
	  getExpression() {
	    this.enterInitialScopes();
	    this.nextToken();
	    if (this.match(140)) {
	      throw this.raise(Errors.ParseExpressionEmptyInput, this.state.startLoc);
	    }
	    const expr = this.parseExpression();
	    if (!this.match(140)) {
	      throw this.raise(Errors.ParseExpressionExpectsEOF, this.state.startLoc, {
	        unexpected: this.input.codePointAt(this.state.start)
	      });
	    }
	    this.finalizeRemainingComments();
	    expr.comments = this.comments;
	    expr.errors = this.state.errors;
	    if (this.optionFlags & 256) {
	      expr.tokens = this.tokens;
	    }
	    return expr;
	  }
	  parseExpression(disallowIn, refExpressionErrors) {
	    if (disallowIn) {
	      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
	    }
	    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
	  }
	  parseExpressionBase(refExpressionErrors) {
	    const startLoc = this.state.startLoc;
	    const expr = this.parseMaybeAssign(refExpressionErrors);
	    if (this.match(12)) {
	      const node = this.startNodeAt(startLoc);
	      node.expressions = [expr];
	      while (this.eat(12)) {
	        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
	      }
	      this.toReferencedList(node.expressions);
	      return this.finishNode(node, "SequenceExpression");
	    }
	    return expr;
	  }
	  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
	    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
	  }
	  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
	    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
	  }
	  setOptionalParametersError(refExpressionErrors) {
	    refExpressionErrors.optionalParametersLoc = this.state.startLoc;
	  }
	  parseMaybeAssign(refExpressionErrors, afterLeftParse) {
	    const startLoc = this.state.startLoc;
	    const isYield = this.isContextual(108);
	    if (isYield) {
	      if (this.prodParam.hasYield) {
	        this.next();
	        let left = this.parseYield(startLoc);
	        if (afterLeftParse) {
	          left = afterLeftParse.call(this, left, startLoc);
	        }
	        return left;
	      }
	    }
	    let ownExpressionErrors;
	    if (refExpressionErrors) {
	      ownExpressionErrors = false;
	    } else {
	      refExpressionErrors = new ExpressionErrors();
	      ownExpressionErrors = true;
	    }
	    const {
	      type
	    } = this.state;
	    if (type === 10 || tokenIsIdentifier(type)) {
	      this.state.potentialArrowAt = this.state.start;
	    }
	    let left = this.parseMaybeConditional(refExpressionErrors);
	    if (afterLeftParse) {
	      left = afterLeftParse.call(this, left, startLoc);
	    }
	    if (tokenIsAssignment(this.state.type)) {
	      const node = this.startNodeAt(startLoc);
	      const operator = this.state.value;
	      node.operator = operator;
	      if (this.match(29)) {
	        this.toAssignable(left, true);
	        node.left = left;
	        const startIndex = startLoc.index;
	        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
	          refExpressionErrors.doubleProtoLoc = null;
	        }
	        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
	          refExpressionErrors.shorthandAssignLoc = null;
	        }
	        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
	          this.checkDestructuringPrivate(refExpressionErrors);
	          refExpressionErrors.privateKeyLoc = null;
	        }
	      } else {
	        node.left = left;
	      }
	      this.next();
	      node.right = this.parseMaybeAssign();
	      this.checkLVal(left, this.finishNode(node, "AssignmentExpression"));
	      return node;
	    } else if (ownExpressionErrors) {
	      this.checkExpressionErrors(refExpressionErrors, true);
	    }
	    if (isYield) {
	      const {
	        type
	      } = this.state;
	      const startsExpr = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
	      if (startsExpr && !this.isAmbiguousPrefixOrIdentifier()) {
	        this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc);
	        return this.parseYield(startLoc);
	      }
	    }
	    return left;
	  }
	  parseMaybeConditional(refExpressionErrors) {
	    const startLoc = this.state.startLoc;
	    const potentialArrowAt = this.state.potentialArrowAt;
	    const expr = this.parseExprOps(refExpressionErrors);
	    if (this.shouldExitDescending(expr, potentialArrowAt)) {
	      return expr;
	    }
	    return this.parseConditional(expr, startLoc, refExpressionErrors);
	  }
	  parseConditional(expr, startLoc, refExpressionErrors) {
	    if (this.eat(17)) {
	      const node = this.startNodeAt(startLoc);
	      node.test = expr;
	      node.consequent = this.parseMaybeAssignAllowIn();
	      this.expect(14);
	      node.alternate = this.parseMaybeAssign();
	      return this.finishNode(node, "ConditionalExpression");
	    }
	    return expr;
	  }
	  parseMaybeUnaryOrPrivate(refExpressionErrors) {
	    return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
	  }
	  parseExprOps(refExpressionErrors) {
	    const startLoc = this.state.startLoc;
	    const potentialArrowAt = this.state.potentialArrowAt;
	    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
	    if (this.shouldExitDescending(expr, potentialArrowAt)) {
	      return expr;
	    }
	    return this.parseExprOp(expr, startLoc, -1);
	  }
	  parseExprOp(left, leftStartLoc, minPrec) {
	    if (this.isPrivateName(left)) {
	      const value = this.getPrivateNameSV(left);
	      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
	        this.raise(Errors.PrivateInExpectedIn, left, {
	          identifierName: value
	        });
	      }
	      this.classScope.usePrivateName(value, left.loc.start);
	    }
	    const op = this.state.type;
	    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
	      let prec = tokenOperatorPrecedence(op);
	      if (prec > minPrec) {
	        if (op === 39) {
	          this.expectPlugin("pipelineOperator");
	          if (this.state.inFSharpPipelineDirectBody) {
	            return left;
	          }
	          this.checkPipelineAtInfixOperator(left, leftStartLoc);
	        }
	        const node = this.startNodeAt(leftStartLoc);
	        node.left = left;
	        node.operator = this.state.value;
	        const logical = op === 41 || op === 42;
	        const coalesce = op === 40;
	        if (coalesce) {
	          prec = tokenOperatorPrecedence(42);
	        }
	        this.next();
	        if (op === 39 && this.hasPlugin(["pipelineOperator", {
	          proposal: "minimal"
	        }])) {
	          if (this.state.type === 96 && this.prodParam.hasAwait) {
	            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
	          }
	        }
	        node.right = this.parseExprOpRightExpr(op, prec);
	        const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
	        const nextOp = this.state.type;
	        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
	          throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
	        }
	        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
	      }
	    }
	    return left;
	  }
	  parseExprOpRightExpr(op, prec) {
	    const startLoc = this.state.startLoc;
	    switch (op) {
	      case 39:
	        switch (this.getPluginOption("pipelineOperator", "proposal")) {
	          case "hack":
	            return this.withTopicBindingContext(() => {
	              return this.parseHackPipeBody();
	            });
	          case "fsharp":
	            return this.withSoloAwaitPermittingContext(() => {
	              return this.parseFSharpPipelineBody(prec);
	            });
	        }
	        if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
	          return this.withTopicBindingContext(() => {
	            if (this.prodParam.hasYield && this.isContextual(108)) {
	              throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);
	            }
	            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
	          });
	        }
	      default:
	        return this.parseExprOpBaseRightExpr(op, prec);
	    }
	  }
	  parseExprOpBaseRightExpr(op, prec) {
	    const startLoc = this.state.startLoc;
	    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
	  }
	  parseHackPipeBody() {
	    var _body$extra;
	    const {
	      startLoc
	    } = this.state;
	    const body = this.parseMaybeAssign();
	    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
	    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
	      this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
	        type: body.type
	      });
	    }
	    if (!this.topicReferenceWasUsedInCurrentContext()) {
	      this.raise(Errors.PipeTopicUnused, startLoc);
	    }
	    return body;
	  }
	  checkExponentialAfterUnary(node) {
	    if (this.match(57)) {
	      this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
	    }
	  }
	  parseMaybeUnary(refExpressionErrors, sawUnary) {
	    const startLoc = this.state.startLoc;
	    const isAwait = this.isContextual(96);
	    if (isAwait && this.recordAwaitIfAllowed()) {
	      this.next();
	      const expr = this.parseAwait(startLoc);
	      if (!sawUnary) this.checkExponentialAfterUnary(expr);
	      return expr;
	    }
	    const update = this.match(34);
	    const node = this.startNode();
	    if (tokenIsPrefix(this.state.type)) {
	      node.operator = this.state.value;
	      node.prefix = true;
	      if (this.match(72)) {
	        this.expectPlugin("throwExpressions");
	      }
	      const isDelete = this.match(89);
	      this.next();
	      node.argument = this.parseMaybeUnary(null, true);
	      this.checkExpressionErrors(refExpressionErrors, true);
	      if (this.state.strict && isDelete) {
	        const arg = node.argument;
	        if (arg.type === "Identifier") {
	          this.raise(Errors.StrictDelete, node);
	        } else if (this.hasPropertyAsPrivateName(arg)) {
	          this.raise(Errors.DeletePrivateField, node);
	        }
	      }
	      if (!update) {
	        if (!sawUnary) {
	          this.checkExponentialAfterUnary(node);
	        }
	        return this.finishNode(node, "UnaryExpression");
	      }
	    }
	    const expr = this.parseUpdate(node, update, refExpressionErrors);
	    if (isAwait) {
	      const {
	        type
	      } = this.state;
	      const startsExpr = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
	      if (startsExpr && !this.isAmbiguousPrefixOrIdentifier()) {
	        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
	        return this.parseAwait(startLoc);
	      }
	    }
	    return expr;
	  }
	  parseUpdate(node, update, refExpressionErrors) {
	    if (update) {
	      const updateExpressionNode = node;
	      this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, "UpdateExpression"));
	      return node;
	    }
	    const startLoc = this.state.startLoc;
	    let expr = this.parseExprSubscripts(refExpressionErrors);
	    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
	    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
	      const node = this.startNodeAt(startLoc);
	      node.operator = this.state.value;
	      node.prefix = false;
	      node.argument = expr;
	      this.next();
	      this.checkLVal(expr, expr = this.finishNode(node, "UpdateExpression"));
	    }
	    return expr;
	  }
	  parseExprSubscripts(refExpressionErrors) {
	    const startLoc = this.state.startLoc;
	    const potentialArrowAt = this.state.potentialArrowAt;
	    const expr = this.parseExprAtom(refExpressionErrors);
	    if (this.shouldExitDescending(expr, potentialArrowAt)) {
	      return expr;
	    }
	    return this.parseSubscripts(expr, startLoc);
	  }
	  parseSubscripts(base, startLoc, noCalls) {
	    const state = {
	      optionalChainMember: false,
	      maybeAsyncArrow: this.atPossibleAsyncArrow(base),
	      stop: false
	    };
	    do {
	      base = this.parseSubscript(base, startLoc, noCalls, state);
	      state.maybeAsyncArrow = false;
	    } while (!state.stop);
	    return base;
	  }
	  parseSubscript(base, startLoc, noCalls, state) {
	    const {
	      type
	    } = this.state;
	    if (!noCalls && type === 15) {
	      return this.parseBind(base, startLoc, noCalls, state);
	    } else if (tokenIsTemplate(type)) {
	      return this.parseTaggedTemplateExpression(base, startLoc, state);
	    }
	    let optional = false;
	    if (type === 18) {
	      if (noCalls) {
	        this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
	        if (this.lookaheadCharCode() === 40) {
	          return this.stopParseSubscript(base, state);
	        }
	      }
	      state.optionalChainMember = optional = true;
	      this.next();
	    }
	    if (!noCalls && this.match(10)) {
	      return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
	    } else {
	      const computed = this.eat(0);
	      if (computed || optional || this.eat(16)) {
	        return this.parseMember(base, startLoc, state, computed, optional);
	      } else {
	        return this.stopParseSubscript(base, state);
	      }
	    }
	  }
	  stopParseSubscript(base, state) {
	    state.stop = true;
	    return base;
	  }
	  parseMember(base, startLoc, state, computed, optional) {
	    const node = this.startNodeAt(startLoc);
	    node.object = base;
	    node.computed = computed;
	    if (computed) {
	      node.property = this.parseExpression();
	      this.expect(3);
	    } else if (this.match(139)) {
	      if (base.type === "Super") {
	        this.raise(Errors.SuperPrivateField, startLoc);
	      }
	      this.classScope.usePrivateName(this.state.value, this.state.startLoc);
	      node.property = this.parsePrivateName();
	    } else {
	      node.property = this.parseIdentifier(true);
	    }
	    if (state.optionalChainMember) {
	      node.optional = optional;
	      return this.finishNode(node, "OptionalMemberExpression");
	    } else {
	      return this.finishNode(node, "MemberExpression");
	    }
	  }
	  parseBind(base, startLoc, noCalls, state) {
	    const node = this.startNodeAt(startLoc);
	    node.object = base;
	    this.next();
	    node.callee = this.parseNoCallExpr();
	    state.stop = true;
	    return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
	  }
	  parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
	    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	    let refExpressionErrors = null;
	    this.state.maybeInArrowParameters = true;
	    this.next();
	    const node = this.startNodeAt(startLoc);
	    node.callee = base;
	    const {
	      maybeAsyncArrow,
	      optionalChainMember
	    } = state;
	    if (maybeAsyncArrow) {
	      this.expressionScope.enter(newAsyncArrowScope());
	      refExpressionErrors = new ExpressionErrors();
	    }
	    if (optionalChainMember) {
	      node.optional = optional;
	    }
	    if (optional) {
	      node.arguments = this.parseCallExpressionArguments(11);
	    } else {
	      node.arguments = this.parseCallExpressionArguments(11, base.type !== "Super", node, refExpressionErrors);
	    }
	    let finishedNode = this.finishCallExpression(node, optionalChainMember);
	    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
	      state.stop = true;
	      this.checkDestructuringPrivate(refExpressionErrors);
	      this.expressionScope.validateAsPattern();
	      this.expressionScope.exit();
	      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
	    } else {
	      if (maybeAsyncArrow) {
	        this.checkExpressionErrors(refExpressionErrors, true);
	        this.expressionScope.exit();
	      }
	      this.toReferencedArguments(finishedNode);
	    }
	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    return finishedNode;
	  }
	  toReferencedArguments(node, isParenthesizedExpr) {
	    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
	  }
	  parseTaggedTemplateExpression(base, startLoc, state) {
	    const node = this.startNodeAt(startLoc);
	    node.tag = base;
	    node.quasi = this.parseTemplate(true);
	    if (state.optionalChainMember) {
	      this.raise(Errors.OptionalChainingNoTemplate, startLoc);
	    }
	    return this.finishNode(node, "TaggedTemplateExpression");
	  }
	  atPossibleAsyncArrow(base) {
	    return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;
	  }
	  finishCallExpression(node, optional) {
	    if (node.callee.type === "Import") {
	      if (node.arguments.length === 0 || node.arguments.length > 2) {
	        this.raise(Errors.ImportCallArity, node);
	      } else {
	        for (const arg of node.arguments) {
	          if (arg.type === "SpreadElement") {
	            this.raise(Errors.ImportCallSpreadArgument, arg);
	          }
	        }
	      }
	    }
	    return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
	  }
	  parseCallExpressionArguments(close, allowPlaceholder, nodeForExtra, refExpressionErrors) {
	    const elts = [];
	    let first = true;
	    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
	    this.state.inFSharpPipelineDirectBody = false;
	    while (!this.eat(close)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12);
	        if (this.match(close)) {
	          if (nodeForExtra) {
	            this.addTrailingCommaExtraToNode(nodeForExtra);
	          }
	          this.next();
	          break;
	        }
	      }
	      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
	    }
	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
	    return elts;
	  }
	  shouldParseAsyncArrow() {
	    return this.match(19) && !this.canInsertSemicolon();
	  }
	  parseAsyncArrowFromCallExpression(node, call) {
	    var _call$extra;
	    this.resetPreviousNodeTrailingComments(call);
	    this.expect(19);
	    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
	    if (call.innerComments) {
	      setInnerComments(node, call.innerComments);
	    }
	    if (call.callee.trailingComments) {
	      setInnerComments(node, call.callee.trailingComments);
	    }
	    return node;
	  }
	  parseNoCallExpr() {
	    const startLoc = this.state.startLoc;
	    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
	  }
	  parseExprAtom(refExpressionErrors) {
	    let node;
	    let decorators = null;
	    const {
	      type
	    } = this.state;
	    switch (type) {
	      case 79:
	        return this.parseSuper();
	      case 83:
	        node = this.startNode();
	        this.next();
	        if (this.match(16)) {
	          return this.parseImportMetaPropertyOrPhaseCall(node);
	        }
	        if (this.match(10)) {
	          if (this.optionFlags & 512) {
	            return this.parseImportCall(node);
	          } else {
	            return this.finishNode(node, "Import");
	          }
	        } else {
	          this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
	          return this.finishNode(node, "Import");
	        }
	      case 78:
	        node = this.startNode();
	        this.next();
	        return this.finishNode(node, "ThisExpression");
	      case 90:
	        {
	          return this.parseDo(this.startNode(), false);
	        }
	      case 56:
	      case 31:
	        {
	          this.readRegexp();
	          return this.parseRegExpLiteral(this.state.value);
	        }
	      case 135:
	        return this.parseNumericLiteral(this.state.value);
	      case 136:
	        return this.parseBigIntLiteral(this.state.value);
	      case 134:
	        return this.parseStringLiteral(this.state.value);
	      case 84:
	        return this.parseNullLiteral();
	      case 85:
	        return this.parseBooleanLiteral(true);
	      case 86:
	        return this.parseBooleanLiteral(false);
	      case 10:
	        {
	          const canBeArrow = this.state.potentialArrowAt === this.state.start;
	          return this.parseParenAndDistinguishExpression(canBeArrow);
	        }
	      case 0:
	        {
	          return this.parseArrayLike(3, true, false, refExpressionErrors);
	        }
	      case 5:
	        {
	          return this.parseObjectLike(8, false, false, refExpressionErrors);
	        }
	      case 68:
	        return this.parseFunctionOrFunctionSent();
	      case 26:
	        decorators = this.parseDecorators();
	      case 80:
	        return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
	      case 77:
	        return this.parseNewOrNewTarget();
	      case 25:
	      case 24:
	        return this.parseTemplate(false);
	      case 15:
	        {
	          node = this.startNode();
	          this.next();
	          node.object = null;
	          const callee = node.callee = this.parseNoCallExpr();
	          if (callee.type === "MemberExpression") {
	            return this.finishNode(node, "BindExpression");
	          } else {
	            throw this.raise(Errors.UnsupportedBind, callee);
	          }
	        }
	      case 139:
	        {
	          this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
	            identifierName: this.state.value
	          });
	          return this.parsePrivateName();
	        }
	      case 33:
	        {
	          return this.parseTopicReferenceThenEqualsSign(54, "%");
	        }
	      case 32:
	        {
	          return this.parseTopicReferenceThenEqualsSign(44, "^");
	        }
	      case 37:
	      case 38:
	        {
	          return this.parseTopicReference("hack");
	        }
	      case 44:
	      case 54:
	      case 27:
	        {
	          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
	          if (pipeProposal) {
	            return this.parseTopicReference(pipeProposal);
	          }
	          this.unexpected();
	          break;
	        }
	      case 47:
	        {
	          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
	          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
	            this.expectOnePlugin(["jsx", "flow", "typescript"]);
	          } else {
	            this.unexpected();
	          }
	          break;
	        }
	      default:
	        {
	          if (type === 137) {
	            return this.parseDecimalLiteral(this.state.value);
	          } else if (type === 2 || type === 1) {
	            return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
	          } else if (type === 6 || type === 7) {
	            return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
	          }
	        }
	        if (tokenIsIdentifier(type)) {
	          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
	            return this.parseModuleExpression();
	          }
	          const canBeArrow = this.state.potentialArrowAt === this.state.start;
	          const containsEsc = this.state.containsEsc;
	          const id = this.parseIdentifier();
	          if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
	            const {
	              type
	            } = this.state;
	            if (type === 68) {
	              this.resetPreviousNodeTrailingComments(id);
	              this.next();
	              return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
	            } else if (tokenIsIdentifier(type)) {
	              if (this.lookaheadCharCode() === 61) {
	                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
	              } else {
	                return id;
	              }
	            } else if (type === 90) {
	              this.resetPreviousNodeTrailingComments(id);
	              return this.parseDo(this.startNodeAtNode(id), true);
	            }
	          }
	          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
	            this.next();
	            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
	          }
	          return id;
	        } else {
	          this.unexpected();
	        }
	    }
	  }
	  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
	    const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
	    if (pipeProposal) {
	      this.state.type = topicTokenType;
	      this.state.value = topicTokenValue;
	      this.state.pos--;
	      this.state.end--;
	      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
	      return this.parseTopicReference(pipeProposal);
	    } else {
	      this.unexpected();
	    }
	  }
	  parseTopicReference(pipeProposal) {
	    const node = this.startNode();
	    const startLoc = this.state.startLoc;
	    const tokenType = this.state.type;
	    this.next();
	    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
	  }
	  finishTopicReference(node, startLoc, pipeProposal, tokenType) {
	    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
	      if (pipeProposal === "hack") {
	        if (!this.topicReferenceIsAllowedInCurrentContext()) {
	          this.raise(Errors.PipeTopicUnbound, startLoc);
	        }
	        this.registerTopicReference();
	        return this.finishNode(node, "TopicReference");
	      } else {
	        if (!this.topicReferenceIsAllowedInCurrentContext()) {
	          this.raise(Errors.PrimaryTopicNotAllowed, startLoc);
	        }
	        this.registerTopicReference();
	        return this.finishNode(node, "PipelinePrimaryTopicReference");
	      }
	    } else {
	      throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
	        token: tokenLabelName(tokenType)
	      });
	    }
	  }
	  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
	    switch (pipeProposal) {
	      case "hack":
	        {
	          return this.hasPlugin(["pipelineOperator", {
	            topicToken: tokenLabelName(tokenType)
	          }]);
	        }
	      case "smart":
	        return tokenType === 27;
	      default:
	        throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
	    }
	  }
	  parseAsyncArrowUnaryFunction(node) {
	    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
	    const params = [this.parseIdentifier()];
	    this.prodParam.exit();
	    if (this.hasPrecedingLineBreak()) {
	      this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
	    }
	    this.expect(19);
	    return this.parseArrowExpression(node, params, true);
	  }
	  parseDo(node, isAsync) {
	    this.expectPlugin("doExpressions");
	    if (isAsync) {
	      this.expectPlugin("asyncDoExpressions");
	    }
	    node.async = isAsync;
	    this.next();
	    const oldLabels = this.state.labels;
	    this.state.labels = [];
	    if (isAsync) {
	      this.prodParam.enter(2);
	      node.body = this.parseBlock();
	      this.prodParam.exit();
	    } else {
	      node.body = this.parseBlock();
	    }
	    this.state.labels = oldLabels;
	    return this.finishNode(node, "DoExpression");
	  }
	  parseSuper() {
	    const node = this.startNode();
	    this.next();
	    if (this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16)) {
	      this.raise(Errors.SuperNotAllowed, node);
	    } else if (!this.scope.allowSuper && !(this.optionFlags & 16)) {
	      this.raise(Errors.UnexpectedSuper, node);
	    }
	    if (!this.match(10) && !this.match(0) && !this.match(16)) {
	      this.raise(Errors.UnsupportedSuper, node);
	    }
	    return this.finishNode(node, "Super");
	  }
	  parsePrivateName() {
	    const node = this.startNode();
	    const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
	    const name = this.state.value;
	    this.next();
	    node.id = this.createIdentifier(id, name);
	    return this.finishNode(node, "PrivateName");
	  }
	  parseFunctionOrFunctionSent() {
	    const node = this.startNode();
	    this.next();
	    if (this.prodParam.hasYield && this.match(16)) {
	      const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
	      this.next();
	      if (this.match(103)) {
	        this.expectPlugin("functionSent");
	      } else if (!this.hasPlugin("functionSent")) {
	        this.unexpected();
	      }
	      return this.parseMetaProperty(node, meta, "sent");
	    }
	    return this.parseFunction(node);
	  }
	  parseMetaProperty(node, meta, propertyName) {
	    node.meta = meta;
	    const containsEsc = this.state.containsEsc;
	    node.property = this.parseIdentifier(true);
	    if (node.property.name !== propertyName || containsEsc) {
	      this.raise(Errors.UnsupportedMetaProperty, node.property, {
	        target: meta.name,
	        onlyValidPropertyName: propertyName
	      });
	    }
	    return this.finishNode(node, "MetaProperty");
	  }
	  parseImportMetaPropertyOrPhaseCall(node) {
	    this.next();
	    if (this.isContextual(105) || this.isContextual(97)) {
	      const isSource = this.isContextual(105);
	      this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
	      this.next();
	      node.phase = isSource ? "source" : "defer";
	      return this.parseImportCall(node);
	    } else {
	      const id = this.createIdentifierAt(this.startNodeAtNode(node), "import", this.state.lastTokStartLoc);
	      if (this.isContextual(101)) {
	        if (!this.inModule) {
	          this.raise(Errors.ImportMetaOutsideModule, id);
	        }
	        this.sawUnambiguousESM = true;
	      }
	      return this.parseMetaProperty(node, id, "meta");
	    }
	  }
	  parseLiteralAtNode(value, type, node) {
	    this.addExtra(node, "rawValue", value);
	    this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
	    node.value = value;
	    this.next();
	    return this.finishNode(node, type);
	  }
	  parseLiteral(value, type) {
	    const node = this.startNode();
	    return this.parseLiteralAtNode(value, type, node);
	  }
	  parseStringLiteral(value) {
	    return this.parseLiteral(value, "StringLiteral");
	  }
	  parseNumericLiteral(value) {
	    return this.parseLiteral(value, "NumericLiteral");
	  }
	  parseBigIntLiteral(value) {
	    return this.parseLiteral(value, "BigIntLiteral");
	  }
	  parseDecimalLiteral(value) {
	    return this.parseLiteral(value, "DecimalLiteral");
	  }
	  parseRegExpLiteral(value) {
	    const node = this.startNode();
	    this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
	    node.pattern = value.pattern;
	    node.flags = value.flags;
	    this.next();
	    return this.finishNode(node, "RegExpLiteral");
	  }
	  parseBooleanLiteral(value) {
	    const node = this.startNode();
	    node.value = value;
	    this.next();
	    return this.finishNode(node, "BooleanLiteral");
	  }
	  parseNullLiteral() {
	    const node = this.startNode();
	    this.next();
	    return this.finishNode(node, "NullLiteral");
	  }
	  parseParenAndDistinguishExpression(canBeArrow) {
	    const startLoc = this.state.startLoc;
	    let val;
	    this.next();
	    this.expressionScope.enter(newArrowHeadScope());
	    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
	    this.state.maybeInArrowParameters = true;
	    this.state.inFSharpPipelineDirectBody = false;
	    const innerStartLoc = this.state.startLoc;
	    const exprList = [];
	    const refExpressionErrors = new ExpressionErrors();
	    let first = true;
	    let spreadStartLoc;
	    let optionalCommaStartLoc;
	    while (!this.match(11)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
	        if (this.match(11)) {
	          optionalCommaStartLoc = this.state.startLoc;
	          break;
	        }
	      }
	      if (this.match(21)) {
	        const spreadNodeStartLoc = this.state.startLoc;
	        spreadStartLoc = this.state.startLoc;
	        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
	        if (!this.checkCommaAfterRest(41)) {
	          break;
	        }
	      } else {
	        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
	      }
	    }
	    const innerEndLoc = this.state.lastTokEndLoc;
	    this.expect(11);
	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
	    let arrowNode = this.startNodeAt(startLoc);
	    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
	      this.checkDestructuringPrivate(refExpressionErrors);
	      this.expressionScope.validateAsPattern();
	      this.expressionScope.exit();
	      this.parseArrowExpression(arrowNode, exprList, false);
	      return arrowNode;
	    }
	    this.expressionScope.exit();
	    if (!exprList.length) {
	      this.unexpected(this.state.lastTokStartLoc);
	    }
	    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
	    if (spreadStartLoc) this.unexpected(spreadStartLoc);
	    this.checkExpressionErrors(refExpressionErrors, true);
	    this.toReferencedListDeep(exprList, true);
	    if (exprList.length > 1) {
	      val = this.startNodeAt(innerStartLoc);
	      val.expressions = exprList;
	      this.finishNode(val, "SequenceExpression");
	      this.resetEndLocation(val, innerEndLoc);
	    } else {
	      val = exprList[0];
	    }
	    return this.wrapParenthesis(startLoc, val);
	  }
	  wrapParenthesis(startLoc, expression) {
	    if (!(this.optionFlags & 1024)) {
	      this.addExtra(expression, "parenthesized", true);
	      this.addExtra(expression, "parenStart", startLoc.index);
	      this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
	      return expression;
	    }
	    const parenExpression = this.startNodeAt(startLoc);
	    parenExpression.expression = expression;
	    return this.finishNode(parenExpression, "ParenthesizedExpression");
	  }
	  shouldParseArrow(params) {
	    return !this.canInsertSemicolon();
	  }
	  parseArrow(node) {
	    if (this.eat(19)) {
	      return node;
	    }
	  }
	  parseParenItem(node, startLoc) {
	    return node;
	  }
	  parseNewOrNewTarget() {
	    const node = this.startNode();
	    this.next();
	    if (this.match(16)) {
	      const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
	      this.next();
	      const metaProp = this.parseMetaProperty(node, meta, "target");
	      if (!this.scope.inNonArrowFunction && !this.scope.inClass && !(this.optionFlags & 4)) {
	        this.raise(Errors.UnexpectedNewTarget, metaProp);
	      }
	      return metaProp;
	    }
	    return this.parseNew(node);
	  }
	  parseNew(node) {
	    this.parseNewCallee(node);
	    if (this.eat(10)) {
	      const args = this.parseExprList(11);
	      this.toReferencedList(args);
	      node.arguments = args;
	    } else {
	      node.arguments = [];
	    }
	    return this.finishNode(node, "NewExpression");
	  }
	  parseNewCallee(node) {
	    const isImport = this.match(83);
	    const callee = this.parseNoCallExpr();
	    node.callee = callee;
	    if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
	      this.raise(Errors.ImportCallNotNewExpression, callee);
	    }
	  }
	  parseTemplateElement(isTagged) {
	    const {
	      start,
	      startLoc,
	      end,
	      value
	    } = this.state;
	    const elemStart = start + 1;
	    const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
	    if (value === null) {
	      if (!isTagged) {
	        this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
	      }
	    }
	    const isTail = this.match(24);
	    const endOffset = isTail ? -1 : -2;
	    const elemEnd = end + endOffset;
	    elem.value = {
	      raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
	      cooked: value === null ? null : value.slice(1, endOffset)
	    };
	    elem.tail = isTail;
	    this.next();
	    const finishedNode = this.finishNode(elem, "TemplateElement");
	    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
	    return finishedNode;
	  }
	  parseTemplate(isTagged) {
	    const node = this.startNode();
	    let curElt = this.parseTemplateElement(isTagged);
	    const quasis = [curElt];
	    const substitutions = [];
	    while (!curElt.tail) {
	      substitutions.push(this.parseTemplateSubstitution());
	      this.readTemplateContinuation();
	      quasis.push(curElt = this.parseTemplateElement(isTagged));
	    }
	    node.expressions = substitutions;
	    node.quasis = quasis;
	    return this.finishNode(node, "TemplateLiteral");
	  }
	  parseTemplateSubstitution() {
	    return this.parseExpression();
	  }
	  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
	    if (isRecord) {
	      this.expectPlugin("recordAndTuple");
	    }
	    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
	    this.state.inFSharpPipelineDirectBody = false;
	    let sawProto = false;
	    let first = true;
	    const node = this.startNode();
	    node.properties = [];
	    this.next();
	    while (!this.match(close)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12);
	        if (this.match(close)) {
	          this.addTrailingCommaExtraToNode(node);
	          break;
	        }
	      }
	      let prop;
	      if (isPattern) {
	        prop = this.parseBindingProperty();
	      } else {
	        prop = this.parsePropertyDefinition(refExpressionErrors);
	        sawProto = this.checkProto(prop, isRecord, sawProto, refExpressionErrors);
	      }
	      if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
	        this.raise(Errors.InvalidRecordProperty, prop);
	      }
	      {
	        if (prop.shorthand) {
	          this.addExtra(prop, "shorthand", true);
	        }
	      }
	      node.properties.push(prop);
	    }
	    this.next();
	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
	    let type = "ObjectExpression";
	    if (isPattern) {
	      type = "ObjectPattern";
	    } else if (isRecord) {
	      type = "RecordExpression";
	    }
	    return this.finishNode(node, type);
	  }
	  addTrailingCommaExtraToNode(node) {
	    this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index);
	    this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
	  }
	  maybeAsyncOrAccessorProp(prop) {
	    return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
	  }
	  parsePropertyDefinition(refExpressionErrors) {
	    let decorators = [];
	    if (this.match(26)) {
	      if (this.hasPlugin("decorators")) {
	        this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
	      }
	      while (this.match(26)) {
	        decorators.push(this.parseDecorator());
	      }
	    }
	    const prop = this.startNode();
	    let isAsync = false;
	    let isAccessor = false;
	    let startLoc;
	    if (this.match(21)) {
	      if (decorators.length) this.unexpected();
	      return this.parseSpread();
	    }
	    if (decorators.length) {
	      prop.decorators = decorators;
	      decorators = [];
	    }
	    prop.method = false;
	    if (refExpressionErrors) {
	      startLoc = this.state.startLoc;
	    }
	    let isGenerator = this.eat(55);
	    this.parsePropertyNamePrefixOperator(prop);
	    const containsEsc = this.state.containsEsc;
	    this.parsePropertyName(prop, refExpressionErrors);
	    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
	      const {
	        key
	      } = prop;
	      const keyName = key.name;
	      if (keyName === "async" && !this.hasPrecedingLineBreak()) {
	        isAsync = true;
	        this.resetPreviousNodeTrailingComments(key);
	        isGenerator = this.eat(55);
	        this.parsePropertyName(prop);
	      }
	      if (keyName === "get" || keyName === "set") {
	        isAccessor = true;
	        this.resetPreviousNodeTrailingComments(key);
	        prop.kind = keyName;
	        if (this.match(55)) {
	          isGenerator = true;
	          this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
	            kind: keyName
	          });
	          this.next();
	        }
	        this.parsePropertyName(prop);
	      }
	    }
	    return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
	  }
	  getGetterSetterExpectedParamCount(method) {
	    return method.kind === "get" ? 0 : 1;
	  }
	  getObjectOrClassMethodParams(method) {
	    return method.params;
	  }
	  checkGetterSetterParams(method) {
	    var _params;
	    const paramCount = this.getGetterSetterExpectedParamCount(method);
	    const params = this.getObjectOrClassMethodParams(method);
	    if (params.length !== paramCount) {
	      this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);
	    }
	    if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
	      this.raise(Errors.BadSetterRestParameter, method);
	    }
	  }
	  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
	    if (isAccessor) {
	      const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
	      this.checkGetterSetterParams(finishedProp);
	      return finishedProp;
	    }
	    if (isAsync || isGenerator || this.match(10)) {
	      if (isPattern) this.unexpected();
	      prop.kind = "method";
	      prop.method = true;
	      return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
	    }
	  }
	  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
	    prop.shorthand = false;
	    if (this.eat(14)) {
	      prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
	      return this.finishObjectProperty(prop);
	    }
	    if (!prop.computed && prop.key.type === "Identifier") {
	      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
	      if (isPattern) {
	        prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
	      } else if (this.match(29)) {
	        const shorthandAssignLoc = this.state.startLoc;
	        if (refExpressionErrors != null) {
	          if (refExpressionErrors.shorthandAssignLoc === null) {
	            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
	          }
	        } else {
	          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
	        }
	        prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
	      } else {
	        prop.value = this.cloneIdentifier(prop.key);
	      }
	      prop.shorthand = true;
	      return this.finishObjectProperty(prop);
	    }
	  }
	  finishObjectProperty(node) {
	    return this.finishNode(node, "ObjectProperty");
	  }
	  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
	    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
	    if (!node) this.unexpected();
	    return node;
	  }
	  parsePropertyName(prop, refExpressionErrors) {
	    if (this.eat(0)) {
	      prop.computed = true;
	      prop.key = this.parseMaybeAssignAllowIn();
	      this.expect(3);
	    } else {
	      const {
	        type,
	        value
	      } = this.state;
	      let key;
	      if (tokenIsKeywordOrIdentifier(type)) {
	        key = this.parseIdentifier(true);
	      } else {
	        switch (type) {
	          case 135:
	            key = this.parseNumericLiteral(value);
	            break;
	          case 134:
	            key = this.parseStringLiteral(value);
	            break;
	          case 136:
	            key = this.parseBigIntLiteral(value);
	            break;
	          case 139:
	            {
	              const privateKeyLoc = this.state.startLoc;
	              if (refExpressionErrors != null) {
	                if (refExpressionErrors.privateKeyLoc === null) {
	                  refExpressionErrors.privateKeyLoc = privateKeyLoc;
	                }
	              } else {
	                this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
	              }
	              key = this.parsePrivateName();
	              break;
	            }
	          default:
	            if (type === 137) {
	              key = this.parseDecimalLiteral(value);
	              break;
	            }
	            this.unexpected();
	        }
	      }
	      prop.key = key;
	      if (type !== 139) {
	        prop.computed = false;
	      }
	    }
	  }
	  initFunction(node, isAsync) {
	    node.id = null;
	    node.generator = false;
	    node.async = isAsync;
	  }
	  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
	    this.initFunction(node, isAsync);
	    node.generator = isGenerator;
	    this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));
	    this.prodParam.enter(functionFlags(isAsync, node.generator));
	    this.parseFunctionParams(node, isConstructor);
	    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
	    this.prodParam.exit();
	    this.scope.exit();
	    return finishedNode;
	  }
	  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
	    if (isTuple) {
	      this.expectPlugin("recordAndTuple");
	    }
	    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
	    this.state.inFSharpPipelineDirectBody = false;
	    const node = this.startNode();
	    this.next();
	    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
	    return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
	  }
	  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
	    this.scope.enter(2 | 4);
	    let flags = functionFlags(isAsync, false);
	    if (!this.match(5) && this.prodParam.hasIn) {
	      flags |= 8;
	    }
	    this.prodParam.enter(flags);
	    this.initFunction(node, isAsync);
	    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	    if (params) {
	      this.state.maybeInArrowParameters = true;
	      this.setArrowFunctionParameters(node, params, trailingCommaLoc);
	    }
	    this.state.maybeInArrowParameters = false;
	    this.parseFunctionBody(node, true);
	    this.prodParam.exit();
	    this.scope.exit();
	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    return this.finishNode(node, "ArrowFunctionExpression");
	  }
	  setArrowFunctionParameters(node, params, trailingCommaLoc) {
	    this.toAssignableList(params, trailingCommaLoc, false);
	    node.params = params;
	  }
	  parseFunctionBodyAndFinish(node, type, isMethod = false) {
	    this.parseFunctionBody(node, false, isMethod);
	    return this.finishNode(node, type);
	  }
	  parseFunctionBody(node, allowExpression, isMethod = false) {
	    const isExpression = allowExpression && !this.match(5);
	    this.expressionScope.enter(newExpressionScope());
	    if (isExpression) {
	      node.body = this.parseMaybeAssign();
	      this.checkParams(node, false, allowExpression, false);
	    } else {
	      const oldStrict = this.state.strict;
	      const oldLabels = this.state.labels;
	      this.state.labels = [];
	      this.prodParam.enter(this.prodParam.currentFlags() | 4);
	      node.body = this.parseBlock(true, false, hasStrictModeDirective => {
	        const nonSimple = !this.isSimpleParamList(node.params);
	        if (hasStrictModeDirective && nonSimple) {
	          this.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node);
	        }
	        const strictModeChanged = !oldStrict && this.state.strict;
	        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
	        if (this.state.strict && node.id) {
	          this.checkIdentifier(node.id, 65, strictModeChanged);
	        }
	      });
	      this.prodParam.exit();
	      this.state.labels = oldLabels;
	    }
	    this.expressionScope.exit();
	  }
	  isSimpleParameter(node) {
	    return node.type === "Identifier";
	  }
	  isSimpleParamList(params) {
	    for (let i = 0, len = params.length; i < len; i++) {
	      if (!this.isSimpleParameter(params[i])) return false;
	    }
	    return true;
	  }
	  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
	    const checkClashes = !allowDuplicates && new Set();
	    const formalParameters = {
	      type: "FormalParameters"
	    };
	    for (const param of node.params) {
	      this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);
	    }
	  }
	  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
	    const elts = [];
	    let first = true;
	    while (!this.eat(close)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12);
	        if (this.match(close)) {
	          if (nodeForExtra) {
	            this.addTrailingCommaExtraToNode(nodeForExtra);
	          }
	          this.next();
	          break;
	        }
	      }
	      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
	    }
	    return elts;
	  }
	  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
	    let elt;
	    if (this.match(12)) {
	      if (!allowEmpty) {
	        this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
	          unexpected: ","
	        });
	      }
	      elt = null;
	    } else if (this.match(21)) {
	      const spreadNodeStartLoc = this.state.startLoc;
	      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
	    } else if (this.match(17)) {
	      this.expectPlugin("partialApplication");
	      if (!allowPlaceholder) {
	        this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
	      }
	      const node = this.startNode();
	      this.next();
	      elt = this.finishNode(node, "ArgumentPlaceholder");
	    } else {
	      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
	    }
	    return elt;
	  }
	  parseIdentifier(liberal) {
	    const node = this.startNode();
	    const name = this.parseIdentifierName(liberal);
	    return this.createIdentifier(node, name);
	  }
	  createIdentifier(node, name) {
	    node.name = name;
	    node.loc.identifierName = name;
	    return this.finishNode(node, "Identifier");
	  }
	  createIdentifierAt(node, name, endLoc) {
	    node.name = name;
	    node.loc.identifierName = name;
	    return this.finishNodeAt(node, "Identifier", endLoc);
	  }
	  parseIdentifierName(liberal) {
	    let name;
	    const {
	      startLoc,
	      type
	    } = this.state;
	    if (tokenIsKeywordOrIdentifier(type)) {
	      name = this.state.value;
	    } else {
	      this.unexpected();
	    }
	    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);
	    if (liberal) {
	      if (tokenIsKeyword) {
	        this.replaceToken(132);
	      }
	    } else {
	      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);
	    }
	    this.next();
	    return name;
	  }
	  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
	    if (word.length > 10) {
	      return;
	    }
	    if (!canBeReservedWord(word)) {
	      return;
	    }
	    if (checkKeywords && isKeyword(word)) {
	      this.raise(Errors.UnexpectedKeyword, startLoc, {
	        keyword: word
	      });
	      return;
	    }
	    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
	    if (reservedTest(word, this.inModule)) {
	      this.raise(Errors.UnexpectedReservedWord, startLoc, {
	        reservedWord: word
	      });
	      return;
	    } else if (word === "yield") {
	      if (this.prodParam.hasYield) {
	        this.raise(Errors.YieldBindingIdentifier, startLoc);
	        return;
	      }
	    } else if (word === "await") {
	      if (this.prodParam.hasAwait) {
	        this.raise(Errors.AwaitBindingIdentifier, startLoc);
	        return;
	      }
	      if (this.scope.inStaticBlock) {
	        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
	        return;
	      }
	      this.expressionScope.recordAsyncArrowParametersError(startLoc);
	    } else if (word === "arguments") {
	      if (this.scope.inClassAndNotInNonArrowFunction) {
	        this.raise(Errors.ArgumentsInClass, startLoc);
	        return;
	      }
	    }
	  }
	  recordAwaitIfAllowed() {
	    const isAwaitAllowed = this.prodParam.hasAwait || this.optionFlags & 1 && !this.scope.inFunction;
	    if (isAwaitAllowed && !this.scope.inFunction) {
	      this.state.hasTopLevelAwait = true;
	    }
	    return isAwaitAllowed;
	  }
	  parseAwait(startLoc) {
	    const node = this.startNodeAt(startLoc);
	    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);
	    if (this.eat(55)) {
	      this.raise(Errors.ObsoleteAwaitStar, node);
	    }
	    if (!this.scope.inFunction && !(this.optionFlags & 1)) {
	      if (this.isAmbiguousPrefixOrIdentifier()) {
	        this.ambiguousScriptDifferentAst = true;
	      } else {
	        this.sawUnambiguousESM = true;
	      }
	    }
	    if (!this.state.soloAwait) {
	      node.argument = this.parseMaybeUnary(null, true);
	    }
	    return this.finishNode(node, "AwaitExpression");
	  }
	  isAmbiguousPrefixOrIdentifier() {
	    if (this.hasPrecedingLineBreak()) return true;
	    const {
	      type
	    } = this.state;
	    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
	  }
	  parseYield(startLoc) {
	    const node = this.startNodeAt(startLoc);
	    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
	    let delegating = false;
	    let argument = null;
	    if (!this.hasPrecedingLineBreak()) {
	      delegating = this.eat(55);
	      switch (this.state.type) {
	        case 13:
	        case 140:
	        case 8:
	        case 11:
	        case 3:
	        case 9:
	        case 14:
	        case 12:
	          if (!delegating) break;
	        default:
	          argument = this.parseMaybeAssign();
	      }
	    }
	    node.delegate = delegating;
	    node.argument = argument;
	    return this.finishNode(node, "YieldExpression");
	  }
	  parseImportCall(node) {
	    this.next();
	    node.source = this.parseMaybeAssignAllowIn();
	    node.options = null;
	    if (this.eat(12)) {
	      if (!this.match(11)) {
	        node.options = this.parseMaybeAssignAllowIn();
	        if (this.eat(12)) {
	          this.addTrailingCommaExtraToNode(node.options);
	          if (!this.match(11)) {
	            do {
	              this.parseMaybeAssignAllowIn();
	            } while (this.eat(12) && !this.match(11));
	            this.raise(Errors.ImportCallArity, node);
	          }
	        }
	      } else {
	        this.addTrailingCommaExtraToNode(node.source);
	      }
	    }
	    this.expect(11);
	    return this.finishNode(node, "ImportExpression");
	  }
	  checkPipelineAtInfixOperator(left, leftStartLoc) {
	    if (this.hasPlugin(["pipelineOperator", {
	      proposal: "smart"
	    }])) {
	      if (left.type === "SequenceExpression") {
	        this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
	      }
	    }
	  }
	  parseSmartPipelineBodyInStyle(childExpr, startLoc) {
	    if (this.isSimpleReference(childExpr)) {
	      const bodyNode = this.startNodeAt(startLoc);
	      bodyNode.callee = childExpr;
	      return this.finishNode(bodyNode, "PipelineBareFunction");
	    } else {
	      const bodyNode = this.startNodeAt(startLoc);
	      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
	      bodyNode.expression = childExpr;
	      return this.finishNode(bodyNode, "PipelineTopicExpression");
	    }
	  }
	  isSimpleReference(expression) {
	    switch (expression.type) {
	      case "MemberExpression":
	        return !expression.computed && this.isSimpleReference(expression.object);
	      case "Identifier":
	        return true;
	      default:
	        return false;
	    }
	  }
	  checkSmartPipeTopicBodyEarlyErrors(startLoc) {
	    if (this.match(19)) {
	      throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
	    }
	    if (!this.topicReferenceWasUsedInCurrentContext()) {
	      this.raise(Errors.PipelineTopicUnused, startLoc);
	    }
	  }
	  withTopicBindingContext(callback) {
	    const outerContextTopicState = this.state.topicContext;
	    this.state.topicContext = {
	      maxNumOfResolvableTopics: 1,
	      maxTopicIndex: null
	    };
	    try {
	      return callback();
	    } finally {
	      this.state.topicContext = outerContextTopicState;
	    }
	  }
	  withSmartMixTopicForbiddingContext(callback) {
	    if (this.hasPlugin(["pipelineOperator", {
	      proposal: "smart"
	    }])) {
	      const outerContextTopicState = this.state.topicContext;
	      this.state.topicContext = {
	        maxNumOfResolvableTopics: 0,
	        maxTopicIndex: null
	      };
	      try {
	        return callback();
	      } finally {
	        this.state.topicContext = outerContextTopicState;
	      }
	    } else {
	      return callback();
	    }
	  }
	  withSoloAwaitPermittingContext(callback) {
	    const outerContextSoloAwaitState = this.state.soloAwait;
	    this.state.soloAwait = true;
	    try {
	      return callback();
	    } finally {
	      this.state.soloAwait = outerContextSoloAwaitState;
	    }
	  }
	  allowInAnd(callback) {
	    const flags = this.prodParam.currentFlags();
	    const prodParamToSet = 8 & ~flags;
	    if (prodParamToSet) {
	      this.prodParam.enter(flags | 8);
	      try {
	        return callback();
	      } finally {
	        this.prodParam.exit();
	      }
	    }
	    return callback();
	  }
	  disallowInAnd(callback) {
	    const flags = this.prodParam.currentFlags();
	    const prodParamToClear = 8 & flags;
	    if (prodParamToClear) {
	      this.prodParam.enter(flags & -9);
	      try {
	        return callback();
	      } finally {
	        this.prodParam.exit();
	      }
	    }
	    return callback();
	  }
	  registerTopicReference() {
	    this.state.topicContext.maxTopicIndex = 0;
	  }
	  topicReferenceIsAllowedInCurrentContext() {
	    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
	  }
	  topicReferenceWasUsedInCurrentContext() {
	    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
	  }
	  parseFSharpPipelineBody(prec) {
	    const startLoc = this.state.startLoc;
	    this.state.potentialArrowAt = this.state.start;
	    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
	    this.state.inFSharpPipelineDirectBody = true;
	    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
	    return ret;
	  }
	  parseModuleExpression() {
	    this.expectPlugin("moduleBlocks");
	    const node = this.startNode();
	    this.next();
	    if (!this.match(5)) {
	      this.unexpected(null, 5);
	    }
	    const program = this.startNodeAt(this.state.endLoc);
	    this.next();
	    const revertScopes = this.initializeScopes(true);
	    this.enterInitialScopes();
	    try {
	      node.body = this.parseProgram(program, 8, "module");
	    } finally {
	      revertScopes();
	    }
	    return this.finishNode(node, "ModuleExpression");
	  }
	  parsePropertyNamePrefixOperator(prop) {}
	}
	const loopLabel = {
	    kind: 1
	  },
	  switchLabel = {
	    kind: 2
	  };
	const loneSurrogate = /[\uD800-\uDFFF]/u;
	const keywordRelationalOperator = /in(?:stanceof)?/y;
	function babel7CompatTokens(tokens, input, startIndex) {
	  for (let i = 0; i < tokens.length; i++) {
	    const token = tokens[i];
	    const {
	      type
	    } = token;
	    if (typeof type === "number") {
	      {
	        if (type === 139) {
	          const {
	            loc,
	            start,
	            value,
	            end
	          } = token;
	          const hashEndPos = start + 1;
	          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
	          tokens.splice(i, 1, new Token({
	            type: getExportedToken(27),
	            value: "#",
	            start: start,
	            end: hashEndPos,
	            startLoc: loc.start,
	            endLoc: hashEndLoc
	          }), new Token({
	            type: getExportedToken(132),
	            value: value,
	            start: hashEndPos,
	            end: end,
	            startLoc: hashEndLoc,
	            endLoc: loc.end
	          }));
	          i++;
	          continue;
	        }
	        if (tokenIsTemplate(type)) {
	          const {
	            loc,
	            start,
	            value,
	            end
	          } = token;
	          const backquoteEnd = start + 1;
	          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
	          let startToken;
	          if (input.charCodeAt(start - startIndex) === 96) {
	            startToken = new Token({
	              type: getExportedToken(22),
	              value: "`",
	              start: start,
	              end: backquoteEnd,
	              startLoc: loc.start,
	              endLoc: backquoteEndLoc
	            });
	          } else {
	            startToken = new Token({
	              type: getExportedToken(8),
	              value: "}",
	              start: start,
	              end: backquoteEnd,
	              startLoc: loc.start,
	              endLoc: backquoteEndLoc
	            });
	          }
	          let templateValue, templateElementEnd, templateElementEndLoc, endToken;
	          if (type === 24) {
	            templateElementEnd = end - 1;
	            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
	            templateValue = value === null ? null : value.slice(1, -1);
	            endToken = new Token({
	              type: getExportedToken(22),
	              value: "`",
	              start: templateElementEnd,
	              end: end,
	              startLoc: templateElementEndLoc,
	              endLoc: loc.end
	            });
	          } else {
	            templateElementEnd = end - 2;
	            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
	            templateValue = value === null ? null : value.slice(1, -2);
	            endToken = new Token({
	              type: getExportedToken(23),
	              value: "${",
	              start: templateElementEnd,
	              end: end,
	              startLoc: templateElementEndLoc,
	              endLoc: loc.end
	            });
	          }
	          tokens.splice(i, 1, startToken, new Token({
	            type: getExportedToken(20),
	            value: templateValue,
	            start: backquoteEnd,
	            end: templateElementEnd,
	            startLoc: backquoteEndLoc,
	            endLoc: templateElementEndLoc
	          }), endToken);
	          i += 2;
	          continue;
	        }
	      }
	      token.type = getExportedToken(type);
	    }
	  }
	  return tokens;
	}
	class StatementParser extends ExpressionParser {
	  parseTopLevel(file, program) {
	    file.program = this.parseProgram(program);
	    file.comments = this.comments;
	    if (this.optionFlags & 256) {
	      file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);
	    }
	    return this.finishNode(file, "File");
	  }
	  parseProgram(program, end = 140, sourceType = this.options.sourceType) {
	    program.sourceType = sourceType;
	    program.interpreter = this.parseInterpreterDirective();
	    this.parseBlockBody(program, true, true, end);
	    if (this.inModule) {
	      if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) {
	        for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
	          this.raise(Errors.ModuleExportUndefined, at, {
	            localName
	          });
	        }
	      }
	      this.addExtra(program, "topLevelAwait", this.state.hasTopLevelAwait);
	    }
	    let finishedProgram;
	    if (end === 140) {
	      finishedProgram = this.finishNode(program, "Program");
	    } else {
	      finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
	    }
	    return finishedProgram;
	  }
	  stmtToDirective(stmt) {
	    const directive = this.castNodeTo(stmt, "Directive");
	    const directiveLiteral = this.castNodeTo(stmt.expression, "DirectiveLiteral");
	    const expressionValue = directiveLiteral.value;
	    const raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));
	    const val = directiveLiteral.value = raw.slice(1, -1);
	    this.addExtra(directiveLiteral, "raw", raw);
	    this.addExtra(directiveLiteral, "rawValue", val);
	    this.addExtra(directiveLiteral, "expressionValue", expressionValue);
	    directive.value = directiveLiteral;
	    delete stmt.expression;
	    return directive;
	  }
	  parseInterpreterDirective() {
	    if (!this.match(28)) {
	      return null;
	    }
	    const node = this.startNode();
	    node.value = this.state.value;
	    this.next();
	    return this.finishNode(node, "InterpreterDirective");
	  }
	  isLet() {
	    if (!this.isContextual(100)) {
	      return false;
	    }
	    return this.hasFollowingBindingAtom();
	  }
	  isUsing() {
	    if (!this.isContextual(107)) {
	      return false;
	    }
	    const next = this.nextTokenInLineStart();
	    const nextCh = this.codePointAtPos(next);
	    return this.chStartsBindingIdentifier(nextCh, next);
	  }
	  isAwaitUsing() {
	    if (!this.isContextual(96)) {
	      return false;
	    }
	    let next = this.nextTokenInLineStart();
	    if (this.isUnparsedContextual(next, "using")) {
	      next = this.nextTokenInLineStartSince(next + 5);
	      const nextCh = this.codePointAtPos(next);
	      if (this.chStartsBindingIdentifier(nextCh, next)) {
	        this.expectPlugin("explicitResourceManagement");
	        return true;
	      }
	    }
	    return false;
	  }
	  chStartsBindingIdentifier(ch, pos) {
	    if (isIdentifierStart(ch)) {
	      keywordRelationalOperator.lastIndex = pos;
	      if (keywordRelationalOperator.test(this.input)) {
	        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
	        if (!isIdentifierChar(endCh) && endCh !== 92) {
	          return false;
	        }
	      }
	      return true;
	    } else if (ch === 92) {
	      return true;
	    } else {
	      return false;
	    }
	  }
	  chStartsBindingPattern(ch) {
	    return ch === 91 || ch === 123;
	  }
	  hasFollowingBindingAtom() {
	    const next = this.nextTokenStart();
	    const nextCh = this.codePointAtPos(next);
	    return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
	  }
	  hasInLineFollowingBindingIdentifierOrBrace() {
	    const next = this.nextTokenInLineStart();
	    const nextCh = this.codePointAtPos(next);
	    return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
	  }
	  allowsForUsing() {
	    const {
	      type,
	      containsEsc,
	      end
	    } = this.lookahead();
	    if (type === 102 && !containsEsc) {
	      const nextCharAfterOf = this.lookaheadCharCodeSince(end);
	      if (nextCharAfterOf !== 61 && nextCharAfterOf !== 58 && nextCharAfterOf !== 59) {
	        return false;
	      }
	    }
	    if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
	      this.expectPlugin("explicitResourceManagement");
	      return true;
	    }
	    return false;
	  }
	  allowsUsing() {
	    return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
	  }
	  parseModuleItem() {
	    return this.parseStatementLike(1 | 2 | 4 | 8);
	  }
	  parseStatementListItem() {
	    return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
	  }
	  parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
	    let flags = 0;
	    if (this.options.annexB && !this.state.strict) {
	      flags |= 4;
	      if (allowLabeledFunction) {
	        flags |= 8;
	      }
	    }
	    return this.parseStatementLike(flags);
	  }
	  parseStatement() {
	    return this.parseStatementLike(0);
	  }
	  parseStatementLike(flags) {
	    let decorators = null;
	    if (this.match(26)) {
	      decorators = this.parseDecorators(true);
	    }
	    return this.parseStatementContent(flags, decorators);
	  }
	  parseStatementContent(flags, decorators) {
	    const startType = this.state.type;
	    const node = this.startNode();
	    const allowDeclaration = !!(flags & 2);
	    const allowFunctionDeclaration = !!(flags & 4);
	    const topLevel = flags & 1;
	    switch (startType) {
	      case 60:
	        return this.parseBreakContinueStatement(node, true);
	      case 63:
	        return this.parseBreakContinueStatement(node, false);
	      case 64:
	        return this.parseDebuggerStatement(node);
	      case 90:
	        return this.parseDoWhileStatement(node);
	      case 91:
	        return this.parseForStatement(node);
	      case 68:
	        if (this.lookaheadCharCode() === 46) break;
	        if (!allowFunctionDeclaration) {
	          this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
	        }
	        return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
	      case 80:
	        if (!allowDeclaration) this.unexpected();
	        return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
	      case 69:
	        return this.parseIfStatement(node);
	      case 70:
	        return this.parseReturnStatement(node);
	      case 71:
	        return this.parseSwitchStatement(node);
	      case 72:
	        return this.parseThrowStatement(node);
	      case 73:
	        return this.parseTryStatement(node);
	      case 96:
	        if (this.isAwaitUsing()) {
	          if (!this.allowsUsing()) {
	            this.raise(Errors.UnexpectedUsingDeclaration, node);
	          } else if (!allowDeclaration) {
	            this.raise(Errors.UnexpectedLexicalDeclaration, node);
	          } else if (!this.recordAwaitIfAllowed()) {
	            this.raise(Errors.AwaitUsingNotInAsyncContext, node);
	          }
	          this.next();
	          return this.parseVarStatement(node, "await using");
	        }
	        break;
	      case 107:
	        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {
	          break;
	        }
	        this.expectPlugin("explicitResourceManagement");
	        if (!this.allowsUsing()) {
	          this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
	        } else if (!allowDeclaration) {
	          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
	        }
	        return this.parseVarStatement(node, "using");
	      case 100:
	        {
	          if (this.state.containsEsc) {
	            break;
	          }
	          const next = this.nextTokenStart();
	          const nextCh = this.codePointAtPos(next);
	          if (nextCh !== 91) {
	            if (!allowDeclaration && this.hasFollowingLineBreak()) break;
	            if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
	              break;
	            }
	          }
	        }
	      case 75:
	        {
	          if (!allowDeclaration) {
	            this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
	          }
	        }
	      case 74:
	        {
	          const kind = this.state.value;
	          return this.parseVarStatement(node, kind);
	        }
	      case 92:
	        return this.parseWhileStatement(node);
	      case 76:
	        return this.parseWithStatement(node);
	      case 5:
	        return this.parseBlock();
	      case 13:
	        return this.parseEmptyStatement(node);
	      case 83:
	        {
	          const nextTokenCharCode = this.lookaheadCharCode();
	          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
	            break;
	          }
	        }
	      case 82:
	        {
	          if (!(this.optionFlags & 8) && !topLevel) {
	            this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
	          }
	          this.next();
	          let result;
	          if (startType === 83) {
	            result = this.parseImport(node);
	          } else {
	            result = this.parseExport(node, decorators);
	          }
	          this.assertModuleNodeAllowed(result);
	          return result;
	        }
	      default:
	        {
	          if (this.isAsyncFunction()) {
	            if (!allowDeclaration) {
	              this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
	            }
	            this.next();
	            return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
	          }
	        }
	    }
	    const maybeName = this.state.value;
	    const expr = this.parseExpression();
	    if (tokenIsIdentifier(startType) && expr.type === "Identifier" && this.eat(14)) {
	      return this.parseLabeledStatement(node, maybeName, expr, flags);
	    } else {
	      return this.parseExpressionStatement(node, expr, decorators);
	    }
	  }
	  assertModuleNodeAllowed(node) {
	    if (!(this.optionFlags & 8) && !this.inModule) {
	      this.raise(Errors.ImportOutsideModule, node);
	    }
	  }
	  decoratorsEnabledBeforeExport() {
	    if (this.hasPlugin("decorators-legacy")) return true;
	    return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
	  }
	  maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
	    if (maybeDecorators) {
	      var _classNode$decorators;
	      if ((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length) {
	        if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
	          this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
	        }
	        classNode.decorators.unshift(...maybeDecorators);
	      } else {
	        classNode.decorators = maybeDecorators;
	      }
	      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
	      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);
	    }
	    return classNode;
	  }
	  canHaveLeadingDecorator() {
	    return this.match(80);
	  }
	  parseDecorators(allowExport) {
	    const decorators = [];
	    do {
	      decorators.push(this.parseDecorator());
	    } while (this.match(26));
	    if (this.match(82)) {
	      if (!allowExport) {
	        this.unexpected();
	      }
	      if (!this.decoratorsEnabledBeforeExport()) {
	        this.raise(Errors.DecoratorExportClass, this.state.startLoc);
	      }
	    } else if (!this.canHaveLeadingDecorator()) {
	      throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
	    }
	    return decorators;
	  }
	  parseDecorator() {
	    this.expectOnePlugin(["decorators", "decorators-legacy"]);
	    const node = this.startNode();
	    this.next();
	    if (this.hasPlugin("decorators")) {
	      const startLoc = this.state.startLoc;
	      let expr;
	      if (this.match(10)) {
	        const startLoc = this.state.startLoc;
	        this.next();
	        expr = this.parseExpression();
	        this.expect(11);
	        expr = this.wrapParenthesis(startLoc, expr);
	        const paramsStartLoc = this.state.startLoc;
	        node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);
	        if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
	          this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
	        }
	      } else {
	        expr = this.parseIdentifier(false);
	        while (this.eat(16)) {
	          const node = this.startNodeAt(startLoc);
	          node.object = expr;
	          if (this.match(139)) {
	            this.classScope.usePrivateName(this.state.value, this.state.startLoc);
	            node.property = this.parsePrivateName();
	          } else {
	            node.property = this.parseIdentifier(true);
	          }
	          node.computed = false;
	          expr = this.finishNode(node, "MemberExpression");
	        }
	        node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);
	      }
	    } else {
	      node.expression = this.parseExprSubscripts();
	    }
	    return this.finishNode(node, "Decorator");
	  }
	  parseMaybeDecoratorArguments(expr, startLoc) {
	    if (this.eat(10)) {
	      const node = this.startNodeAt(startLoc);
	      node.callee = expr;
	      node.arguments = this.parseCallExpressionArguments(11);
	      this.toReferencedList(node.arguments);
	      return this.finishNode(node, "CallExpression");
	    }
	    return expr;
	  }
	  parseBreakContinueStatement(node, isBreak) {
	    this.next();
	    if (this.isLineTerminator()) {
	      node.label = null;
	    } else {
	      node.label = this.parseIdentifier();
	      this.semicolon();
	    }
	    this.verifyBreakContinue(node, isBreak);
	    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
	  }
	  verifyBreakContinue(node, isBreak) {
	    let i;
	    for (i = 0; i < this.state.labels.length; ++i) {
	      const lab = this.state.labels[i];
	      if (node.label == null || lab.name === node.label.name) {
	        if (lab.kind != null && (isBreak || lab.kind === 1)) {
	          break;
	        }
	        if (node.label && isBreak) break;
	      }
	    }
	    if (i === this.state.labels.length) {
	      const type = isBreak ? "BreakStatement" : "ContinueStatement";
	      this.raise(Errors.IllegalBreakContinue, node, {
	        type
	      });
	    }
	  }
	  parseDebuggerStatement(node) {
	    this.next();
	    this.semicolon();
	    return this.finishNode(node, "DebuggerStatement");
	  }
	  parseHeaderExpression() {
	    this.expect(10);
	    const val = this.parseExpression();
	    this.expect(11);
	    return val;
	  }
	  parseDoWhileStatement(node) {
	    this.next();
	    this.state.labels.push(loopLabel);
	    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
	    this.state.labels.pop();
	    this.expect(92);
	    node.test = this.parseHeaderExpression();
	    this.eat(13);
	    return this.finishNode(node, "DoWhileStatement");
	  }
	  parseForStatement(node) {
	    this.next();
	    this.state.labels.push(loopLabel);
	    let awaitAt = null;
	    if (this.isContextual(96) && this.recordAwaitIfAllowed()) {
	      awaitAt = this.state.startLoc;
	      this.next();
	    }
	    this.scope.enter(0);
	    this.expect(10);
	    if (this.match(13)) {
	      if (awaitAt !== null) {
	        this.unexpected(awaitAt);
	      }
	      return this.parseFor(node, null);
	    }
	    const startsWithLet = this.isContextual(100);
	    {
	      const startsWithAwaitUsing = this.isAwaitUsing();
	      const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.allowsForUsing();
	      const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
	      if (this.match(74) || this.match(75) || isLetOrUsing) {
	        const initNode = this.startNode();
	        let kind;
	        if (startsWithAwaitUsing) {
	          kind = "await using";
	          if (!this.recordAwaitIfAllowed()) {
	            this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
	          }
	          this.next();
	        } else {
	          kind = this.state.value;
	        }
	        this.next();
	        this.parseVar(initNode, true, kind);
	        const init = this.finishNode(initNode, "VariableDeclaration");
	        const isForIn = this.match(58);
	        if (isForIn && starsWithUsingDeclaration) {
	          this.raise(Errors.ForInUsing, init);
	        }
	        if ((isForIn || this.isContextual(102)) && init.declarations.length === 1) {
	          return this.parseForIn(node, init, awaitAt);
	        }
	        if (awaitAt !== null) {
	          this.unexpected(awaitAt);
	        }
	        return this.parseFor(node, init);
	      }
	    }
	    const startsWithAsync = this.isContextual(95);
	    const refExpressionErrors = new ExpressionErrors();
	    const init = this.parseExpression(true, refExpressionErrors);
	    const isForOf = this.isContextual(102);
	    if (isForOf) {
	      if (startsWithLet) {
	        this.raise(Errors.ForOfLet, init);
	      }
	      if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
	        this.raise(Errors.ForOfAsync, init);
	      }
	    }
	    if (isForOf || this.match(58)) {
	      this.checkDestructuringPrivate(refExpressionErrors);
	      this.toAssignable(init, true);
	      const type = isForOf ? "ForOfStatement" : "ForInStatement";
	      this.checkLVal(init, {
	        type
	      });
	      return this.parseForIn(node, init, awaitAt);
	    } else {
	      this.checkExpressionErrors(refExpressionErrors, true);
	    }
	    if (awaitAt !== null) {
	      this.unexpected(awaitAt);
	    }
	    return this.parseFor(node, init);
	  }
	  parseFunctionStatement(node, isAsync, isHangingDeclaration) {
	    this.next();
	    return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
	  }
	  parseIfStatement(node) {
	    this.next();
	    node.test = this.parseHeaderExpression();
	    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
	    node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
	    return this.finishNode(node, "IfStatement");
	  }
	  parseReturnStatement(node) {
	    if (!this.prodParam.hasReturn && !(this.optionFlags & 2)) {
	      this.raise(Errors.IllegalReturn, this.state.startLoc);
	    }
	    this.next();
	    if (this.isLineTerminator()) {
	      node.argument = null;
	    } else {
	      node.argument = this.parseExpression();
	      this.semicolon();
	    }
	    return this.finishNode(node, "ReturnStatement");
	  }
	  parseSwitchStatement(node) {
	    this.next();
	    node.discriminant = this.parseHeaderExpression();
	    const cases = node.cases = [];
	    this.expect(5);
	    this.state.labels.push(switchLabel);
	    this.scope.enter(256);
	    let cur;
	    for (let sawDefault; !this.match(8);) {
	      if (this.match(61) || this.match(65)) {
	        const isCase = this.match(61);
	        if (cur) this.finishNode(cur, "SwitchCase");
	        cases.push(cur = this.startNode());
	        cur.consequent = [];
	        this.next();
	        if (isCase) {
	          cur.test = this.parseExpression();
	        } else {
	          if (sawDefault) {
	            this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
	          }
	          sawDefault = true;
	          cur.test = null;
	        }
	        this.expect(14);
	      } else {
	        if (cur) {
	          cur.consequent.push(this.parseStatementListItem());
	        } else {
	          this.unexpected();
	        }
	      }
	    }
	    this.scope.exit();
	    if (cur) this.finishNode(cur, "SwitchCase");
	    this.next();
	    this.state.labels.pop();
	    return this.finishNode(node, "SwitchStatement");
	  }
	  parseThrowStatement(node) {
	    this.next();
	    if (this.hasPrecedingLineBreak()) {
	      this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
	    }
	    node.argument = this.parseExpression();
	    this.semicolon();
	    return this.finishNode(node, "ThrowStatement");
	  }
	  parseCatchClauseParam() {
	    const param = this.parseBindingAtom();
	    this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
	    this.checkLVal(param, {
	      type: "CatchClause"
	    }, 9);
	    return param;
	  }
	  parseTryStatement(node) {
	    this.next();
	    node.block = this.parseBlock();
	    node.handler = null;
	    if (this.match(62)) {
	      const clause = this.startNode();
	      this.next();
	      if (this.match(10)) {
	        this.expect(10);
	        clause.param = this.parseCatchClauseParam();
	        this.expect(11);
	      } else {
	        clause.param = null;
	        this.scope.enter(0);
	      }
	      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
	      this.scope.exit();
	      node.handler = this.finishNode(clause, "CatchClause");
	    }
	    node.finalizer = this.eat(67) ? this.parseBlock() : null;
	    if (!node.handler && !node.finalizer) {
	      this.raise(Errors.NoCatchOrFinally, node);
	    }
	    return this.finishNode(node, "TryStatement");
	  }
	  parseVarStatement(node, kind, allowMissingInitializer = false) {
	    this.next();
	    this.parseVar(node, false, kind, allowMissingInitializer);
	    this.semicolon();
	    return this.finishNode(node, "VariableDeclaration");
	  }
	  parseWhileStatement(node) {
	    this.next();
	    node.test = this.parseHeaderExpression();
	    this.state.labels.push(loopLabel);
	    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
	    this.state.labels.pop();
	    return this.finishNode(node, "WhileStatement");
	  }
	  parseWithStatement(node) {
	    if (this.state.strict) {
	      this.raise(Errors.StrictWith, this.state.startLoc);
	    }
	    this.next();
	    node.object = this.parseHeaderExpression();
	    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
	    return this.finishNode(node, "WithStatement");
	  }
	  parseEmptyStatement(node) {
	    this.next();
	    return this.finishNode(node, "EmptyStatement");
	  }
	  parseLabeledStatement(node, maybeName, expr, flags) {
	    for (const label of this.state.labels) {
	      if (label.name === maybeName) {
	        this.raise(Errors.LabelRedeclaration, expr, {
	          labelName: maybeName
	        });
	      }
	    }
	    const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
	    for (let i = this.state.labels.length - 1; i >= 0; i--) {
	      const label = this.state.labels[i];
	      if (label.statementStart === node.start) {
	        label.statementStart = this.sourceToOffsetPos(this.state.start);
	        label.kind = kind;
	      } else {
	        break;
	      }
	    }
	    this.state.labels.push({
	      name: maybeName,
	      kind: kind,
	      statementStart: this.sourceToOffsetPos(this.state.start)
	    });
	    node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
	    this.state.labels.pop();
	    node.label = expr;
	    return this.finishNode(node, "LabeledStatement");
	  }
	  parseExpressionStatement(node, expr, decorators) {
	    node.expression = expr;
	    this.semicolon();
	    return this.finishNode(node, "ExpressionStatement");
	  }
	  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
	    const node = this.startNode();
	    if (allowDirectives) {
	      this.state.strictErrors.clear();
	    }
	    this.expect(5);
	    if (createNewLexicalScope) {
	      this.scope.enter(0);
	    }
	    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
	    if (createNewLexicalScope) {
	      this.scope.exit();
	    }
	    return this.finishNode(node, "BlockStatement");
	  }
	  isValidDirective(stmt) {
	    return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
	  }
	  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
	    const body = node.body = [];
	    const directives = node.directives = [];
	    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
	  }
	  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
	    const oldStrict = this.state.strict;
	    let hasStrictModeDirective = false;
	    let parsedNonDirective = false;
	    while (!this.match(end)) {
	      const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
	      if (directives && !parsedNonDirective) {
	        if (this.isValidDirective(stmt)) {
	          const directive = this.stmtToDirective(stmt);
	          directives.push(directive);
	          if (!hasStrictModeDirective && directive.value.value === "use strict") {
	            hasStrictModeDirective = true;
	            this.setStrict(true);
	          }
	          continue;
	        }
	        parsedNonDirective = true;
	        this.state.strictErrors.clear();
	      }
	      body.push(stmt);
	    }
	    afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
	    if (!oldStrict) {
	      this.setStrict(false);
	    }
	    this.next();
	  }
	  parseFor(node, init) {
	    node.init = init;
	    this.semicolon(false);
	    node.test = this.match(13) ? null : this.parseExpression();
	    this.semicolon(false);
	    node.update = this.match(11) ? null : this.parseExpression();
	    this.expect(11);
	    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
	    this.scope.exit();
	    this.state.labels.pop();
	    return this.finishNode(node, "ForStatement");
	  }
	  parseForIn(node, init, awaitAt) {
	    const isForIn = this.match(58);
	    this.next();
	    if (isForIn) {
	      if (awaitAt !== null) this.unexpected(awaitAt);
	    } else {
	      node.await = awaitAt !== null;
	    }
	    if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
	      this.raise(Errors.ForInOfLoopInitializer, init, {
	        type: isForIn ? "ForInStatement" : "ForOfStatement"
	      });
	    }
	    if (init.type === "AssignmentPattern") {
	      this.raise(Errors.InvalidLhs, init, {
	        ancestor: {
	          type: "ForStatement"
	        }
	      });
	    }
	    node.left = init;
	    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
	    this.expect(11);
	    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
	    this.scope.exit();
	    this.state.labels.pop();
	    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
	  }
	  parseVar(node, isFor, kind, allowMissingInitializer = false) {
	    const declarations = node.declarations = [];
	    node.kind = kind;
	    for (;;) {
	      const decl = this.startNode();
	      this.parseVarId(decl, kind);
	      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
	      if (decl.init === null && !allowMissingInitializer) {
	        if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
	          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
	            kind: "destructuring"
	          });
	        } else if ((kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102))) {
	          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
	            kind
	          });
	        }
	      }
	      declarations.push(this.finishNode(decl, "VariableDeclarator"));
	      if (!this.eat(12)) break;
	    }
	    return node;
	  }
	  parseVarId(decl, kind) {
	    const id = this.parseBindingAtom();
	    if (kind === "using" || kind === "await using") {
	      if (id.type === "ArrayPattern" || id.type === "ObjectPattern") {
	        this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);
	      }
	    }
	    this.checkLVal(id, {
	      type: "VariableDeclarator"
	    }, kind === "var" ? 5 : 8201);
	    decl.id = id;
	  }
	  parseAsyncFunctionExpression(node) {
	    return this.parseFunction(node, 8);
	  }
	  parseFunction(node, flags = 0) {
	    const hangingDeclaration = flags & 2;
	    const isDeclaration = !!(flags & 1);
	    const requireId = isDeclaration && !(flags & 4);
	    const isAsync = !!(flags & 8);
	    this.initFunction(node, isAsync);
	    if (this.match(55)) {
	      if (hangingDeclaration) {
	        this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
	      }
	      this.next();
	      node.generator = true;
	    }
	    if (isDeclaration) {
	      node.id = this.parseFunctionId(requireId);
	    }
	    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	    this.state.maybeInArrowParameters = false;
	    this.scope.enter(2);
	    this.prodParam.enter(functionFlags(isAsync, node.generator));
	    if (!isDeclaration) {
	      node.id = this.parseFunctionId();
	    }
	    this.parseFunctionParams(node, false);
	    this.withSmartMixTopicForbiddingContext(() => {
	      this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
	    });
	    this.prodParam.exit();
	    this.scope.exit();
	    if (isDeclaration && !hangingDeclaration) {
	      this.registerFunctionStatementId(node);
	    }
	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    return node;
	  }
	  parseFunctionId(requireId) {
	    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
	  }
	  parseFunctionParams(node, isConstructor) {
	    this.expect(10);
	    this.expressionScope.enter(newParameterDeclarationScope());
	    node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
	    this.expressionScope.exit();
	  }
	  registerFunctionStatementId(node) {
	    if (!node.id) return;
	    this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
	  }
	  parseClass(node, isStatement, optionalId) {
	    this.next();
	    const oldStrict = this.state.strict;
	    this.state.strict = true;
	    this.parseClassId(node, isStatement, optionalId);
	    this.parseClassSuper(node);
	    node.body = this.parseClassBody(!!node.superClass, oldStrict);
	    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
	  }
	  isClassProperty() {
	    return this.match(29) || this.match(13) || this.match(8);
	  }
	  isClassMethod() {
	    return this.match(10);
	  }
	  nameIsConstructor(key) {
	    return key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor";
	  }
	  isNonstaticConstructor(method) {
	    return !method.computed && !method.static && this.nameIsConstructor(method.key);
	  }
	  parseClassBody(hadSuperClass, oldStrict) {
	    this.classScope.enter();
	    const state = {
	      hadConstructor: false,
	      hadSuperClass
	    };
	    let decorators = [];
	    const classBody = this.startNode();
	    classBody.body = [];
	    this.expect(5);
	    this.withSmartMixTopicForbiddingContext(() => {
	      while (!this.match(8)) {
	        if (this.eat(13)) {
	          if (decorators.length > 0) {
	            throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
	          }
	          continue;
	        }
	        if (this.match(26)) {
	          decorators.push(this.parseDecorator());
	          continue;
	        }
	        const member = this.startNode();
	        if (decorators.length) {
	          member.decorators = decorators;
	          this.resetStartLocationFromNode(member, decorators[0]);
	          decorators = [];
	        }
	        this.parseClassMember(classBody, member, state);
	        if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
	          this.raise(Errors.DecoratorConstructor, member);
	        }
	      }
	    });
	    this.state.strict = oldStrict;
	    this.next();
	    if (decorators.length) {
	      throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
	    }
	    this.classScope.exit();
	    return this.finishNode(classBody, "ClassBody");
	  }
	  parseClassMemberFromModifier(classBody, member) {
	    const key = this.parseIdentifier(true);
	    if (this.isClassMethod()) {
	      const method = member;
	      method.kind = "method";
	      method.computed = false;
	      method.key = key;
	      method.static = false;
	      this.pushClassMethod(classBody, method, false, false, false, false);
	      return true;
	    } else if (this.isClassProperty()) {
	      const prop = member;
	      prop.computed = false;
	      prop.key = key;
	      prop.static = false;
	      classBody.body.push(this.parseClassProperty(prop));
	      return true;
	    }
	    this.resetPreviousNodeTrailingComments(key);
	    return false;
	  }
	  parseClassMember(classBody, member, state) {
	    const isStatic = this.isContextual(106);
	    if (isStatic) {
	      if (this.parseClassMemberFromModifier(classBody, member)) {
	        return;
	      }
	      if (this.eat(5)) {
	        this.parseClassStaticBlock(classBody, member);
	        return;
	      }
	    }
	    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
	  }
	  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
	    const publicMethod = member;
	    const privateMethod = member;
	    const publicProp = member;
	    const privateProp = member;
	    const accessorProp = member;
	    const method = publicMethod;
	    const publicMember = publicMethod;
	    member.static = isStatic;
	    this.parsePropertyNamePrefixOperator(member);
	    if (this.eat(55)) {
	      method.kind = "method";
	      const isPrivateName = this.match(139);
	      this.parseClassElementName(method);
	      this.parsePostMemberNameModifiers(method);
	      if (isPrivateName) {
	        this.pushClassPrivateMethod(classBody, privateMethod, true, false);
	        return;
	      }
	      if (this.isNonstaticConstructor(publicMethod)) {
	        this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
	      }
	      this.pushClassMethod(classBody, publicMethod, true, false, false, false);
	      return;
	    }
	    const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
	    const key = this.parseClassElementName(member);
	    const maybeContextualKw = isContextual ? key.name : null;
	    const isPrivate = this.isPrivateName(key);
	    const maybeQuestionTokenStartLoc = this.state.startLoc;
	    this.parsePostMemberNameModifiers(publicMember);
	    if (this.isClassMethod()) {
	      method.kind = "method";
	      if (isPrivate) {
	        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
	        return;
	      }
	      const isConstructor = this.isNonstaticConstructor(publicMethod);
	      let allowsDirectSuper = false;
	      if (isConstructor) {
	        publicMethod.kind = "constructor";
	        if (state.hadConstructor && !this.hasPlugin("typescript")) {
	          this.raise(Errors.DuplicateConstructor, key);
	        }
	        if (isConstructor && this.hasPlugin("typescript") && member.override) {
	          this.raise(Errors.OverrideOnConstructor, key);
	        }
	        state.hadConstructor = true;
	        allowsDirectSuper = state.hadSuperClass;
	      }
	      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
	    } else if (this.isClassProperty()) {
	      if (isPrivate) {
	        this.pushClassPrivateProperty(classBody, privateProp);
	      } else {
	        this.pushClassProperty(classBody, publicProp);
	      }
	    } else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
	      this.resetPreviousNodeTrailingComments(key);
	      const isGenerator = this.eat(55);
	      if (publicMember.optional) {
	        this.unexpected(maybeQuestionTokenStartLoc);
	      }
	      method.kind = "method";
	      const isPrivate = this.match(139);
	      this.parseClassElementName(method);
	      this.parsePostMemberNameModifiers(publicMember);
	      if (isPrivate) {
	        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
	      } else {
	        if (this.isNonstaticConstructor(publicMethod)) {
	          this.raise(Errors.ConstructorIsAsync, publicMethod.key);
	        }
	        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
	      }
	    } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
	      this.resetPreviousNodeTrailingComments(key);
	      method.kind = maybeContextualKw;
	      const isPrivate = this.match(139);
	      this.parseClassElementName(publicMethod);
	      if (isPrivate) {
	        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
	      } else {
	        if (this.isNonstaticConstructor(publicMethod)) {
	          this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
	        }
	        this.pushClassMethod(classBody, publicMethod, false, false, false, false);
	      }
	      this.checkGetterSetterParams(publicMethod);
	    } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
	      this.expectPlugin("decoratorAutoAccessors");
	      this.resetPreviousNodeTrailingComments(key);
	      const isPrivate = this.match(139);
	      this.parseClassElementName(publicProp);
	      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);
	    } else if (this.isLineTerminator()) {
	      if (isPrivate) {
	        this.pushClassPrivateProperty(classBody, privateProp);
	      } else {
	        this.pushClassProperty(classBody, publicProp);
	      }
	    } else {
	      this.unexpected();
	    }
	  }
	  parseClassElementName(member) {
	    const {
	      type,
	      value
	    } = this.state;
	    if ((type === 132 || type === 134) && member.static && value === "prototype") {
	      this.raise(Errors.StaticPrototype, this.state.startLoc);
	    }
	    if (type === 139) {
	      if (value === "constructor") {
	        this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
	      }
	      const key = this.parsePrivateName();
	      member.key = key;
	      return key;
	    }
	    this.parsePropertyName(member);
	    return member.key;
	  }
	  parseClassStaticBlock(classBody, member) {
	    var _member$decorators;
	    this.scope.enter(64 | 128 | 16);
	    const oldLabels = this.state.labels;
	    this.state.labels = [];
	    this.prodParam.enter(0);
	    const body = member.body = [];
	    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);
	    this.prodParam.exit();
	    this.scope.exit();
	    this.state.labels = oldLabels;
	    classBody.body.push(this.finishNode(member, "StaticBlock"));
	    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
	      this.raise(Errors.DecoratorStaticBlock, member);
	    }
	  }
	  pushClassProperty(classBody, prop) {
	    if (!prop.computed && this.nameIsConstructor(prop.key)) {
	      this.raise(Errors.ConstructorClassField, prop.key);
	    }
	    classBody.body.push(this.parseClassProperty(prop));
	  }
	  pushClassPrivateProperty(classBody, prop) {
	    const node = this.parseClassPrivateProperty(prop);
	    classBody.body.push(node);
	    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
	  }
	  pushClassAccessorProperty(classBody, prop, isPrivate) {
	    if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {
	      this.raise(Errors.ConstructorClassField, prop.key);
	    }
	    const node = this.parseClassAccessorProperty(prop);
	    classBody.body.push(node);
	    if (isPrivate) {
	      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
	    }
	  }
	  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
	    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
	  }
	  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
	    const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
	    classBody.body.push(node);
	    const kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
	    this.declareClassPrivateMethodInScope(node, kind);
	  }
	  declareClassPrivateMethodInScope(node, kind) {
	    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
	  }
	  parsePostMemberNameModifiers(methodOrProp) {}
	  parseClassPrivateProperty(node) {
	    this.parseInitializer(node);
	    this.semicolon();
	    return this.finishNode(node, "ClassPrivateProperty");
	  }
	  parseClassProperty(node) {
	    this.parseInitializer(node);
	    this.semicolon();
	    return this.finishNode(node, "ClassProperty");
	  }
	  parseClassAccessorProperty(node) {
	    this.parseInitializer(node);
	    this.semicolon();
	    return this.finishNode(node, "ClassAccessorProperty");
	  }
	  parseInitializer(node) {
	    this.scope.enter(64 | 16);
	    this.expressionScope.enter(newExpressionScope());
	    this.prodParam.enter(0);
	    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
	    this.expressionScope.exit();
	    this.prodParam.exit();
	    this.scope.exit();
	  }
	  parseClassId(node, isStatement, optionalId, bindingType = 8331) {
	    if (tokenIsIdentifier(this.state.type)) {
	      node.id = this.parseIdentifier();
	      if (isStatement) {
	        this.declareNameFromIdentifier(node.id, bindingType);
	      }
	    } else {
	      if (optionalId || !isStatement) {
	        node.id = null;
	      } else {
	        throw this.raise(Errors.MissingClassName, this.state.startLoc);
	      }
	    }
	  }
	  parseClassSuper(node) {
	    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
	  }
	  parseExport(node, decorators) {
	    const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
	    const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
	    const parseAfterDefault = !hasDefault || this.eat(12);
	    const hasStar = parseAfterDefault && this.eatExportStar(node);
	    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
	    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
	    const isFromRequired = hasDefault || hasStar;
	    if (hasStar && !hasNamespace) {
	      if (hasDefault) this.unexpected();
	      if (decorators) {
	        throw this.raise(Errors.UnsupportedDecoratorExport, node);
	      }
	      this.parseExportFrom(node, true);
	      this.sawUnambiguousESM = true;
	      return this.finishNode(node, "ExportAllDeclaration");
	    }
	    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
	    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
	      this.unexpected(null, 5);
	    }
	    if (hasNamespace && parseAfterNamespace) {
	      this.unexpected(null, 98);
	    }
	    let hasDeclaration;
	    if (isFromRequired || hasSpecifiers) {
	      hasDeclaration = false;
	      if (decorators) {
	        throw this.raise(Errors.UnsupportedDecoratorExport, node);
	      }
	      this.parseExportFrom(node, isFromRequired);
	    } else {
	      hasDeclaration = this.maybeParseExportDeclaration(node);
	    }
	    if (isFromRequired || hasSpecifiers || hasDeclaration) {
	      var _node2$declaration;
	      const node2 = node;
	      this.checkExport(node2, true, false, !!node2.source);
	      if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
	        this.maybeTakeDecorators(decorators, node2.declaration, node2);
	      } else if (decorators) {
	        throw this.raise(Errors.UnsupportedDecoratorExport, node);
	      }
	      this.sawUnambiguousESM = true;
	      return this.finishNode(node2, "ExportNamedDeclaration");
	    }
	    if (this.eat(65)) {
	      const node2 = node;
	      const decl = this.parseExportDefaultExpression();
	      node2.declaration = decl;
	      if (decl.type === "ClassDeclaration") {
	        this.maybeTakeDecorators(decorators, decl, node2);
	      } else if (decorators) {
	        throw this.raise(Errors.UnsupportedDecoratorExport, node);
	      }
	      this.checkExport(node2, true, true);
	      this.sawUnambiguousESM = true;
	      return this.finishNode(node2, "ExportDefaultDeclaration");
	    }
	    this.unexpected(null, 5);
	  }
	  eatExportStar(node) {
	    return this.eat(55);
	  }
	  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
	    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
	      this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
	      const id = maybeDefaultIdentifier || this.parseIdentifier(true);
	      const specifier = this.startNodeAtNode(id);
	      specifier.exported = id;
	      node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
	      return true;
	    }
	    return false;
	  }
	  maybeParseExportNamespaceSpecifier(node) {
	    if (this.isContextual(93)) {
	      var _ref, _ref$specifiers;
	      (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];
	      const specifier = this.startNodeAt(this.state.lastTokStartLoc);
	      this.next();
	      specifier.exported = this.parseModuleExportName();
	      node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
	      return true;
	    }
	    return false;
	  }
	  maybeParseExportNamedSpecifiers(node) {
	    if (this.match(5)) {
	      const node2 = node;
	      if (!node2.specifiers) node2.specifiers = [];
	      const isTypeExport = node2.exportKind === "type";
	      node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
	      node2.source = null;
	      if (this.hasPlugin("importAssertions")) {
	        node2.assertions = [];
	      } else {
	        node2.attributes = [];
	      }
	      node2.declaration = null;
	      return true;
	    }
	    return false;
	  }
	  maybeParseExportDeclaration(node) {
	    if (this.shouldParseExportDeclaration()) {
	      node.specifiers = [];
	      node.source = null;
	      if (this.hasPlugin("importAssertions")) {
	        node.assertions = [];
	      } else {
	        node.attributes = [];
	      }
	      node.declaration = this.parseExportDeclaration(node);
	      return true;
	    }
	    return false;
	  }
	  isAsyncFunction() {
	    if (!this.isContextual(95)) return false;
	    const next = this.nextTokenInLineStart();
	    return this.isUnparsedContextual(next, "function");
	  }
	  parseExportDefaultExpression() {
	    const expr = this.startNode();
	    if (this.match(68)) {
	      this.next();
	      return this.parseFunction(expr, 1 | 4);
	    } else if (this.isAsyncFunction()) {
	      this.next();
	      this.next();
	      return this.parseFunction(expr, 1 | 4 | 8);
	    }
	    if (this.match(80)) {
	      return this.parseClass(expr, true, true);
	    }
	    if (this.match(26)) {
	      if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
	        this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
	      }
	      return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
	    }
	    if (this.match(75) || this.match(74) || this.isLet() || this.hasPlugin("explicitResourceManagement") && (this.isUsing() || this.isAwaitUsing())) {
	      throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
	    }
	    const res = this.parseMaybeAssignAllowIn();
	    this.semicolon();
	    return res;
	  }
	  parseExportDeclaration(node) {
	    if (this.match(80)) {
	      const node = this.parseClass(this.startNode(), true, false);
	      return node;
	    }
	    return this.parseStatementListItem();
	  }
	  isExportDefaultSpecifier() {
	    const {
	      type
	    } = this.state;
	    if (tokenIsIdentifier(type)) {
	      if (type === 95 && !this.state.containsEsc || type === 100) {
	        return false;
	      }
	      if ((type === 130 || type === 129) && !this.state.containsEsc) {
	        const {
	          type: nextType
	        } = this.lookahead();
	        if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {
	          this.expectOnePlugin(["flow", "typescript"]);
	          return false;
	        }
	      }
	    } else if (!this.match(65)) {
	      return false;
	    }
	    const next = this.nextTokenStart();
	    const hasFrom = this.isUnparsedContextual(next, "from");
	    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
	      return true;
	    }
	    if (this.match(65) && hasFrom) {
	      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
	      return nextAfterFrom === 34 || nextAfterFrom === 39;
	    }
	    return false;
	  }
	  parseExportFrom(node, expect) {
	    if (this.eatContextual(98)) {
	      node.source = this.parseImportSource();
	      this.checkExport(node);
	      this.maybeParseImportAttributes(node);
	      this.checkJSONModuleImport(node);
	    } else if (expect) {
	      this.unexpected();
	    }
	    this.semicolon();
	  }
	  shouldParseExportDeclaration() {
	    const {
	      type
	    } = this.state;
	    if (type === 26) {
	      this.expectOnePlugin(["decorators", "decorators-legacy"]);
	      if (this.hasPlugin("decorators")) {
	        if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
	          this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
	        }
	        return true;
	      }
	    }
	    if (this.hasPlugin("explicitResourceManagement")) {
	      if (this.isUsing()) {
	        this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
	        return true;
	      }
	      if (this.isAwaitUsing()) {
	        this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
	        return true;
	      }
	    }
	    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
	  }
	  checkExport(node, checkNames, isDefault, isFrom) {
	    if (checkNames) {
	      var _node$specifiers;
	      if (isDefault) {
	        this.checkDuplicateExports(node, "default");
	        if (this.hasPlugin("exportDefaultFrom")) {
	          var _declaration$extra;
	          const declaration = node.declaration;
	          if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
	            this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
	          }
	        }
	      } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
	        for (const specifier of node.specifiers) {
	          const {
	            exported
	          } = specifier;
	          const exportName = exported.type === "Identifier" ? exported.name : exported.value;
	          this.checkDuplicateExports(specifier, exportName);
	          if (!isFrom && specifier.local) {
	            const {
	              local
	            } = specifier;
	            if (local.type !== "Identifier") {
	              this.raise(Errors.ExportBindingIsString, specifier, {
	                localName: local.value,
	                exportName
	              });
	            } else {
	              this.checkReservedWord(local.name, local.loc.start, true, false);
	              this.scope.checkLocalExport(local);
	            }
	          }
	        }
	      } else if (node.declaration) {
	        const decl = node.declaration;
	        if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
	          const {
	            id
	          } = decl;
	          if (!id) throw new Error("Assertion failure");
	          this.checkDuplicateExports(node, id.name);
	        } else if (decl.type === "VariableDeclaration") {
	          for (const declaration of decl.declarations) {
	            this.checkDeclaration(declaration.id);
	          }
	        }
	      }
	    }
	  }
	  checkDeclaration(node) {
	    if (node.type === "Identifier") {
	      this.checkDuplicateExports(node, node.name);
	    } else if (node.type === "ObjectPattern") {
	      for (const prop of node.properties) {
	        this.checkDeclaration(prop);
	      }
	    } else if (node.type === "ArrayPattern") {
	      for (const elem of node.elements) {
	        if (elem) {
	          this.checkDeclaration(elem);
	        }
	      }
	    } else if (node.type === "ObjectProperty") {
	      this.checkDeclaration(node.value);
	    } else if (node.type === "RestElement") {
	      this.checkDeclaration(node.argument);
	    } else if (node.type === "AssignmentPattern") {
	      this.checkDeclaration(node.left);
	    }
	  }
	  checkDuplicateExports(node, exportName) {
	    if (this.exportedIdentifiers.has(exportName)) {
	      if (exportName === "default") {
	        this.raise(Errors.DuplicateDefaultExport, node);
	      } else {
	        this.raise(Errors.DuplicateExport, node, {
	          exportName
	        });
	      }
	    }
	    this.exportedIdentifiers.add(exportName);
	  }
	  parseExportSpecifiers(isInTypeExport) {
	    const nodes = [];
	    let first = true;
	    this.expect(5);
	    while (!this.eat(8)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12);
	        if (this.eat(8)) break;
	      }
	      const isMaybeTypeOnly = this.isContextual(130);
	      const isString = this.match(134);
	      const node = this.startNode();
	      node.local = this.parseModuleExportName();
	      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
	    }
	    return nodes;
	  }
	  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
	    if (this.eatContextual(93)) {
	      node.exported = this.parseModuleExportName();
	    } else if (isString) {
	      node.exported = this.cloneStringLiteral(node.local);
	    } else if (!node.exported) {
	      node.exported = this.cloneIdentifier(node.local);
	    }
	    return this.finishNode(node, "ExportSpecifier");
	  }
	  parseModuleExportName() {
	    if (this.match(134)) {
	      const result = this.parseStringLiteral(this.state.value);
	      const surrogate = loneSurrogate.exec(result.value);
	      if (surrogate) {
	        this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
	          surrogateCharCode: surrogate[0].charCodeAt(0)
	        });
	      }
	      return result;
	    }
	    return this.parseIdentifier(true);
	  }
	  isJSONModuleImport(node) {
	    if (node.assertions != null) {
	      return node.assertions.some(({
	        key,
	        value
	      }) => {
	        return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
	      });
	    }
	    return false;
	  }
	  checkImportReflection(node) {
	    const {
	      specifiers
	    } = node;
	    const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
	    if (node.phase === "source") {
	      if (singleBindingType !== "ImportDefaultSpecifier") {
	        this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
	      }
	    } else if (node.phase === "defer") {
	      if (singleBindingType !== "ImportNamespaceSpecifier") {
	        this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
	      }
	    } else if (node.module) {
	      var _node$assertions;
	      if (singleBindingType !== "ImportDefaultSpecifier") {
	        this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
	      }
	      if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {
	        this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
	      }
	    }
	  }
	  checkJSONModuleImport(node) {
	    if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
	      const {
	        specifiers
	      } = node;
	      if (specifiers != null) {
	        const nonDefaultNamedSpecifier = specifiers.find(specifier => {
	          let imported;
	          if (specifier.type === "ExportSpecifier") {
	            imported = specifier.local;
	          } else if (specifier.type === "ImportSpecifier") {
	            imported = specifier.imported;
	          }
	          if (imported !== undefined) {
	            return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
	          }
	        });
	        if (nonDefaultNamedSpecifier !== undefined) {
	          this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
	        }
	      }
	    }
	  }
	  isPotentialImportPhase(isExport) {
	    if (isExport) return false;
	    return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
	  }
	  applyImportPhase(node, isExport, phase, loc) {
	    if (isExport) {
	      return;
	    }
	    if (phase === "module") {
	      this.expectPlugin("importReflection", loc);
	      node.module = true;
	    } else if (this.hasPlugin("importReflection")) {
	      node.module = false;
	    }
	    if (phase === "source") {
	      this.expectPlugin("sourcePhaseImports", loc);
	      node.phase = "source";
	    } else if (phase === "defer") {
	      this.expectPlugin("deferredImportEvaluation", loc);
	      node.phase = "defer";
	    } else if (this.hasPlugin("sourcePhaseImports")) {
	      node.phase = null;
	    }
	  }
	  parseMaybeImportPhase(node, isExport) {
	    if (!this.isPotentialImportPhase(isExport)) {
	      this.applyImportPhase(node, isExport, null);
	      return null;
	    }
	    const phaseIdentifier = this.startNode();
	    const phaseIdentifierName = this.parseIdentifierName(true);
	    const {
	      type
	    } = this.state;
	    const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
	    if (isImportPhase) {
	      this.applyImportPhase(node, isExport, phaseIdentifierName, phaseIdentifier.loc.start);
	      return null;
	    } else {
	      this.applyImportPhase(node, isExport, null);
	      return this.createIdentifier(phaseIdentifier, phaseIdentifierName);
	    }
	  }
	  isPrecedingIdImportPhase(phase) {
	    const {
	      type
	    } = this.state;
	    return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
	  }
	  parseImport(node) {
	    if (this.match(134)) {
	      return this.parseImportSourceAndAttributes(node);
	    }
	    return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
	  }
	  parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
	    node.specifiers = [];
	    const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
	    const parseNext = !hasDefault || this.eat(12);
	    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
	    if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
	    this.expectContextual(98);
	    return this.parseImportSourceAndAttributes(node);
	  }
	  parseImportSourceAndAttributes(node) {
	    var _node$specifiers2;
	    (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];
	    node.source = this.parseImportSource();
	    this.maybeParseImportAttributes(node);
	    this.checkImportReflection(node);
	    this.checkJSONModuleImport(node);
	    this.semicolon();
	    this.sawUnambiguousESM = true;
	    return this.finishNode(node, "ImportDeclaration");
	  }
	  parseImportSource() {
	    if (!this.match(134)) this.unexpected();
	    return this.parseExprAtom();
	  }
	  parseImportSpecifierLocal(node, specifier, type) {
	    specifier.local = this.parseIdentifier();
	    node.specifiers.push(this.finishImportSpecifier(specifier, type));
	  }
	  finishImportSpecifier(specifier, type, bindingType = 8201) {
	    this.checkLVal(specifier.local, {
	      type
	    }, bindingType);
	    return this.finishNode(specifier, type);
	  }
	  parseImportAttributes() {
	    this.expect(5);
	    const attrs = [];
	    const attrNames = new Set();
	    do {
	      if (this.match(8)) {
	        break;
	      }
	      const node = this.startNode();
	      const keyName = this.state.value;
	      if (attrNames.has(keyName)) {
	        this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
	          key: keyName
	        });
	      }
	      attrNames.add(keyName);
	      if (this.match(134)) {
	        node.key = this.parseStringLiteral(keyName);
	      } else {
	        node.key = this.parseIdentifier(true);
	      }
	      this.expect(14);
	      if (!this.match(134)) {
	        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
	      }
	      node.value = this.parseStringLiteral(this.state.value);
	      attrs.push(this.finishNode(node, "ImportAttribute"));
	    } while (this.eat(12));
	    this.expect(8);
	    return attrs;
	  }
	  parseModuleAttributes() {
	    const attrs = [];
	    const attributes = new Set();
	    do {
	      const node = this.startNode();
	      node.key = this.parseIdentifier(true);
	      if (node.key.name !== "type") {
	        this.raise(Errors.ModuleAttributeDifferentFromType, node.key);
	      }
	      if (attributes.has(node.key.name)) {
	        this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {
	          key: node.key.name
	        });
	      }
	      attributes.add(node.key.name);
	      this.expect(14);
	      if (!this.match(134)) {
	        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
	      }
	      node.value = this.parseStringLiteral(this.state.value);
	      attrs.push(this.finishNode(node, "ImportAttribute"));
	    } while (this.eat(12));
	    return attrs;
	  }
	  maybeParseImportAttributes(node) {
	    let attributes;
	    {
	      var useWith = false;
	    }
	    if (this.match(76)) {
	      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
	        return;
	      }
	      this.next();
	      if (this.hasPlugin("moduleAttributes")) {
	        attributes = this.parseModuleAttributes();
	        this.addExtra(node, "deprecatedWithLegacySyntax", true);
	      } else {
	        attributes = this.parseImportAttributes();
	      }
	      {
	        useWith = true;
	      }
	    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
	      if (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions")) {
	        this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
	      }
	      if (!this.hasPlugin("importAssertions")) {
	        this.addExtra(node, "deprecatedAssertSyntax", true);
	      }
	      this.next();
	      attributes = this.parseImportAttributes();
	    } else {
	      attributes = [];
	    }
	    if (!useWith && this.hasPlugin("importAssertions")) {
	      node.assertions = attributes;
	    } else {
	      node.attributes = attributes;
	    }
	  }
	  maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
	    if (maybeDefaultIdentifier) {
	      const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
	      specifier.local = maybeDefaultIdentifier;
	      node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
	      return true;
	    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
	      this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
	      return true;
	    }
	    return false;
	  }
	  maybeParseStarImportSpecifier(node) {
	    if (this.match(55)) {
	      const specifier = this.startNode();
	      this.next();
	      this.expectContextual(93);
	      this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
	      return true;
	    }
	    return false;
	  }
	  parseNamedImportSpecifiers(node) {
	    let first = true;
	    this.expect(5);
	    while (!this.eat(8)) {
	      if (first) {
	        first = false;
	      } else {
	        if (this.eat(14)) {
	          throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
	        }
	        this.expect(12);
	        if (this.eat(8)) break;
	      }
	      const specifier = this.startNode();
	      const importedIsString = this.match(134);
	      const isMaybeTypeOnly = this.isContextual(130);
	      specifier.imported = this.parseModuleExportName();
	      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, undefined);
	      node.specifiers.push(importSpecifier);
	    }
	  }
	  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
	    if (this.eatContextual(93)) {
	      specifier.local = this.parseIdentifier();
	    } else {
	      const {
	        imported
	      } = specifier;
	      if (importedIsString) {
	        throw this.raise(Errors.ImportBindingIsString, specifier, {
	          importName: imported.value
	        });
	      }
	      this.checkReservedWord(imported.name, specifier.loc.start, true, true);
	      if (!specifier.local) {
	        specifier.local = this.cloneIdentifier(imported);
	      }
	    }
	    return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
	  }
	  isThisParam(param) {
	    return param.type === "Identifier" && param.name === "this";
	  }
	}
	class Parser extends StatementParser {
	  constructor(options, input, pluginsMap) {
	    options = getOptions(options);
	    super(options, input);
	    this.options = options;
	    this.initializeScopes();
	    this.plugins = pluginsMap;
	    this.filename = options.sourceFilename;
	    this.startIndex = options.startIndex;
	    let optionFlags = 0;
	    if (options.allowAwaitOutsideFunction) {
	      optionFlags |= 1;
	    }
	    if (options.allowReturnOutsideFunction) {
	      optionFlags |= 2;
	    }
	    if (options.allowImportExportEverywhere) {
	      optionFlags |= 8;
	    }
	    if (options.allowSuperOutsideMethod) {
	      optionFlags |= 16;
	    }
	    if (options.allowUndeclaredExports) {
	      optionFlags |= 64;
	    }
	    if (options.allowNewTargetOutsideFunction) {
	      optionFlags |= 4;
	    }
	    if (options.allowYieldOutsideFunction) {
	      optionFlags |= 32;
	    }
	    if (options.ranges) {
	      optionFlags |= 128;
	    }
	    if (options.tokens) {
	      optionFlags |= 256;
	    }
	    if (options.createImportExpressions) {
	      optionFlags |= 512;
	    }
	    if (options.createParenthesizedExpressions) {
	      optionFlags |= 1024;
	    }
	    if (options.errorRecovery) {
	      optionFlags |= 2048;
	    }
	    if (options.attachComment) {
	      optionFlags |= 4096;
	    }
	    if (options.annexB) {
	      optionFlags |= 8192;
	    }
	    this.optionFlags = optionFlags;
	  }
	  getScopeHandler() {
	    return ScopeHandler;
	  }
	  parse() {
	    this.enterInitialScopes();
	    const file = this.startNode();
	    const program = this.startNode();
	    this.nextToken();
	    file.errors = null;
	    this.parseTopLevel(file, program);
	    file.errors = this.state.errors;
	    file.comments.length = this.state.commentsLen;
	    return file;
	  }
	}
	function parse(input, options) {
	  var _options;
	  if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
	    options = Object.assign({}, options);
	    try {
	      options.sourceType = "module";
	      const parser = getParser(options, input);
	      const ast = parser.parse();
	      if (parser.sawUnambiguousESM) {
	        return ast;
	      }
	      if (parser.ambiguousScriptDifferentAst) {
	        try {
	          options.sourceType = "script";
	          return getParser(options, input).parse();
	        } catch (_unused) {}
	      } else {
	        ast.program.sourceType = "script";
	      }
	      return ast;
	    } catch (moduleError) {
	      try {
	        options.sourceType = "script";
	        return getParser(options, input).parse();
	      } catch (_unused2) {}
	      throw moduleError;
	    }
	  } else {
	    return getParser(options, input).parse();
	  }
	}
	function parseExpression(input, options) {
	  const parser = getParser(options, input);
	  if (parser.options.strictMode) {
	    parser.state.strict = true;
	  }
	  return parser.getExpression();
	}
	function generateExportedTokenTypes(internalTokenTypes) {
	  const tokenTypes = {};
	  for (const typeName of Object.keys(internalTokenTypes)) {
	    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);
	  }
	  return tokenTypes;
	}
	const tokTypes = generateExportedTokenTypes(tt);
	function getParser(options, input) {
	  let cls = Parser;
	  const pluginsMap = new Map();
	  if (options != null && options.plugins) {
	    for (const plugin of options.plugins) {
	      let name, opts;
	      if (typeof plugin === "string") {
	        name = plugin;
	      } else {
	        [name, opts] = plugin;
	      }
	      if (!pluginsMap.has(name)) {
	        pluginsMap.set(name, opts || {});
	      }
	    }
	    validatePlugins(pluginsMap);
	    cls = getParserClass(pluginsMap);
	  }
	  return new cls(options, input, pluginsMap);
	}
	const parserClassCache = new Map();
	function getParserClass(pluginsMap) {
	  const pluginList = [];
	  for (const name of mixinPluginNames) {
	    if (pluginsMap.has(name)) {
	      pluginList.push(name);
	    }
	  }
	  const key = pluginList.join("|");
	  let cls = parserClassCache.get(key);
	  if (!cls) {
	    cls = Parser;
	    for (const plugin of pluginList) {
	      cls = mixinPlugins[plugin](cls);
	    }
	    parserClassCache.set(key, cls);
	  }
	  return cls;
	}
	lib.parse = parse;
	lib.parseExpression = parseExpression;
	lib.tokTypes = tokTypes;
	
	return lib;
}

var libExports = /*@__PURE__*/ requireLib();

// @ts-check
/** @typedef { import('estree').BaseNode} BaseNode */

/** @typedef {{
	skip: () => void;
	remove: () => void;
	replace: (node: BaseNode) => void;
}} WalkerContext */

class WalkerBase {
	constructor() {
		/** @type {boolean} */
		this.should_skip = false;

		/** @type {boolean} */
		this.should_remove = false;

		/** @type {BaseNode | null} */
		this.replacement = null;

		/** @type {WalkerContext} */
		this.context = {
			skip: () => (this.should_skip = true),
			remove: () => (this.should_remove = true),
			replace: (node) => (this.replacement = node)
		};
	}

	/**
	 *
	 * @param {any} parent
	 * @param {string} prop
	 * @param {number} index
	 * @param {BaseNode} node
	 */
	replace(parent, prop, index, node) {
		if (parent) {
			if (index !== null) {
				parent[prop][index] = node;
			} else {
				parent[prop] = node;
			}
		}
	}

	/**
	 *
	 * @param {any} parent
	 * @param {string} prop
	 * @param {number} index
	 */
	remove(parent, prop, index) {
		if (parent) {
			if (index !== null) {
				parent[prop].splice(index, 1);
			} else {
				delete parent[prop];
			}
		}
	}
}

// @ts-check

/** @typedef { import('estree').BaseNode} BaseNode */
/** @typedef { import('./walker.js').WalkerContext} WalkerContext */

/** @typedef {(
 *    this: WalkerContext,
 *    node: BaseNode,
 *    parent: BaseNode,
 *    key: string,
 *    index: number
 * ) => void} SyncHandler */

class SyncWalker extends WalkerBase {
	/**
	 *
	 * @param {SyncHandler} enter
	 * @param {SyncHandler} leave
	 */
	constructor(enter, leave) {
		super();

		/** @type {SyncHandler} */
		this.enter = enter;

		/** @type {SyncHandler} */
		this.leave = leave;
	}

	/**
	 *
	 * @param {BaseNode} node
	 * @param {BaseNode} parent
	 * @param {string} [prop]
	 * @param {number} [index]
	 * @returns {BaseNode}
	 */
	visit(node, parent, prop, index) {
		if (node) {
			if (this.enter) {
				const _should_skip = this.should_skip;
				const _should_remove = this.should_remove;
				const _replacement = this.replacement;
				this.should_skip = false;
				this.should_remove = false;
				this.replacement = null;

				this.enter.call(this.context, node, parent, prop, index);

				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}

				if (this.should_remove) {
					this.remove(parent, prop, index);
				}

				const skipped = this.should_skip;
				const removed = this.should_remove;

				this.should_skip = _should_skip;
				this.should_remove = _should_remove;
				this.replacement = _replacement;

				if (skipped) return node;
				if (removed) return null;
			}

			for (const key in node) {
				const value = node[key];

				if (typeof value !== "object") {
					continue;
				} else if (Array.isArray(value)) {
					for (let i = 0; i < value.length; i += 1) {
						if (value[i] !== null && typeof value[i].type === 'string') {
							if (!this.visit(value[i], node, key, i)) {
								// removed
								i--;
							}
						}
					}
				} else if (value !== null && typeof value.type === "string") {
					this.visit(value, node, key, null);
				}
			}

			if (this.leave) {
				const _replacement = this.replacement;
				const _should_remove = this.should_remove;
				this.replacement = null;
				this.should_remove = false;

				this.leave.call(this.context, node, parent, prop, index);

				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}

				if (this.should_remove) {
					this.remove(parent, prop, index);
				}

				const removed = this.should_remove;

				this.replacement = _replacement;
				this.should_remove = _should_remove;

				if (removed) return null;
			}
		}

		return node;
	}
}

// @ts-check

/** @typedef { import('estree').BaseNode} BaseNode */
/** @typedef { import('./sync.js').SyncHandler} SyncHandler */
/** @typedef { import('./async.js').AsyncHandler} AsyncHandler */

/**
 *
 * @param {BaseNode} ast
 * @param {{
 *   enter?: SyncHandler
 *   leave?: SyncHandler
 * }} walker
 * @returns {BaseNode}
 */
function walk$2(ast, { enter, leave }) {
	const instance = new SyncWalker(enter, leave);
	return instance.visit(ast, null);
}

function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
  const rootExp = root.type === "Program" ? root.body[0].type === "ExpressionStatement" && root.body[0].expression : root;
  walk$2(root, {
    enter(node, parent) {
      parent && parentStack.push(parent);
      if (parent && parent.type.startsWith("TS") && !TS_NODE_TYPES.includes(parent.type)) {
        return this.skip();
      }
      if (node.type === "Identifier") {
        const isLocal = !!knownIds[node.name];
        const isRefed = isReferencedIdentifier(node, parent, parentStack);
        if (includeAll || isRefed && !isLocal) {
          onIdentifier(node, parent, parentStack, isRefed, isLocal);
        }
      } else if (node.type === "ObjectProperty" && // eslint-disable-next-line no-restricted-syntax
      (parent == null ? void 0 : parent.type) === "ObjectPattern") {
        node.inPattern = true;
      } else if (isFunctionType(node)) {
        if (node.scopeIds) {
          node.scopeIds.forEach((id) => markKnownIds(id, knownIds));
        } else {
          walkFunctionParams(
            node,
            (id) => markScopeIdentifier(node, id, knownIds)
          );
        }
      } else if (node.type === "BlockStatement") {
        if (node.scopeIds) {
          node.scopeIds.forEach((id) => markKnownIds(id, knownIds));
        } else {
          walkBlockDeclarations(
            node,
            (id) => markScopeIdentifier(node, id, knownIds)
          );
        }
      } else if (node.type === "CatchClause" && node.param) {
        for (const id of extractIdentifiers$1(node.param)) {
          markScopeIdentifier(node, id, knownIds);
        }
      } else if (isForStatement(node)) {
        walkForStatement(
          node,
          false,
          (id) => markScopeIdentifier(node, id, knownIds)
        );
      }
    },
    leave(node, parent) {
      parent && parentStack.pop();
      if (node !== rootExp && node.scopeIds) {
        for (const id of node.scopeIds) {
          knownIds[id]--;
          if (knownIds[id] === 0) {
            delete knownIds[id];
          }
        }
      }
    }
  });
}
function isReferencedIdentifier(id, parent, parentStack) {
  if (!parent) {
    return true;
  }
  if (id.name === "arguments") {
    return false;
  }
  if (isReferenced(id, parent)) {
    return true;
  }
  switch (parent.type) {
    case "AssignmentExpression":
    case "AssignmentPattern":
      return true;
    case "ObjectPattern":
    case "ArrayPattern":
      return isInDestructureAssignment(parent, parentStack);
  }
  return false;
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p = parentStack[i];
      if (p.type === "AssignmentExpression") {
        return true;
      } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function isInNewExpression(parentStack) {
  let i = parentStack.length;
  while (i--) {
    const p = parentStack[i];
    if (p.type === "NewExpression") {
      return true;
    } else if (p.type !== "MemberExpression") {
      break;
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers$1(p)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare) continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers$1(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id) continue;
      onIdent(stmt.id);
    } else if (isForStatement(stmt)) {
      walkForStatement(stmt, true, onIdent);
    }
  }
}
function isForStatement(stmt) {
  return stmt.type === "ForOfStatement" || stmt.type === "ForInStatement" || stmt.type === "ForStatement";
}
function walkForStatement(stmt, isVar, onIdent) {
  const variable = stmt.type === "ForStatement" ? stmt.init : stmt.left;
  if (variable && variable.type === "VariableDeclaration" && (variable.kind === "var" ? isVar : !isVar)) {
    for (const decl of variable.declarations) {
      for (const id of extractIdentifiers$1(decl.id)) {
        onIdent(id);
      }
    }
  }
}
function extractIdentifiers$1(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers$1(prop.argument, nodes);
        } else {
          extractIdentifiers$1(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element) extractIdentifiers$1(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers$1(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers$1(param.left, nodes);
      break;
  }
  return nodes;
}
function markKnownIds(name, knownIds) {
  if (name in knownIds) {
    knownIds[name]++;
  } else {
    knownIds[name] = 1;
  }
}
function markScopeIdentifier(node, child, knownIds) {
  const { name } = child;
  if (node.scopeIds && node.scopeIds.has(name)) {
    return;
  }
  markKnownIds(name, knownIds);
  (node.scopeIds || (node.scopeIds = /* @__PURE__ */ new Set())).add(name);
}
const isFunctionType = (node) => {
  return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
};
const isStaticProperty = (node) => !!node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
function isReferenced(node, parent, grandparent) {
  switch (parent.type) {
    // yes: PARENT[NODE]
    // yes: NODE.child
    // no: parent.NODE
    case "MemberExpression":
    case "OptionalMemberExpression":
      if (parent.property === node) {
        return !!parent.computed;
      }
      return parent.object === node;
    case "JSXMemberExpression":
      return parent.object === node;
    // no: let NODE = init;
    // yes: let id = NODE;
    case "VariableDeclarator":
      return parent.init === node;
    // yes: () => NODE
    // no: (NODE) => {}
    case "ArrowFunctionExpression":
      return parent.body === node;
    // no: class { #NODE; }
    // no: class { get #NODE() {} }
    // no: class { #NODE() {} }
    // no: class { fn() { return this.#NODE; } }
    case "PrivateName":
      return false;
    // no: class { NODE() {} }
    // yes: class { [NODE]() {} }
    // no: class { foo(NODE) {} }
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "ObjectMethod":
      if (parent.key === node) {
        return !!parent.computed;
      }
      return false;
    // yes: { [NODE]: "" }
    // no: { NODE: "" }
    // depends: { NODE }
    // depends: { key: NODE }
    case "ObjectProperty":
      if (parent.key === node) {
        return !!parent.computed;
      }
      return true;
    // no: class { NODE = value; }
    // yes: class { [NODE] = value; }
    // yes: class { key = NODE; }
    case "ClassProperty":
      if (parent.key === node) {
        return !!parent.computed;
      }
      return true;
    case "ClassPrivateProperty":
      return parent.key !== node;
    // no: class NODE {}
    // yes: class Foo extends NODE {}
    case "ClassDeclaration":
    case "ClassExpression":
      return parent.superClass === node;
    // yes: left = NODE;
    // no: NODE = right;
    case "AssignmentExpression":
      return parent.right === node;
    // no: [NODE = foo] = [];
    // yes: [foo = NODE] = [];
    case "AssignmentPattern":
      return parent.right === node;
    // no: NODE: for (;;) {}
    case "LabeledStatement":
      return false;
    // no: try {} catch (NODE) {}
    case "CatchClause":
      return false;
    // no: function foo(...NODE) {}
    case "RestElement":
      return false;
    case "BreakStatement":
    case "ContinueStatement":
      return false;
    // no: function NODE() {}
    // no: function foo(NODE) {}
    case "FunctionDeclaration":
    case "FunctionExpression":
      return false;
    // no: export NODE from "foo";
    // no: export * as NODE from "foo";
    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return false;
    // no: export { foo as NODE };
    // yes: export { NODE as foo };
    // no: export { NODE as foo } from "foo";
    case "ExportSpecifier":
      return parent.local === node;
    // no: import NODE from "foo";
    // no: import * as NODE from "foo";
    // no: import { NODE as foo } from "foo";
    // no: import { foo as NODE } from "foo";
    // no: import NODE from "bar";
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return false;
    // no: import "foo" assert { NODE: "json" }
    case "ImportAttribute":
      return false;
    // no: <div NODE="foo" />
    case "JSXAttribute":
      return false;
    // no: [NODE] = [];
    // no: ({ NODE }) = [];
    case "ObjectPattern":
    case "ArrayPattern":
      return false;
    // no: new.NODE
    // no: NODE.target
    case "MetaProperty":
      return false;
    // yes: type X = { someProperty: NODE }
    // no: type X = { NODE: OtherType }
    case "ObjectTypeProperty":
      return parent.key !== node;
    // yes: enum X { Foo = NODE }
    // no: enum X { NODE }
    case "TSEnumMember":
      return parent.id !== node;
    // yes: { [NODE]: value }
    // no: { NODE: value }
    case "TSPropertySignature":
      if (parent.key === node) {
        return !!parent.computed;
      }
      return true;
  }
  return true;
}
const TS_NODE_TYPES = [
  "TSAsExpression",
  // foo as number
  "TSTypeAssertion",
  // (<number>foo)
  "TSNonNullExpression",
  // foo!
  "TSInstantiationExpression",
  // foo<string>
  "TSSatisfiesExpression"
  // foo satisfies T
];
function unwrapTSNode(node) {
  if (TS_NODE_TYPES.includes(node.type)) {
    return unwrapTSNode(node.expression);
  } else {
    return node;
  }
}
function isStaticNode(node) {
  node = unwrapTSNode(node);
  switch (node.type) {
    case "UnaryExpression":
      return isStaticNode(node.argument);
    case "LogicalExpression":
    // 1 > 2
    case "BinaryExpression":
      return isStaticNode(node.left) && isStaticNode(node.right);
    case "ConditionalExpression": {
      return isStaticNode(node.test) && isStaticNode(node.consequent) && isStaticNode(node.alternate);
    }
    case "SequenceExpression":
    // (1, 2)
    case "TemplateLiteral":
      return node.expressions.every((expr) => isStaticNode(expr));
    case "ParenthesizedExpression":
      return isStaticNode(node.expression);
    case "StringLiteral":
    case "NumericLiteral":
    case "BooleanLiteral":
    case "NullLiteral":
    case "BigIntLiteral":
      return true;
  }
  return false;
}
function isConstantNode(node, bindings) {
  if (isStaticNode(node)) return true;
  node = unwrapTSNode(node);
  switch (node.type) {
    case "Identifier":
      const type = bindings[node.name];
      return type === "literal-const";
    case "RegExpLiteral":
      return true;
    case "ObjectExpression":
      return node.properties.every((prop) => {
        if (prop.type === "ObjectMethod") return false;
        if (prop.type === "SpreadElement")
          return isConstantNode(prop.argument, bindings);
        return (!prop.computed || isConstantNode(prop.key, bindings)) && isConstantNode(prop.value, bindings);
      });
    case "ArrayExpression":
      return node.elements.every((element) => {
        if (element === null) return true;
        if (element.type === "SpreadElement")
          return isConstantNode(element.argument, bindings);
        return isConstantNode(element, bindings);
      });
  }
  return false;
}

const isStaticExp = (p) => p.type === 4 && p.isStatic;
function isCoreComponent(tag) {
  switch (tag) {
    case "Teleport":
    case "teleport":
      return TELEPORT;
    case "Suspense":
    case "suspense":
      return SUSPENSE;
    case "KeepAlive":
    case "keep-alive":
      return KEEP_ALIVE;
    case "BaseTransition":
    case "base-transition":
      return BASE_TRANSITION;
  }
}
const nonIdentifierRE = /^\d|[^\$\w\xA0-\uFFFF]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
const getExpSource = (exp) => exp.type === 4 ? exp.content : exp.loc.source;
const isMemberExpressionBrowser = (exp) => {
  const path = getExpSource(exp).trim().replace(whitespaceRE, (s) => s.trim());
  let state = 0 /* inMemberExp */;
  let stateStack = [];
  let currentOpenBracketCount = 0;
  let currentOpenParensCount = 0;
  let currentStringType = null;
  for (let i = 0; i < path.length; i++) {
    const char = path.charAt(i);
    switch (state) {
      case 0 /* inMemberExp */:
        if (char === "[") {
          stateStack.push(state);
          state = 1 /* inBrackets */;
          currentOpenBracketCount++;
        } else if (char === "(") {
          stateStack.push(state);
          state = 2 /* inParens */;
          currentOpenParensCount++;
        } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
          return false;
        }
        break;
      case 1 /* inBrackets */:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3 /* inString */;
          currentStringType = char;
        } else if (char === `[`) {
          currentOpenBracketCount++;
        } else if (char === `]`) {
          if (!--currentOpenBracketCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 2 /* inParens */:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3 /* inString */;
          currentStringType = char;
        } else if (char === `(`) {
          currentOpenParensCount++;
        } else if (char === `)`) {
          if (i === path.length - 1) {
            return false;
          }
          if (!--currentOpenParensCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 3 /* inString */:
        if (char === currentStringType) {
          state = stateStack.pop();
          currentStringType = null;
        }
        break;
    }
  }
  return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpressionNode = (exp, context) => {
  try {
    let ret = exp.ast || libExports.parseExpression(getExpSource(exp), {
      plugins: context.expressionPlugins ? [...context.expressionPlugins, "typescript"] : ["typescript"]
    });
    ret = unwrapTSNode(ret);
    return ret.type === "MemberExpression" || ret.type === "OptionalMemberExpression" || ret.type === "Identifier" && ret.name !== "undefined";
  } catch (e) {
    return false;
  }
};
const isMemberExpression$1 = isMemberExpressionNode;
const fnExpRE = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const isFnExpressionBrowser = (exp) => fnExpRE.test(getExpSource(exp));
const isFnExpressionNode = (exp, context) => {
  try {
    let ret = exp.ast || libExports.parseExpression(getExpSource(exp), {
      plugins: context.expressionPlugins ? [...context.expressionPlugins, "typescript"] : ["typescript"]
    });
    if (ret.type === "Program") {
      ret = ret.body[0];
      if (ret.type === "ExpressionStatement") {
        ret = ret.expression;
      }
    }
    ret = unwrapTSNode(ret);
    return ret.type === "FunctionExpression" || ret.type === "ArrowFunctionExpression";
  } catch (e) {
    return false;
  }
};
const isFnExpression = isFnExpressionNode;
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(
    {
      offset: pos.offset,
      line: pos.line,
      column: pos.column
    },
    source,
    numberOfCharacters
  );
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir$1(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && (isString$1(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp$1(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly) continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p) => p.type === 7 && p.name === "bind" && (!p.arg || // v-bind="obj"
    p.arg.type !== 4 || // v-bind:[_ctx.foo]
    !p.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
const propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString$1(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString$1(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      );
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString$1(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString$1(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString$1(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some(
      (p) => p.key.type === 4 && p.key.content === propKeyName
    );
  }
  return result;
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some((c) => isObject$2(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
    case 20:
      return false;
    default:
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;

const defaultParserOptions = {
  parseMode: "base",
  ns: 0,
  delimiters: [`{{`, `}}`],
  getNamespace: () => 0,
  isVoidTag: NO,
  isPreTag: NO,
  isIgnoreNewlineTag: NO,
  isCustomElement: NO,
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: true,
  prefixIdentifiers: false
};
let currentOptions = defaultParserOptions;
let currentRoot = null;
let currentInput = "";
let currentOpenTag = null;
let currentProp = null;
let currentAttrValue = "";
let currentAttrStartIndex = -1;
let currentAttrEndIndex = -1;
let inPre = 0;
let inVPre = false;
let currentVPreBoundary = null;
const stack = [];
const tokenizer = new Tokenizer(stack, {
  onerr: emitError,
  ontext(start, end) {
    onText(getSlice(start, end), start, end);
  },
  ontextentity(char, start, end) {
    onText(char, start, end);
  },
  oninterpolation(start, end) {
    if (inVPre) {
      return onText(getSlice(start, end), start, end);
    }
    let innerStart = start + tokenizer.delimiterOpen.length;
    let innerEnd = end - tokenizer.delimiterClose.length;
    while (isWhitespace(currentInput.charCodeAt(innerStart))) {
      innerStart++;
    }
    while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
      innerEnd--;
    }
    let exp = getSlice(innerStart, innerEnd);
    if (exp.includes("&")) {
      {
        exp = decodeHTML(exp);
      }
    }
    addNode({
      type: 5,
      content: createExp(exp, false, getLoc(innerStart, innerEnd)),
      loc: getLoc(start, end)
    });
  },
  onopentagname(start, end) {
    const name = getSlice(start, end);
    currentOpenTag = {
      type: 1,
      tag: name,
      ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
      tagType: 0,
      // will be refined on tag close
      props: [],
      children: [],
      loc: getLoc(start - 1, end),
      codegenNode: void 0
    };
  },
  onopentagend(end) {
    endOpenTag(end);
  },
  onclosetag(start, end) {
    const name = getSlice(start, end);
    if (!currentOptions.isVoidTag(name)) {
      let found = false;
      for (let i = 0; i < stack.length; i++) {
        const e = stack[i];
        if (e.tag.toLowerCase() === name.toLowerCase()) {
          found = true;
          if (i > 0) {
            emitError(24, stack[0].loc.start.offset);
          }
          for (let j = 0; j <= i; j++) {
            const el = stack.shift();
            onCloseTag(el, end, j < i);
          }
          break;
        }
      }
      if (!found) {
        emitError(23, backTrack(start, 60));
      }
    }
  },
  onselfclosingtag(end) {
    const name = currentOpenTag.tag;
    currentOpenTag.isSelfClosing = true;
    endOpenTag(end);
    if (stack[0] && stack[0].tag === name) {
      onCloseTag(stack.shift(), end);
    }
  },
  onattribname(start, end) {
    currentProp = {
      type: 6,
      name: getSlice(start, end),
      nameLoc: getLoc(start, end),
      value: void 0,
      loc: getLoc(start)
    };
  },
  ondirname(start, end) {
    const raw = getSlice(start, end);
    const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
    if (!inVPre && name === "") {
      emitError(26, start);
    }
    if (inVPre || name === "") {
      currentProp = {
        type: 6,
        name: raw,
        nameLoc: getLoc(start, end),
        value: void 0,
        loc: getLoc(start)
      };
    } else {
      currentProp = {
        type: 7,
        name,
        rawName: raw,
        exp: void 0,
        arg: void 0,
        modifiers: raw === "." ? [createSimpleExpression("prop")] : [],
        loc: getLoc(start)
      };
      if (name === "pre") {
        inVPre = tokenizer.inVPre = true;
        currentVPreBoundary = currentOpenTag;
        const props = currentOpenTag.props;
        for (let i = 0; i < props.length; i++) {
          if (props[i].type === 7) {
            props[i] = dirToAttr(props[i]);
          }
        }
      }
    }
  },
  ondirarg(start, end) {
    if (start === end) return;
    const arg = getSlice(start, end);
    if (inVPre) {
      currentProp.name += arg;
      setLocEnd(currentProp.nameLoc, end);
    } else {
      const isStatic = arg[0] !== `[`;
      currentProp.arg = createExp(
        isStatic ? arg : arg.slice(1, -1),
        isStatic,
        getLoc(start, end),
        isStatic ? 3 : 0
      );
    }
  },
  ondirmodifier(start, end) {
    const mod = getSlice(start, end);
    if (inVPre) {
      currentProp.name += "." + mod;
      setLocEnd(currentProp.nameLoc, end);
    } else if (currentProp.name === "slot") {
      const arg = currentProp.arg;
      if (arg) {
        arg.content += "." + mod;
        setLocEnd(arg.loc, end);
      }
    } else {
      const exp = createSimpleExpression(mod, true, getLoc(start, end));
      currentProp.modifiers.push(exp);
    }
  },
  onattribdata(start, end) {
    currentAttrValue += getSlice(start, end);
    if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
    currentAttrEndIndex = end;
  },
  onattribentity(char, start, end) {
    currentAttrValue += char;
    if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
    currentAttrEndIndex = end;
  },
  onattribnameend(end) {
    const start = currentProp.loc.start.offset;
    const name = getSlice(start, end);
    if (currentProp.type === 7) {
      currentProp.rawName = name;
    }
    if (currentOpenTag.props.some(
      (p) => (p.type === 7 ? p.rawName : p.name) === name
    )) {
      emitError(2, start);
    }
  },
  onattribend(quote, end) {
    if (currentOpenTag && currentProp) {
      setLocEnd(currentProp.loc, end);
      if (quote !== 0) {
        if (currentProp.type === 6) {
          if (currentProp.name === "class") {
            currentAttrValue = condense(currentAttrValue).trim();
          }
          if (quote === 1 && !currentAttrValue) {
            emitError(13, end);
          }
          currentProp.value = {
            type: 2,
            content: currentAttrValue,
            loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
          };
          if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
            tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
          }
        } else {
          let expParseMode = 0 /* Normal */;
          {
            if (currentProp.name === "for") {
              expParseMode = 3 /* Skip */;
            } else if (currentProp.name === "slot") {
              expParseMode = 1 /* Params */;
            } else if (currentProp.name === "on" && currentAttrValue.includes(";")) {
              expParseMode = 2 /* Statements */;
            }
          }
          currentProp.exp = createExp(
            currentAttrValue,
            false,
            getLoc(currentAttrStartIndex, currentAttrEndIndex),
            0,
            expParseMode
          );
          if (currentProp.name === "for") {
            currentProp.forParseResult = parseForExpression(currentProp.exp);
          }
        }
      }
      if (currentProp.type !== 7 || currentProp.name !== "pre") {
        currentOpenTag.props.push(currentProp);
      }
    }
    currentAttrValue = "";
    currentAttrStartIndex = currentAttrEndIndex = -1;
  },
  oncomment(start, end) {
    if (currentOptions.comments) {
      addNode({
        type: 3,
        content: getSlice(start, end),
        loc: getLoc(start - 4, end + 3)
      });
    }
  },
  onend() {
    const end = currentInput.length;
    if (tokenizer.state !== 1) {
      switch (tokenizer.state) {
        case 5:
        case 8:
          emitError(5, end);
          break;
        case 3:
        case 4:
          emitError(
            25,
            tokenizer.sectionStart
          );
          break;
        case 28:
          if (tokenizer.currentSequence === Sequences.CdataEnd) {
            emitError(6, end);
          } else {
            emitError(7, end);
          }
          break;
        case 6:
        case 7:
        case 9:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        // "
        case 20:
        // '
        case 21:
          emitError(9, end);
          break;
      }
    }
    for (let index = 0; index < stack.length; index++) {
      onCloseTag(stack[index], end - 1);
      emitError(24, stack[index].loc.start.offset);
    }
  },
  oncdata(start, end) {
    if (stack[0].ns !== 0) {
      onText(getSlice(start, end), start, end);
    } else {
      emitError(1, start - 9);
    }
  },
  onprocessinginstruction(start) {
    if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
      emitError(
        21,
        start - 1
      );
    }
  }
});
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch) return;
  const [, LHS, RHS] = inMatch;
  const createAliasExpression = (content, offset, asParam = false) => {
    const start = loc.start.offset + offset;
    const end = start + content.length;
    return createExp(
      content,
      false,
      getLoc(start, end),
      0,
      asParam ? 1 /* Params */ : 0 /* Normal */
    );
  };
  const result = {
    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: false
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(keyContent, keyOffset, true);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(
          indexContent,
          exp.indexOf(
            indexContent,
            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
          ),
          true
        );
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(valueContent, trimmedOffset, true);
  }
  return result;
}
function getSlice(start, end) {
  return currentInput.slice(start, end);
}
function endOpenTag(end) {
  if (tokenizer.inSFCRoot) {
    currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
  }
  addNode(currentOpenTag);
  const { tag, ns } = currentOpenTag;
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre++;
  }
  if (currentOptions.isVoidTag(tag)) {
    onCloseTag(currentOpenTag, end);
  } else {
    stack.unshift(currentOpenTag);
    if (ns === 1 || ns === 2) {
      tokenizer.inXML = true;
    }
  }
  currentOpenTag = null;
}
function onText(content, start, end) {
  const parent = stack[0] || currentRoot;
  const lastNode = parent.children[parent.children.length - 1];
  if (lastNode && lastNode.type === 2) {
    lastNode.content += content;
    setLocEnd(lastNode.loc, end);
  } else {
    parent.children.push({
      type: 2,
      content,
      loc: getLoc(start, end)
    });
  }
}
function onCloseTag(el, end, isImplied = false) {
  if (isImplied) {
    setLocEnd(el.loc, backTrack(end, 60));
  } else {
    setLocEnd(el.loc, lookAhead(end, 62) + 1);
  }
  if (tokenizer.inSFCRoot) {
    if (el.children.length) {
      el.innerLoc.end = extend({}, el.children[el.children.length - 1].loc.end);
    } else {
      el.innerLoc.end = extend({}, el.innerLoc.start);
    }
    el.innerLoc.source = getSlice(
      el.innerLoc.start.offset,
      el.innerLoc.end.offset
    );
  }
  const { tag, ns, children } = el;
  if (!inVPre) {
    if (tag === "slot") {
      el.tagType = 2;
    } else if (isFragmentTemplate(el)) {
      el.tagType = 3;
    } else if (isComponent(el)) {
      el.tagType = 1;
    }
  }
  if (!tokenizer.inRCDATA) {
    el.children = condenseWhitespace(children);
  }
  if (ns === 0 && currentOptions.isIgnoreNewlineTag(tag)) {
    const first = children[0];
    if (first && first.type === 2) {
      first.content = first.content.replace(/^\r?\n/, "");
    }
  }
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre--;
  }
  if (currentVPreBoundary === el) {
    inVPre = tokenizer.inVPre = false;
    currentVPreBoundary = null;
  }
  if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
    tokenizer.inXML = false;
  }
}
function lookAhead(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1) i++;
  return i;
}
function backTrack(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i >= 0) i--;
  return i;
}
const specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
function isFragmentTemplate({ tag, props }) {
  if (tag === "template") {
    for (let i = 0; i < props.length; i++) {
      if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
        return true;
      }
    }
  }
  return false;
}
function isComponent({ tag, props }) {
  if (currentOptions.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        }
      }
    }
  }
  return false;
}
function isUpperCase(c) {
  return c > 64 && c < 91;
}
const windowsNewlineRE = /\r\n/g;
function condenseWhitespace(nodes, tag) {
  const shouldCondense = currentOptions.whitespace !== "preserve";
  let removedWhitespace = false;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === 2) {
      if (!inPre) {
        if (isAllWhitespace(node.content)) {
          const prev = nodes[i - 1] && nodes[i - 1].type;
          const next = nodes[i + 1] && nodes[i + 1].type;
          if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = condense(node.content);
        }
      } else {
        node.content = node.content.replace(windowsNewlineRE, "\n");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function isAllWhitespace(str) {
  for (let i = 0; i < str.length; i++) {
    if (!isWhitespace(str.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
function hasNewlineChar(str) {
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c === 10 || c === 13) {
      return true;
    }
  }
  return false;
}
function condense(str) {
  let ret = "";
  let prevCharIsWhitespace = false;
  for (let i = 0; i < str.length; i++) {
    if (isWhitespace(str.charCodeAt(i))) {
      if (!prevCharIsWhitespace) {
        ret += " ";
        prevCharIsWhitespace = true;
      }
    } else {
      ret += str[i];
      prevCharIsWhitespace = false;
    }
  }
  return ret;
}
function addNode(node) {
  (stack[0] || currentRoot).children.push(node);
}
function getLoc(start, end) {
  return {
    start: tokenizer.getPos(start),
    // @ts-expect-error allow late attachment
    end: end == null ? end : tokenizer.getPos(end),
    // @ts-expect-error allow late attachment
    source: end == null ? end : getSlice(start, end)
  };
}
function cloneLoc(loc) {
  return getLoc(loc.start.offset, loc.end.offset);
}
function setLocEnd(loc, end) {
  loc.end = tokenizer.getPos(end);
  loc.source = getSlice(loc.start.offset, end);
}
function dirToAttr(dir) {
  const attr = {
    type: 6,
    name: dir.rawName,
    nameLoc: getLoc(
      dir.loc.start.offset,
      dir.loc.start.offset + dir.rawName.length
    ),
    value: void 0,
    loc: dir.loc
  };
  if (dir.exp) {
    const loc = dir.exp.loc;
    if (loc.end.offset < dir.loc.end.offset) {
      loc.start.offset--;
      loc.start.column--;
      loc.end.offset++;
      loc.end.column++;
    }
    attr.value = {
      type: 2,
      content: dir.exp.content,
      loc
    };
  }
  return attr;
}
function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0 /* Normal */) {
  const exp = createSimpleExpression(content, isStatic, loc, constType);
  if (!isStatic && currentOptions.prefixIdentifiers && parseMode !== 3 /* Skip */ && content.trim()) {
    if (isSimpleIdentifier(content)) {
      exp.ast = null;
      return exp;
    }
    try {
      const plugins = currentOptions.expressionPlugins;
      const options = {
        plugins: plugins ? [...plugins, "typescript"] : ["typescript"]
      };
      if (parseMode === 2 /* Statements */) {
        exp.ast = libExports.parse(` ${content} `, options).program;
      } else if (parseMode === 1 /* Params */) {
        exp.ast = libExports.parseExpression(`(${content})=>{}`, options);
      } else {
        exp.ast = libExports.parseExpression(`(${content})`, options);
      }
    } catch (e) {
      exp.ast = false;
      emitError(45, loc.start.offset, e.message);
    }
  }
  return exp;
}
function emitError(code, index, message) {
  currentOptions.onError(
    createCompilerError(code, getLoc(index, index), void 0, message)
  );
}
function reset() {
  tokenizer.reset();
  currentOpenTag = null;
  currentProp = null;
  currentAttrValue = "";
  currentAttrStartIndex = -1;
  currentAttrEndIndex = -1;
  stack.length = 0;
}
function baseParse(input, options) {
  reset();
  currentInput = input;
  currentOptions = extend({}, defaultParserOptions);
  if (options) {
    let key;
    for (key in options) {
      if (options[key] != null) {
        currentOptions[key] = options[key];
      }
    }
  }
  {
    if (currentOptions.decodeEntities) {
      console.warn(
        `[@vue/compiler-core] decodeEntities option is passed but will be ignored in non-browser builds.`
      );
    }
  }
  tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
  tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
  const delimiters = options && options.delimiters;
  if (delimiters) {
    tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
    tokenizer.delimiterClose = toCharCodes(delimiters[1]);
  }
  const root = currentRoot = createRoot([], input);
  tokenizer.parse(currentInput);
  root.loc = getLoc(0, input.length);
  root.children = condenseWhitespace(root.children);
  currentRoot = null;
  return root;
}

function cacheStatic(root, context) {
  walk$1(
    root,
    void 0,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0])
  );
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk$1(node, parent, context, doNotHoistNode = false, inFor = false) {
  const { children } = node;
  const toCache = [];
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1;
          toCache.push(child);
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = codegenNode.patchFlag;
          if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType >= 2) {
        toCache.push(child);
        continue;
      }
    }
    if (child.type === 1) {
      const isComponent = child.tagType === 1;
      if (isComponent) {
        context.scopes.vSlot++;
      }
      walk$1(child, node, context, false, inFor);
      if (isComponent) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk$1(child, node, context, child.children.length === 1, true);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk$1(
          child.branches[i2],
          node,
          context,
          child.branches[i2].children.length === 1,
          inFor
        );
      }
    }
  }
  let cachedAsArray = false;
  const slotCacheKeys = [];
  if (toCache.length === children.length && node.type === 1) {
    if (node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray$3(node.codegenNode.children)) {
      node.codegenNode.children = getCacheExpression(
        createArrayExpression(node.codegenNode.children)
      );
      cachedAsArray = true;
    } else if (node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !isArray$3(node.codegenNode.children) && node.codegenNode.children.type === 15) {
      const slot = getSlotNode(node.codegenNode, "default");
      if (slot) {
        slotCacheKeys.push(context.cached.length);
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    } else if (node.tagType === 3 && parent && parent.type === 1 && parent.tagType === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !isArray$3(parent.codegenNode.children) && parent.codegenNode.children.type === 15) {
      const slotName = findDir$1(node, "slot", true);
      const slot = slotName && slotName.arg && getSlotNode(parent.codegenNode, slotName.arg);
      if (slot) {
        slotCacheKeys.push(context.cached.length);
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    }
  }
  if (!cachedAsArray) {
    for (const child of toCache) {
      slotCacheKeys.push(context.cached.length);
      child.codegenNode = context.cache(child.codegenNode);
    }
  }
  if (slotCacheKeys.length && node.type === 1 && node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !isArray$3(node.codegenNode.children) && node.codegenNode.children.type === 15) {
    node.codegenNode.children.properties.push(
      createObjectProperty(
        `__`,
        createSimpleExpression(JSON.stringify(slotCacheKeys), false)
      )
    );
  }
  function getCacheExpression(value) {
    const exp = context.cache(value);
    if (inFor && context.hmr) {
      exp.needArraySpread = true;
    }
    return exp;
  }
  function getSlotNode(node2, name) {
    if (node2.children && !isArray$3(node2.children) && node2.children.type === 15) {
      const slot = node2.children.properties.find(
        (p) => p.key === name || p.key.content === name
      );
      return slot && slot.value;
    }
  }
  if (toCache.length && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") {
        return 0;
      }
      if (codegenNode.patchFlag === void 0) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString$1(child) || isSymbol$1(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    case 20:
      return 2;
    default:
      return 0;
  }
}
const allowHoistedHelperSet = /* @__PURE__ */ new Set([
  NORMALIZE_CLASS,
  NORMALIZE_STYLE,
  NORMALIZE_PROPS,
  GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString$1(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}

function getSelfName(filename) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  return nameMatch ? capitalize(camelize(nameMatch[1])) : null;
}
function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic = false,
  hmr = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = NOOP,
  isCustomElement = NOOP,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const context = {
    // options
    filename,
    selfName: getSelfName(filename),
    prefixIdentifiers,
    hoistStatic,
    hmr,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    cached: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    grandParent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      {
        if (!context.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if (!context.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: NOOP,
    addIdentifiers(exp) {
      {
        if (isString$1(exp)) {
          addId(exp);
        } else if (exp.identifiers) {
          exp.identifiers.forEach(addId);
        } else if (exp.type === 4) {
          addId(exp.content);
        }
      }
    },
    removeIdentifiers(exp) {
      {
        if (isString$1(exp)) {
          removeId(exp);
        } else if (exp.identifiers) {
          exp.identifiers.forEach(removeId);
        } else if (exp.type === 4) {
          removeId(exp.content);
        }
      }
    },
    hoist(exp) {
      if (isString$1(exp)) exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        2
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false, inVOnce = false) {
      const cacheExp = createCacheExpression(
        context.cached.length,
        exp,
        isVNode,
        inVOnce
      );
      context.cached.push(cacheExp);
      return cacheExp;
    }
  };
  function addId(id) {
    const { identifiers } = context;
    if (identifiers[id] === void 0) {
      identifiers[id] = 0;
    }
    identifiers[id]++;
  }
  function removeId(id) {
    context.identifiers[id]--;
  }
  return context;
}
function transform$1(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    cacheStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  root.transformed = true;
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    if (children.filter((c) => c.type !== 3).length === 1) {
      patchFlag |= 2048;
    }
    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      void 0,
      root.children,
      patchFlag,
      void 0,
      void 0,
      true,
      void 0,
      false
    );
  } else ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString$1(child)) continue;
    context.grandParent = context.parent;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray$3(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    // for container types, further traverse downwards
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform$1(name, fn) {
  const matches = isString$1(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit) exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}

var sourceMap$1 = {};

var sourceMapGenerator$1 = {};

var base64Vlq$1 = {};

var base64$1 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBase64$1;

function requireBase64$1 () {
	if (hasRequiredBase64$1) return base64$1;
	hasRequiredBase64$1 = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	base64$1.encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	base64$1.decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};
	return base64$1;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBase64Vlq$1;

function requireBase64Vlq$1 () {
	if (hasRequiredBase64Vlq$1) return base64Vlq$1;
	hasRequiredBase64Vlq$1 = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	var base64 = /*@__PURE__*/ requireBase64$1();

	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	base64Vlq$1.encode = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	base64Vlq$1.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};
	return base64Vlq$1;
}

var util$2 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredUtil$2;

function requireUtil$2 () {
	if (hasRequiredUtil$2) return util$2;
	hasRequiredUtil$2 = 1;
	(function (exports) {
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		/**
		 * This is a helper function for getting values from parameter/options
		 * objects.
		 *
		 * @param args The object we are extracting values from
		 * @param name The name of the property we are getting.
		 * @param defaultValue An optional value to return if the property is missing
		 * from the object. If this is not specified and the property is missing, an
		 * error will be thrown.
		 */
		function getArg(aArgs, aName, aDefaultValue) {
		  if (aName in aArgs) {
		    return aArgs[aName];
		  } else if (arguments.length === 3) {
		    return aDefaultValue;
		  } else {
		    throw new Error('"' + aName + '" is a required argument.');
		  }
		}
		exports.getArg = getArg;

		var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
		var dataUrlRegexp = /^data:.+\,.+$/;

		function urlParse(aUrl) {
		  var match = aUrl.match(urlRegexp);
		  if (!match) {
		    return null;
		  }
		  return {
		    scheme: match[1],
		    auth: match[2],
		    host: match[3],
		    port: match[4],
		    path: match[5]
		  };
		}
		exports.urlParse = urlParse;

		function urlGenerate(aParsedUrl) {
		  var url = '';
		  if (aParsedUrl.scheme) {
		    url += aParsedUrl.scheme + ':';
		  }
		  url += '//';
		  if (aParsedUrl.auth) {
		    url += aParsedUrl.auth + '@';
		  }
		  if (aParsedUrl.host) {
		    url += aParsedUrl.host;
		  }
		  if (aParsedUrl.port) {
		    url += ":" + aParsedUrl.port;
		  }
		  if (aParsedUrl.path) {
		    url += aParsedUrl.path;
		  }
		  return url;
		}
		exports.urlGenerate = urlGenerate;

		var MAX_CACHED_INPUTS = 32;

		/**
		 * Takes some function `f(input) -> result` and returns a memoized version of
		 * `f`.
		 *
		 * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
		 * memoization is a dumb-simple, linear least-recently-used cache.
		 */
		function lruMemoize(f) {
		  var cache = [];

		  return function(input) {
		    for (var i = 0; i < cache.length; i++) {
		      if (cache[i].input === input) {
		        var temp = cache[0];
		        cache[0] = cache[i];
		        cache[i] = temp;
		        return cache[0].result;
		      }
		    }

		    var result = f(input);

		    cache.unshift({
		      input,
		      result,
		    });

		    if (cache.length > MAX_CACHED_INPUTS) {
		      cache.pop();
		    }

		    return result;
		  };
		}

		/**
		 * Normalizes a path, or the path portion of a URL:
		 *
		 * - Replaces consecutive slashes with one slash.
		 * - Removes unnecessary '.' parts.
		 * - Removes unnecessary '<dir>/..' parts.
		 *
		 * Based on code in the Node.js 'path' core module.
		 *
		 * @param aPath The path or url to normalize.
		 */
		var normalize = lruMemoize(function normalize(aPath) {
		  var path = aPath;
		  var url = urlParse(aPath);
		  if (url) {
		    if (!url.path) {
		      return aPath;
		    }
		    path = url.path;
		  }
		  var isAbsolute = exports.isAbsolute(path);
		  // Split the path into parts between `/` characters. This is much faster than
		  // using `.split(/\/+/g)`.
		  var parts = [];
		  var start = 0;
		  var i = 0;
		  while (true) {
		    start = i;
		    i = path.indexOf("/", start);
		    if (i === -1) {
		      parts.push(path.slice(start));
		      break;
		    } else {
		      parts.push(path.slice(start, i));
		      while (i < path.length && path[i] === "/") {
		        i++;
		      }
		    }
		  }

		  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
		    part = parts[i];
		    if (part === '.') {
		      parts.splice(i, 1);
		    } else if (part === '..') {
		      up++;
		    } else if (up > 0) {
		      if (part === '') {
		        // The first part is blank if the path is absolute. Trying to go
		        // above the root is a no-op. Therefore we can remove all '..' parts
		        // directly after the root.
		        parts.splice(i + 1, up);
		        up = 0;
		      } else {
		        parts.splice(i, 2);
		        up--;
		      }
		    }
		  }
		  path = parts.join('/');

		  if (path === '') {
		    path = isAbsolute ? '/' : '.';
		  }

		  if (url) {
		    url.path = path;
		    return urlGenerate(url);
		  }
		  return path;
		});
		exports.normalize = normalize;

		/**
		 * Joins two paths/URLs.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be joined with the root.
		 *
		 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
		 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
		 *   first.
		 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
		 *   is updated with the result and aRoot is returned. Otherwise the result
		 *   is returned.
		 *   - If aPath is absolute, the result is aPath.
		 *   - Otherwise the two paths are joined with a slash.
		 * - Joining for example 'http://' and 'www.example.com' is also supported.
		 */
		function join(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }
		  if (aPath === "") {
		    aPath = ".";
		  }
		  var aPathUrl = urlParse(aPath);
		  var aRootUrl = urlParse(aRoot);
		  if (aRootUrl) {
		    aRoot = aRootUrl.path || '/';
		  }

		  // `join(foo, '//www.example.org')`
		  if (aPathUrl && !aPathUrl.scheme) {
		    if (aRootUrl) {
		      aPathUrl.scheme = aRootUrl.scheme;
		    }
		    return urlGenerate(aPathUrl);
		  }

		  if (aPathUrl || aPath.match(dataUrlRegexp)) {
		    return aPath;
		  }

		  // `join('http://', 'www.example.com')`
		  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
		    aRootUrl.host = aPath;
		    return urlGenerate(aRootUrl);
		  }

		  var joined = aPath.charAt(0) === '/'
		    ? aPath
		    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

		  if (aRootUrl) {
		    aRootUrl.path = joined;
		    return urlGenerate(aRootUrl);
		  }
		  return joined;
		}
		exports.join = join;

		exports.isAbsolute = function (aPath) {
		  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
		};

		/**
		 * Make a path relative to a URL or another path.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be made relative to aRoot.
		 */
		function relative(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }

		  aRoot = aRoot.replace(/\/$/, '');

		  // It is possible for the path to be above the root. In this case, simply
		  // checking whether the root is a prefix of the path won't work. Instead, we
		  // need to remove components from the root one by one, until either we find
		  // a prefix that fits, or we run out of components to remove.
		  var level = 0;
		  while (aPath.indexOf(aRoot + '/') !== 0) {
		    var index = aRoot.lastIndexOf("/");
		    if (index < 0) {
		      return aPath;
		    }

		    // If the only part of the root that is left is the scheme (i.e. http://,
		    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
		    // have exhausted all components, so the path is not relative to the root.
		    aRoot = aRoot.slice(0, index);
		    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
		      return aPath;
		    }

		    ++level;
		  }

		  // Make sure we add a "../" for each component we removed from the root.
		  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
		}
		exports.relative = relative;

		var supportsNullProto = (function () {
		  var obj = Object.create(null);
		  return !('__proto__' in obj);
		}());

		function identity (s) {
		  return s;
		}

		/**
		 * Because behavior goes wacky when you set `__proto__` on objects, we
		 * have to prefix all the strings in our set with an arbitrary character.
		 *
		 * See https://github.com/mozilla/source-map/pull/31 and
		 * https://github.com/mozilla/source-map/issues/30
		 *
		 * @param String aStr
		 */
		function toSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return '$' + aStr;
		  }

		  return aStr;
		}
		exports.toSetString = supportsNullProto ? identity : toSetString;

		function fromSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return aStr.slice(1);
		  }

		  return aStr;
		}
		exports.fromSetString = supportsNullProto ? identity : fromSetString;

		function isProtoString(s) {
		  if (!s) {
		    return false;
		  }

		  var length = s.length;

		  if (length < 9 /* "__proto__".length */) {
		    return false;
		  }

		  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
		      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
		      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
		      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 9) !== 95  /* '_' */) {
		    return false;
		  }

		  for (var i = length - 10; i >= 0; i--) {
		    if (s.charCodeAt(i) !== 36 /* '$' */) {
		      return false;
		    }
		  }

		  return true;
		}

		/**
		 * Comparator between two mappings where the original positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same original source/line/column, but different generated
		 * line and column the same. Useful when searching for a mapping with a
		 * stubbed out mapping.
		 */
		function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
		  var cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0 || onlyCompareOriginal) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByOriginalPositions = compareByOriginalPositions;

		function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
		  var cmp;

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0 || onlyCompareOriginal) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;

		/**
		 * Comparator between two mappings with deflated source and name indices where
		 * the generated positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same generated line and column, but different
		 * source/name/original line and column the same. Useful when searching for a
		 * mapping with a stubbed out mapping.
		 */
		function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0 || onlyCompareGenerated) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

		function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
		  var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0 || onlyCompareGenerated) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;

		function strcmp(aStr1, aStr2) {
		  if (aStr1 === aStr2) {
		    return 0;
		  }

		  if (aStr1 === null) {
		    return 1; // aStr2 !== null
		  }

		  if (aStr2 === null) {
		    return -1; // aStr1 !== null
		  }

		  if (aStr1 > aStr2) {
		    return 1;
		  }

		  return -1;
		}

		/**
		 * Comparator between two mappings with inflated source and name strings where
		 * the generated positions are compared.
		 */
		function compareByGeneratedPositionsInflated(mappingA, mappingB) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

		/**
		 * Strip any JSON XSSI avoidance prefix from the string (as documented
		 * in the source maps specification), and then parse the string as
		 * JSON.
		 */
		function parseSourceMapInput(str) {
		  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
		}
		exports.parseSourceMapInput = parseSourceMapInput;

		/**
		 * Compute the URL of a source given the the source root, the source's
		 * URL, and the source map's URL.
		 */
		function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
		  sourceURL = sourceURL || '';

		  if (sourceRoot) {
		    // This follows what Chrome does.
		    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
		      sourceRoot += '/';
		    }
		    // The spec says:
		    //   Line 4: An optional source root, useful for relocating source
		    //   files on a server or removing repeated values in the
		    //   “sources” entry.  This value is prepended to the individual
		    //   entries in the “source” field.
		    sourceURL = sourceRoot + sourceURL;
		  }

		  // Historically, SourceMapConsumer did not take the sourceMapURL as
		  // a parameter.  This mode is still somewhat supported, which is why
		  // this code block is conditional.  However, it's preferable to pass
		  // the source map URL to SourceMapConsumer, so that this function
		  // can implement the source URL resolution algorithm as outlined in
		  // the spec.  This block is basically the equivalent of:
		  //    new URL(sourceURL, sourceMapURL).toString()
		  // ... except it avoids using URL, which wasn't available in the
		  // older releases of node still supported by this library.
		  //
		  // The spec says:
		  //   If the sources are not absolute URLs after prepending of the
		  //   “sourceRoot”, the sources are resolved relative to the
		  //   SourceMap (like resolving script src in a html document).
		  if (sourceMapURL) {
		    var parsed = urlParse(sourceMapURL);
		    if (!parsed) {
		      throw new Error("sourceMapURL could not be parsed");
		    }
		    if (parsed.path) {
		      // Strip the last path component, but keep the "/".
		      var index = parsed.path.lastIndexOf('/');
		      if (index >= 0) {
		        parsed.path = parsed.path.substring(0, index + 1);
		      }
		    }
		    sourceURL = join(urlGenerate(parsed), sourceURL);
		  }

		  return normalize(sourceURL);
		}
		exports.computeSourceURL = computeSourceURL; 
	} (util$2));
	return util$2;
}

var arraySet$1 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredArraySet$1;

function requireArraySet$1 () {
	if (hasRequiredArraySet$1) return arraySet$1;
	hasRequiredArraySet$1 = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = /*@__PURE__*/ requireUtil$2();
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	arraySet$1.ArraySet = ArraySet;
	return arraySet$1;
}

var mappingList$1 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredMappingList$1;

function requireMappingList$1 () {
	if (hasRequiredMappingList$1) return mappingList$1;
	hasRequiredMappingList$1 = 1;
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = /*@__PURE__*/ requireUtil$2();

	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	mappingList$1.MappingList = MappingList;
	return mappingList$1;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceMapGenerator$1;

function requireSourceMapGenerator$1 () {
	if (hasRequiredSourceMapGenerator$1) return sourceMapGenerator$1;
	hasRequiredSourceMapGenerator$1 = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var base64VLQ = /*@__PURE__*/ requireBase64Vlq$1();
	var util = /*@__PURE__*/ requireUtil$2();
	var ArraySet = /*@__PURE__*/ requireArraySet$1().ArraySet;
	var MappingList = /*@__PURE__*/ requireMappingList$1().MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._ignoreInvalidMapping = util.getArg(aArgs, 'ignoreInvalidMapping', false);
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  this._mappings = new MappingList();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    }));
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      if (this._validateMapping(generated, original, source, name) === false) {
	        return;
	      }
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet();
	    var newNames = new ArraySet();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	      var message = 'original.line and original.column are not numbers -- you probably meant to omit ' +
	      'the original mapping entirely and only map the generated position. If so, pass ' +
	      'null for the original mapping instead of an object with empty or null values.';

	      if (this._ignoreInvalidMapping) {
	        if (typeof console !== 'undefined' && console.warn) {
	          console.warn(message);
	        }
	        return false;
	      } else {
	        throw new Error(message);
	      }
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      var message = 'Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      });

	      if (this._ignoreInvalidMapping) {
	        if (typeof console !== 'undefined' && console.warn) {
	          console.warn(message);
	        }
	        return false;
	      } else {
	        throw new Error(message)
	      }
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64VLQ.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64VLQ.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64VLQ.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64VLQ.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64VLQ.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	sourceMapGenerator$1.SourceMapGenerator = SourceMapGenerator;
	return sourceMapGenerator$1;
}

var sourceMapConsumer$1 = {};

var binarySearch$1 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBinarySearch$1;

function requireBinarySearch$1 () {
	if (hasRequiredBinarySearch$1) return binarySearch$1;
	hasRequiredBinarySearch$1 = 1;
	(function (exports) {
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		exports.GREATEST_LOWER_BOUND = 1;
		exports.LEAST_UPPER_BOUND = 2;

		/**
		 * Recursive implementation of binary search.
		 *
		 * @param aLow Indices here and lower do not contain the needle.
		 * @param aHigh Indices here and higher do not contain the needle.
		 * @param aNeedle The element being searched for.
		 * @param aHaystack The non-empty array being searched.
		 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
		 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
		 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 */
		function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
		  // This function terminates when one of the following is true:
		  //
		  //   1. We find the exact element we are looking for.
		  //
		  //   2. We did not find the exact element, but we can return the index of
		  //      the next-closest element.
		  //
		  //   3. We did not find the exact element, and there is no next-closest
		  //      element than the one we are searching for, so we return -1.
		  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
		  var cmp = aCompare(aNeedle, aHaystack[mid], true);
		  if (cmp === 0) {
		    // Found the element we are looking for.
		    return mid;
		  }
		  else if (cmp > 0) {
		    // Our needle is greater than aHaystack[mid].
		    if (aHigh - mid > 1) {
		      // The element is in the upper half.
		      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
		    }

		    // The exact needle element was not found in this haystack. Determine if
		    // we are in termination case (3) or (2) and return the appropriate thing.
		    if (aBias == exports.LEAST_UPPER_BOUND) {
		      return aHigh < aHaystack.length ? aHigh : -1;
		    } else {
		      return mid;
		    }
		  }
		  else {
		    // Our needle is less than aHaystack[mid].
		    if (mid - aLow > 1) {
		      // The element is in the lower half.
		      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
		    }

		    // we are in termination case (3) or (2) and return the appropriate thing.
		    if (aBias == exports.LEAST_UPPER_BOUND) {
		      return mid;
		    } else {
		      return aLow < 0 ? -1 : aLow;
		    }
		  }
		}

		/**
		 * This is an implementation of binary search which will always try and return
		 * the index of the closest element if there is no exact hit. This is because
		 * mappings between original and generated line/col pairs are single points,
		 * and there is an implicit region between each of them, so a miss just means
		 * that you aren't on the very start of a region.
		 *
		 * @param aNeedle The element you are looking for.
		 * @param aHaystack The array that is being searched.
		 * @param aCompare A function which takes the needle and an element in the
		 *     array and returns -1, 0, or 1 depending on whether the needle is less
		 *     than, equal to, or greater than the element, respectively.
		 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
		 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
		 */
		exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
		  if (aHaystack.length === 0) {
		    return -1;
		  }

		  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
		                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
		  if (index < 0) {
		    return -1;
		  }

		  // We have found either the exact element, or the next-closest element than
		  // the one we are searching for. However, there may be more than one such
		  // element. Make sure we always return the smallest of these.
		  while (index - 1 >= 0) {
		    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
		      break;
		    }
		    --index;
		  }

		  return index;
		}; 
	} (binarySearch$1));
	return binarySearch$1;
}

var quickSort$1 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredQuickSort$1;

function requireQuickSort$1 () {
	if (hasRequiredQuickSort$1) return quickSort$1;
	hasRequiredQuickSort$1 = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.

	function SortTemplate(comparator) {

	/**
	 * Swap the elements indexed by `x` and `y` in the array `ary`.
	 *
	 * @param {Array} ary
	 *        The array.
	 * @param {Number} x
	 *        The index of the first item.
	 * @param {Number} y
	 *        The index of the second item.
	 */
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}

	/**
	 * Returns a random integer within the range `low .. high` inclusive.
	 *
	 * @param {Number} low
	 *        The lower bound on the range.
	 * @param {Number} high
	 *        The upper bound on the range.
	 */
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}

	/**
	 * The Quick Sort algorithm.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 * @param {Number} p
	 *        Start index of the array
	 * @param {Number} r
	 *        End index of the array
	 */
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.

	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.

	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;

	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];

	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot, false) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }

	    swap(ary, i + 1, j);
	    var q = i + 1;

	    // (2) Recurse on each half.

	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}

	  return doQuickSort;
	}

	function cloneSort(comparator) {
	  let template = SortTemplate.toString();
	  let templateFn = new Function(`return ${template}`)();
	  return templateFn(comparator);
	}

	/**
	 * Sort the given array in-place with the given comparator function.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 */

	let sortCache = new WeakMap();
	quickSort$1.quickSort = function (ary, comparator, start = 0) {
	  let doQuickSort = sortCache.get(comparator);
	  if (doQuickSort === void 0) {
	    doQuickSort = cloneSort(comparator);
	    sortCache.set(comparator, doQuickSort);
	  }
	  doQuickSort(ary, comparator, start, ary.length - 1);
	};
	return quickSort$1;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceMapConsumer$1;

function requireSourceMapConsumer$1 () {
	if (hasRequiredSourceMapConsumer$1) return sourceMapConsumer$1;
	hasRequiredSourceMapConsumer$1 = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = /*@__PURE__*/ requireUtil$2();
	var binarySearch = /*@__PURE__*/ requireBinarySearch$1();
	var ArraySet = /*@__PURE__*/ requireArraySet$1().ArraySet;
	var base64VLQ = /*@__PURE__*/ requireBase64Vlq$1();
	var quickSort = /*@__PURE__*/ requireQuickSort$1().quickSort;

	function SourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
	    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	}

	SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	};

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	SourceMapConsumer.prototype._version = 3;

	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.

	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__generatedMappings;
	  }
	});

	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__originalMappings;
	  }
	});

	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };

	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;

	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;

	/**
	 * Iterate over each mapping between an original source/line/column and a
	 * generated line/column in this source map.
	 *
	 * @param Function aCallback
	 *        The function that is called with each mapping.
	 * @param Object aContext
	 *        Optional. If specified, this object will be the value of `this` every
	 *        time that `aCallback` is called.
	 * @param aOrder
	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	 *        iterate over the mappings sorted by the generated file's line/column
	 *        order or the original's source/line/column order, respectively. Defaults to
	 *        `SourceMapConsumer.GENERATED_ORDER`.
	 */
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }

	    var sourceRoot = this.sourceRoot;
	    var boundCallback = aCallback.bind(context);
	    var names = this._names;
	    var sources = this._sources;
	    var sourceMapURL = this._sourceMapURL;

	    for (var i = 0, n = mappings.length; i < n; i++) {
	      var mapping = mappings[i];
	      var source = mapping.source === null ? null : sources.at(mapping.source);
	      if(source !== null) {
	        source = util.computeSourceURL(sourceRoot, source, sourceMapURL);
	      }
	      boundCallback({
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : names.at(mapping.name)
	      });
	    }
	  };

	/**
	 * Returns all generated line and column information for the original source,
	 * line, and column provided. If no column is provided, returns all mappings
	 * corresponding to a either the line we are searching for or the next
	 * closest line that has any mappings. Otherwise, returns all mappings
	 * corresponding to the given line and either the column we are searching for
	 * or the next closest column that has any offsets.
	 *
	 * The only argument is an object with the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number is 1-based.
	 *   - column: Optional. the column number in the original source.
	 *    The column number is 0-based.
	 *
	 * and an array of objects is returned, each with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *    line number is 1-based.
	 *   - column: The column number in the generated source, or null.
	 *    The column number is 0-based.
	 */
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');

	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };

	    needle.source = this._findSourceIndex(needle.source);
	    if (needle.source < 0) {
	      return [];
	    }

	    var mappings = [];

	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      }
	    }

	    return mappings;
	  };

	sourceMapConsumer$1.SourceMapConsumer = SourceMapConsumer;

	/**
	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
	 * query for information about the original file positions by giving it a file
	 * position in the generated source.
	 *
	 * The first parameter is the raw source map (either as a JSON string, or
	 * already parsed to an object). According to the spec, source maps have the
	 * following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - sources: An array of URLs to the original source files.
	 *   - names: An array of identifiers which can be referrenced by individual mappings.
	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
	 *   - sourcesContent: Optional. An array of contents of the original source files.
	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
	 *   - file: Optional. The generated file this source map is associated with.
	 *
	 * Here is an example source map, taken from the source map spec[0]:
	 *
	 *     {
	 *       version : 3,
	 *       file: "out.js",
	 *       sourceRoot : "",
	 *       sources: ["foo.js", "bar.js"],
	 *       names: ["src", "maps", "are", "fun"],
	 *       mappings: "AA,AB;;ABCDE;"
	 *     }
	 *
	 * The second parameter, if given, is a string whose value is the URL
	 * at which the source map was found.  This URL is used to compute the
	 * sources array.
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	 */
	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);

	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  if (sourceRoot) {
	    sourceRoot = util.normalize(sourceRoot);
	  }

	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });

	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet.fromArray(names.map(String), true);
	  this._sources = ArraySet.fromArray(sources, true);

	  this._absoluteSources = this._sources.toArray().map(function (s) {
	    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
	  });

	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this._sourceMapURL = aSourceMapURL;
	  this.file = file;
	}

	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

	/**
	 * Utility function to find the index of a source.  Returns -1 if not
	 * found.
	 */
	BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
	  var relativeSource = aSource;
	  if (this.sourceRoot != null) {
	    relativeSource = util.relative(this.sourceRoot, relativeSource);
	  }

	  if (this._sources.has(relativeSource)) {
	    return this._sources.indexOf(relativeSource);
	  }

	  // Maybe aSource is an absolute URL as returned by |sources|.  In
	  // this case we can't simply undo the transform.
	  var i;
	  for (i = 0; i < this._absoluteSources.length; ++i) {
	    if (this._absoluteSources[i] == aSource) {
	      return i;
	    }
	  }

	  return -1;
	};

	/**
	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	 *
	 * @param SourceMapGenerator aSourceMap
	 *        The source map that will be consumed.
	 * @param String aSourceMapURL
	 *        The URL at which the source map can be found (optional)
	 * @returns BasicSourceMapConsumer
	 */
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);

	    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;
	    smc._sourceMapURL = aSourceMapURL;
	    smc._absoluteSources = smc._sources.toArray().map(function (s) {
	      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
	    });

	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.

	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];

	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;

	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;

	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }

	        destOriginalMappings.push(destMapping);
	      }

	      destGeneratedMappings.push(destMapping);
	    }

	    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

	    return smc;
	  };

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	BasicSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._absoluteSources.slice();
	  }
	});

	/**
	 * Provide the JIT with a nice shape / hidden class.
	 */
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */

	const compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
	function sortGenerated(array, start) {
	  let l = array.length;
	  let n = array.length - start;
	  if (n <= 1) {
	    return;
	  } else if (n == 2) {
	    let a = array[start];
	    let b = array[start + 1];
	    if (compareGenerated(a, b) > 0) {
	      array[start] = b;
	      array[start + 1] = a;
	    }
	  } else if (n < 20) {
	    for (let i = start; i < l; i++) {
	      for (let j = i; j > start; j--) {
	        let a = array[j - 1];
	        let b = array[j];
	        if (compareGenerated(a, b) <= 0) {
	          break;
	        }
	        array[j - 1] = b;
	        array[j] = a;
	      }
	    }
	  } else {
	    quickSort(array, compareGenerated, start);
	  }
	}
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, segment, end, value;

	    let subarrayStart = 0;
	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;

	        sortGenerated(generatedMappings, subarrayStart);
	        subarrayStart = generatedMappings.length;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;

	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        aStr.slice(index, end);

	        segment = [];
	        while (index < end) {
	          base64VLQ.decode(aStr, index, temp);
	          value = temp.value;
	          index = temp.rest;
	          segment.push(value);
	        }

	        if (segment.length === 2) {
	          throw new Error('Found a source, but no line and column');
	        }

	        if (segment.length === 3) {
	          throw new Error('Found a source and line, but no column');
	        }

	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;

	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];

	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;

	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;

	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }

	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          let currentSource = mapping.source;
	          while (originalMappings.length <= currentSource) {
	            originalMappings.push(null);
	          }
	          if (originalMappings[currentSource] === null) {
	            originalMappings[currentSource] = [];
	          }
	          originalMappings[currentSource].push(mapping);
	        }
	      }
	    }

	    sortGenerated(generatedMappings, subarrayStart);
	    this.__generatedMappings = generatedMappings;

	    for (var i = 0; i < originalMappings.length; i++) {
	      if (originalMappings[i] != null) {
	        quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
	      }
	    }
	    this.__originalMappings = [].concat(...originalMappings);
	  };

	/**
	 * Find the mapping that best matches the hypothetical "needle" mapping that
	 * we are searching for in the given "haystack" of mappings.
	 */
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.

	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }

	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };

	/**
	 * Compute the last column for each generated mapping. The last column is
	 * inclusive.
	 */
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];

	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];

	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }

	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the generated source.  The column
	 *     number is 0-based.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the original source, or null.  The
	 *     column number is 0-based.
	 *   - name: The original identifier, or null.
	 */
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];

	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }

	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }

	    var index = this._findSourceIndex(aSource);
	    if (index >= 0) {
	      return this.sourcesContent[index];
	    }

	    var relativeSource = aSource;
	    if (this.sourceRoot != null) {
	      relativeSource = util.relative(this.sourceRoot, relativeSource);
	    }

	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }

	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + relativeSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
	      }
	    }

	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the original source.  The column
	 *     number is 0-based.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the generated source, or null.
	 *     The column number is 0-based.
	 */
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    source = this._findSourceIndex(source);
	    if (source < 0) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }

	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }

	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };

	sourceMapConsumer$1.BasicSourceMapConsumer = BasicSourceMapConsumer;

	/**
	 * An IndexedSourceMapConsumer instance represents a parsed source map which
	 * we can query for information. It differs from BasicSourceMapConsumer in
	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	 * input.
	 *
	 * The first parameter is a raw source map (either as a JSON string, or already
	 * parsed to an object). According to the spec for indexed source maps, they
	 * have the following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - file: Optional. The generated file this source map is associated with.
	 *   - sections: A list of section definitions.
	 *
	 * Each value under the "sections" field has two fields:
	 *   - offset: The offset into the original specified at which this section
	 *       begins to apply, defined as an object with a "line" and "column"
	 *       field.
	 *   - map: A source map definition. This source map could also be indexed,
	 *       but doesn't have to be.
	 *
	 * Instead of the "map" field, it's also possible to have a "url" field
	 * specifying a URL to retrieve a source map from, but that's currently
	 * unsupported.
	 *
	 * Here's an example source map, taken from the source map spec[0], but
	 * modified to omit a section which uses the "url" field.
	 *
	 *  {
	 *    version : 3,
	 *    file: "app.js",
	 *    sections: [{
	 *      offset: {line:100, column:10},
	 *      map: {
	 *        version : 3,
	 *        file: "section.js",
	 *        sources: ["foo.js", "bar.js"],
	 *        names: ["src", "maps", "are", "fun"],
	 *        mappings: "AAAA,E;;ABCDE;"
	 *      }
	 *    }],
	 *  }
	 *
	 * The second parameter, if given, is a string whose value is the URL
	 * at which the source map was found.  This URL is used to compute the
	 * sources array.
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	 */
	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');

	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  this._sources = new ArraySet();
	  this._names = new ArraySet();

	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');

	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;

	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
	    }
	  });
	}

	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	IndexedSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the generated source.  The column
	 *     number is 0-based.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the original source, or null.  The
	 *     column number is 0-based.
	 *   - name: The original identifier, or null.
	 */
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }

	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];

	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }

	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content || content === '') {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the original source.  The column
	 *     number is 0-based.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *     line number is 1-based. 
	 *   - column: The column number in the generated source, or null.
	 *     The column number is 0-based.
	 */
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }

	    return {
	      line: null,
	      column: null
	    };
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];

	        var source = section.consumer._sources.at(mapping.source);
	        if(source !== null) {
	          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
	        }
	        this._sources.add(source);
	        source = this._sources.indexOf(source);

	        var name = null;
	        if (mapping.name) {
	          name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	        }

	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };

	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }

	    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort(this.__originalMappings, util.compareByOriginalPositions);
	  };

	sourceMapConsumer$1.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	return sourceMapConsumer$1;
}

var sourceNode$1 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceNode$1;

function requireSourceNode$1 () {
	if (hasRequiredSourceNode$1) return sourceNode$1;
	hasRequiredSourceNode$1 = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var SourceMapGenerator = /*@__PURE__*/ requireSourceMapGenerator$1().SourceMapGenerator;
	var util = /*@__PURE__*/ requireUtil$2();

	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	// operating systems these days (capturing the result).
	var REGEX_NEWLINE = /(\r?\n)/;

	// Newline character code for charCodeAt() comparisons
	var NEWLINE_CODE = 10;

	// Private symbol for identifying `SourceNode`s when multiple versions of
	// the source-map library are loaded. This MUST NOT CHANGE across
	// versions!
	var isSourceNode = "$$$isSourceNode$$$";

	/**
	 * SourceNodes provide a way to abstract over interpolating/concatenating
	 * snippets of generated JavaScript source code while maintaining the line and
	 * column information associated with the original source code.
	 *
	 * @param aLine The original line number.
	 * @param aColumn The original column number.
	 * @param aSource The original source's filename.
	 * @param aChunks Optional. An array of strings which are snippets of
	 *        generated JS, or other SourceNodes.
	 * @param aName The original identifier.
	 */
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}

	/**
	 * Creates a SourceNode from generated code and a SourceMapConsumer.
	 *
	 * @param aGeneratedCode The generated code
	 * @param aSourceMapConsumer The SourceMap for the generated code
	 * @param aRelativePath Optional. The path that relative sources in the
	 *        SourceMapConsumer should be relative to.
	 */
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();

	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are accessed by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var remainingLinesIndex = 0;
	    var shiftNextLine = function() {
	      var lineContents = getNextLine();
	      // The last line of a file might not have a newline.
	      var newLine = getNextLine() || "";
	      return lineContents + newLine;

	      function getNextLine() {
	        return remainingLinesIndex < remainingLines.length ?
	            remainingLines[remainingLinesIndex++] : undefined;
	      }
	    };

	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;

	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[remainingLinesIndex] || '';
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[remainingLinesIndex] || '';
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLinesIndex < remainingLines.length) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.splice(remainingLinesIndex).join(""));
	    }

	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });

	    return node;

	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };

	/**
	 * Add a chunk of generated JS to this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Add a chunk of generated JS to the beginning of this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Walk over the tree of JS snippets in this node and its children. The
	 * walking function is called once for each snippet of JS and is passed that
	 * snippet and the its original associated source's line/column location.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};

	/**
	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	 * each of `this.children`.
	 *
	 * @param aSep The separator.
	 */
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};

	/**
	 * Call String.prototype.replace on the very right-most source snippet. Useful
	 * for trimming whitespace from the end of a source node, etc.
	 *
	 * @param aPattern The pattern to replace.
	 * @param aReplacement The thing to replace the pattern with.
	 */
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};

	/**
	 * Set the source content for a source file. This will be added to the SourceMapGenerator
	 * in the sourcesContent field.
	 *
	 * @param aSourceFile The filename of the source file
	 * @param aSourceContent The content of the source file
	 */
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };

	/**
	 * Walk over the tree of SourceNodes. The walking function is called for each
	 * source file content and is passed the filename and source content.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }

	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };

	/**
	 * Return the string representation of this source node. Walks over the tree
	 * and concatenates all the various snippets together to one string.
	 */
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};

	/**
	 * Returns the string representation of this source node along with a source
	 * map.
	 */
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        // Mappings end at eol
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });

	  return { code: generated.code, map: map };
	};

	sourceNode$1.SourceNode = SourceNode;
	return sourceNode$1;
}

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var hasRequiredSourceMap$1;

function requireSourceMap$1 () {
	if (hasRequiredSourceMap$1) return sourceMap$1;
	hasRequiredSourceMap$1 = 1;
	sourceMap$1.SourceMapGenerator = /*@__PURE__*/ requireSourceMapGenerator$1().SourceMapGenerator;
	sourceMap$1.SourceMapConsumer = /*@__PURE__*/ requireSourceMapConsumer$1().SourceMapConsumer;
	sourceMap$1.SourceNode = /*@__PURE__*/ requireSourceNode$1().SourceNode;
	return sourceMap$1;
}

var sourceMapExports = /*@__PURE__*/ requireSourceMap$1();

const PURE_ANNOTATION = `/*@__PURE__*/`;
const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
const NewlineType = {
  "Start": 0,
  "0": "Start",
  "End": -1,
  "-1": "End",
  "None": -2,
  "-2": "None",
  "Unknown": -3,
  "-3": "Unknown"
};
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, newlineIndex = -2, node) {
      context.code += code;
      if (context.map) {
        if (node) {
          let name;
          if (node.type === 4 && !node.isStatic) {
            const content = node.content.replace(/^_ctx\./, "");
            if (content !== node.content && isSimpleIdentifier(content)) {
              name = content;
            }
          }
          addMapping(node.loc.start, name);
        }
        if (newlineIndex === -3) {
          advancePositionWithMutation(context, code);
        } else {
          context.offset += code.length;
          if (newlineIndex === -2) {
            context.column += code.length;
          } else {
            if (newlineIndex === -1) {
              newlineIndex = code.length - 1;
            }
            context.line++;
            context.column = code.length - newlineIndex;
          }
        }
        if (node && node.loc !== locStub) {
          addMapping(node.loc.end);
        }
      }
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push("\n" + `  `.repeat(n), 0);
  }
  function addMapping(loc, name = null) {
    const { _names, _mappings } = context.map;
    if (name !== null && !_names.has(name)) _names.add(name);
    _mappings.add({
      originalLine: loc.line,
      originalColumn: loc.column - 1,
      // source-map column is 0 based
      generatedLine: context.line,
      generatedColumn: context.column - 1,
      source: filename,
      name
    });
  }
  if (sourceMap) {
    context.map = new sourceMapExports.SourceMapGenerator();
    context.map.setSourceContent(filename, context.source);
    context.map._sources.add(filename);
  }
  return context;
}
function generate$1(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated) options.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const genScopeId = scopeId != null && mode === "module";
  const isSetupInlined = !!options.inline;
  const preambleContext = isSetupInlined ? createCodegenContext(ast, options) : context;
  if (mode === "module") {
    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined);
  } else {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  if (options.bindingMetadata && !options.inline) {
    args.push("$props", "$setup", "$data", "$options");
  }
  const signature = options.isTS ? args.map((arg) => `${arg}: any`).join(",") : args.join(", ");
  if (isSetupInlined) {
    push(`(${signature}) => {`);
  } else {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(
        `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
        -1
      );
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`
`, 0);
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: isSetupInlined ? preambleContext.code : ``,
    map: context.map ? context.map.toJSON() : void 0,
    helpers: ast.helpers
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = ssr ? `require(${JSON.stringify(runtimeModuleName)})` : runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    if (prefixIdentifiers) {
      push(
        `const { ${helpers.map(aliasHelper).join(", ")} } = ${VueBinding}
`,
        -1
      );
    } else {
      push(`const _Vue = ${VueBinding}
`, -1);
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(`const { ${staticHelpers} } = _Vue
`, -1);
      }
    }
  }
  if (ast.ssrHelpers && ast.ssrHelpers.length) {
    push(
      `const { ${ast.ssrHelpers.map(aliasHelper).join(", ")} } = require("${ssrRuntimeModuleName}")
`,
      -1
    );
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genModulePreamble(ast, context, genScopeId, inline) {
  const {
    push,
    newline,
    optimizeImports,
    runtimeModuleName,
    ssrRuntimeModuleName
  } = context;
  if (ast.helpers.size) {
    const helpers = Array.from(ast.helpers);
    if (optimizeImports) {
      push(
        `import { ${helpers.map((s) => helperNameMap[s]).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`,
        -1
      );
      push(
        `
// Binding optimization for webpack code-split
const ${helpers.map((s) => `_${helperNameMap[s]} = ${helperNameMap[s]}`).join(", ")}
`,
        -1
      );
    } else {
      push(
        `import { ${helpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`,
        -1
      );
    }
  }
  if (ast.ssrHelpers && ast.ssrHelpers.length) {
    push(
      `import { ${ast.ssrHelpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(", ")} } from "${ssrRuntimeModuleName}"
`,
      -1
    );
  }
  if (ast.imports.length) {
    genImports(ast.imports, context);
    newline();
  }
  genHoists(ast.hoists, context);
  newline();
  if (!inline) {
    push(`export `);
  }
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(
    type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  );
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
    );
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = `);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function genImports(importsOptions, context) {
  if (!importsOptions.length) {
    return;
  }
  importsOptions.forEach((imports) => {
    context.push(`import `);
    genNode(imports.exp, context);
    context.push(` from '${imports.path}'`);
    context.newline();
  });
}
function isText(n) {
  return isString$1(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || nodes.some((n) => isArray$3(n) || !isText(n));
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString$1(node)) {
      push(node, -3);
    } else if (isArray$3(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString$1(node)) {
    context.push(node, -3);
    return;
  }
  if (isSymbol$1(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      assert(
        node.codegenNode != null,
        `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`
      );
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression$1(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    // SSR only types
    case 22:
      genTemplateLiteral(node, context);
      break;
    case 23:
      genIfStatement(node, context);
      break;
    case 24:
      genAssignmentExpression(node, context);
      break;
    case 25:
      genSequenceExpression(node, context);
      break;
    case 26:
      genReturnStatement(node, context);
      break;
    /* v8 ignore start */
    case 10:
      break;
    default:
      {
        assert(false, `unhandled codegen node type: ${node.type}`);
        const exhaustiveCheck = node;
        return exhaustiveCheck;
      }
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), -3, node);
}
function genExpression$1(node, context) {
  const { content, isStatic } = node;
  context.push(
    isStatic ? JSON.stringify(content) : content,
    -3,
    node
  );
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure) push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString$1(child)) {
      context.push(child, -3);
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, -2, node);
  } else {
    push(`[${node.content}]`, -3, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(
    `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
    -3,
    node
  );
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent
  } = node;
  let patchFlagString;
  if (patchFlag) {
    {
      if (patchFlag < 0) {
        patchFlagString = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
      } else {
        const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
        patchFlagString = patchFlag + ` /* ${flagNames} */`;
      }
    }
  }
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent) : getVNodeHelper(context.inSSR, isComponent);
  push(helper(callHelper) + `(`, -2, node);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlagString, dynamicProps]),
    context
  );
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null) break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString$1(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, -2, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, -2, node);
    return;
  }
  const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, -2, node);
  if (isArray$3(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray$3(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression$1(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(
    true
    /* without newline */
  );
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  const { needPauseTracking, needArraySpread } = node;
  if (needArraySpread) {
    push(`[...(`);
  }
  push(`_cache[${node.index}] || (`);
  if (needPauseTracking) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1`);
    if (node.inVOnce) push(`, true`);
    push(`),`);
    newline();
    push(`(`);
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (needPauseTracking) {
    push(`).cacheIndex = ${node.index},`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
  if (needArraySpread) {
    push(`)]`);
  }
}
function genTemplateLiteral(node, context) {
  const { push, indent, deindent } = context;
  push("`");
  const l = node.elements.length;
  const multilines = l > 3;
  for (let i = 0; i < l; i++) {
    const e = node.elements[i];
    if (isString$1(e)) {
      push(e.replace(/(`|\$|\\)/g, "\\$1"), -3);
    } else {
      push("${");
      if (multilines) indent();
      genNode(e, context);
      if (multilines) deindent();
      push("}");
    }
  }
  push("`");
}
function genIfStatement(node, context) {
  const { push, indent, deindent } = context;
  const { test, consequent, alternate } = node;
  push(`if (`);
  genNode(test, context);
  push(`) {`);
  indent();
  genNode(consequent, context);
  deindent();
  push(`}`);
  if (alternate) {
    push(` else `);
    if (alternate.type === 23) {
      genIfStatement(alternate, context);
    } else {
      push(`{`);
      indent();
      genNode(alternate, context);
      deindent();
      push(`}`);
    }
  }
}
function genAssignmentExpression(node, context) {
  genNode(node.left, context);
  context.push(` = `);
  genNode(node.right, context);
}
function genSequenceExpression(node, context) {
  context.push(`(`);
  genNodeList(node.expressions, context);
  context.push(`)`);
}
function genReturnStatement({ returns }, context) {
  context.push(`return `);
  if (isArray$3(returns)) {
    genNodeListAsArray(returns, context);
  } else {
    genNode(returns, context);
  }
}

const isLiteralWhitelisted = /* @__PURE__ */ makeMap("true,false,null,this");
const transformExpression = (node, context) => {
  if (node.type === 5) {
    node.content = processExpression(
      node.content,
      context
    );
  } else if (node.type === 1) {
    const memo = findDir$1(node, "memo");
    for (let i = 0; i < node.props.length; i++) {
      const dir = node.props[i];
      if (dir.type === 7 && dir.name !== "for") {
        const exp = dir.exp;
        const arg = dir.arg;
        if (exp && exp.type === 4 && !(dir.name === "on" && arg) && // key has been processed in transformFor(vMemo + vFor)
        !(memo && arg && arg.type === 4 && arg.content === "key")) {
          dir.exp = processExpression(
            exp,
            context,
            // slot args must be processed as function params
            dir.name === "slot"
          );
        }
        if (arg && arg.type === 4 && !arg.isStatic) {
          dir.arg = processExpression(arg, context);
        }
      }
    }
  }
};
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  if (!context.prefixIdentifiers || !node.content.trim()) {
    return node;
  }
  const { inline, bindingMetadata } = context;
  const rewriteIdentifier = (raw, parent, id) => {
    const type = hasOwn(bindingMetadata, raw) && bindingMetadata[raw];
    if (inline) {
      const isAssignmentLVal = parent && parent.type === "AssignmentExpression" && parent.left === id;
      const isUpdateArg = parent && parent.type === "UpdateExpression" && parent.argument === id;
      const isDestructureAssignment = parent && isInDestructureAssignment(parent, parentStack);
      const isNewExpression = parent && isInNewExpression(parentStack);
      const wrapWithUnref = (raw2) => {
        const wrapped = `${context.helperString(UNREF)}(${raw2})`;
        return isNewExpression ? `(${wrapped})` : wrapped;
      };
      if (isConst(type) || type === "setup-reactive-const" || localVars[raw]) {
        return raw;
      } else if (type === "setup-ref") {
        return `${raw}.value`;
      } else if (type === "setup-maybe-ref") {
        return isAssignmentLVal || isUpdateArg || isDestructureAssignment ? `${raw}.value` : wrapWithUnref(raw);
      } else if (type === "setup-let") {
        if (isAssignmentLVal) {
          const { right: rVal, operator } = parent;
          const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1);
          const rExpString = stringifyExpression(
            processExpression(
              createSimpleExpression(rExp, false),
              context,
              false,
              false,
              knownIds
            )
          );
          return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore
` : ``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`;
        } else if (isUpdateArg) {
          id.start = parent.start;
          id.end = parent.end;
          const { prefix: isPrefix, operator } = parent;
          const prefix = isPrefix ? operator : ``;
          const postfix = isPrefix ? `` : operator;
          return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore
` : ``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`;
        } else if (isDestructureAssignment) {
          return raw;
        } else {
          return wrapWithUnref(raw);
        }
      } else if (type === "props") {
        return genPropsAccessExp(raw);
      } else if (type === "props-aliased") {
        return genPropsAccessExp(bindingMetadata.__propsAliases[raw]);
      }
    } else {
      if (type && type.startsWith("setup") || type === "literal-const") {
        return `$setup.${raw}`;
      } else if (type === "props-aliased") {
        return `$props['${bindingMetadata.__propsAliases[raw]}']`;
      } else if (type) {
        return `$${type}.${raw}`;
      }
    }
    return `_ctx.${raw}`;
  };
  const rawExp = node.content;
  let ast = node.ast;
  if (ast === false) {
    return node;
  }
  if (ast === null || !ast && isSimpleIdentifier(rawExp)) {
    const isScopeVarReference = context.identifiers[rawExp];
    const isAllowedGlobal = isGloballyAllowed(rawExp);
    const isLiteral = isLiteralWhitelisted(rawExp);
    if (!asParams && !isScopeVarReference && !isLiteral && (!isAllowedGlobal || bindingMetadata[rawExp])) {
      if (isConst(bindingMetadata[rawExp])) {
        node.constType = 1;
      }
      node.content = rewriteIdentifier(rawExp);
    } else if (!isScopeVarReference) {
      if (isLiteral) {
        node.constType = 3;
      } else {
        node.constType = 2;
      }
    }
    return node;
  }
  if (!ast) {
    const source = asRawStatements ? ` ${rawExp} ` : `(${rawExp})${asParams ? `=>{}` : ``}`;
    try {
      ast = libExports.parseExpression(source, {
        sourceType: "module",
        plugins: context.expressionPlugins
      });
    } catch (e) {
      context.onError(
        createCompilerError(
          45,
          node.loc,
          void 0,
          e.message
        )
      );
      return node;
    }
  }
  const ids = [];
  const parentStack = [];
  const knownIds = Object.create(context.identifiers);
  walkIdentifiers(
    ast,
    (node2, parent, _, isReferenced, isLocal) => {
      if (isStaticPropertyKey(node2, parent)) {
        return;
      }
      const needPrefix = isReferenced && canPrefix$1(node2);
      if (needPrefix && !isLocal) {
        if (isStaticProperty(parent) && parent.shorthand) {
          node2.prefix = `${node2.name}: `;
        }
        node2.name = rewriteIdentifier(node2.name, parent, node2);
        ids.push(node2);
      } else {
        if (!(needPrefix && isLocal) && (!parent || parent.type !== "CallExpression" && parent.type !== "NewExpression" && parent.type !== "MemberExpression")) {
          node2.isConstant = true;
        }
        ids.push(node2);
      }
    },
    true,
    // invoke on ALL identifiers
    parentStack,
    knownIds
  );
  const children = [];
  ids.sort((a, b) => a.start - b.start);
  ids.forEach((id, i) => {
    const start = id.start - 1;
    const end = id.end - 1;
    const last = ids[i - 1];
    const leadingText = rawExp.slice(last ? last.end - 1 : 0, start);
    if (leadingText.length || id.prefix) {
      children.push(leadingText + (id.prefix || ``));
    }
    const source = rawExp.slice(start, end);
    children.push(
      createSimpleExpression(
        id.name,
        false,
        {
          start: advancePositionWithClone(node.loc.start, source, start),
          end: advancePositionWithClone(node.loc.start, source, end),
          source
        },
        id.isConstant ? 3 : 0
      )
    );
    if (i === ids.length - 1 && end < rawExp.length) {
      children.push(rawExp.slice(end));
    }
  });
  let ret;
  if (children.length) {
    ret = createCompoundExpression(children, node.loc);
    ret.ast = ast;
  } else {
    ret = node;
    ret.constType = 3;
  }
  ret.identifiers = Object.keys(knownIds);
  return ret;
}
function canPrefix$1(id) {
  if (isGloballyAllowed(id.name)) {
    return false;
  }
  if (id.name === "require") {
    return false;
  }
  return true;
}
function stringifyExpression(exp) {
  if (isString$1(exp)) {
    return exp;
  } else if (exp.type === 4) {
    return exp.content;
  } else {
    return exp.children.map(stringifyExpression).join("");
  }
}
function isConst(type) {
  return type === "setup-const" || type === "literal-const";
}

const transformIf = createStructuralDirectiveTransform$1(
  /^(if|else|else-if)$/,
  (node, dir, context) => {
    return processIf$1(node, dir, context, (ifNode, branch, isRoot) => {
      const siblings = context.parent.children;
      let i = siblings.indexOf(ifNode);
      let key = 0;
      while (i-- >= 0) {
        const sibling = siblings[i];
        if (sibling && sibling.type === 9) {
          key += sibling.branches.length;
        }
      }
      return () => {
        if (isRoot) {
          ifNode.codegenNode = createCodegenNodeForBranch(
            branch,
            key,
            context
          );
        } else {
          const parentCondition = getParentCondition(ifNode.codegenNode);
          parentCondition.alternate = createCodegenNodeForBranch(
            branch,
            key + ifNode.branches.length - 1,
            context
          );
        }
      };
    });
  }
);
function processIf$1(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (context.prefixIdentifiers && dir.exp) {
    dir.exp = processExpression(dir.exp, context);
  }
  if (dir.name === "if") {
    const branch = createIfBranch$1(node, dir);
    const ifNode = {
      type: 9,
      loc: cloneLoc(node.loc),
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        comments.unshift(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        context.removeNode();
        const branch = createIfBranch$1(node, dir);
        if (comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(context.parent && context.parent.type === 1 && (context.parent.tag === "transition" || context.parent.tag === "Transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        {
          const key = branch.userKey;
          if (key) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key)) {
                context.onError(
                  createCompilerError(
                    29,
                    branch.userKey.loc
                  )
                );
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit) onExit();
        context.currentNode = null;
      } else {
        context.onError(
          createCompilerError(30, node.loc)
        );
      }
      break;
    }
  }
}
function createIfBranch$1(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir$1(node, "for") ? node.children : [node],
    userKey: findProp$1(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context.helper(CREATE_COMMENT), [
        '"v-if"' ,
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      if (!branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
      }
      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag,
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}

const transformBind = (dir, _node, context) => {
  const { modifiers, loc } = dir;
  const arg = dir.arg;
  let { exp } = dir;
  if (exp && exp.type === 4 && !exp.content.trim()) {
    {
      context.onError(
        createCompilerError(34, loc)
      );
      return {
        props: [
          createObjectProperty(arg, createSimpleExpression("", true, loc))
        ]
      };
    }
  }
  if (!exp) {
    if (arg.type !== 4 || !arg.isStatic) {
      context.onError(
        createCompilerError(
          52,
          arg.loc
        )
      );
      return {
        props: [
          createObjectProperty(arg, createSimpleExpression("", true, loc))
        ]
      };
    }
    transformBindShorthand(dir, context);
    exp = dir.exp;
  }
  if (arg.type !== 4) {
    arg.children.unshift(`(`);
    arg.children.push(`) || ""`);
  } else if (!arg.isStatic) {
    arg.content = `${arg.content} || ""`;
  }
  if (modifiers.some((mod) => mod.content === "camel")) {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = camelize(arg.content);
      } else {
        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
      }
    } else {
      arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
      arg.children.push(`)`);
    }
  }
  if (!context.inSSR) {
    if (modifiers.some((mod) => mod.content === "prop")) {
      injectPrefix(arg, ".");
    }
    if (modifiers.some((mod) => mod.content === "attr")) {
      injectPrefix(arg, "^");
    }
  }
  return {
    props: [createObjectProperty(arg, exp)]
  };
};
const transformBindShorthand = (dir, context) => {
  const arg = dir.arg;
  const propName = camelize(arg.content);
  dir.exp = createSimpleExpression(propName, false, arg.loc);
  {
    dir.exp = processExpression(dir.exp, context);
  }
};
const injectPrefix = (arg, prefix) => {
  if (arg.type === 4) {
    if (arg.isStatic) {
      arg.content = prefix + arg.content;
    } else {
      arg.content = `\`${prefix}\${${arg.content}}\``;
    }
  } else {
    arg.children.unshift(`'${prefix}' + (`);
    arg.children.push(`)`);
  }
};

const transformFor = createStructuralDirectiveTransform$1(
  "for",
  (node, dir, context) => {
    const { helper, removeHelper } = context;
    return processFor$1(node, dir, context, (forNode) => {
      const renderExp = createCallExpression(helper(RENDER_LIST), [
        forNode.source
      ]);
      const isTemplate = isTemplateNode(node);
      const memo = findDir$1(node, "memo");
      const keyProp = findProp$1(node, `key`, false, true);
      const isDirKey = keyProp && keyProp.type === 7;
      if (isDirKey && !keyProp.exp) {
        transformBindShorthand(keyProp, context);
      }
      let keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
      if (memo && keyExp && isDirKey) {
        {
          keyProp.exp = keyExp = processExpression(
            keyExp,
            context
          );
        }
      }
      const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
      if (isTemplate) {
        if (memo) {
          memo.exp = processExpression(
            memo.exp,
            context
          );
        }
        if (keyProperty && keyProp.type !== 6) {
          keyProperty.value = processExpression(
            keyProperty.value,
            context
          );
        }
      }
      const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
      const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
      forNode.codegenNode = createVNodeCall(
        context,
        helper(FRAGMENT),
        void 0,
        renderExp,
        fragmentFlag,
        void 0,
        void 0,
        true,
        !isStableFragment,
        false,
        node.loc
      );
      return () => {
        let childBlock;
        const { children } = forNode;
        if (isTemplate) {
          node.children.some((c) => {
            if (c.type === 1) {
              const key = findProp$1(c, "key");
              if (key) {
                context.onError(
                  createCompilerError(
                    33,
                    key.loc
                  )
                );
                return true;
              }
            }
          });
        }
        const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
        const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
        if (slotOutlet) {
          childBlock = slotOutlet.codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
        } else if (needFragmentWrapper) {
          childBlock = createVNodeCall(
            context,
            helper(FRAGMENT),
            keyProperty ? createObjectExpression([keyProperty]) : void 0,
            node.children,
            64,
            void 0,
            void 0,
            true,
            void 0,
            false
          );
        } else {
          childBlock = children[0].codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
          if (childBlock.isBlock !== !isStableFragment) {
            if (childBlock.isBlock) {
              removeHelper(OPEN_BLOCK);
              removeHelper(
                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
              );
            } else {
              removeHelper(
                getVNodeHelper(context.inSSR, childBlock.isComponent)
              );
            }
          }
          childBlock.isBlock = !isStableFragment;
          if (childBlock.isBlock) {
            helper(OPEN_BLOCK);
            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
          } else {
            helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
          }
        }
        if (memo) {
          const loop = createFunctionExpression(
            createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ])
          );
          loop.body = createBlockStatement([
            createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
            createCompoundExpression([
              `if (_cached`,
              ...keyExp ? [` && _cached.key === `, keyExp] : [],
              ` && ${context.helperString(
                IS_MEMO_SAME
              )}(_cached, _memo)) return _cached`
            ]),
            createCompoundExpression([`const _item = `, childBlock]),
            createSimpleExpression(`_item.memo = _memo`),
            createSimpleExpression(`return _item`)
          ]);
          renderExp.arguments.push(
            loop,
            createSimpleExpression(`_cache`),
            createSimpleExpression(String(context.cached.length))
          );
          context.cached.push(null);
        } else {
          renderExp.arguments.push(
            createFunctionExpression(
              createForLoopParams(forNode.parseResult),
              childBlock,
              true
            )
          );
        }
      };
    });
  }
);
function processFor$1(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = dir.forParseResult;
  if (!parseResult) {
    context.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  finalizeForParseResult(parseResult, context);
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  if (context.prefixIdentifiers) {
    value && addIdentifiers(value);
    key && addIdentifiers(key);
    index && addIdentifiers(index);
  }
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (context.prefixIdentifiers) {
      value && removeIdentifiers(value);
      key && removeIdentifiers(key);
      index && removeIdentifiers(index);
    }
    if (onExit) onExit();
  };
}
function finalizeForParseResult(result, context) {
  if (result.finalized) return;
  if (context.prefixIdentifiers) {
    result.source = processExpression(
      result.source,
      context
    );
    if (result.key) {
      result.key = processExpression(
        result.key,
        context,
        true
      );
    }
    if (result.index) {
      result.index = processExpression(
        result.index,
        context,
        true
      );
    }
    if (result.value) {
      result.value = processExpression(
        result.value,
        context,
        true
      );
    }
  }
  result.finalized = true;
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i]) break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}

const defaultFallback = createSimpleExpression(`undefined`, false);
const trackSlotScopes = (node, context) => {
  if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
    const vSlot = findDir$1(node, "slot");
    if (vSlot) {
      const slotProps = vSlot.exp;
      if (context.prefixIdentifiers) {
        slotProps && context.addIdentifiers(slotProps);
      }
      context.scopes.vSlot++;
      return () => {
        if (context.prefixIdentifiers) {
          slotProps && context.removeIdentifiers(slotProps);
        }
        context.scopes.vSlot--;
      };
    }
  }
};
const trackVForSlotScopes = (node, context) => {
  let vFor;
  if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir$1(node, "for"))) {
    const result = vFor.forParseResult;
    if (result) {
      finalizeForParseResult(result, context);
      const { value, key, index } = result;
      const { addIdentifiers, removeIdentifiers } = context;
      value && addIdentifiers(value);
      key && addIdentifiers(key);
      index && addIdentifiers(index);
      return () => {
        value && removeIdentifiers(value);
        key && removeIdentifiers(key);
        index && removeIdentifiers(index);
      };
    }
  }
};
const buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
  props,
  children,
  false,
  true,
  children.length ? children[0].loc : loc
);
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  if (!context.ssr && context.prefixIdentifiers) {
    hasDynamicSlots = hasScopeRef(node, context.identifiers);
  }
  const onComponentSlot = findDir$1(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, void 0, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir$1(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(
        createCompilerError(37, slotDir.loc)
      );
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const vFor = findDir$1(slotElement, "for");
    const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
    let vIf;
    let vElse;
    if (vIf = findDir$1(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
          defaultFallback
        )
      );
    } else if (vElse = findDir$1(
      slotElement,
      /^else(-if)?$/,
      true
      /* allowEmpty */
    )) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir$1(prev, /^(else-)?if$/)) {
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(
          vElse.exp,
          buildDynamicSlot(
            slotName,
            slotFunction,
            conditionalBranchIndex++
          ),
          defaultFallback
        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(
          createCompilerError(30, vElse.loc)
        );
      }
    } else if (vFor) {
      hasDynamicSlots = true;
      const parseResult = vFor.forParseResult;
      if (parseResult) {
        finalizeForParseResult(parseResult, context);
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
            )
          ])
        );
      } else {
        context.onError(
          createCompilerError(
            32,
            vFor.loc
          )
        );
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(
            createCompilerError(
              38,
              dirLoc
            )
          );
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, void 0, children2, loc);
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some((node2) => isNonWhitespaceContent$1(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(
          createCompilerError(
            39,
            implicitDefaultChildren[0].loc
          )
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + (` /* ${slotFlagsText[slotFlag]} */` ),
          false
        )
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn, index) {
  const props = [
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ];
  if (index != null) {
    props.push(
      createObjectProperty(`key`, createSimpleExpression(String(index), true))
    );
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches)) return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children)) return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent$1(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent$1(node.content);
}

const directiveImportMap = /* @__PURE__ */ new WeakMap();
const transformElement$1 = (node, context) => {
  return function postTransformElement() {
    node = context.currentNode;
    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
      return;
    }
    const { tag, props } = node;
    const isComponent = node.tagType === 1;
    let vnodeTag = isComponent ? resolveComponentType(node, context) : `"${tag}"`;
    const isDynamicComponent = isObject$2(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    let vnodeProps;
    let vnodeChildren;
    let patchFlag = 0;
    let vnodeDynamicProps;
    let dynamicPropNames;
    let vnodeDirectives;
    let shouldUseBlock = (
      // dynamic component may resolve to plain elements
      isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent && // <svg> and <foreignObject> must be forced into blocks so that block
      // updates inside get proper isSVG flag at runtime. (#639, #643)
      // This is technically web-specific, but splitting the logic out of core
      // leads to too much unnecessary complexity.
      (tag === "svg" || tag === "foreignObject" || tag === "math")
    );
    if (props.length > 0) {
      const propsBuildResult = buildProps$1(
        node,
        context,
        void 0,
        isComponent,
        isDynamicComponent
      );
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      const directives = propsBuildResult.directives;
      vnodeDirectives = directives && directives.length ? createArrayExpression(
        directives.map((dir) => buildDirectiveArgs(dir, context))
      ) : void 0;
      if (propsBuildResult.shouldUseBlock) {
        shouldUseBlock = true;
      }
    }
    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        shouldUseBlock = true;
        patchFlag |= 1024;
        if (node.children.length > 1) {
          context.onError(
            createCompilerError(46, {
              start: node.children[0].loc.start,
              end: node.children[node.children.length - 1].loc.end,
              source: ""
            })
          );
        }
      }
      const shouldBuildAsSlots = isComponent && // Teleport is not a real component and has dedicated runtime handling
      vnodeTag !== TELEPORT && // explained above.
      vnodeTag !== KEEP_ALIVE;
      if (shouldBuildAsSlots) {
        const { slots, hasDynamicSlots } = buildSlots(node, context);
        vnodeChildren = slots;
        if (hasDynamicSlots) {
          patchFlag |= 1024;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        const child = node.children[0];
        const type = child.type;
        const hasDynamicTextChild = type === 5 || type === 8;
        if (hasDynamicTextChild && getConstantType(child, context) === 0) {
          patchFlag |= 1;
        }
        if (hasDynamicTextChild || type === 2) {
          vnodeChildren = child;
        } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    }
    if (dynamicPropNames && dynamicPropNames.length) {
      vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
    }
    node.codegenNode = createVNodeCall(
      context,
      vnodeTag,
      vnodeProps,
      vnodeChildren,
      patchFlag === 0 ? void 0 : patchFlag,
      vnodeDynamicProps,
      vnodeDirectives,
      !!shouldUseBlock,
      false,
      isComponent,
      node.loc
    );
  };
};
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag$1(tag);
  const isProp = findProp$1(
    node,
    "is",
    false,
    true
    /* allow empty */
  );
  if (isProp) {
    if (isExplicitDynamic || false) {
      let exp;
      if (isProp.type === 6) {
        exp = isProp.value && createSimpleExpression(isProp.value.content, true);
      } else {
        exp = isProp.exp;
        if (!exp) {
          exp = createSimpleExpression(`is`, false, isProp.arg.loc);
          {
            exp = isProp.exp = processExpression(exp, context);
          }
        }
      }
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr) context.helper(builtIn);
    return builtIn;
  }
  {
    const fromSetup = resolveSetupReference$1(tag, context);
    if (fromSetup) {
      return fromSetup;
    }
    const dotIndex = tag.indexOf(".");
    if (dotIndex > 0) {
      const ns = resolveSetupReference$1(tag.slice(0, dotIndex), context);
      if (ns) {
        return ns + tag.slice(dotIndex);
      }
    }
  }
  if (context.selfName && capitalize(camelize(tag)) === context.selfName) {
    context.helper(RESOLVE_COMPONENT);
    context.components.add(tag + `__self`);
    return toValidAssetId(tag, `component`);
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function resolveSetupReference$1(name, context) {
  const bindings = context.bindingMetadata;
  if (!bindings || bindings.__isScriptSetup === false) {
    return;
  }
  const camelName = camelize(name);
  const PascalName = capitalize(camelName);
  const checkType = (type) => {
    if (bindings[name] === type) {
      return name;
    }
    if (bindings[camelName] === type) {
      return camelName;
    }
    if (bindings[PascalName] === type) {
      return PascalName;
    }
  };
  const fromConst = checkType("setup-const") || checkType("setup-reactive-const") || checkType("literal-const");
  if (fromConst) {
    return context.inline ? (
      // in inline mode, const setup bindings (e.g. imports) can be used as-is
      fromConst
    ) : `$setup[${JSON.stringify(fromConst)}]`;
  }
  const fromMaybeRef = checkType("setup-let") || checkType("setup-ref") || checkType("setup-maybe-ref");
  if (fromMaybeRef) {
    return context.inline ? (
      // setup scope bindings that may be refs need to be unrefed
      `${context.helperString(UNREF)}(${fromMaybeRef})`
    ) : `$setup[${JSON.stringify(fromMaybeRef)}]`;
  }
  const fromProps = checkType("props");
  if (fromProps) {
    return `${context.helperString(UNREF)}(${context.inline ? "__props" : "$props"}[${JSON.stringify(fromProps)}])`;
  }
}
function buildProps$1(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties$1(properties), elementLoc)
      );
      properties = [];
    }
    if (arg) mergeArgs.push(arg);
  };
  const pushRefVForMarker = () => {
    if (context.scopes.vFor > 0) {
      properties.push(
        createObjectProperty(
          createSimpleExpression("ref_for", true),
          createSimpleExpression("true")
        )
      );
    }
  };
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (isEventHandler && (!isComponent || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== "onclick" && // omit v-model handlers
      name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !isReservedProp$1(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp$1(name)) {
        hasVnodeHook = true;
      }
      if (isEventHandler && value.type === 14) {
        value = value.arguments[0];
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, nameLoc, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        pushRefVForMarker();
        if (value && context.inline) {
          const binding = context.bindingMetadata[value.content];
          if (binding === "setup-let" || binding === "setup-ref" || binding === "setup-maybe-ref") {
            isStatic = false;
            properties.push(
              createObjectProperty(
                createSimpleExpression("ref_key", true),
                createSimpleExpression(value.content, true, value.loc)
              )
            );
          }
        }
      }
      if (name === "is" && (isComponentTag$1(tag) || value && value.content.startsWith("vue:") || false)) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(name, true, nameLoc),
          createSimpleExpression(
            value ? value.content : "",
            isStatic,
            value ? value.loc : loc
          )
        )
      );
    } else {
      const { name, arg, exp, loc, modifiers } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent) {
          context.onError(
            createCompilerError(40, loc)
          );
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag$1(tag) || false)) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref")) {
        pushRefVForMarker();
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            pushRefVForMarker();
            pushMergeArg();
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(
            createCompilerError(
              isVBind ? 34 : 35,
              loc
            )
          );
        }
        continue;
      }
      if (isVBind && modifiers.some((mod) => mod.content === "prop")) {
        patchFlag |= 32;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol$1(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties$1(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (styleProp && // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties$1(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    const fromSetup = resolveSetupReference$1("v-" + dir.name, context);
    if (fromSetup) {
      dirArgs.push(fromSetup);
    } else {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp) dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(
          (modifier) => createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1) propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag$1(tag) {
  return tag === "component" || tag === "Component";
}

const transformSlotOutlet$1 = (node, context) => {
  if (isSlotOutlet(node)) {
    const { children, loc } = node;
    const { slotName, slotProps } = processSlotOutlet(node, context);
    const slotArgs = [
      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
      slotName,
      "{}",
      "undefined",
      "true"
    ];
    let expectedLen = 2;
    if (slotProps) {
      slotArgs[2] = slotProps;
      expectedLen = 3;
    }
    if (children.length) {
      slotArgs[3] = createFunctionExpression([], children, false, false, loc);
      expectedLen = 4;
    }
    if (context.scopeId && !context.slotted) {
      expectedLen = 5;
    }
    slotArgs.splice(expectedLen);
    node.codegenNode = createCallExpression(
      context.helper(RENDER_SLOT),
      slotArgs,
      loc
    );
  }
};
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = camelize(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp) {
          slotName = p.exp;
        } else if (p.arg && p.arg.type === 4) {
          const name = camelize(p.arg.content);
          slotName = p.exp = createSimpleExpression(name, false, p.arg.loc);
          {
            slotName = p.exp = processExpression(p.exp, context);
          }
        }
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps$1(
      node,
      context,
      nonNameProps,
      false,
      false
    );
    slotProps = props;
    if (directives.length) {
      context.onError(
        createCompilerError(
          36,
          directives[0].loc
        )
      );
    }
  }
  return {
    slotName,
    slotProps
  };
}

const transformOn$1 = (dir, node, context, augmentor) => {
  const { loc, modifiers, arg } = dir;
  if (!dir.exp && !modifiers.length) {
    context.onError(createCompilerError(35, loc));
  }
  let eventName;
  if (arg.type === 4) {
    if (arg.isStatic) {
      let rawName = arg.content;
      if (rawName.startsWith("vnode")) {
        context.onError(createCompilerError(51, arg.loc));
      }
      if (rawName.startsWith("vue:")) {
        rawName = `vnode-${rawName.slice(4)}`;
      }
      const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        toHandlerKey(camelize(rawName))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${rawName}`
      );
      eventName = createSimpleExpression(eventString, true, arg.loc);
    } else {
      eventName = createCompoundExpression([
        `${context.helperString(TO_HANDLER_KEY)}(`,
        arg,
        `)`
      ]);
    }
  } else {
    eventName = arg;
    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
    eventName.children.push(`)`);
  }
  let exp = dir.exp;
  if (exp && !exp.content.trim()) {
    exp = void 0;
  }
  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
  if (exp) {
    const isMemberExp = isMemberExpression$1(exp, context);
    const isInlineStatement = !(isMemberExp || isFnExpression(exp, context));
    const hasMultipleStatements = exp.content.includes(`;`);
    if (context.prefixIdentifiers) {
      isInlineStatement && context.addIdentifiers(`$event`);
      exp = dir.exp = processExpression(
        exp,
        context,
        false,
        hasMultipleStatements
      );
      isInlineStatement && context.removeIdentifiers(`$event`);
      shouldCache = context.cacheHandlers && // unnecessary to cache inside v-once
      !context.inVOnce && // runtime constants don't need to be cached
      // (this is analyzed by compileScript in SFC <script setup>)
      !(exp.type === 4 && exp.constType > 0) && // #1541 bail if this is a member exp handler passed to a component -
      // we need to use the original function to preserve arity,
      // e.g. <transition> relies on checking cb.length to determine
      // transition end handling. Inline function is ok since its arity
      // is preserved even when cached.
      !(isMemberExp && node.tagType === 1) && // bail if the function references closure variables (v-for, v-slot)
      // it must be passed fresh to avoid stale values.
      !hasScopeRef(exp, context.identifiers);
      if (shouldCache && isMemberExp) {
        if (exp.type === 4) {
          exp.content = `${exp.content} && ${exp.content}(...args)`;
        } else {
          exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`];
        }
      }
    }
    if (isInlineStatement || shouldCache && isMemberExp) {
      exp = createCompoundExpression([
        `${isInlineStatement ? context.isTS ? `($event: any)` : `$event` : `${context.isTS ? `
//@ts-ignore
` : ``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
        exp,
        hasMultipleStatements ? `}` : `)`
      ]);
    }
  }
  let ret = {
    props: [
      createObjectProperty(
        eventName,
        exp || createSimpleExpression(`() => {}`, false, loc)
      )
    ]
  };
  if (augmentor) {
    ret = augmentor(ret);
  }
  if (shouldCache) {
    ret.props[0].value = context.cache(ret.props[0].value);
  }
  ret.props.forEach((p) => p.key.isHandlerKey = true);
  return ret;
};

const transformText$1 = (node, context) => {
  if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
    return () => {
      const children = node.children;
      let currentContainer = void 0;
      let hasText = false;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child)) {
          hasText = true;
          for (let j = i + 1; j < children.length; j++) {
            const next = children[j];
            if (isText$1(next)) {
              if (!currentContainer) {
                currentContainer = children[i] = createCompoundExpression(
                  [child],
                  child.loc
                );
              }
              currentContainer.children.push(` + `, next);
              children.splice(j, 1);
              j--;
            } else {
              currentContainer = void 0;
              break;
            }
          }
        }
      }
      if (!hasText || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !node.props.find(
        (p) => p.type === 7 && !context.directiveTransforms[p.name]
      ) && // in compat mode, <template> tags with no special directives
      // will be rendered as a fragment so its children must be
      // converted into vnodes.
      true)) {
        return;
      }
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child) || child.type === 8) {
          const callArgs = [];
          if (child.type !== 2 || child.content !== " ") {
            callArgs.push(child);
          }
          if (!context.ssr && getConstantType(child, context) === 0) {
            callArgs.push(
              1 + (` /* ${PatchFlagNames[1]} */` )
            );
          }
          children[i] = {
            type: 12,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(
              context.helper(CREATE_TEXT),
              callArgs
            )
          };
        }
      }
    };
  }
};

const seen$2 = /* @__PURE__ */ new WeakSet();
const transformOnce = (node, context) => {
  if (node.type === 1 && findDir$1(node, "once", true)) {
    if (seen$2.has(node) || context.inVOnce || context.inSSR) {
      return;
    }
    seen$2.add(node);
    context.inVOnce = true;
    context.helper(SET_BLOCK_TRACKING);
    return () => {
      context.inVOnce = false;
      const cur = context.currentNode;
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(
          cur.codegenNode,
          true,
          true
        );
      }
    };
  }
};

const transformModel$1 = (dir, node, context) => {
  const { exp, arg } = dir;
  if (!exp) {
    context.onError(
      createCompilerError(41, dir.loc)
    );
    return createTransformProps();
  }
  const rawExp = exp.loc.source.trim();
  const expString = exp.type === 4 ? exp.content : rawExp;
  const bindingType = context.bindingMetadata[rawExp];
  if (bindingType === "props" || bindingType === "props-aliased") {
    context.onError(createCompilerError(44, exp.loc));
    return createTransformProps();
  }
  const maybeRef = context.inline && (bindingType === "setup-let" || bindingType === "setup-ref" || bindingType === "setup-maybe-ref");
  if (!expString.trim() || !isMemberExpression$1(exp, context) && !maybeRef) {
    context.onError(
      createCompilerError(42, exp.loc)
    );
    return createTransformProps();
  }
  if (context.prefixIdentifiers && isSimpleIdentifier(expString) && context.identifiers[expString]) {
    context.onError(
      createCompilerError(43, exp.loc)
    );
    return createTransformProps();
  }
  const propName = arg ? arg : createSimpleExpression("modelValue", true);
  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
  let assignmentExp;
  const eventArg = context.isTS ? `($event: any)` : `$event`;
  if (maybeRef) {
    if (bindingType === "setup-ref") {
      assignmentExp = createCompoundExpression([
        `${eventArg} => ((`,
        createSimpleExpression(rawExp, false, exp.loc),
        `).value = $event)`
      ]);
    } else {
      const altAssignment = bindingType === "setup-let" ? `${rawExp} = $event` : `null`;
      assignmentExp = createCompoundExpression([
        `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,
        createSimpleExpression(rawExp, false, exp.loc),
        `).value = $event : ${altAssignment})`
      ]);
    }
  } else {
    assignmentExp = createCompoundExpression([
      `${eventArg} => ((`,
      exp,
      `) = $event)`
    ]);
  }
  const props = [
    // modelValue: foo
    createObjectProperty(propName, dir.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    createObjectProperty(eventName, assignmentExp)
  ];
  if (context.prefixIdentifiers && !context.inVOnce && context.cacheHandlers && !hasScopeRef(exp, context.identifiers)) {
    props[1].value = context.cache(props[1].value);
  }
  if (dir.modifiers.length && node.tagType === 1) {
    const modifiers = dir.modifiers.map((m) => m.content).map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
    props.push(
      createObjectProperty(
        modifiersKey,
        createSimpleExpression(
          `{ ${modifiers} }`,
          false,
          dir.loc,
          2
        )
      )
    );
  }
  return createTransformProps(props);
};
function createTransformProps(props = []) {
  return { props };
}

const seen$1 = /* @__PURE__ */ new WeakSet();
const transformMemo = (node, context) => {
  if (node.type === 1) {
    const dir = findDir$1(node, "memo");
    if (!dir || seen$1.has(node)) {
      return;
    }
    seen$1.add(node);
    return () => {
      const codegenNode = node.codegenNode || context.currentNode.codegenNode;
      if (codegenNode && codegenNode.type === 13) {
        if (node.tagType !== 1) {
          convertToBlock(codegenNode, context);
        }
        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
          dir.exp,
          createFunctionExpression(void 0, codegenNode),
          `_cache`,
          String(context.cached.length)
        ]);
        context.cached.push(null);
      }
    };
  }
};

function getBaseTransformPreset$1(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[],
      ...prefixIdentifiers ? [
        // order is important
        trackVForSlotScopes,
        transformExpression
      ] : [],
      transformSlotOutlet$1,
      transformElement$1,
      trackSlotScopes,
      transformText$1
    ],
    {
      on: transformOn$1,
      bind: transformBind,
      model: transformModel$1
    }
  ];
}
function baseCompile(source, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  const prefixIdentifiers = options.prefixIdentifiers === true || isModuleMode;
  if (!prefixIdentifiers && options.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const resolvedOptions = extend({}, options, {
    prefixIdentifiers
  });
  const ast = isString$1(source) ? baseParse(source, resolvedOptions) : source;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset$1(prefixIdentifiers);
  if (options.isTS) {
    const { expressionPlugins } = options;
    if (!expressionPlugins || !expressionPlugins.includes("typescript")) {
      options.expressionPlugins = [...expressionPlugins || [], "typescript"];
    }
  }
  transform$1(
    ast,
    extend({}, resolvedOptions, {
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate$1(ast, resolvedOptions);
}

const BindingTypes = {
  "DATA": "data",
  "PROPS": "props",
  "PROPS_ALIASED": "props-aliased",
  "SETUP_LET": "setup-let",
  "SETUP_CONST": "setup-const",
  "SETUP_REACTIVE_CONST": "setup-reactive-const",
  "SETUP_MAYBE_REF": "setup-maybe-ref",
  "SETUP_REF": "setup-ref",
  "OPTIONS": "options",
  "LITERAL_CONST": "literal-const"
};

const noopDirectiveTransform = () => ({ props: [] });

const V_MODEL_RADIO = Symbol(`vModelRadio` );
const V_MODEL_CHECKBOX = Symbol(
  `vModelCheckbox` 
);
const V_MODEL_TEXT = Symbol(`vModelText` );
const V_MODEL_SELECT = Symbol(
  `vModelSelect` 
);
const V_MODEL_DYNAMIC = Symbol(
  `vModelDynamic` 
);
const V_ON_WITH_MODIFIERS = Symbol(
  `vOnModifiersGuard` 
);
const V_ON_WITH_KEYS = Symbol(
  `vOnKeysGuard` 
);
const V_SHOW = Symbol(`vShow` );
const TRANSITION = Symbol(`Transition` );
const TRANSITION_GROUP = Symbol(
  `TransitionGroup` 
);
registerRuntimeHelpers({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [TRANSITION]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
});

const parserOptions = {
  parseMode: "html",
  isVoidTag,
  isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
  isPreTag: (tag) => tag === "pre",
  isIgnoreNewlineTag: (tag) => tag === "pre" || tag === "textarea",
  decodeEntities: void 0,
  isBuiltInComponent: (tag) => {
    if (tag === "Transition" || tag === "transition") {
      return TRANSITION;
    } else if (tag === "TransitionGroup" || tag === "transition-group") {
      return TRANSITION_GROUP;
    }
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(tag, parent, rootNamespace) {
    let ns = parent ? parent.ns : rootNamespace;
    if (parent && ns === 2) {
      if (parent.tag === "annotation-xml") {
        if (tag === "svg") {
          return 1;
        }
        if (parent.props.some(
          (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
        )) {
          ns = 0;
        }
      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
        ns = 0;
      }
    } else if (parent && ns === 1) {
      if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
        ns = 0;
      }
    }
    if (ns === 0) {
      if (tag === "svg") {
        return 1;
      }
      if (tag === "math") {
        return 2;
      }
    }
    return ns;
  }
};

const transformStyle = (node) => {
  if (node.type === 1) {
    node.props.forEach((p, i) => {
      if (p.type === 6 && p.name === "style" && p.value) {
        node.props[i] = {
          type: 7,
          name: `bind`,
          arg: createSimpleExpression(`style`, true, p.loc),
          exp: parseInlineCSS(p.value.content, p.loc),
          modifiers: [],
          loc: p.loc
        };
      }
    });
  }
};
const parseInlineCSS = (cssText, loc) => {
  const normalized = parseStringStyle(cssText);
  return createSimpleExpression(
    JSON.stringify(normalized),
    false,
    loc,
    3
  );
};

function createDOMCompilerError(code, loc) {
  return createCompilerError(
    code,
    loc,
    DOMErrorMessages 
  );
}
const DOMErrorCodes = {
  "X_V_HTML_NO_EXPRESSION": 53,
  "53": "X_V_HTML_NO_EXPRESSION",
  "X_V_HTML_WITH_CHILDREN": 54,
  "54": "X_V_HTML_WITH_CHILDREN",
  "X_V_TEXT_NO_EXPRESSION": 55,
  "55": "X_V_TEXT_NO_EXPRESSION",
  "X_V_TEXT_WITH_CHILDREN": 56,
  "56": "X_V_TEXT_WITH_CHILDREN",
  "X_V_MODEL_ON_INVALID_ELEMENT": 57,
  "57": "X_V_MODEL_ON_INVALID_ELEMENT",
  "X_V_MODEL_ARG_ON_ELEMENT": 58,
  "58": "X_V_MODEL_ARG_ON_ELEMENT",
  "X_V_MODEL_ON_FILE_INPUT_ELEMENT": 59,
  "59": "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
  "X_V_MODEL_UNNECESSARY_VALUE": 60,
  "60": "X_V_MODEL_UNNECESSARY_VALUE",
  "X_V_SHOW_NO_EXPRESSION": 61,
  "61": "X_V_SHOW_NO_EXPRESSION",
  "X_TRANSITION_INVALID_CHILDREN": 62,
  "62": "X_TRANSITION_INVALID_CHILDREN",
  "X_IGNORED_SIDE_EFFECT_TAG": 63,
  "63": "X_IGNORED_SIDE_EFFECT_TAG",
  "__EXTEND_POINT__": 64,
  "64": "__EXTEND_POINT__"
};
const DOMErrorMessages = {
  [53]: `v-html is missing expression.`,
  [54]: `v-html will override element children.`,
  [55]: `v-text is missing expression.`,
  [56]: `v-text will override element children.`,
  [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
  [58]: `v-model argument is not supported on plain elements.`,
  [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
  [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
  [61]: `v-show is missing expression.`,
  [62]: `<Transition> expects exactly one child element or component.`,
  [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`,
  // just to fulfill types
  [64]: ``
};

const transformVHtml$1 = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(53, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(54, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`innerHTML`, true, loc),
        exp || createSimpleExpression("", true)
      )
    ]
  };
};

const transformVText$1 = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(55, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(56, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`textContent`, true),
        exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(
          context.helperString(TO_DISPLAY_STRING),
          [exp],
          loc
        ) : createSimpleExpression("", true)
      )
    ]
  };
};

const transformModel = (dir, node, context) => {
  const baseResult = transformModel$1(dir, node, context);
  if (!baseResult.props.length || node.tagType === 1) {
    return baseResult;
  }
  if (dir.arg) {
    context.onError(
      createDOMCompilerError(
        58,
        dir.arg.loc
      )
    );
  }
  function checkDuplicatedValue() {
    const value = findDir$1(node, "bind");
    if (value && isStaticArgOf(value.arg, "value")) {
      context.onError(
        createDOMCompilerError(
          60,
          value.loc
        )
      );
    }
  }
  const { tag } = node;
  const isCustomElement = context.isCustomElement(tag);
  if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
    let directiveToUse = V_MODEL_TEXT;
    let isInvalidType = false;
    if (tag === "input" || isCustomElement) {
      const type = findProp$1(node, `type`);
      if (type) {
        if (type.type === 7) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else if (type.value) {
          switch (type.value.content) {
            case "radio":
              directiveToUse = V_MODEL_RADIO;
              break;
            case "checkbox":
              directiveToUse = V_MODEL_CHECKBOX;
              break;
            case "file":
              isInvalidType = true;
              context.onError(
                createDOMCompilerError(
                  59,
                  dir.loc
                )
              );
              break;
            default:
              checkDuplicatedValue();
              break;
          }
        }
      } else if (hasDynamicKeyVBind(node)) {
        directiveToUse = V_MODEL_DYNAMIC;
      } else {
        checkDuplicatedValue();
      }
    } else if (tag === "select") {
      directiveToUse = V_MODEL_SELECT;
    } else {
      checkDuplicatedValue();
    }
    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse);
    }
  } else {
    context.onError(
      createDOMCompilerError(
        57,
        dir.loc
      )
    );
  }
  baseResult.props = baseResult.props.filter(
    (p) => !(p.key.type === 4 && p.key.content === "modelValue")
  );
  return baseResult;
};

const isEventOptionModifier = /* @__PURE__ */ makeMap(`passive,once,capture`);
const isNonKeyModifier = /* @__PURE__ */ makeMap(
  // event propagation management
  `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
);
const maybeKeyModifier = /* @__PURE__ */ makeMap("left,right");
const isKeyboardEvent = /* @__PURE__ */ makeMap(`onkeyup,onkeydown,onkeypress`);
const resolveModifiers = (key, modifiers, context, loc) => {
  const keyModifiers = [];
  const nonKeyModifiers = [];
  const eventOptionModifiers = [];
  for (let i = 0; i < modifiers.length; i++) {
    const modifier = modifiers[i].content;
    if (isEventOptionModifier(modifier)) {
      eventOptionModifiers.push(modifier);
    } else {
      const keyString = isString$1(key) ? key : isStaticExp(key) ? key.content : null;
      if (maybeKeyModifier(modifier)) {
        if (keyString) {
          if (isKeyboardEvent(keyString.toLowerCase())) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }
  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  };
};
const transformClick = (key, event) => {
  const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
  return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
    `(`,
    key,
    `) === "onClick" ? "${event}" : (`,
    key,
    `)`
  ]) : key;
};
const transformOn = (dir, node, context) => {
  return transformOn$1(dir, node, context, (baseResult) => {
    const { modifiers } = dir;
    if (!modifiers.length) return baseResult;
    let { key, value: handlerExp } = baseResult.props[0];
    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
    if (nonKeyModifiers.includes("right")) {
      key = transformClick(key, `onContextmenu`);
    }
    if (nonKeyModifiers.includes("middle")) {
      key = transformClick(key, `onMouseup`);
    }
    if (nonKeyModifiers.length) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
        handlerExp,
        JSON.stringify(nonKeyModifiers)
      ]);
    }
    if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
    (!isStaticExp(key) || isKeyboardEvent(key.content.toLowerCase()))) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
        handlerExp,
        JSON.stringify(keyModifiers)
      ]);
    }
    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
      key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
    }
    return {
      props: [createObjectProperty(key, handlerExp)]
    };
  });
};

const transformShow = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(61, loc)
    );
  }
  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  };
};

const transformTransition = (node, context) => {
  if (node.type === 1 && node.tagType === 1) {
    const component = context.isBuiltInComponent(node.tag);
    if (component === TRANSITION) {
      return () => {
        if (!node.children.length) {
          return;
        }
        if (hasMultipleChildren(node)) {
          context.onError(
            createDOMCompilerError(
              62,
              {
                start: node.children[0].loc.start,
                end: node.children[node.children.length - 1].loc.end,
                source: ""
              }
            )
          );
        }
        const child = node.children[0];
        if (child.type === 1) {
          for (const p of child.props) {
            if (p.type === 7 && p.name === "show") {
              node.props.push({
                type: 6,
                name: "persisted",
                nameLoc: node.loc,
                value: void 0,
                loc: node.loc
              });
            }
          }
        }
      };
    }
  }
};
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter(
    (c) => c.type !== 3 && !(c.type === 2 && !c.content.trim())
  );
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}

const expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;
const stringifyStatic = (children, context, parent) => {
  if (context.scopes.vSlot > 0) {
    return;
  }
  const isParentCached = parent.type === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !isArray$3(parent.codegenNode.children) && parent.codegenNode.children.type === 20;
  let nc = 0;
  let ec = 0;
  const currentChunk = [];
  const stringifyCurrentChunk = (currentIndex) => {
    if (nc >= 20 || ec >= 5) {
      const staticCall = createCallExpression(context.helper(CREATE_STATIC), [
        JSON.stringify(
          currentChunk.map((node) => stringifyNode(node, context)).join("")
        ).replace(expReplaceRE, `" + $1 + "`),
        // the 2nd argument indicates the number of DOM nodes this static vnode
        // will insert / hydrate
        String(currentChunk.length)
      ]);
      const deleteCount = currentChunk.length - 1;
      if (isParentCached) {
        children.splice(
          currentIndex - currentChunk.length,
          currentChunk.length,
          // @ts-expect-error
          staticCall
        );
      } else {
        currentChunk[0].codegenNode.value = staticCall;
        if (currentChunk.length > 1) {
          children.splice(currentIndex - currentChunk.length + 1, deleteCount);
          const cacheIndex = context.cached.indexOf(
            currentChunk[currentChunk.length - 1].codegenNode
          );
          if (cacheIndex > -1) {
            for (let i2 = cacheIndex; i2 < context.cached.length; i2++) {
              const c = context.cached[i2];
              if (c) c.index -= deleteCount;
            }
            context.cached.splice(cacheIndex - deleteCount + 1, deleteCount);
          }
        }
      }
      return deleteCount;
    }
    return 0;
  };
  let i = 0;
  for (; i < children.length; i++) {
    const child = children[i];
    const isCached = isParentCached || getCachedNode(child);
    if (isCached) {
      const result = analyzeNode(child);
      if (result) {
        nc += result[0];
        ec += result[1];
        currentChunk.push(child);
        continue;
      }
    }
    i -= stringifyCurrentChunk(i);
    nc = 0;
    ec = 0;
    currentChunk.length = 0;
  }
  stringifyCurrentChunk(i);
};
const getCachedNode = (node) => {
  if ((node.type === 1 && node.tagType === 0 || node.type === 12) && node.codegenNode && node.codegenNode.type === 20) {
    return node.codegenNode;
  }
};
const dataAriaRE = /^(data|aria)-/;
const isStringifiableAttr = (name, ns) => {
  return (ns === 0 ? isKnownHtmlAttr(name) : ns === 1 ? isKnownSvgAttr(name) : ns === 2 ? isKnownMathMLAttr(name) : false) || dataAriaRE.test(name);
};
const isNonStringifiable = /* @__PURE__ */ makeMap(
  `caption,thead,tr,th,tbody,td,tfoot,colgroup,col`
);
function analyzeNode(node) {
  if (node.type === 1 && isNonStringifiable(node.tag)) {
    return false;
  }
  if (node.type === 12) {
    return [1, 0];
  }
  let nc = 1;
  let ec = node.props.length > 0 ? 1 : 0;
  let bailed = false;
  const bail = () => {
    bailed = true;
    return false;
  };
  function walk(node2) {
    const isOptionTag = node2.tag === "option" && node2.ns === 0;
    for (let i = 0; i < node2.props.length; i++) {
      const p = node2.props[i];
      if (p.type === 6 && !isStringifiableAttr(p.name, node2.ns)) {
        return bail();
      }
      if (p.type === 7 && p.name === "bind") {
        if (p.arg && (p.arg.type === 8 || p.arg.isStatic && !isStringifiableAttr(p.arg.content, node2.ns))) {
          return bail();
        }
        if (p.exp && (p.exp.type === 8 || p.exp.constType < 3)) {
          return bail();
        }
        if (isOptionTag && isStaticArgOf(p.arg, "value") && p.exp && !p.exp.isStatic) {
          return bail();
        }
      }
    }
    for (let i = 0; i < node2.children.length; i++) {
      nc++;
      const child = node2.children[i];
      if (child.type === 1) {
        if (child.props.length > 0) {
          ec++;
        }
        walk(child);
        if (bailed) {
          return false;
        }
      }
    }
    return true;
  }
  return walk(node) ? [nc, ec] : false;
}
function stringifyNode(node, context) {
  if (isString$1(node)) {
    return node;
  }
  if (isSymbol$1(node)) {
    return ``;
  }
  switch (node.type) {
    case 1:
      return stringifyElement(node, context);
    case 2:
      return escapeHtml(node.content);
    case 3:
      return `<!--${escapeHtml(node.content)}-->`;
    case 5:
      return escapeHtml(toDisplayString(evaluateConstant(node.content)));
    case 8:
      return escapeHtml(evaluateConstant(node));
    case 12:
      return stringifyNode(node.content, context);
    default:
      return "";
  }
}
function stringifyElement(node, context) {
  let res = `<${node.tag}`;
  let innerHTML = "";
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      res += ` ${p.name}`;
      if (p.value) {
        res += `="${escapeHtml(p.value.content)}"`;
      }
    } else if (p.type === 7) {
      if (p.name === "bind") {
        const exp = p.exp;
        if (exp.content[0] === "_") {
          res += ` ${p.arg.content}="__VUE_EXP_START__${exp.content}__VUE_EXP_END__"`;
          continue;
        }
        if (isBooleanAttr(p.arg.content) && exp.content === "false") {
          continue;
        }
        let evaluated = evaluateConstant(exp);
        if (evaluated != null) {
          const arg = p.arg && p.arg.content;
          if (arg === "class") {
            evaluated = normalizeClass(evaluated);
          } else if (arg === "style") {
            evaluated = stringifyStyle(normalizeStyle(evaluated));
          }
          res += ` ${p.arg.content}="${escapeHtml(
            evaluated
          )}"`;
        }
      } else if (p.name === "html") {
        innerHTML = evaluateConstant(p.exp);
      } else if (p.name === "text") {
        innerHTML = escapeHtml(
          toDisplayString(evaluateConstant(p.exp))
        );
      }
    }
  }
  if (context.scopeId) {
    res += ` ${context.scopeId}`;
  }
  res += `>`;
  if (innerHTML) {
    res += innerHTML;
  } else {
    for (let i = 0; i < node.children.length; i++) {
      res += stringifyNode(node.children[i], context);
    }
  }
  if (!isVoidTag(node.tag)) {
    res += `</${node.tag}>`;
  }
  return res;
}
function evaluateConstant(exp) {
  if (exp.type === 4) {
    return new Function(`return (${exp.content})`)();
  } else {
    let res = ``;
    exp.children.forEach((c) => {
      if (isString$1(c) || isSymbol$1(c)) {
        return;
      }
      if (c.type === 2) {
        res += c.content;
      } else if (c.type === 5) {
        res += toDisplayString(evaluateConstant(c.content));
      } else {
        res += evaluateConstant(c);
      }
    });
    return res;
  }
}

const ignoreSideEffectTags = (node, context) => {
  if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
    context.onError(
      createDOMCompilerError(
        63,
        node.loc
      )
    );
    context.removeNode();
  }
};

function isValidHTMLNesting(parent, child) {
  if (parent in onlyValidChildren) {
    return onlyValidChildren[parent].has(child);
  }
  if (child in onlyValidParents) {
    return onlyValidParents[child].has(parent);
  }
  if (parent in knownInvalidChildren) {
    if (knownInvalidChildren[parent].has(child)) return false;
  }
  if (child in knownInvalidParents) {
    if (knownInvalidParents[child].has(parent)) return false;
  }
  return true;
}
const headings = /* @__PURE__ */ new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);
const emptySet = /* @__PURE__ */ new Set([]);
const onlyValidChildren = {
  head: /* @__PURE__ */ new Set([
    "base",
    "basefront",
    "bgsound",
    "link",
    "meta",
    "title",
    "noscript",
    "noframes",
    "style",
    "script",
    "template"
  ]),
  optgroup: /* @__PURE__ */ new Set(["option"]),
  select: /* @__PURE__ */ new Set(["optgroup", "option", "hr"]),
  // table
  table: /* @__PURE__ */ new Set(["caption", "colgroup", "tbody", "tfoot", "thead"]),
  tr: /* @__PURE__ */ new Set(["td", "th"]),
  colgroup: /* @__PURE__ */ new Set(["col"]),
  tbody: /* @__PURE__ */ new Set(["tr"]),
  thead: /* @__PURE__ */ new Set(["tr"]),
  tfoot: /* @__PURE__ */ new Set(["tr"]),
  // these elements can not have any children elements
  script: emptySet,
  iframe: emptySet,
  option: emptySet,
  textarea: emptySet,
  style: emptySet,
  title: emptySet
};
const onlyValidParents = {
  // sections
  html: emptySet,
  body: /* @__PURE__ */ new Set(["html"]),
  head: /* @__PURE__ */ new Set(["html"]),
  // table
  td: /* @__PURE__ */ new Set(["tr"]),
  colgroup: /* @__PURE__ */ new Set(["table"]),
  caption: /* @__PURE__ */ new Set(["table"]),
  tbody: /* @__PURE__ */ new Set(["table"]),
  tfoot: /* @__PURE__ */ new Set(["table"]),
  col: /* @__PURE__ */ new Set(["colgroup"]),
  th: /* @__PURE__ */ new Set(["tr"]),
  thead: /* @__PURE__ */ new Set(["table"]),
  tr: /* @__PURE__ */ new Set(["tbody", "thead", "tfoot"]),
  // data list
  dd: /* @__PURE__ */ new Set(["dl", "div"]),
  dt: /* @__PURE__ */ new Set(["dl", "div"]),
  // other
  figcaption: /* @__PURE__ */ new Set(["figure"]),
  // li: new Set(["ul", "ol"]),
  summary: /* @__PURE__ */ new Set(["details"]),
  area: /* @__PURE__ */ new Set(["map"])
};
const knownInvalidChildren = {
  p: /* @__PURE__ */ new Set([
    "address",
    "article",
    "aside",
    "blockquote",
    "center",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "fieldset",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "hr",
    "li",
    "main",
    "nav",
    "menu",
    "ol",
    "p",
    "pre",
    "section",
    "table",
    "ul"
  ]),
  svg: /* @__PURE__ */ new Set([
    "b",
    "blockquote",
    "br",
    "code",
    "dd",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "i",
    "img",
    "li",
    "menu",
    "meta",
    "ol",
    "p",
    "pre",
    "ruby",
    "s",
    "small",
    "span",
    "strong",
    "sub",
    "sup",
    "table",
    "u",
    "ul",
    "var"
  ])
};
const knownInvalidParents = {
  a: /* @__PURE__ */ new Set(["a"]),
  button: /* @__PURE__ */ new Set(["button"]),
  dd: /* @__PURE__ */ new Set(["dd", "dt"]),
  dt: /* @__PURE__ */ new Set(["dd", "dt"]),
  form: /* @__PURE__ */ new Set(["form"]),
  li: /* @__PURE__ */ new Set(["li"]),
  h1: headings,
  h2: headings,
  h3: headings,
  h4: headings,
  h5: headings,
  h6: headings
};

const validateHtmlNesting = (node, context) => {
  if (node.type === 1 && node.tagType === 0 && context.parent && context.parent.type === 1 && context.parent.tagType === 0 && !isValidHTMLNesting(context.parent.tag, node.tag)) {
    const error = new SyntaxError(
      `<${node.tag}> cannot be child of <${context.parent.tag}>, according to HTML specifications. This can cause hydration errors or potentially disrupt future functionality.`
    );
    error.loc = node.loc;
    context.onWarn(error);
  }
};

const DOMNodeTransforms = [
  transformStyle,
  ...[transformTransition, validateHtmlNesting] 
];
const DOMDirectiveTransforms = {
  cloak: noopDirectiveTransform,
  html: transformVHtml$1,
  text: transformVText$1,
  model: transformModel,
  // override compiler-core
  on: transformOn,
  // override compiler-core
  show: transformShow
};
function compile$2(src, options = {}) {
  return baseCompile(
    src,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: stringifyStatic
    })
  );
}
function parse$3(template, options = {}) {
  return baseParse(template, extend({}, parserOptions, options));
}

var CompilerDOM = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BASE_TRANSITION: BASE_TRANSITION,
  BindingTypes: BindingTypes,
  CAMELIZE: CAMELIZE,
  CAPITALIZE: CAPITALIZE,
  CREATE_BLOCK: CREATE_BLOCK,
  CREATE_COMMENT: CREATE_COMMENT,
  CREATE_ELEMENT_BLOCK: CREATE_ELEMENT_BLOCK,
  CREATE_ELEMENT_VNODE: CREATE_ELEMENT_VNODE,
  CREATE_SLOTS: CREATE_SLOTS,
  CREATE_STATIC: CREATE_STATIC,
  CREATE_TEXT: CREATE_TEXT,
  CREATE_VNODE: CREATE_VNODE,
  CompilerDeprecationTypes: CompilerDeprecationTypes,
  ConstantTypes: ConstantTypes,
  DOMDirectiveTransforms: DOMDirectiveTransforms,
  DOMErrorCodes: DOMErrorCodes,
  DOMErrorMessages: DOMErrorMessages,
  DOMNodeTransforms: DOMNodeTransforms,
  ElementTypes: ElementTypes,
  ErrorCodes: ErrorCodes,
  FRAGMENT: FRAGMENT,
  GUARD_REACTIVE_PROPS: GUARD_REACTIVE_PROPS,
  IS_MEMO_SAME: IS_MEMO_SAME,
  IS_REF: IS_REF,
  KEEP_ALIVE: KEEP_ALIVE,
  MERGE_PROPS: MERGE_PROPS,
  NORMALIZE_CLASS: NORMALIZE_CLASS,
  NORMALIZE_PROPS: NORMALIZE_PROPS,
  NORMALIZE_STYLE: NORMALIZE_STYLE,
  Namespaces: Namespaces,
  NewlineType: NewlineType,
  NodeTypes: NodeTypes,
  OPEN_BLOCK: OPEN_BLOCK,
  POP_SCOPE_ID: POP_SCOPE_ID,
  PUSH_SCOPE_ID: PUSH_SCOPE_ID,
  RENDER_LIST: RENDER_LIST,
  RENDER_SLOT: RENDER_SLOT,
  RESOLVE_COMPONENT: RESOLVE_COMPONENT,
  RESOLVE_DIRECTIVE: RESOLVE_DIRECTIVE,
  RESOLVE_DYNAMIC_COMPONENT: RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_FILTER: RESOLVE_FILTER,
  SET_BLOCK_TRACKING: SET_BLOCK_TRACKING,
  SUSPENSE: SUSPENSE,
  TELEPORT: TELEPORT,
  TO_DISPLAY_STRING: TO_DISPLAY_STRING,
  TO_HANDLERS: TO_HANDLERS,
  TO_HANDLER_KEY: TO_HANDLER_KEY,
  TRANSITION: TRANSITION,
  TRANSITION_GROUP: TRANSITION_GROUP,
  TS_NODE_TYPES: TS_NODE_TYPES,
  UNREF: UNREF,
  V_MODEL_CHECKBOX: V_MODEL_CHECKBOX,
  V_MODEL_DYNAMIC: V_MODEL_DYNAMIC,
  V_MODEL_RADIO: V_MODEL_RADIO,
  V_MODEL_SELECT: V_MODEL_SELECT,
  V_MODEL_TEXT: V_MODEL_TEXT,
  V_ON_WITH_KEYS: V_ON_WITH_KEYS,
  V_ON_WITH_MODIFIERS: V_ON_WITH_MODIFIERS,
  V_SHOW: V_SHOW,
  WITH_CTX: WITH_CTX,
  WITH_DIRECTIVES: WITH_DIRECTIVES,
  WITH_MEMO: WITH_MEMO,
  advancePositionWithClone: advancePositionWithClone,
  advancePositionWithMutation: advancePositionWithMutation,
  assert: assert,
  baseCompile: baseCompile,
  baseParse: baseParse,
  buildDirectiveArgs: buildDirectiveArgs,
  buildProps: buildProps$1,
  buildSlots: buildSlots,
  checkCompatEnabled: checkCompatEnabled,
  compile: compile$2,
  convertToBlock: convertToBlock,
  createArrayExpression: createArrayExpression,
  createAssignmentExpression: createAssignmentExpression,
  createBlockStatement: createBlockStatement,
  createCacheExpression: createCacheExpression,
  createCallExpression: createCallExpression,
  createCompilerError: createCompilerError,
  createCompoundExpression: createCompoundExpression,
  createConditionalExpression: createConditionalExpression,
  createDOMCompilerError: createDOMCompilerError,
  createForLoopParams: createForLoopParams,
  createFunctionExpression: createFunctionExpression,
  createIfStatement: createIfStatement,
  createInterpolation: createInterpolation,
  createObjectExpression: createObjectExpression,
  createObjectProperty: createObjectProperty,
  createReturnStatement: createReturnStatement,
  createRoot: createRoot,
  createSequenceExpression: createSequenceExpression,
  createSimpleExpression: createSimpleExpression,
  createStructuralDirectiveTransform: createStructuralDirectiveTransform$1,
  createTemplateLiteral: createTemplateLiteral,
  createTransformContext: createTransformContext,
  createVNodeCall: createVNodeCall,
  defaultOnError: defaultOnError,
  defaultOnWarn: defaultOnWarn,
  errorMessages: errorMessages$1,
  extractIdentifiers: extractIdentifiers$1,
  findDir: findDir$1,
  findProp: findProp$1,
  forAliasRE: forAliasRE,
  generate: generate$1,
  generateCodeFrame: generateCodeFrame,
  getBaseTransformPreset: getBaseTransformPreset$1,
  getConstantType: getConstantType,
  getMemoedVNodeCall: getMemoedVNodeCall,
  getSelfName: getSelfName,
  getVNodeBlockHelper: getVNodeBlockHelper,
  getVNodeHelper: getVNodeHelper,
  hasDynamicKeyVBind: hasDynamicKeyVBind,
  hasScopeRef: hasScopeRef,
  helperNameMap: helperNameMap,
  injectProp: injectProp,
  isConstantNode: isConstantNode,
  isCoreComponent: isCoreComponent,
  isFnExpression: isFnExpression,
  isFnExpressionBrowser: isFnExpressionBrowser,
  isFnExpressionNode: isFnExpressionNode,
  isFunctionType: isFunctionType,
  isInDestructureAssignment: isInDestructureAssignment,
  isInNewExpression: isInNewExpression,
  isLiteralWhitelisted: isLiteralWhitelisted,
  isMemberExpression: isMemberExpression$1,
  isMemberExpressionBrowser: isMemberExpressionBrowser,
  isMemberExpressionNode: isMemberExpressionNode,
  isReferencedIdentifier: isReferencedIdentifier,
  isSimpleIdentifier: isSimpleIdentifier,
  isSlotOutlet: isSlotOutlet,
  isStaticArgOf: isStaticArgOf,
  isStaticExp: isStaticExp,
  isStaticNode: isStaticNode,
  isStaticProperty: isStaticProperty,
  isStaticPropertyKey: isStaticPropertyKey,
  isTemplateNode: isTemplateNode,
  isText: isText$1,
  isVSlot: isVSlot,
  isValidHTMLNesting: isValidHTMLNesting,
  locStub: locStub,
  noopDirectiveTransform: noopDirectiveTransform,
  parse: parse$3,
  parserOptions: parserOptions,
  processExpression: processExpression,
  processFor: processFor$1,
  processIf: processIf$1,
  processSlotOutlet: processSlotOutlet,
  registerRuntimeHelpers: registerRuntimeHelpers,
  resolveComponentType: resolveComponentType,
  resolveModifiers: resolveModifiers,
  stringifyExpression: stringifyExpression,
  toValidAssetId: toValidAssetId,
  trackSlotScopes: trackSlotScopes,
  trackVForSlotScopes: trackVForSlotScopes,
  transform: transform$1,
  transformBind: transformBind,
  transformElement: transformElement$1,
  transformExpression: transformExpression,
  transformModel: transformModel$1,
  transformOn: transformOn$1,
  transformStyle: transformStyle,
  traverseNode: traverseNode,
  unwrapTSNode: unwrapTSNode,
  walkBlockDeclarations: walkBlockDeclarations,
  walkFunctionParams: walkFunctionParams,
  walkIdentifiers: walkIdentifiers,
  warnDeprecation: warnDeprecation
});

var hashSum;
var hasRequiredHashSum;

function requireHashSum () {
	if (hasRequiredHashSum) return hashSum;
	hasRequiredHashSum = 1;

	function pad (hash, len) {
	  while (hash.length < len) {
	    hash = '0' + hash;
	  }
	  return hash;
	}

	function fold (hash, text) {
	  var i;
	  var chr;
	  var len;
	  if (text.length === 0) {
	    return hash;
	  }
	  for (i = 0, len = text.length; i < len; i++) {
	    chr = text.charCodeAt(i);
	    hash = ((hash << 5) - hash) + chr;
	    hash |= 0;
	  }
	  return hash < 0 ? hash * -2 : hash;
	}

	function foldObject (hash, o, seen) {
	  return Object.keys(o).sort().reduce(foldKey, hash);
	  function foldKey (hash, key) {
	    return foldValue(hash, o[key], key, seen);
	  }
	}

	function foldValue (input, value, key, seen) {
	  var hash = fold(fold(fold(input, key), toString(value)), typeof value);
	  if (value === null) {
	    return fold(hash, 'null');
	  }
	  if (value === undefined) {
	    return fold(hash, 'undefined');
	  }
	  if (typeof value === 'object' || typeof value === 'function') {
	    if (seen.indexOf(value) !== -1) {
	      return fold(hash, '[Circular]' + key);
	    }
	    seen.push(value);

	    var objHash = foldObject(hash, value, seen);

	    if (!('valueOf' in value) || typeof value.valueOf !== 'function') {
	      return objHash;
	    }

	    try {
	      return fold(objHash, String(value.valueOf()))
	    } catch (err) {
	      return fold(objHash, '[valueOf exception]' + (err.stack || err.message))
	    }
	  }
	  return fold(hash, value.toString());
	}

	function toString (o) {
	  return Object.prototype.toString.call(o);
	}

	function sum (o) {
	  return pad(foldValue(0, o, '', []).toString(16), 8);
	}

	hashSum = sum;
	return hashSum;
}

var hashSumExports = /*@__PURE__*/ requireHashSum();
var hash = /*@__PURE__*/getDefaultExportFromCjs(hashSumExports);

const CSS_VARS_HELPER = `useCssVars`;
function genCssVarsFromList(vars, id, isProd, isSSR = false) {
  return `{
  ${vars.map(
    (key) => `"${isSSR ? `--` : ``}${genVarName$1(id, key, isProd, isSSR)}": (${key})`
  ).join(",\n  ")}
}`;
}
function genVarName$1(id, raw, isProd, isSSR = false) {
  if (isProd) {
    return hash(id + raw);
  } else {
    return `${id}-${getEscapedCssVarName(raw, isSSR)}`;
  }
}
function normalizeExpression(exp) {
  exp = exp.trim();
  if (exp[0] === `'` && exp[exp.length - 1] === `'` || exp[0] === `"` && exp[exp.length - 1] === `"`) {
    return exp.slice(1, -1);
  }
  return exp;
}
const vBindRE = /v-bind\s*\(/g;
function parseCssVars(sfc) {
  const vars = [];
  sfc.styles.forEach((style) => {
    let match;
    const content = style.content.replace(/\/\*([\s\S]*?)\*\/|\/\/.*/g, "");
    while (match = vBindRE.exec(content)) {
      const start = match.index + match[0].length;
      const end = lexBinding(content, start);
      if (end !== null) {
        const variable = normalizeExpression(content.slice(start, end));
        if (!vars.includes(variable)) {
          vars.push(variable);
        }
      }
    }
  });
  return vars;
}
function lexBinding(content, start) {
  let state = 0 /* inParens */;
  let parenDepth = 0;
  for (let i = start; i < content.length; i++) {
    const char = content.charAt(i);
    switch (state) {
      case 0 /* inParens */:
        if (char === `'`) {
          state = 1 /* inSingleQuoteString */;
        } else if (char === `"`) {
          state = 2 /* inDoubleQuoteString */;
        } else if (char === `(`) {
          parenDepth++;
        } else if (char === `)`) {
          if (parenDepth > 0) {
            parenDepth--;
          } else {
            return i;
          }
        }
        break;
      case 1 /* inSingleQuoteString */:
        if (char === `'`) {
          state = 0 /* inParens */;
        }
        break;
      case 2 /* inDoubleQuoteString */:
        if (char === `"`) {
          state = 0 /* inParens */;
        }
        break;
    }
  }
  return null;
}
const cssVarsPlugin = (opts) => {
  const { id, isProd } = opts;
  return {
    postcssPlugin: "vue-sfc-vars",
    Declaration(decl) {
      const value = decl.value;
      if (vBindRE.test(value)) {
        vBindRE.lastIndex = 0;
        let transformed = "";
        let lastIndex = 0;
        let match;
        while (match = vBindRE.exec(value)) {
          const start = match.index + match[0].length;
          const end = lexBinding(value, start);
          if (end !== null) {
            const variable = normalizeExpression(value.slice(start, end));
            transformed += value.slice(lastIndex, match.index) + `var(--${genVarName$1(id, variable, isProd)})`;
            lastIndex = end + 1;
          }
        }
        decl.value = transformed + value.slice(lastIndex);
      }
    }
  };
};
cssVarsPlugin.postcss = true;
function genCssVarsCode(vars, bindings, id, isProd) {
  const varsExp = genCssVarsFromList(vars, id, isProd);
  const exp = createSimpleExpression(varsExp, false);
  const context = createTransformContext(createRoot([]), {
    prefixIdentifiers: true,
    inline: true,
    bindingMetadata: bindings.__isScriptSetup === false ? void 0 : bindings
  });
  const transformed = processExpression(exp, context);
  const transformedString = transformed.type === 4 ? transformed.content : transformed.children.map((c) => {
    return typeof c === "string" ? c : c.content;
  }).join("");
  return `_${CSS_VARS_HELPER}(_ctx => (${transformedString}))`;
}
function genNormalScriptCssVarsCode(cssVars, bindings, id, isProd, defaultVar) {
  return `
import { ${CSS_VARS_HELPER} as _${CSS_VARS_HELPER} } from 'vue'
const __injectCSSVars__ = () => {
${genCssVarsCode(
    cssVars,
    bindings,
    id,
    isProd
  )}}
const __setup__ = ${defaultVar}.setup
${defaultVar}.setup = __setup__
  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }
  : __injectCSSVars__
`;
}

var global$1 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser = true;
var env = {};
var argv = [];
var version$1 = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config = {};

function noop() {}

var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var browser$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env,
  argv: argv,
  version: version$1,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};

function createCache(max = 500) {
  {
    return /* @__PURE__ */ new Map();
  }
}

function isImportUsed(local, sfc) {
  return resolveTemplateUsedIdentifiers(sfc).has(local);
}
const templateUsageCheckCache = createCache();
function resolveTemplateUsedIdentifiers(sfc) {
  const { content, ast } = sfc.template;
  const cached = templateUsageCheckCache.get(content);
  if (cached) {
    return cached;
  }
  const ids = /* @__PURE__ */ new Set();
  ast.children.forEach(walk);
  function walk(node) {
    var _a;
    switch (node.type) {
      case 1:
        let tag = node.tag;
        if (tag.includes(".")) tag = tag.split(".")[0].trim();
        if (!parserOptions.isNativeTag(tag) && !parserOptions.isBuiltInComponent(tag)) {
          ids.add(camelize(tag));
          ids.add(capitalize(camelize(tag)));
        }
        for (let i = 0; i < node.props.length; i++) {
          const prop = node.props[i];
          if (prop.type === 7) {
            if (!isBuiltInDirective(prop.name)) {
              ids.add(`v${capitalize(camelize(prop.name))}`);
            }
            if (prop.arg && !prop.arg.isStatic) {
              extractIdentifiers(ids, prop.arg);
            }
            if (prop.name === "for") {
              extractIdentifiers(ids, prop.forParseResult.source);
            } else if (prop.exp) {
              extractIdentifiers(ids, prop.exp);
            } else if (prop.name === "bind" && !prop.exp) {
              ids.add(camelize(prop.arg.content));
            }
          }
          if (prop.type === 6 && prop.name === "ref" && ((_a = prop.value) == null ? void 0 : _a.content)) {
            ids.add(prop.value.content);
          }
        }
        node.children.forEach(walk);
        break;
      case 5:
        extractIdentifiers(ids, node.content);
        break;
    }
  }
  templateUsageCheckCache.set(content, ids);
  return ids;
}
function extractIdentifiers(ids, node) {
  if (node.ast) {
    walkIdentifiers(node.ast, (n) => ids.add(n.name));
  } else if (node.ast === null) {
    ids.add(node.content);
  }
}

var __defProp$a = Object.defineProperty;
var __defProps$9 = Object.defineProperties;
var __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var __hasOwnProp$a = Object.prototype.hasOwnProperty;
var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$a = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$a.call(b, prop))
      __defNormalProp$a(a, prop, b[prop]);
  if (__getOwnPropSymbols$a)
    for (var prop of __getOwnPropSymbols$a(b)) {
      if (__propIsEnum$a.call(b, prop))
        __defNormalProp$a(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));
const DEFAULT_FILENAME = "anonymous.vue";
const parseCache$1 = createCache();
function parse$2(source, options = {}) {
  var _a;
  const sourceKey = genCacheKey(source, __spreadProps$9(__spreadValues$a({}, options), {
    compiler: { parse: (_a = options.compiler) == null ? void 0 : _a.parse }
  }));
  const cache = parseCache$1.get(sourceKey);
  if (cache) {
    return cache;
  }
  const {
    sourceMap = true,
    filename = DEFAULT_FILENAME,
    sourceRoot = "",
    pad = false,
    ignoreEmpty = true,
    compiler = CompilerDOM,
    templateParseOptions = {}
  } = options;
  const descriptor = {
    filename,
    source,
    template: null,
    script: null,
    scriptSetup: null,
    styles: [],
    customBlocks: [],
    cssVars: [],
    slotted: false,
    vapor: false,
    shouldForceReload: (prevImports) => hmrShouldReload(prevImports, descriptor)
  };
  const errors = [];
  const ast = compiler.parse(source, __spreadProps$9(__spreadValues$a({
    parseMode: "sfc",
    prefixIdentifiers: true
  }, templateParseOptions), {
    onError: (e) => {
      errors.push(e);
    }
  }));
  ast.children.forEach((node) => {
    if (node.type !== 1) {
      return;
    }
    if (ignoreEmpty && node.tag !== "template" && isEmpty(node) && !hasAttr(node, "src")) {
      descriptor.vapor || (descriptor.vapor = hasAttr(node, "vapor"));
      return;
    }
    switch (node.tag) {
      case "template":
        if (!descriptor.template) {
          const templateBlock = descriptor.template = createBlock(
            node,
            source,
            false
          );
          descriptor.vapor || (descriptor.vapor = !!templateBlock.attrs.vapor);
          if (!templateBlock.attrs.src) {
            templateBlock.ast = createRoot(node.children, source);
          }
          if (templateBlock.attrs.functional) {
            const err = new SyntaxError(
              `<template functional> is no longer supported in Vue 3, since functional components no longer have significant performance difference from stateful ones. Just use a normal <template> instead.`
            );
            err.loc = node.props.find(
              (p) => p.type === 6 && p.name === "functional"
            ).loc;
            errors.push(err);
          }
        } else {
          errors.push(createDuplicateBlockError(node));
        }
        break;
      case "script":
        const scriptBlock = createBlock(node, source, pad);
        descriptor.vapor || (descriptor.vapor = !!scriptBlock.attrs.vapor);
        const isSetup = !!(scriptBlock.attrs.setup || scriptBlock.attrs.vapor);
        if (isSetup && !descriptor.scriptSetup) {
          descriptor.scriptSetup = scriptBlock;
          break;
        }
        if (!isSetup && !descriptor.script) {
          descriptor.script = scriptBlock;
          break;
        }
        errors.push(createDuplicateBlockError(node, isSetup));
        break;
      case "style":
        const styleBlock = createBlock(node, source, pad);
        if (styleBlock.attrs.vars) {
          errors.push(
            new SyntaxError(
              `<style vars> has been replaced by a new proposal: https://github.com/vuejs/rfcs/pull/231`
            )
          );
        }
        descriptor.styles.push(styleBlock);
        break;
      default:
        descriptor.customBlocks.push(createBlock(node, source, pad));
        break;
    }
  });
  if (!descriptor.template && !descriptor.script && !descriptor.scriptSetup) {
    errors.push(
      new SyntaxError(
        `At least one <template> or <script> is required in a single file component. ${descriptor.filename}`
      )
    );
  }
  if (descriptor.scriptSetup) {
    if (descriptor.scriptSetup.src) {
      errors.push(
        new SyntaxError(
          `<script setup> cannot use the "src" attribute because its syntax will be ambiguous outside of the component.`
        )
      );
      descriptor.scriptSetup = null;
    }
    if (descriptor.script && descriptor.script.src) {
      errors.push(
        new SyntaxError(
          `<script> cannot use the "src" attribute when <script setup> is also present because they must be processed together.`
        )
      );
      descriptor.script = null;
    }
  }
  let templateColumnOffset = 0;
  if (descriptor.template && (descriptor.template.lang === "pug" || descriptor.template.lang === "jade")) {
    [descriptor.template.content, templateColumnOffset] = dedent(
      descriptor.template.content
    );
  }
  if (sourceMap) {
    const genMap = (block, columnOffset = 0) => {
      if (block && !block.src) {
        block.map = generateSourceMap(
          filename,
          source,
          block.content,
          sourceRoot,
          !pad || block.type === "template" ? block.loc.start.line - 1 : 0,
          columnOffset
        );
      }
    };
    genMap(descriptor.template, templateColumnOffset);
    genMap(descriptor.script);
    descriptor.styles.forEach((s) => genMap(s));
    descriptor.customBlocks.forEach((s) => genMap(s));
  }
  descriptor.cssVars = parseCssVars(descriptor);
  const slottedRE = /(?:::v-|:)slotted\(/;
  descriptor.slotted = descriptor.styles.some(
    (s) => s.scoped && slottedRE.test(s.content)
  );
  const result = {
    descriptor,
    errors
  };
  parseCache$1.set(sourceKey, result);
  return result;
}
function createDuplicateBlockError(node, isScriptSetup = false) {
  const err = new SyntaxError(
    `Single file component can contain only one <${node.tag}${isScriptSetup ? ` setup` : ``}> element`
  );
  err.loc = node.loc;
  return err;
}
function createBlock(node, source, pad) {
  const type = node.tag;
  const loc = node.innerLoc;
  const attrs = {};
  const block = {
    type,
    content: source.slice(loc.start.offset, loc.end.offset),
    loc,
    attrs
  };
  if (pad) {
    block.content = padContent(source, block, pad) + block.content;
  }
  node.props.forEach((p) => {
    if (p.type === 6) {
      const name = p.name;
      attrs[name] = p.value ? p.value.content || true : true;
      if (name === "lang") {
        block.lang = p.value && p.value.content;
      } else if (name === "src") {
        block.src = p.value && p.value.content;
      } else if (type === "style") {
        if (name === "scoped") {
          block.scoped = true;
        } else if (name === "module") {
          block.module = attrs[name];
        }
      } else if (type === "script" && name === "setup") {
        block.setup = attrs.setup;
      }
    }
  });
  return block;
}
const splitRE = /\r?\n/g;
const emptyRE = /^(?:\/\/)?\s*$/;
const replaceRE = /./g;
function generateSourceMap(filename, source, generated, sourceRoot, lineOffset, columnOffset) {
  const map = new sourceMapExports.SourceMapGenerator({
    file: filename.replace(/\\/g, "/"),
    sourceRoot: sourceRoot.replace(/\\/g, "/")
  });
  map.setSourceContent(filename, source);
  map._sources.add(filename);
  generated.split(splitRE).forEach((line, index) => {
    if (!emptyRE.test(line)) {
      const originalLine = index + 1 + lineOffset;
      const generatedLine = index + 1;
      for (let i = 0; i < line.length; i++) {
        if (!/\s/.test(line[i])) {
          map._mappings.add({
            originalLine,
            originalColumn: i + columnOffset,
            generatedLine,
            generatedColumn: i,
            source: filename,
            name: null
          });
        }
      }
    }
  });
  return map.toJSON();
}
function padContent(content, block, pad) {
  content = content.slice(0, block.loc.start.offset);
  if (pad === "space") {
    return content.replace(replaceRE, " ");
  } else {
    const offset = content.split(splitRE).length;
    const padChar = block.type === "script" && !block.lang ? "//\n" : "\n";
    return Array(offset).join(padChar);
  }
}
function hasAttr(node, name) {
  return node.props.some((p) => p.type === 6 && p.name === name);
}
function isEmpty(node) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (child.type !== 2 || child.content.trim() !== "") {
      return false;
    }
  }
  return true;
}
function hmrShouldReload(prevImports, next) {
  if (!next.scriptSetup || next.scriptSetup.lang !== "ts" && next.scriptSetup.lang !== "tsx" && // fixed by uts
  next.scriptSetup.lang !== "uts") {
    return false;
  }
  for (const key in prevImports) {
    if (!prevImports[key].isUsedInTemplate && isImportUsed(key, next)) {
      return true;
    }
  }
  return false;
}
function dedent(s) {
  const lines = s.split("\n");
  const minIndent = lines.reduce(function(minIndent2, line) {
    var _a, _b;
    if (line.trim() === "") {
      return minIndent2;
    }
    const indent = ((_b = (_a = line.match(/^\s*/)) == null ? void 0 : _a[0]) == null ? void 0 : _b.length) || 0;
    return Math.min(indent, minIndent2);
  }, Infinity);
  if (minIndent === 0) {
    return [s, minIndent];
  }
  return [
    lines.map(function(line) {
      return line.slice(minIndent);
    }).join("\n"),
    minIndent
  ];
}

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
function resolve() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : '/';

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
}
// path.normalize(path)
// posix version
function normalize$1(path) {
  var isPathAbsolute = isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isPathAbsolute).join('/');

  if (!path && !isPathAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isPathAbsolute ? '/' : '') + path;
}
// posix version
function isAbsolute(path) {
  return path.charAt(0) === '/';
}

// posix version
function join() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize$1(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
}


// path.relative(from, to)
// posix version
function relative(from, to) {
  from = resolve(from).substr(1);
  to = resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
}

var sep = '/';
var delimiter$1 = ':';

function dirname(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
}

function basename(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
}


function extname(path) {
  return splitPath(path)[3];
}
var path = {
  extname: extname,
  basename: basename,
  dirname: dirname,
  sep: sep,
  delimiter: delimiter$1,
  relative: relative,
  join: join,
  isAbsolute: isAbsolute,
  normalize: normalize$1,
  resolve: resolve
};
function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b' ?
    function (str, start, len) { return str.substr(start, len) } :
    function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

var _polyfillNode_path = /*#__PURE__*/Object.freeze({
  __proto__: null,
  basename: basename,
  default: path,
  delimiter: delimiter$1,
  dirname: dirname,
  extname: extname,
  isAbsolute: isAbsolute,
  join: join,
  normalize: normalize$1,
  relative: relative,
  resolve: resolve,
  sep: sep
});

/*! https://mths.be/punycode v1.4.1 by @mathias */


/** Highest positive signed 32-bit float value */
var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'
var regexNonASCII = /[^\x20-\x7E]/; // unprintable ASCII chars + non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
  'overflow': 'Overflow: input needs wider integers to process',
  'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
  'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error(type) {
  throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map$1(array, fn) {
  var length = array.length;
  var result = [];
  while (length--) {
    result[length] = fn(array[length]);
  }
  return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
  var parts = string.split('@');
  var result = '';
  if (parts.length > 1) {
    // In email addresses, only the domain name should be punycoded. Leave
    // the local part (i.e. everything up to `@`) intact.
    result = parts[0] + '@';
    string = parts[1];
  }
  // Avoid `split(regex)` for IE8 compatibility. See #17.
  string = string.replace(regexSeparators, '\x2E');
  var labels = string.split('.');
  var encoded = map$1(labels, fn).join('.');
  return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
  var output = [],
    counter = 0,
    length = string.length,
    value,
    extra;
  while (counter < length) {
    value = string.charCodeAt(counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // high surrogate, and there is a next character
      extra = string.charCodeAt(counter++);
      if ((extra & 0xFC00) == 0xDC00) { // low surrogate
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // unmatched surrogate; only append this code unit, in case the next
        // code unit is the high surrogate of a surrogate pair
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
function digitToBasic(digit, flag) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
}

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
function adapt(delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for ( /* no initialization */ ; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
}

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
function encode$1(input) {
  var n,
    delta,
    handledCPCount,
    basicLength,
    bias,
    j,
    m,
    q,
    k,
    t,
    currentValue,
    output = [],
    /** `inputLength` will hold the number of code points in `input`. */
    inputLength,
    /** Cached calculation results */
    handledCPCountPlusOne,
    baseMinusT,
    qMinusT;

  // Convert the input in UCS-2 to Unicode
  input = ucs2decode(input);

  // Cache the length
  inputLength = input.length;

  // Initialize the state
  n = initialN;
  delta = 0;
  bias = initialBias;

  // Handle the basic code points
  for (j = 0; j < inputLength; ++j) {
    currentValue = input[j];
    if (currentValue < 0x80) {
      output.push(stringFromCharCode(currentValue));
    }
  }

  handledCPCount = basicLength = output.length;

  // `handledCPCount` is the number of code points that have been handled;
  // `basicLength` is the number of basic code points.

  // Finish the basic string - if it is not empty - with a delimiter
  if (basicLength) {
    output.push(delimiter);
  }

  // Main encoding loop:
  while (handledCPCount < inputLength) {

    // All non-basic code points < n have been handled already. Find the next
    // larger one:
    for (m = maxInt, j = 0; j < inputLength; ++j) {
      currentValue = input[j];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }

    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
    // but guard against overflow
    handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error('overflow');
    }

    delta += (m - n) * handledCPCountPlusOne;
    n = m;

    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];

      if (currentValue < n && ++delta > maxInt) {
        error('overflow');
      }

      if (currentValue == n) {
        // Represent delta as a generalized variable-length integer
        for (q = delta, k = base; /* no condition */ ; k += base) {
          t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
          if (q < t) {
            break;
          }
          qMinusT = q - t;
          baseMinusT = base - t;
          output.push(
            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
          );
          q = floor(qMinusT / baseMinusT);
        }

        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }

    ++delta;
    ++n;

  }
  return output.join('');
}

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
function toASCII(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ?
      'xn--' + encode$1(string) :
      string;
  });
}

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init () {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray (b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = (tmp >> 16) & 0xFF;
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output.push(tripletToBase64(tmp));
  }
  return output.join('')
}

function fromByteArray (uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[(tmp << 4) & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
    output += lookup[tmp >> 10];
    output += lookup[(tmp >> 4) & 0x3F];
    output += lookup[(tmp << 2) & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('')
}

function read (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

function write (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString$1 = {}.toString;

var isArray$2 = Array.isArray || function (arr) {
  return toString$1.call(arr) == '[object Array]';
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */


var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
  ? global$1.TYPED_ARRAY_SUPPORT
  : true;

/*
 * Export kMaxLength after typed array support is determined.
 */
kMaxLength();

function kMaxLength () {
  return Buffer$1.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer$1(length);
    }
    that.length = length;
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer$1 (arg, encodingOrOffset, length) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
    return new Buffer$1(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer$1.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer$1._augment = function (arr) {
  arr.__proto__ = Buffer$1.prototype;
  return arr
};

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer$1.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
};

if (Buffer$1.TYPED_ARRAY_SUPPORT) {
  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
  Buffer$1.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer$1[Symbol.species] === Buffer$1) ;
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer$1.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
};

function allocUnsafe (that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer$1.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer$1.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
};

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that
}

function fromObject (that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len);
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray$2(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}
Buffer$1.isBuffer = isBuffer$1;
function internalIsBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer$1.compare = function compare (a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer$1.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer$1.concat = function concat (list, length) {
  if (!isArray$2(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer$1.alloc(0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer$1.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};

function byteLength (string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$1.byteLength = byteLength;

function slowToString (encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer$1.prototype._isBuffer = true;

function swap (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer$1.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer$1.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer$1.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer$1.prototype.toString = function toString () {
  var length = this.length | 0;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer$1.prototype.equals = function equals (b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer$1.compare(this, b) === 0
};

Buffer$1.prototype.inspect = function inspect () {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>'
};

Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer$1.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer$1.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer$1.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer$1.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf)
  } else {
    return fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res
}

Buffer$1.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$1.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$1(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4)
};

Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4)
};

Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8)
};

Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = (value & 0xff);
  return offset + 1
};

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
  }
}

Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val)
      ? val
      : utf8ToBytes(new Buffer$1(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}


function base64ToBytes (str) {
  return toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
}

function isFastBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
}

var inherits;
if (typeof Object.create === 'function'){
  inherits = function inherits(ctor, superCtor) {
    // implementation from standard node.js 'util' module
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
function format$1(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject$1(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
}

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
function deprecate(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global$1.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (browser$1.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1.throwDeprecation) {
        throw new Error(msg);
      } else if (browser$1.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

var debugs = {};
var debugEnviron;
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = browser$1.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format$1.apply(null, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
}

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    _extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray$1(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty$2(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty$2(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var length = output.reduce(function(prev, cur) {
    if (cur.indexOf('\n') >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray$1(ar) {
  return Array.isArray(ar);
}

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

function isNull(arg) {
  return arg === null;
}

function isNullOrUndefined(arg) {
  return arg == null;
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isString(arg) {
  return typeof arg === 'string';
}

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

function isUndefined(arg) {
  return arg === void 0;
}

function isRegExp(re) {
  return isObject$1(re) && objectToString(re) === '[object RegExp]';
}

function isObject$1(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isDate(d) {
  return isObject$1(d) && objectToString(d) === '[object Date]';
}

function isError(e) {
  return isObject$1(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}

function isFunction(arg) {
  return typeof arg === 'function';
}

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}

function isBuffer(maybeBuf) {
  return Buffer$1.isBuffer(maybeBuf);
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
function log() {
  console.log('%s - %s', timestamp(), format$1.apply(null, arguments));
}

function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject$1(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}
function hasOwnProperty$2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { browser$1.nextTick(cb.bind(null, null, ret)); },
        function(rej) { browser$1.nextTick(callbackifyOnRejected.bind(null, rej, cb)); });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}

var _polyfillNode_util = {
  inherits: inherits,
  _extend: _extend,
  log: log,
  isBuffer: isBuffer,
  isPrimitive: isPrimitive,
  isFunction: isFunction,
  isError: isError,
  isDate: isDate,
  isObject: isObject$1,
  isRegExp: isRegExp,
  isUndefined: isUndefined,
  isSymbol: isSymbol,
  isString: isString,
  isNumber: isNumber,
  isNullOrUndefined: isNullOrUndefined,
  isNull: isNull,
  isBoolean: isBoolean,
  isArray: isArray$1,
  inspect: inspect,
  deprecate: deprecate,
  format: format$1,
  debuglog: debuglog,
  promisify: promisify,
  callbackify: callbackify,
};

var _polyfillNode_util$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  _extend: _extend,
  callbackify: callbackify,
  debuglog: debuglog,
  default: _polyfillNode_util,
  deprecate: deprecate,
  format: format$1,
  inherits: inherits,
  inspect: inspect,
  isArray: isArray$1,
  isBoolean: isBoolean,
  isBuffer: isBuffer,
  isDate: isDate,
  isError: isError,
  isFunction: isFunction,
  isNull: isNull,
  isNullOrUndefined: isNullOrUndefined,
  isNumber: isNumber,
  isObject: isObject$1,
  isPrimitive: isPrimitive,
  isRegExp: isRegExp,
  isString: isString,
  isSymbol: isSymbol,
  isUndefined: isUndefined,
  log: log,
  promisify: promisify
});

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty$1(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};
function stringifyPrimitive(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
}

function stringify (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
}
function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

function parse$1(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty$1(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
}

// WHATWG API
const URL$1 = global$1.URL;
const URLSearchParams = global$1.URLSearchParams;
var _polyfillNode_url = {
  parse: urlParse,
  resolve: urlResolve,
  resolveObject: urlResolveObject,
  fileURLToPath: urlFileURLToPath,
  format: urlFormat,
  Url: Url,

  // WHATWG API
  URL: URL$1,
  URLSearchParams,  
};
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
  portPattern = /:[0-9]*$/,

  // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

  // RFC 2396: characters reserved for delimiting URLs.
  // We actually just auto-escape these.
  delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

  // RFC 2396: characters not allowed for various reasons.
  unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),
  // Characters that are never ever allowed in a hostname.
  // Note that any invalid chars are also handled, but these
  // are the ones that are *expected* to be seen, so we fast-path
  // them.
  nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
  hostEndingChars = ['/', '?', '#'],
  hostnameMaxLen = 255,
  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  // protocols that can allow "unsafe" and "unwise" chars.
  unsafeProtocol = {
    'javascript': true,
    'javascript:': true
  },
  // protocols that never have a hostname.
  hostlessProtocol = {
    'javascript': true,
    'javascript:': true
  },
  // protocols that always contain a // bit.
  slashedProtocol = {
    'http': true,
    'https': true,
    'ftp': true,
    'gopher': true,
    'file': true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  };

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject$1(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  return parse(this, url, parseQueryString, slashesDenoteHost);
};

function parse(self, url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError('Parameter \'url\' must be a string, not ' + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
    splitter =
    (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
    uSplit = url.split(splitter),
    slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      self.path = rest;
      self.href = rest;
      self.pathname = simplePath[1];
      if (simplePath[2]) {
        self.search = simplePath[2];
        if (parseQueryString) {
          self.query = parse$1(self.search.substr(1));
        } else {
          self.query = self.search.substr(1);
        }
      } else if (parseQueryString) {
        self.search = '';
        self.query = {};
      }
      return self;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    self.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      self.slashes = true;
    }
  }
  var i, hec, l, p;
  if (!hostlessProtocol[proto] &&
    (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      self.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    self.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    parseHost(self);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    self.hostname = self.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = self.hostname[0] === '[' &&
      self.hostname[self.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = self.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            self.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (self.hostname.length > hostnameMaxLen) {
      self.hostname = '';
    } else {
      // hostnames are always lower case.
      self.hostname = self.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      self.hostname = toASCII(self.hostname);
    }

    p = self.port ? ':' + self.port : '';
    var h = self.hostname || '';
    self.host = h + p;
    self.href += self.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      self.hostname = self.hostname.substr(1, self.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    self.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    self.search = rest.substr(qm);
    self.query = rest.substr(qm + 1);
    if (parseQueryString) {
      self.query = parse$1(self.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    self.search = '';
    self.query = {};
  }
  if (rest) self.pathname = rest;
  if (slashedProtocol[lowerProto] &&
    self.hostname && !self.pathname) {
    self.pathname = '/';
  }

  //to support http.request
  if (self.pathname || self.search) {
    p = self.pathname || '';
    var s = self.search || '';
    self.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  self.href = format(self);
  return self;
}

function urlFileURLToPath(path) {
  if (typeof path === 'string')
    path = new Url().parse(path);
  else if (!(path instanceof Url))
    throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + (typeof path) + String(path));
  if (path.protocol !== 'file:')
    throw new TypeError('The URL must be of scheme file');
  return getPathFromURLPosix(path);
}

function getPathFromURLPosix(url) {
  const pathname = url.pathname;
  for (let n = 0; n < pathname.length; n++) {
    if (pathname[n] === '%') {
      const third = pathname.codePointAt(n + 2) | 0x20;
      if (pathname[n + 1] === '2' && third === 102) {
        throw new TypeError(
          'must not include encoded / characters'
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = parse({}, obj);
  return format(obj);
}

function format(self) {
  var auth = self.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = self.protocol || '',
    pathname = self.pathname || '',
    hash = self.hash || '',
    host = false,
    query = '';

  if (self.host) {
    host = auth + self.host;
  } else if (self.hostname) {
    host = auth + (self.hostname.indexOf(':') === -1 ?
      self.hostname :
      '[' + this.hostname + ']');
    if (self.port) {
      host += ':' + self.port;
    }
  }

  if (self.query &&
    isObject$1(self.query) &&
    Object.keys(self.query).length) {
    query = stringify(self.query);
  }

  var search = self.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (self.slashes ||
    (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
}

Url.prototype.format = function() {
  return format(this);
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
      result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }
  var relPath;
  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
    isRelAbs = (
      relative.host ||
      relative.pathname && relative.pathname.charAt(0) === '/'
    ),
    mustEndAbs = (isRelAbs || isSourceAbs ||
      (result.host && relative.pathname)),
    removeAllDots = mustEndAbs,
    srcPath = result.pathname && result.pathname.split('/') || [],
    psychotic = result.protocol && !slashedProtocol[result.protocol];
  relPath = relative.pathname && relative.pathname.split('/') || [];
  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }
  var authInHost;
  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
      relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      authInHost = result.host && result.host.indexOf('@') > 0 ?
        result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
        (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
    (result.host || relative.host || srcPath.length > 1) &&
    (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
    (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
    (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
      srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    authInHost = result.host && result.host.indexOf('@') > 0 ?
      result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
      (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  return parseHost(this);
};

function parseHost(self) {
  var host = self.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      self.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) self.hostname = host;
}

var _polyfillNode_url$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  URL: URL$1,
  URLSearchParams: URLSearchParams,
  Url: Url,
  default: _polyfillNode_url,
  fileURLToPath: urlFileURLToPath,
  format: urlFormat,
  parse: urlParse,
  resolve: urlResolve,
  resolveObject: urlResolveObject
});

function isRelativeUrl(url) {
  const firstChar = url.charAt(0);
  return firstChar === "." || firstChar === "~" || firstChar === "@";
}
const externalRE = /^(https?:)?\/\//;
function isExternalUrl(url) {
  return externalRE.test(url);
}
const dataUrlRE = /^\s*data:/i;
function isDataUrl(url) {
  return dataUrlRE.test(url);
}
function parseUrl(url) {
  const firstChar = url.charAt(0);
  if (firstChar === "~") {
    const secondChar = url.charAt(1);
    url = url.slice(secondChar === "/" ? 2 : 1);
  }
  return parseUriParts(url);
}
function parseUriParts(urlString) {
  return urlParse(isString$1(urlString) ? urlString : "", false, true);
}

var __defProp$9 = Object.defineProperty;
var __defProps$8 = Object.defineProperties;
var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$9 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$9.call(b, prop))
      __defNormalProp$9(a, prop, b[prop]);
  if (__getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(b)) {
      if (__propIsEnum$9.call(b, prop))
        __defNormalProp$9(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));
const defaultAssetUrlOptions = {
  base: null,
  includeAbsolute: false,
  tags: {
    video: ["src", "poster"],
    source: ["src"],
    img: ["src"],
    image: ["xlink:href", "href"],
    use: ["xlink:href", "href"]
  }
};
const normalizeOptions = (options) => {
  if (Object.keys(options).some((key) => isArray$3(options[key]))) {
    return __spreadProps$8(__spreadValues$9({}, defaultAssetUrlOptions), {
      tags: options
    });
  }
  return __spreadValues$9(__spreadValues$9({}, defaultAssetUrlOptions), options);
};
const createAssetUrlTransformWithOptions = (options) => {
  return (node, context) => transformAssetUrl(node, context, options);
};
const transformAssetUrl = (node, context, options = defaultAssetUrlOptions) => {
  if (node.type === 1) {
    if (!node.props.length) {
      return;
    }
    const tags = options.tags || defaultAssetUrlOptions.tags;
    const attrs = tags[node.tag];
    const wildCardAttrs = tags["*"];
    if (!attrs && !wildCardAttrs) {
      return;
    }
    const assetAttrs = (attrs || []).concat(wildCardAttrs || []);
    node.props.forEach((attr, index) => {
      if (attr.type !== 6 || !assetAttrs.includes(attr.name) || !attr.value || isExternalUrl(attr.value.content) || isDataUrl(attr.value.content) || attr.value.content[0] === "#" || !options.includeAbsolute && !isRelativeUrl(attr.value.content)) {
        return;
      }
      const url = parseUrl(attr.value.content);
      if (options.base && attr.value.content[0] === ".") {
        const base = parseUrl(options.base);
        const protocol = base.protocol || "";
        const host = base.host ? protocol + "//" + base.host : "";
        const basePath = base.path || "/";
        attr.value.content = host + (path.posix || path).join(basePath, url.path + (url.hash || ""));
        return;
      }
      const exp = getImportsExpressionExp(url.path, url.hash, attr.loc, context);
      node.props[index] = {
        type: 7,
        name: "bind",
        arg: createSimpleExpression(attr.name, true, attr.loc),
        exp,
        modifiers: [],
        loc: attr.loc
      };
    });
  }
};
function getImportsExpressionExp(path2, hash, loc, context) {
  if (path2) {
    let name;
    let exp;
    const existingIndex = context.imports.findIndex((i) => i.path === path2);
    if (existingIndex > -1) {
      name = `_imports_${existingIndex}`;
      exp = context.imports[existingIndex].exp;
    } else {
      name = `_imports_${context.imports.length}`;
      exp = createSimpleExpression(
        name,
        false,
        loc,
        3
      );
      context.imports.push({
        exp,
        path: decodeURIComponent(path2)
      });
    }
    if (!hash) {
      return exp;
    }
    const hashExp = `${name} + '${hash}'`;
    const finalExp = createSimpleExpression(
      hashExp,
      false,
      loc,
      3
    );
    if (!context.hoistStatic) {
      return finalExp;
    }
    const existingHoistIndex = context.hoists.findIndex((h) => {
      return h && h.type === 4 && !h.isStatic && h.content === hashExp;
    });
    if (existingHoistIndex > -1) {
      return createSimpleExpression(
        `_hoisted_${existingHoistIndex + 1}`,
        false,
        loc,
        3
      );
    }
    return context.hoist(finalExp);
  } else {
    return createSimpleExpression(`''`, false, loc, 3);
  }
}

const srcsetTags = ["img", "source"];
const escapedSpaceCharacters = /( |\\t|\\n|\\f|\\r)+/g;
const createSrcsetTransformWithOptions = (options) => {
  return (node, context) => transformSrcset(node, context, options);
};
const transformSrcset = (node, context, options = defaultAssetUrlOptions) => {
  if (node.type === 1) {
    if (srcsetTags.includes(node.tag) && node.props.length) {
      node.props.forEach((attr, index) => {
        if (attr.name === "srcset" && attr.type === 6) {
          if (!attr.value) return;
          const value = attr.value.content;
          if (!value) return;
          const imageCandidates = value.split(",").map((s) => {
            const [url, descriptor] = s.replace(escapedSpaceCharacters, " ").trim().split(" ", 2);
            return { url, descriptor };
          });
          for (let i = 0; i < imageCandidates.length; i++) {
            const { url } = imageCandidates[i];
            if (isDataUrl(url)) {
              imageCandidates[i + 1].url = url + "," + imageCandidates[i + 1].url;
              imageCandidates.splice(i, 1);
            }
          }
          const shouldProcessUrl = (url) => {
            return !isExternalUrl(url) && !isDataUrl(url) && (options.includeAbsolute || isRelativeUrl(url));
          };
          if (!imageCandidates.some(({ url }) => shouldProcessUrl(url))) {
            return;
          }
          if (options.base) {
            const base = options.base;
            const set = [];
            let needImportTransform = false;
            imageCandidates.forEach((candidate) => {
              let { url, descriptor } = candidate;
              descriptor = descriptor ? ` ${descriptor}` : ``;
              if (url[0] === ".") {
                candidate.url = (path.posix || path).join(base, url);
                set.push(candidate.url + descriptor);
              } else if (shouldProcessUrl(url)) {
                needImportTransform = true;
              } else {
                set.push(url + descriptor);
              }
            });
            if (!needImportTransform) {
              attr.value.content = set.join(", ");
              return;
            }
          }
          const compoundExpression = createCompoundExpression([], attr.loc);
          imageCandidates.forEach(({ url, descriptor }, index2) => {
            if (shouldProcessUrl(url)) {
              const { path: path2 } = parseUrl(url);
              let exp2;
              if (path2) {
                const existingImportsIndex = context.imports.findIndex(
                  (i) => i.path === path2
                );
                if (existingImportsIndex > -1) {
                  exp2 = createSimpleExpression(
                    `_imports_${existingImportsIndex}`,
                    false,
                    attr.loc,
                    3
                  );
                } else {
                  exp2 = createSimpleExpression(
                    `_imports_${context.imports.length}`,
                    false,
                    attr.loc,
                    3
                  );
                  context.imports.push({ exp: exp2, path: path2 });
                }
                compoundExpression.children.push(exp2);
              }
            } else {
              const exp2 = createSimpleExpression(
                `"${url}"`,
                false,
                attr.loc,
                3
              );
              compoundExpression.children.push(exp2);
            }
            const isNotLast = imageCandidates.length - 1 > index2;
            if (descriptor && isNotLast) {
              compoundExpression.children.push(` + ' ${descriptor}, ' + `);
            } else if (descriptor) {
              compoundExpression.children.push(` + ' ${descriptor}'`);
            } else if (isNotLast) {
              compoundExpression.children.push(` + ', ' + `);
            }
          });
          let exp = compoundExpression;
          if (context.hoistStatic) {
            exp = context.hoist(compoundExpression);
            exp.constType = 3;
          }
          node.props[index] = {
            type: 7,
            name: "bind",
            arg: createSimpleExpression("srcset", true, attr.loc),
            exp,
            modifiers: [],
            loc: attr.loc
          };
        }
      });
    }
  }
};

const newDynamic = () => ({
  flags: 1,
  children: []
});
const newBlock = (node) => ({
  type: 1,
  node,
  dynamic: newDynamic(),
  effect: [],
  operation: [],
  returns: [],
  tempId: 0
});
function wrapTemplate(node, dirs) {
  if (node.tagType === 3) {
    return node;
  }
  const reserved = [];
  const pass = [];
  node.props.forEach((prop) => {
    if (prop.type === 7 && dirs.includes(prop.name)) {
      reserved.push(prop);
    } else {
      pass.push(prop);
    }
  });
  return extend({}, node, {
    type: 1,
    tag: "template",
    props: reserved,
    tagType: 3,
    children: [extend({}, node, { props: pass })]
  });
}
const EMPTY_EXPRESSION = createSimpleExpression(
  "",
  true
);

const findProp = findProp$1;
const findDir = findDir$1;
function propToExpression(prop) {
  return prop.type === 6 ? prop.value ? createSimpleExpression(prop.value.content, true, prop.value.loc) : EMPTY_EXPRESSION : prop.exp;
}
function isConstantExpression(exp) {
  return isLiteralWhitelisted(exp.content) || isGloballyAllowed(exp.content) || getLiteralExpressionValue(exp) !== null;
}
function isStaticExpression(node, bindings) {
  if (node.ast) {
    return isConstantNode(node.ast, bindings);
  } else if (node.ast === null) {
    const type = bindings[node.content];
    return type === "literal-const";
  }
  return false;
}
function resolveExpression(exp) {
  if (!exp.isStatic) {
    const value = getLiteralExpressionValue(exp);
    if (value !== null) {
      return createSimpleExpression("" + value, true, exp.loc);
    }
  }
  return exp;
}
function getLiteralExpressionValue(exp) {
  if (exp.ast) {
    if (exp.ast.type === "StringLiteral") {
      return exp.ast.value;
    } else if (exp.ast.type === "TemplateLiteral" && exp.ast.expressions.length === 0) {
      return exp.ast.quasis[0].value.cooked;
    }
  }
  return exp.isStatic ? exp.content : null;
}

class TransformContext {
  constructor(ir, node, options = {}) {
    this.ir = ir;
    this.node = node;
    this.selfName = null;
    this.parent = null;
    this.index = 0;
    this.block = this.ir.block;
    this.template = "";
    this.childrenTemplate = [];
    this.dynamic = this.ir.block.dynamic;
    this.inVOnce = false;
    this.inVFor = 0;
    this.comment = [];
    this.component = this.ir.component;
    this.directive = this.ir.directive;
    this.slots = [];
    this.globalId = 0;
    this.increaseId = () => this.globalId++;
    this.options = extend({}, defaultOptions, options);
    this.root = this;
    if (options.filename) this.selfName = getSelfName(options.filename);
  }
  enterBlock(ir, isVFor = false) {
    const { block, template, dynamic, childrenTemplate, slots } = this;
    this.block = ir;
    this.dynamic = ir.dynamic;
    this.template = "";
    this.childrenTemplate = [];
    this.slots = [];
    isVFor && this.inVFor++;
    return () => {
      this.registerTemplate();
      this.block = block;
      this.template = template;
      this.dynamic = dynamic;
      this.childrenTemplate = childrenTemplate;
      this.slots = slots;
      isVFor && this.inVFor--;
    };
  }
  reference() {
    if (this.dynamic.id !== void 0) return this.dynamic.id;
    this.dynamic.flags |= 1;
    return this.dynamic.id = this.increaseId();
  }
  pushTemplate(content) {
    const existing = this.ir.template.findIndex(
      (template) => template === content
    );
    if (existing !== -1) return existing;
    this.ir.template.push(content);
    return this.ir.template.length - 1;
  }
  registerTemplate() {
    if (!this.template) return -1;
    const id = this.pushTemplate(this.template);
    return this.dynamic.template = id;
  }
  registerEffect(expressions, operation, getIndex = () => this.block.effect.length) {
    const operations = [operation].flat();
    expressions = expressions.filter((exp) => !isConstantExpression(exp));
    if (this.inVOnce || expressions.length === 0 || expressions.every(
      (e) => isStaticExpression(e, this.root.options.bindingMetadata)
    )) {
      return this.registerOperation(...operations);
    }
    this.block.effect.splice(getIndex(), 0, {
      expressions,
      operations
    });
  }
  registerOperation(...node) {
    this.block.operation.push(...node);
  }
  create(node, index) {
    return Object.assign(Object.create(TransformContext.prototype), this, {
      node,
      parent: this,
      index,
      template: "",
      childrenTemplate: [],
      dynamic: newDynamic()
    });
  }
}
const defaultOptions = {
  filename: "",
  prefixIdentifiers: true,
  hoistStatic: false,
  hmr: false,
  cacheHandlers: false,
  nodeTransforms: [],
  directiveTransforms: {},
  transformHoist: null,
  isBuiltInComponent: NOOP,
  isCustomElement: NOOP,
  expressionPlugins: [],
  scopeId: null,
  slotted: true,
  ssr: false,
  inSSR: false,
  ssrCssVars: ``,
  templateMode: "string",
  bindingMetadata: EMPTY_OBJ,
  inline: false,
  isTS: false,
  // fixed by uts
  disableEventDelegation: false,
  disableClassBinding: false,
  onError: defaultOnError,
  onWarn: defaultOnWarn
};
function transform(node, options = {}) {
  const ir = {
    type: 0,
    node,
    source: node.source,
    template: [],
    component: /* @__PURE__ */ new Set(),
    directive: /* @__PURE__ */ new Set(),
    block: newBlock(node),
    hasTemplateRef: false
  };
  const context = new TransformContext(ir, node, options);
  transformNode(context);
  return ir;
}
function transformNode(context) {
  let { node } = context;
  const { nodeTransforms } = context.options;
  const exitFns = [];
  for (const nodeTransform of nodeTransforms) {
    const onExit = nodeTransform(node, context);
    if (onExit) {
      if (isArray$3(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.node) {
      return;
    } else {
      node = context.node;
    }
  }
  context.node = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
  if (context.node.type === 0) {
    context.registerTemplate();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = (n) => isString$1(name) ? n === name : name.includes(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (const prop of props) {
        if (prop.type === 7 && matches(prop.name)) {
          const onExit = fn(
            node,
            prop,
            context
          );
          if (onExit) exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}

const NEWLINE = Symbol(`newline` );
const LF = Symbol(`line feed` );
const INDENT_START = Symbol(`indent start` );
const INDENT_END = Symbol(`indent end` );
function buildCodeFragment(...frag) {
  const push = frag.push.bind(frag);
  const unshift = frag.unshift.bind(frag);
  return [frag, push, unshift];
}
function genMulti([left, right, seg, placeholder], ...frags) {
  if (placeholder) {
    while (frags.length > 0 && !frags[frags.length - 1]) {
      frags.pop();
    }
    frags = frags.map((frag2) => frag2 || placeholder);
  } else {
    frags = frags.filter(Boolean);
  }
  const frag = [];
  push(left);
  for (let [i, fn] of frags.entries()) {
    push(fn);
    if (i < frags.length - 1) push(seg);
  }
  push(right);
  return frag;
  function push(fn) {
    if (!isArray$3(fn)) fn = [fn];
    frag.push(...fn);
  }
}
const DELIMITERS_ARRAY = ["[", "]", ", "];
const DELIMITERS_ARRAY_NEWLINE = [
  ["[", INDENT_START, NEWLINE],
  [INDENT_END, NEWLINE, "]"],
  [", ", NEWLINE]
];
const DELIMITERS_OBJECT = ["{ ", " }", ", "];
const DELIMITERS_OBJECT_NEWLINE = [
  ["{", INDENT_START, NEWLINE],
  [INDENT_END, NEWLINE, "}"],
  [", ", NEWLINE]
];
function genCall(name, ...frags) {
  const hasPlaceholder = isArray$3(name);
  const fnName = hasPlaceholder ? name[0] : name;
  const placeholder = hasPlaceholder ? name[1] : "null";
  return [fnName, ...genMulti(["(", ")", ", ", placeholder], ...frags)];
}
function codeFragmentToString(code, context) {
  const {
    options: { filename, sourceMap }
  } = context;
  let map;
  if (sourceMap) {
    map = new sourceMapExports.SourceMapGenerator();
    map.setSourceContent(filename, context.ir.source);
    map._sources.add(filename);
  }
  let codegen = "";
  const pos = { line: 1, column: 1, offset: 0 };
  let indentLevel = 0;
  for (let frag of code) {
    if (!frag) continue;
    if (frag === NEWLINE) {
      frag = [`
${`  `.repeat(indentLevel)}`, 0];
    } else if (frag === INDENT_START) {
      indentLevel++;
      continue;
    } else if (frag === INDENT_END) {
      indentLevel--;
      continue;
    } else if (frag === LF) {
      pos.line++;
      pos.column = 0;
      pos.offset++;
      continue;
    }
    if (isString$1(frag)) frag = [frag];
    let [code2, newlineIndex = -2, loc, name] = frag;
    codegen += code2;
    if (map) {
      if (loc) addMapping(loc.start, name);
      if (newlineIndex === -3) {
        advancePositionWithMutation(pos, code2);
      } else {
        pos.offset += code2.length;
        if (newlineIndex === -2) {
          pos.column += code2.length;
        } else {
          if (newlineIndex === -1) {
            newlineIndex = code2.length - 1;
          }
          pos.line++;
          pos.column = code2.length - newlineIndex;
        }
      }
      if (loc && loc !== locStub) {
        addMapping(loc.end);
      }
    }
  }
  return [codegen, map];
  function addMapping(loc, name = null) {
    const { _names, _mappings } = map;
    if (name !== null && !_names.has(name)) _names.add(name);
    _mappings.add({
      originalLine: loc.line,
      originalColumn: loc.column - 1,
      // source-map column is 0 based
      generatedLine: pos.line,
      generatedColumn: pos.column - 1,
      source: filename,
      name
    });
  }
}

const IRDynamicPropsKind = {
  "EXPRESSION": 0,
  "0": "EXPRESSION",
  "ATTRIBUTE": 1,
  "1": "ATTRIBUTE"
};
const IRSlotType = {
  "STATIC": 0,
  "0": "STATIC",
  "DYNAMIC": 1,
  "1": "DYNAMIC",
  "LOOP": 2,
  "2": "LOOP",
  "CONDITIONAL": 3,
  "3": "CONDITIONAL",
  "EXPRESSION": 4,
  "4": "EXPRESSION"
};

const IRNodeTypes = {
  "ROOT": 0,
  "0": "ROOT",
  "BLOCK": 1,
  "1": "BLOCK",
  "SET_PROP": 2,
  "2": "SET_PROP",
  "SET_DYNAMIC_PROPS": 3,
  "3": "SET_DYNAMIC_PROPS",
  "SET_TEXT": 4,
  "4": "SET_TEXT",
  "SET_EVENT": 5,
  "5": "SET_EVENT",
  "SET_DYNAMIC_EVENTS": 6,
  "6": "SET_DYNAMIC_EVENTS",
  "SET_HTML": 7,
  "7": "SET_HTML",
  "SET_TEMPLATE_REF": 8,
  "8": "SET_TEMPLATE_REF",
  "INSERT_NODE": 9,
  "9": "INSERT_NODE",
  "PREPEND_NODE": 10,
  "10": "PREPEND_NODE",
  "CREATE_COMPONENT_NODE": 11,
  "11": "CREATE_COMPONENT_NODE",
  "SLOT_OUTLET_NODE": 12,
  "12": "SLOT_OUTLET_NODE",
  "DIRECTIVE": 13,
  "13": "DIRECTIVE",
  "DECLARE_OLD_REF": 14,
  "14": "DECLARE_OLD_REF",
  "IF": 15,
  "15": "IF",
  "FOR": 16,
  "16": "FOR",
  "GET_TEXT_CHILD": 17,
  "17": "GET_TEXT_CHILD"
};
const DynamicFlag = {
  "NONE": 0,
  "0": "NONE",
  "REFERENCED": 1,
  "1": "REFERENCED",
  "NON_TEMPLATE": 2,
  "2": "NON_TEMPLATE",
  "INSERT": 4,
  "4": "INSERT"
};
function isBlockOperation(op) {
  const type = op.type;
  return type === 11 || type === 12 || type === 15 || type === 16;
}

function genInsertNode({ parent, elements, anchor }, { helper }) {
  let element = elements.map((el) => `n${el}`).join(", ");
  if (elements.length > 1) element = `[${element}]`;
  return [
    NEWLINE,
    ...genCall(
      helper("insert"),
      element,
      `n${parent}`,
      anchor === void 0 ? void 0 : `n${anchor}`
    )
  ];
}
function genPrependNode(oper, { helper }) {
  return [
    NEWLINE,
    ...genCall(
      helper("prepend"),
      `n${oper.parent}`,
      ...oper.elements.map((el) => `n${el}`)
    )
  ];
}

function genExpression(node, context, assignment) {
  const { content, ast, isStatic, loc } = node;
  if (isStatic) {
    return [[JSON.stringify(content), -2, loc]];
  }
  if (!node.content.trim() || // there was a parsing error
  ast === false || isConstantExpression(node)) {
    return [[content, -2, loc], assignment && ` = ${assignment}`];
  }
  if (ast === null) {
    return genIdentifier(content, context, loc, assignment);
  }
  const ids = [];
  const parentStackMap = /* @__PURE__ */ new Map();
  const parentStack = [];
  walkIdentifiers(
    ast,
    (id) => {
      ids.push(id);
      parentStackMap.set(id, parentStack.slice());
    },
    false,
    parentStack
  );
  let hasMemberExpression = false;
  if (ids.length) {
    const [frag, push] = buildCodeFragment();
    const isTSNode = ast && TS_NODE_TYPES.includes(ast.type);
    ids.sort((a, b) => a.start - b.start).forEach((id, i) => {
      const start = id.start - 1;
      const end = id.end - 1;
      const last = ids[i - 1];
      if (!(isTSNode && i === 0)) {
        const leadingText = content.slice(last ? last.end - 1 : 0, start);
        if (leadingText.length) push([leadingText, -3]);
      }
      const source = content.slice(start, end);
      const parentStack2 = parentStackMap.get(id);
      const parent = parentStack2[parentStack2.length - 1];
      hasMemberExpression || (hasMemberExpression = parent && (parent.type === "MemberExpression" || parent.type === "OptionalMemberExpression"));
      push(
        ...genIdentifier(
          source,
          context,
          {
            start: advancePositionWithClone(node.loc.start, source, start),
            end: advancePositionWithClone(node.loc.start, source, end),
            source
          },
          hasMemberExpression ? void 0 : assignment,
          id,
          parent,
          parentStack2
        )
      );
      if (i === ids.length - 1 && end < content.length && !isTSNode) {
        push([content.slice(end), -3]);
      }
    });
    if (assignment && hasMemberExpression) {
      push(` = ${assignment}`);
    }
    return frag;
  } else {
    return [[content, -3, loc]];
  }
}
function genIdentifier(raw, context, loc, assignment, id, parent, parentStack) {
  const { options, helper, identifiers } = context;
  const { inline, bindingMetadata } = options;
  let name = raw;
  const idMap = identifiers[raw];
  if (idMap && idMap.length) {
    const replacement = idMap[0];
    if (isString$1(replacement)) {
      if (parent && parent.type === "ObjectProperty" && parent.shorthand) {
        return [[`${name}: ${replacement}`, -2, loc]];
      } else {
        return [[replacement, -2, loc]];
      }
    } else {
      return genExpression(replacement, context, assignment);
    }
  }
  let prefix;
  if (isStaticProperty(parent) && parent.shorthand) {
    prefix = `${raw}: `;
  }
  const type = bindingMetadata && bindingMetadata[raw];
  if (inline) {
    switch (type) {
      case "setup-let":
        name = raw = assignment ? `_isRef(${raw}) ? (${raw}.value = ${assignment}) : (${raw} = ${assignment})` : unref();
        break;
      case "setup-ref":
        name = raw = withAssignment(`${raw}.value`);
        break;
      case "setup-maybe-ref":
        const isDestructureAssignment = parent && isInDestructureAssignment(parent, parentStack || []);
        const isAssignmentLVal = parent && parent.type === "AssignmentExpression" && parent.left === id;
        const isUpdateArg = parent && parent.type === "UpdateExpression" && parent.argument === id;
        raw = isAssignmentLVal || isUpdateArg || isDestructureAssignment ? name = `${raw}.value` : assignment ? `${helper("isRef")}(${raw}) ? (${raw}.value = ${assignment}) : null` : unref();
        break;
      case "props":
        raw = genPropsAccessExp(raw);
        break;
      case "props-aliased":
        raw = genPropsAccessExp(bindingMetadata.__propsAliases[raw]);
        break;
      default:
        raw = withAssignment(raw);
    }
  } else {
    if (canPrefix(raw)) {
      if (type === "props-aliased") {
        raw = `$props['${bindingMetadata.__propsAliases[raw]}']`;
      } else {
        raw = `${type === "props" ? "$props" : "_ctx"}.${raw}`;
      }
    }
    raw = withAssignment(raw);
  }
  return [prefix, [raw, -2, loc, name]];
  function withAssignment(s) {
    return assignment ? `${s} = ${assignment}` : s;
  }
  function unref() {
    return `${helper("unref")}(${raw})`;
  }
}
function canPrefix(name) {
  if (isGloballyAllowed(name)) {
    return false;
  }
  if (
    // special case for webpack compilation
    name === "require" || name === "$props" || name === "$emit" || name === "$attrs" || name === "$slots"
  )
    return false;
  return true;
}
function processExpressions(context, expressions) {
  const {
    seenVariable,
    variableToExpMap,
    expToVariableMap,
    seenIdentifier,
    updatedVariable
  } = analyzeExpressions(expressions);
  const varDeclarations = processRepeatedVariables(
    context,
    seenVariable,
    variableToExpMap,
    expToVariableMap,
    seenIdentifier,
    updatedVariable
  );
  const expDeclarations = processRepeatedExpressions(
    context,
    expressions,
    varDeclarations,
    updatedVariable,
    expToVariableMap
  );
  return genDeclarations([...varDeclarations, ...expDeclarations], context);
}
function analyzeExpressions(expressions) {
  const seenVariable = /* @__PURE__ */ Object.create(null);
  const variableToExpMap = /* @__PURE__ */ new Map();
  const expToVariableMap = /* @__PURE__ */ new Map();
  const seenIdentifier = /* @__PURE__ */ new Set();
  const updatedVariable = /* @__PURE__ */ new Set();
  const registerVariable = (name, exp, isIdentifier, loc, parentStack = []) => {
    if (isIdentifier) seenIdentifier.add(name);
    seenVariable[name] = (seenVariable[name] || 0) + 1;
    variableToExpMap.set(
      name,
      (variableToExpMap.get(name) || /* @__PURE__ */ new Set()).add(exp)
    );
    const variables = expToVariableMap.get(exp) || [];
    variables.push({ name, loc });
    expToVariableMap.set(exp, variables);
    if (parentStack.some(
      (p) => p.type === "UpdateExpression" || p.type === "AssignmentExpression"
    )) {
      updatedVariable.add(name);
    }
  };
  for (const exp of expressions) {
    if (!exp.ast) {
      exp.ast === null && registerVariable(exp.content, exp, true);
      continue;
    }
    walkIdentifiers(exp.ast, (currentNode, parent, parentStack) => {
      if (parent && isMemberExpression(parent)) {
        const memberExp = extractMemberExpression(parent, (id) => {
          registerVariable(id.name, exp, true, {
            start: id.start,
            end: id.end
          });
        });
        registerVariable(
          memberExp,
          exp,
          false,
          { start: parent.start, end: parent.end },
          parentStack
        );
      } else if (!parentStack.some(isMemberExpression)) {
        registerVariable(
          currentNode.name,
          exp,
          true,
          { start: currentNode.start, end: currentNode.end },
          parentStack
        );
      }
    });
  }
  return {
    seenVariable,
    seenIdentifier,
    variableToExpMap,
    expToVariableMap,
    updatedVariable
  };
}
function processRepeatedVariables(context, seenVariable, variableToExpMap, expToVariableMap, seenIdentifier, updatedVariable) {
  const declarations = [];
  const expToReplacementMap = /* @__PURE__ */ new Map();
  for (const [name, exps] of variableToExpMap) {
    if (updatedVariable.has(name)) continue;
    if (seenVariable[name] > 1 && exps.size > 0) {
      const isIdentifier = seenIdentifier.has(name);
      const varName = isIdentifier ? name : genVarName(name);
      exps.forEach((node) => {
        if (node.ast && varName !== name) {
          const replacements = expToReplacementMap.get(node) || [];
          replacements.push({
            name: varName,
            locs: expToVariableMap.get(node).reduce(
              (locs, v) => {
                if (v.name === name && v.loc) locs.push(v.loc);
                return locs;
              },
              []
            )
          });
          expToReplacementMap.set(node, replacements);
        }
      });
      if (!declarations.some((d) => d.name === varName) && (!isIdentifier || shouldDeclareVariable(name, expToVariableMap, exps))) {
        declarations.push({
          name: varName,
          isIdentifier,
          value: extend(
            { ast: isIdentifier ? null : parseExp(context, name) },
            createSimpleExpression(name)
          ),
          rawName: name,
          exps,
          seenCount: seenVariable[name]
        });
      }
    }
  }
  for (const [exp, replacements] of expToReplacementMap) {
    replacements.flatMap(
      ({ name, locs }) => locs.map(({ start, end }) => ({ start, end, name }))
    ).sort((a, b) => b.end - a.end).forEach(({ start, end, name }) => {
      exp.content = exp.content.slice(0, start - 1) + name + exp.content.slice(end - 1);
    });
    exp.ast = parseExp(context, exp.content);
  }
  return declarations;
}
function shouldDeclareVariable(name, expToVariableMap, exps) {
  const vars = Array.from(
    exps,
    (exp) => expToVariableMap.get(exp).map((v) => v.name)
  );
  if (vars.every((v) => v.length === 1)) {
    return true;
  }
  if (vars.some((v) => v.filter((e) => e === name).length > 1)) {
    return true;
  }
  const first = vars[0];
  if (vars.some((v) => v.length !== first.length)) {
    if (vars.some(
      (v) => v.length > first.length && v.every((e) => first.includes(e))
    ) || vars.some((v) => first.length > v.length && first.every((e) => v.includes(e)))) {
      return false;
    }
    return true;
  }
  if (vars.some((v) => v.some((e) => first.includes(e)))) {
    return false;
  }
  return true;
}
function processRepeatedExpressions(context, expressions, varDeclarations, updatedVariable, expToVariableMap) {
  const declarations = [];
  const seenExp = expressions.reduce(
    (acc, exp) => {
      const variables = expToVariableMap.get(exp).map((v) => v.name);
      if (exp.ast && exp.ast.type !== "Identifier" && !(variables && variables.some((v) => updatedVariable.has(v)))) {
        acc[exp.content] = (acc[exp.content] || 0) + 1;
      }
      return acc;
    },
    /* @__PURE__ */ Object.create(null)
  );
  Object.entries(seenExp).forEach(([content, count]) => {
    if (count > 1) {
      const varName = genVarName(content);
      if (!declarations.some((d) => d.name === varName)) {
        const delVars = {};
        for (let i = varDeclarations.length - 1; i >= 0; i--) {
          const item = varDeclarations[i];
          if (!item.exps || !item.seenCount) continue;
          const shouldRemove = [...item.exps].every(
            (node) => node.content === content && item.seenCount === count
          );
          if (shouldRemove) {
            delVars[item.name] = item.rawName;
            varDeclarations.splice(i, 1);
          }
        }
        const value = extend(
          {},
          expressions.find((exp) => exp.content === content)
        );
        Object.keys(delVars).forEach((name) => {
          value.content = value.content.replace(name, delVars[name]);
          if (value.ast) value.ast = parseExp(context, value.content);
        });
        declarations.push({
          name: varName,
          value
        });
      }
      expressions.forEach((exp) => {
        if (exp.content === content) {
          exp.content = varName;
          exp.ast = null;
        } else if (exp.content.includes(content)) {
          exp.content = exp.content.replace(
            new RegExp(escapeRegExp(content), "g"),
            varName
          );
          exp.ast = parseExp(context, exp.content);
        }
      });
    }
  });
  return declarations;
}
function genDeclarations(declarations, context) {
  const [frag, push] = buildCodeFragment();
  const ids = /* @__PURE__ */ Object.create(null);
  declarations.forEach(({ name, isIdentifier, value }) => {
    if (isIdentifier) {
      const varName = ids[name] = `_${name}`;
      push(`const ${varName} = `, ...genExpression(value, context), NEWLINE);
    }
  });
  declarations.forEach(({ name, isIdentifier, value }) => {
    if (!isIdentifier) {
      const varName = ids[name] = `_${name}`;
      push(
        `const ${varName} = `,
        ...context.withId(() => genExpression(value, context), ids),
        NEWLINE
      );
    }
  });
  return { ids, frag };
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function parseExp(context, content) {
  const plugins = context.options.expressionPlugins;
  const options = {
    plugins: plugins ? [...plugins, "typescript"] : ["typescript"]
  };
  return libExports.parseExpression(`(${content})`, options);
}
function genVarName(exp) {
  return `${exp.replace(/[^a-zA-Z0-9]/g, "_").replace(/_+/g, "_").replace(/_+$/, "")}`;
}
function extractMemberExpression(exp, onIdentifier) {
  if (!exp) return "";
  switch (exp.type) {
    case "Identifier":
      onIdentifier(exp);
      return exp.name;
    case "StringLiteral":
      return exp.extra ? exp.extra.raw : exp.value;
    case "NumericLiteral":
      return exp.value.toString();
    case "BinaryExpression":
      return `${extractMemberExpression(exp.left, onIdentifier)} ${exp.operator} ${extractMemberExpression(exp.right, onIdentifier)}`;
    case "CallExpression":
      return `${extractMemberExpression(exp.callee, onIdentifier)}(${exp.arguments.map((arg) => extractMemberExpression(arg, onIdentifier)).join(", ")})`;
    case "MemberExpression":
    // foo[bar.baz]
    case "OptionalMemberExpression":
      const object = extractMemberExpression(exp.object, onIdentifier);
      const prop = exp.computed ? `[${extractMemberExpression(exp.property, onIdentifier)}]` : `.${extractMemberExpression(exp.property, NOOP)}`;
      return `${object}${prop}`;
    default:
      return "";
  }
}
const isMemberExpression = (node) => {
  return node.type === "MemberExpression" || node.type === "OptionalMemberExpression";
};

function genSetEvent(oper, context) {
  const { helper } = context;
  const { element, key, keyOverride, value, modifiers, delegate, effect } = oper;
  const name = genName();
  const handler = genEventHandler(context, value, modifiers);
  const eventOptions = genEventOptions();
  if (delegate) {
    context.delegates.add(key.content);
    if (!context.block.operation.some(isSameDelegateEvent)) {
      return [NEWLINE, `n${element}.$evt${key.content} = `, ...handler];
    }
  }
  return [
    NEWLINE,
    ...genCall(
      helper(delegate ? "delegate" : "on"),
      `n${element}`,
      name,
      handler,
      eventOptions
    )
  ];
  function genName() {
    const expr = genExpression(key, context);
    if (keyOverride) {
      const find = JSON.stringify(keyOverride[0]);
      const replacement = JSON.stringify(keyOverride[1]);
      const wrapped = ["(", ...expr, ")"];
      return [...wrapped, ` === ${find} ? ${replacement} : `, ...wrapped];
    } else {
      return genExpression(key, context);
    }
  }
  function genEventOptions() {
    let { options } = modifiers;
    if (!options.length && !effect) return;
    return genMulti(
      DELIMITERS_OBJECT_NEWLINE,
      effect && ["effect: true"],
      ...options.map((option) => [`${option}: true`])
    );
  }
  function isSameDelegateEvent(op) {
    if (op.type === 5 && op !== oper && op.delegate && op.element === oper.element && op.key.content === key.content) {
      return true;
    }
  }
}
function genSetDynamicEvents(oper, context) {
  const { helper } = context;
  return [
    NEWLINE,
    ...genCall(
      helper("setDynamicEvents"),
      `n${oper.element}`,
      genExpression(oper.event, context)
    )
  ];
}
function genEventHandler(context, value, modifiers = { nonKeys: [], keys: [] }, extraWrap = false) {
  let handlerExp = [`() => {}`];
  if (value && value.content.trim()) {
    if (isMemberExpression$1(value, context.options)) {
      handlerExp = genExpression(value, context);
      if (!isConstantBinding(value, context) && !extraWrap) {
        handlerExp = [`e => `, ...handlerExp, `(e)`];
      }
    } else if (isFnExpression(value, context.options)) {
      handlerExp = genExpression(value, context);
    } else {
      const referencesEvent = value.content.includes("$event");
      const hasMultipleStatements = value.content.includes(`;`);
      const expr = referencesEvent ? context.withId(() => genExpression(value, context), {
        $event: null
      }) : genExpression(value, context);
      handlerExp = [
        referencesEvent ? "$event => " : "() => ",
        hasMultipleStatements ? "{" : "(",
        ...expr,
        hasMultipleStatements ? "}" : ")"
      ];
    }
  }
  const { keys, nonKeys } = modifiers;
  if (nonKeys.length)
    handlerExp = genWithModifiers(context, handlerExp, nonKeys);
  if (keys.length) handlerExp = genWithKeys(context, handlerExp, keys);
  if (extraWrap) handlerExp.unshift(`() => `);
  return handlerExp;
}
function genWithModifiers(context, handler, nonKeys) {
  return genCall(
    context.helper("withModifiers"),
    handler,
    JSON.stringify(nonKeys)
  );
}
function genWithKeys(context, handler, keys) {
  return genCall(context.helper("withKeys"), handler, JSON.stringify(keys));
}
function isConstantBinding(value, context) {
  if (value.ast === null) {
    const bindingType = context.options.bindingMetadata[value.content];
    if (bindingType === "setup-const") {
      return true;
    }
  }
}

function genFor(oper, context) {
  const { helper } = context;
  const {
    source,
    value,
    key,
    index,
    render,
    keyProp,
    once,
    id,
    component,
    onlyChild
  } = oper;
  let rawValue = null;
  const rawKey = key && key.content;
  const rawIndex = index && index.content;
  const sourceExpr = ["() => (", ...genExpression(source, context), ")"];
  const idToPathMap = parseValueDestructure();
  const [depth, exitScope] = context.enterScope();
  const idMap = {};
  const itemVar = `_for_item${depth}`;
  idMap[itemVar] = null;
  idToPathMap.forEach((pathInfo, id2) => {
    let path = `${itemVar}.value${pathInfo ? pathInfo.path : ""}`;
    if (pathInfo) {
      if (pathInfo.helper) {
        idMap[pathInfo.helper] = null;
        path = `${pathInfo.helper}(${path}, ${pathInfo.helperArgs})`;
      }
      if (pathInfo.dynamic) {
        const node = idMap[id2] = createSimpleExpression(path);
        const plugins = context.options.expressionPlugins;
        node.ast = libExports.parseExpression(`(${path})`, {
          plugins: plugins ? [...plugins, "typescript"] : ["typescript"]
        });
      } else {
        idMap[id2] = path;
      }
    } else {
      idMap[id2] = path;
    }
  });
  const args = [itemVar];
  if (rawKey) {
    const keyVar = `_for_key${depth}`;
    args.push(`, ${keyVar}`);
    idMap[rawKey] = `${keyVar}.value`;
    idMap[keyVar] = null;
  }
  if (rawIndex) {
    const indexVar = `_for_index${depth}`;
    args.push(`, ${indexVar}`);
    idMap[rawIndex] = `${indexVar}.value`;
    idMap[indexVar] = null;
  }
  const blockFn = context.withId(() => genBlock(render, context, args), idMap);
  exitScope();
  let flags = 0;
  if (onlyChild) {
    flags |= 1;
  }
  if (component) {
    flags |= 2;
  }
  if (once) {
    flags |= 4;
  }
  return [
    NEWLINE,
    `const n${id} = `,
    ...genCall(
      helper("createFor"),
      sourceExpr,
      blockFn,
      genCallback(keyProp),
      flags ? String(flags) : void 0
      // todo: hydrationNode
    )
  ];
  function parseValueDestructure() {
    const map = /* @__PURE__ */ new Map();
    if (value) {
      rawValue = value && value.content;
      if (value.ast) {
        walkIdentifiers(
          value.ast,
          (id2, _, parentStack, ___, isLocal) => {
            if (isLocal) {
              let path = "";
              let isDynamic = false;
              let helper2;
              let helperArgs;
              for (let i = 0; i < parentStack.length; i++) {
                const parent = parentStack[i];
                const child = parentStack[i + 1] || id2;
                if (parent.type === "ObjectProperty" && parent.value === child) {
                  if (parent.key.type === "StringLiteral") {
                    path += `[${JSON.stringify(parent.key.value)}]`;
                  } else if (parent.computed) {
                    isDynamic = true;
                    path += `[${value.content.slice(
                      parent.key.start - 1,
                      parent.key.end - 1
                    )}]`;
                  } else {
                    path += `.${parent.key.name}`;
                  }
                } else if (parent.type === "ArrayPattern") {
                  const index2 = parent.elements.indexOf(child);
                  if (child.type === "RestElement") {
                    path += `.slice(${index2})`;
                  } else {
                    path += `[${index2}]`;
                  }
                } else if (parent.type === "ObjectPattern" && child.type === "RestElement") {
                  helper2 = context.helper("getRestElement");
                  helperArgs = "[" + parent.properties.filter((p) => p.type === "ObjectProperty").map((p) => {
                    if (p.key.type === "StringLiteral") {
                      return JSON.stringify(p.key.value);
                    } else if (p.computed) {
                      isDynamic = true;
                      return value.content.slice(
                        p.key.start - 1,
                        p.key.end - 1
                      );
                    } else {
                      return JSON.stringify(p.key.name);
                    }
                  }).join(", ") + "]";
                }
                if (child.type === "AssignmentPattern" && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
                  isDynamic = true;
                  helper2 = context.helper("getDefaultValue");
                  helperArgs = value.content.slice(
                    child.right.start - 1,
                    child.right.end - 1
                  );
                }
              }
              map.set(id2.name, { path, dynamic: isDynamic, helper: helper2, helperArgs });
            }
          },
          true
        );
      } else {
        map.set(rawValue, null);
      }
    }
    return map;
  }
  function genCallback(expr) {
    if (!expr) return false;
    const res = context.withId(
      () => genExpression(expr, context),
      genSimpleIdMap()
    );
    return [
      ...genMulti(
        ["(", ")", ", "],
        rawValue ? rawValue : rawKey || rawIndex ? "_" : void 0,
        rawKey ? rawKey : rawIndex ? "__" : void 0,
        rawIndex
      ),
      " => (",
      ...res,
      ")"
    ];
  }
  function genSimpleIdMap() {
    const idMap2 = {};
    if (rawKey) idMap2[rawKey] = null;
    if (rawIndex) idMap2[rawIndex] = null;
    idToPathMap.forEach((_, id2) => idMap2[id2] = null);
    return idMap2;
  }
}

function genSetHtml(oper, context) {
  const { helper } = context;
  const { value, element } = oper;
  return [
    NEWLINE,
    ...genCall(helper("setHtml"), `n${element}`, genExpression(value, context))
  ];
}

function genIf(oper, context, isNested = false) {
  const { helper } = context;
  const { condition, positive, negative, once } = oper;
  const [frag, push] = buildCodeFragment();
  const conditionExpr = [
    "() => (",
    ...genExpression(condition, context),
    ")"
  ];
  let positiveArg = genBlock(positive, context);
  let negativeArg = false;
  if (negative) {
    if (negative.type === 1) {
      negativeArg = genBlock(negative, context);
    } else {
      negativeArg = ["() => ", ...genIf(negative, context, true)];
    }
  }
  if (!isNested) push(NEWLINE, `const n${oper.id} = `);
  push(
    ...genCall(
      helper("createIf"),
      conditionExpr,
      positiveArg,
      negativeArg,
      once && "true"
    )
  );
  return frag;
}

const helpers = {
  setText: { name: "setText" },
  setHtml: { name: "setHtml" },
  setClass: { name: "setClass" },
  setStyle: { name: "setStyle" },
  setValue: { name: "setValue" },
  setAttr: { name: "setAttr", needKey: true },
  setProp: { name: "setProp", needKey: true },
  setDOMProp: { name: "setDOMProp", needKey: true }};
function genSetProp(oper, context) {
  const { helper } = context;
  const {
    prop: { key, values, modifier },
    tag
  } = oper;
  const resolvedHelper = getRuntimeHelper(tag, key.content, modifier);
  const propValue = genPropValue(values, context);
  return [
    NEWLINE,
    ...genCall(
      [helper(resolvedHelper.name), null],
      `n${oper.element}`,
      resolvedHelper.needKey ? genExpression(key, context) : false,
      propValue
    )
  ];
}
function genDynamicProps$1(oper, context) {
  const { helper } = context;
  const values = oper.props.map(
    (props) => Array.isArray(props) ? genLiteralObjectProps(props, context) : props.kind === 1 ? genLiteralObjectProps([props], context) : genExpression(props.value, context)
  );
  return [
    NEWLINE,
    ...genCall(
      helper("setDynamicProps"),
      `n${oper.element}`,
      genMulti(DELIMITERS_ARRAY, ...values),
      oper.root && "true"
    )
  ];
}
function genLiteralObjectProps(props, context) {
  return genMulti(
    DELIMITERS_OBJECT,
    ...props.map((prop) => [
      ...genPropKey(prop, context),
      `: `,
      ...genPropValue(prop.values, context)
    ])
  );
}
function genPropKey({ key: node, modifier, runtimeCamelize, handler, handlerModifiers }, context) {
  const { helper } = context;
  const handlerModifierPostfix = handlerModifiers ? handlerModifiers.map(capitalize).join("") : "";
  if (node.isStatic) {
    const keyName = (handler ? toHandlerKey(node.content) : node.content) + handlerModifierPostfix;
    return [
      [
        isSimpleIdentifier(keyName) ? keyName : JSON.stringify(keyName),
        -2,
        node.loc
      ]
    ];
  }
  let key = genExpression(node, context);
  if (runtimeCamelize) {
    key = genCall(helper("camelize"), key);
  }
  if (handler) {
    key = genCall(helper("toHandlerKey"), key);
  }
  return [
    "[",
    modifier && `${JSON.stringify(modifier)} + `,
    ...key,
    handlerModifierPostfix ? ` + ${JSON.stringify(handlerModifierPostfix)}` : void 0,
    "]"
  ];
}
function genPropValue(values, context) {
  if (values.length === 1) {
    return genExpression(values[0], context);
  }
  return genMulti(
    DELIMITERS_ARRAY,
    ...values.map((expr) => genExpression(expr, context))
  );
}
function getRuntimeHelper(tag, key, modifier) {
  const tagName = tag.toUpperCase();
  if (modifier) {
    if (modifier === ".") {
      return getSpecialHelper(key, tagName) || helpers.setDOMProp;
    } else {
      return helpers.setAttr;
    }
  }
  const helper = getSpecialHelper(key, tagName);
  if (helper) {
    return helper;
  }
  if (/aria[A-Z]/.test(key)) {
    return helpers.setDOMProp;
  }
  if (isSVGTag(tag)) {
    return helpers.setAttr;
  }
  if (shouldSetAsAttr(tagName, key) || key.includes("-")) {
    return helpers.setAttr;
  }
  return helpers.setProp;
}
function getSpecialHelper(keyName, tagName) {
  if (keyName === "value" && canSetValueDirectly(tagName)) {
    return helpers.setValue;
  } else if (keyName === "class") {
    return helpers.setClass;
  } else if (keyName === "style") {
    return helpers.setStyle;
  } else if (keyName === "innerHTML") {
    return helpers.setHtml;
  } else if (keyName === "textContent") {
    return helpers.setText;
  }
}

const setTemplateRefIdent = `_setTemplateRef`;
function genSetTemplateRef(oper, context) {
  return [
    NEWLINE,
    oper.effect && `r${oper.element} = `,
    ...genCall(
      setTemplateRefIdent,
      // will be generated in root scope
      `n${oper.element}`,
      genRefValue(oper.value, context),
      oper.effect ? `r${oper.element}` : oper.refFor ? "void 0" : void 0,
      oper.refFor && "true"
    )
  ];
}
function genDeclareOldRef(oper) {
  return [NEWLINE, `let r${oper.id}`];
}
function genRefValue(value, context) {
  if (value && context.options.inline) {
    const binding = context.options.bindingMetadata[value.content];
    if (binding === "setup-let" || binding === "setup-ref" || binding === "setup-maybe-ref") {
      return [value.content];
    }
  }
  return genExpression(value, context);
}

function genSetText(oper, context) {
  const { helper } = context;
  const { element, values, generated, jsx } = oper;
  const texts = combineValues(values, context, jsx);
  return [
    NEWLINE,
    ...genCall(helper("setText"), `${generated ? "x" : "n"}${element}`, texts)
  ];
}
function combineValues(values, context, jsx) {
  return values.flatMap((value, i) => {
    let exp = genExpression(value, context);
    if (!jsx && getLiteralExpressionValue(value) == null) {
      exp = genCall(context.helper("toDisplayString"), exp);
    }
    if (i > 0) {
      exp.unshift(jsx ? ", " : " + ");
    }
    return exp;
  });
}
function genGetTextChild(oper, context) {
  return [
    NEWLINE,
    `const x${oper.parent} = ${context.helper("child")}(n${oper.parent})`
  ];
}

function genVShow(oper, context) {
  return [
    NEWLINE,
    ...genCall(context.helper("applyVShow"), `n${oper.element}`, [
      `() => (`,
      ...genExpression(oper.dir.exp, context),
      `)`
    ])
  ];
}

const helperMap = {
  text: "applyTextModel",
  radio: "applyRadioModel",
  checkbox: "applyCheckboxModel",
  select: "applySelectModel",
  dynamic: "applyDynamicModel"
};
function genVModel(oper, context) {
  const {
    modelType,
    element,
    dir: { exp, modifiers }
  } = oper;
  return [
    NEWLINE,
    ...genCall(
      context.helper(helperMap[modelType]),
      `n${element}`,
      // getter
      [`() => (`, ...genExpression(exp, context), `)`],
      // setter
      genModelHandler(exp, context),
      // modifiers
      modifiers.length ? `{ ${modifiers.map((e) => e.content + ": true").join(",")} }` : void 0
    )
  ];
}
function genModelHandler(exp, context) {
  return [
    `${context.options.isTS ? `(_value: any)` : `_value`} => (`,
    ...genExpression(exp, context, "_value"),
    ")"
  ];
}

function genBuiltinDirective(oper, context) {
  switch (oper.name) {
    case "show":
      return genVShow(oper, context);
    case "model":
      return genVModel(oper, context);
    default:
      return [];
  }
}
function genDirectivesForElement(id, context) {
  const dirs = filterCustomDirectives(id, context.block.operation);
  return dirs.length ? genCustomDirectives(dirs, context) : [];
}
function genCustomDirectives(opers, context) {
  const { helper } = context;
  const element = `n${opers[0].element}`;
  const directiveItems = opers.map(genDirectiveItem);
  const directives = genMulti(DELIMITERS_ARRAY, ...directiveItems);
  return [
    NEWLINE,
    ...genCall(helper("withVaporDirectives"), element, directives)
  ];
  function genDirectiveItem({
    dir,
    name,
    asset
  }) {
    const directiveVar = asset ? toValidAssetId(name, "directive") : genExpression(
      extend(createSimpleExpression(name, false), { ast: null }),
      context
    );
    const value = dir.exp && ["() => ", ...genExpression(dir.exp, context)];
    const argument = dir.arg && genExpression(dir.arg, context);
    const modifiers = !!dir.modifiers.length && [
      "{ ",
      genDirectiveModifiers(dir.modifiers.map((m) => m.content)),
      " }"
    ];
    return genMulti(
      DELIMITERS_ARRAY.concat("void 0"),
      directiveVar,
      value,
      argument,
      modifiers
    );
  }
}
function genDirectiveModifiers(modifiers) {
  return modifiers.map(
    (value) => `${isSimpleIdentifier(value) ? value : JSON.stringify(value)}: true`
  ).join(", ");
}
function filterCustomDirectives(id, operations) {
  return operations.filter(
    (oper) => oper.type === 13 && oper.element === id && !oper.builtin
  );
}

function genCreateComponent(operation, context) {
  const { helper } = context;
  const tag = genTag();
  const { root, props, slots, once } = operation;
  const rawSlots = genRawSlots(slots, context);
  const [ids, handlers] = processInlineHandlers(props, context);
  const rawProps = context.withId(() => genRawProps(props, context), ids);
  const inlineHandlers = handlers.reduce(
    (acc, { name, value }) => {
      const handler = genEventHandler(context, value, void 0, false);
      return [...acc, `const ${name} = `, ...handler, NEWLINE];
    },
    []
  );
  const args = [
    tag,
    rawProps,
    rawSlots,
    root ? "true" : false,
    once && "true"
  ];
  if (context.options.templateMode === "factory") {
    if (operation.asset || operation.dynamic && !operation.dynamic.isStatic) {
      args.unshift(`$doc`);
    }
  }
  return [
    NEWLINE,
    ...inlineHandlers,
    `const n${operation.id} = `,
    ...genCall(
      operation.dynamic && !operation.dynamic.isStatic ? helper("createDynamicComponent") : operation.asset ? helper("createComponentWithFallback") : helper("createComponent"),
      ...args
    ),
    ...genDirectivesForElement(operation.id, context)
  ];
  function genTag() {
    if (operation.dynamic) {
      if (operation.dynamic.isStatic) {
        return genCall(
          helper("resolveDynamicComponent"),
          genExpression(operation.dynamic, context)
        );
      } else {
        return ["() => (", ...genExpression(operation.dynamic, context), ")"];
      }
    } else if (operation.asset) {
      return toValidAssetId(operation.tag, "component");
    } else {
      return genExpression(
        extend(createSimpleExpression(operation.tag, false), { ast: null }),
        context
      );
    }
  }
}
function getUniqueHandlerName(context, name) {
  const { seenInlineHandlerNames } = context;
  const count = seenInlineHandlerNames[name] || 0;
  seenInlineHandlerNames[name] = count + 1;
  return count === 0 ? name : `${name}${count}`;
}
function processInlineHandlers(props, context) {
  const ids = /* @__PURE__ */ Object.create(null);
  const handlers = [];
  const staticProps = props[0];
  if (isArray$3(staticProps)) {
    for (let i = 0; i < staticProps.length; i++) {
      const prop = staticProps[i];
      if (!prop.handler) continue;
      prop.values.forEach((value, i2) => {
        const isMemberExp = isMemberExpression$1(value, context.options);
        if (!isMemberExp) {
          const name = getUniqueHandlerName(context, `_on_${prop.key.content}`);
          handlers.push({ name, value });
          ids[name] = null;
          prop.values[i2] = extend({ ast: null }, createSimpleExpression(name));
        }
      });
    }
  }
  return [ids, handlers];
}
function genRawProps(props, context) {
  const staticProps = props[0];
  if (isArray$3(staticProps)) {
    if (!staticProps.length && props.length === 1) {
      return;
    }
    return genStaticProps(
      staticProps,
      context,
      genDynamicProps(props.slice(1), context)
    );
  } else if (props.length) {
    return genStaticProps([], context, genDynamicProps(props, context));
  }
}
function genStaticProps(props, context, dynamicProps) {
  const args = props.map((prop) => genProp(prop, context, true));
  if (dynamicProps) {
    args.push([`$: `, ...dynamicProps]);
  }
  return genMulti(
    args.length > 1 ? DELIMITERS_OBJECT_NEWLINE : DELIMITERS_OBJECT,
    ...args
  );
}
function genDynamicProps(props, context) {
  const { helper } = context;
  const frags = [];
  for (const p of props) {
    let expr;
    if (isArray$3(p)) {
      if (p.length) {
        frags.push(genStaticProps(p, context));
      }
      continue;
    } else {
      if (p.kind === 1)
        expr = genMulti(DELIMITERS_OBJECT, genProp(p, context));
      else {
        expr = genExpression(p.value, context);
        if (p.handler) expr = genCall(helper("toHandlers"), expr);
      }
    }
    frags.push(["() => (", ...expr, ")"]);
  }
  if (frags.length) {
    return genMulti(DELIMITERS_ARRAY_NEWLINE, ...frags);
  }
}
function genProp(prop, context, isStatic) {
  const values = genPropValue(prop.values, context);
  return [
    ...genPropKey(prop, context),
    ": ",
    ...prop.handler ? genEventHandler(
      context,
      prop.values[0],
      void 0,
      true
    ) : isStatic ? ["() => (", ...values, ")"] : values,
    ...prop.model ? [...genModelEvent(prop, context), ...genModelModifiers(prop, context)] : []
  ];
}
function genModelEvent(prop, context) {
  const name = prop.key.isStatic ? [JSON.stringify(`onUpdate:${camelize(prop.key.content)}`)] : ['["onUpdate:" + ', ...genExpression(prop.key, context), "]"];
  const handler = genModelHandler(prop.values[0], context);
  return [",", NEWLINE, ...name, ": () => ", ...handler];
}
function genModelModifiers(prop, context) {
  const { key, modelModifiers } = prop;
  if (!modelModifiers || !modelModifiers.length) return [];
  const modifiersKey = key.isStatic ? key.content === "modelValue" ? [`modelModifiers`] : [`${key.content}Modifiers`] : ["[", ...genExpression(key, context), ' + "Modifiers"]'];
  const modifiersVal = genDirectiveModifiers(modelModifiers);
  return [",", NEWLINE, ...modifiersKey, `: () => ({ ${modifiersVal} })`];
}
function genRawSlots(slots, context) {
  if (!slots.length) return;
  const staticSlots = slots[0];
  if (staticSlots.slotType === 0) {
    return genStaticSlots(
      staticSlots,
      context,
      slots.length > 1 ? slots.slice(1) : void 0
    );
  } else {
    return genStaticSlots(
      { slots: {} },
      context,
      slots
    );
  }
}
function genStaticSlots({ slots }, context, dynamicSlots) {
  const args = Object.keys(slots).map((name) => [
    `${JSON.stringify(name)}: `,
    ...genSlotBlockWithProps(slots[name], context)
  ]);
  if (dynamicSlots) {
    args.push([`$: `, ...genDynamicSlots(dynamicSlots, context)]);
  }
  return genMulti(DELIMITERS_OBJECT_NEWLINE, ...args);
}
function genDynamicSlots(slots, context) {
  return genMulti(
    DELIMITERS_ARRAY_NEWLINE,
    ...slots.map(
      (slot) => slot.slotType === 0 ? genStaticSlots(slot, context) : slot.slotType === 4 ? slot.slots.content : genDynamicSlot(slot, context, true)
    )
  );
}
function genDynamicSlot(slot, context, withFunction = false) {
  let frag;
  switch (slot.slotType) {
    case 1:
      frag = genBasicDynamicSlot(slot, context);
      break;
    case 2:
      frag = genLoopSlot(slot, context);
      break;
    case 3:
      frag = genConditionalSlot(slot, context);
      break;
  }
  return withFunction ? ["() => (", ...frag, ")"] : frag;
}
function genBasicDynamicSlot(slot, context) {
  const { name, fn } = slot;
  return genMulti(
    DELIMITERS_OBJECT_NEWLINE,
    ["name: ", ...genExpression(name, context)],
    ["fn: ", ...genSlotBlockWithProps(fn, context)]
  );
}
function genLoopSlot(slot, context) {
  const { name, fn, loop } = slot;
  const { value, key, index, source } = loop;
  const rawValue = value && value.content;
  const rawKey = key && key.content;
  const rawIndex = index && index.content;
  const idMap = {};
  if (rawValue) idMap[rawValue] = rawValue;
  if (rawKey) idMap[rawKey] = rawKey;
  if (rawIndex) idMap[rawIndex] = rawIndex;
  const slotExpr = genMulti(
    DELIMITERS_OBJECT_NEWLINE,
    ["name: ", ...context.withId(() => genExpression(name, context), idMap)],
    [
      "fn: ",
      ...context.withId(() => genSlotBlockWithProps(fn, context), idMap)
    ]
  );
  return [
    ...genCall(
      context.helper("createForSlots"),
      genExpression(source, context),
      [
        ...genMulti(
          ["(", ")", ", "],
          rawValue ? rawValue : rawKey || rawIndex ? "_" : void 0,
          rawKey ? rawKey : rawIndex ? "__" : void 0,
          rawIndex
        ),
        " => (",
        ...slotExpr,
        ")"
      ]
    )
  ];
}
function genConditionalSlot(slot, context) {
  const { condition, positive, negative } = slot;
  return [
    ...genExpression(condition, context),
    INDENT_START,
    NEWLINE,
    "? ",
    ...genDynamicSlot(positive, context),
    NEWLINE,
    ": ",
    ...negative ? [...genDynamicSlot(negative, context)] : ["void 0"],
    INDENT_END
  ];
}
function genSlotBlockWithProps(oper, context) {
  let isDestructureAssignment = false;
  let rawProps;
  let propsName;
  let exitScope;
  let depth;
  const { props } = oper;
  const idsOfProps = /* @__PURE__ */ new Set();
  if (props) {
    rawProps = props.content;
    if (isDestructureAssignment = !!props.ast) {
      [depth, exitScope] = context.enterScope();
      propsName = `_slotProps${depth}`;
      walkIdentifiers(
        props.ast,
        (id, _, __, ___, isLocal) => {
          if (isLocal) idsOfProps.add(id.name);
        },
        true
      );
    } else {
      idsOfProps.add(propsName = rawProps);
    }
  }
  const idMap = {};
  idsOfProps.forEach(
    (id) => idMap[id] = isDestructureAssignment ? `${propsName}[${JSON.stringify(id)}]` : null
  );
  const blockFn = context.withId(
    () => genBlock(oper, context, [propsName]),
    idMap
  );
  exitScope && exitScope();
  return blockFn;
}

function genSlotOutlet(oper, context) {
  const { helper } = context;
  const { id, name, fallback } = oper;
  const [frag, push] = buildCodeFragment();
  const nameExpr = name.isStatic ? genExpression(name, context) : ["() => (", ...genExpression(name, context), ")"];
  let fallbackArg;
  if (fallback) {
    fallbackArg = genBlock(fallback, context);
  }
  push(
    NEWLINE,
    `const n${id} = `,
    ...genCall(
      helper("createSlot"),
      nameExpr,
      genRawProps(oper.props, context) || "null",
      fallbackArg
    )
  );
  return frag;
}

function genOperations(opers, context) {
  const [frag, push] = buildCodeFragment();
  for (const operation of opers) {
    push(...genOperationWithInsertionState(operation, context));
  }
  return frag;
}
function genOperationWithInsertionState(oper, context) {
  const [frag, push] = buildCodeFragment();
  if (isBlockOperation(oper) && oper.parent) {
    push(...genInsertionState(oper, context));
  }
  push(...genOperation(oper, context));
  return frag;
}
function genOperation(oper, context) {
  switch (oper.type) {
    case 2:
      return genSetProp(oper, context);
    case 3:
      return genDynamicProps$1(oper, context);
    case 4:
      return genSetText(oper, context);
    case 5:
      return genSetEvent(oper, context);
    case 6:
      return genSetDynamicEvents(oper, context);
    case 7:
      return genSetHtml(oper, context);
    case 8:
      return genSetTemplateRef(oper, context);
    case 9:
      return genInsertNode(oper, context);
    case 10:
      return genPrependNode(oper, context);
    case 15:
      return genIf(oper, context);
    case 16:
      return genFor(oper, context);
    case 11:
      return genCreateComponent(oper, context);
    case 14:
      return genDeclareOldRef(oper);
    case 12:
      return genSlotOutlet(oper, context);
    case 13:
      return genBuiltinDirective(oper, context);
    case 17:
      return genGetTextChild(oper, context);
    default:
      const exhaustiveCheck = oper;
      throw new Error(
        `Unhandled operation type in genOperation: ${exhaustiveCheck}`
      );
  }
}
function genEffects(effects, context) {
  const { helper } = context;
  const expressions = effects.flatMap((effect) => effect.expressions);
  const [frag, push, unshift] = buildCodeFragment();
  let operationsCount = 0;
  const { ids, frag: declarationFrags } = processExpressions(
    context,
    expressions
  );
  push(...declarationFrags);
  for (let i = 0; i < effects.length; i++) {
    const effect = effects[i];
    operationsCount += effect.operations.length;
    const frags = context.withId(() => genEffect(effect, context), ids);
    i > 0 && push(NEWLINE);
    if (frag[frag.length - 1] === ")" && frags[0] === "(") {
      push(";");
    }
    push(...frags);
  }
  const newLineCount = frag.filter((frag2) => frag2 === NEWLINE).length;
  if (newLineCount > 1 || operationsCount > 1 || declarationFrags.length > 0) {
    unshift(`{`, INDENT_START, NEWLINE);
    push(INDENT_END, NEWLINE, "}");
  }
  if (effects.length) {
    unshift(NEWLINE, `${helper("renderEffect")}(() => `);
    push(`)`);
  }
  return frag;
}
function genEffect({ operations }, context) {
  const [frag, push] = buildCodeFragment();
  const operationsExps = genOperations(operations, context);
  const newlineCount = operationsExps.filter((frag2) => frag2 === NEWLINE).length;
  if (newlineCount > 1) {
    push(...operationsExps);
  } else {
    push(...operationsExps.filter((frag2) => frag2 !== NEWLINE));
  }
  return frag;
}
function genInsertionState(operation, context) {
  return [
    NEWLINE,
    ...genCall(
      context.helper("setInsertionState"),
      `n${operation.parent}`,
      operation.anchor == null ? void 0 : operation.anchor === -1 ? `0` : `n${operation.anchor}`
    )
  ];
}

const COMMENT_START = "<!--";
const COMMENT_END = "-->";
const DOCTYPE_START = "<!";
const WHITESPACE_REGEX = /\s/;
const ATTRIBUTE_NAME_REGEX = /[\s=]/;
const SELF_CLOSING_REGEX = /\s*\/$/;
class HtmlParser {
  constructor(html) {
    this.html = html;
    this.length = html.length;
    this.index = 0;
  }
  /**
   * Parse HTML string into an array of HTML nodes
   */
  parse() {
    const nodes = [];
    this.index = 0;
    while (this.index < this.length) {
      if (this.html[this.index] === "<") {
        const result = this.parseTag();
        if (result) {
          nodes.push(result.node);
          this.index = result.endIndex;
        } else {
          this.index++;
        }
      } else {
        const textNode = this.parseText();
        if (textNode) {
          nodes.push(textNode);
        }
      }
    }
    return nodes;
  }
  // =============================================================================
  // Private Methods - Main Parsing Logic
  // =============================================================================
  /**
   * Parse text content until next tag
   */
  parseText() {
    const start = this.index;
    const nextTag = this.html.indexOf("<", start);
    const end = nextTag === -1 ? this.length : nextTag;
    if (start === end) return null;
    const content = this.html.substring(start, end);
    this.index = end;
    return { type: "text", content };
  }
  /**
   * Parse a tag (element, comment, or doctype)
   */
  parseTag() {
    if (this.html.startsWith(COMMENT_START, this.index)) {
      return this.parseComment();
    }
    if (this.html.startsWith(DOCTYPE_START, this.index)) {
      return this.parseDoctype();
    }
    return this.parseElement();
  }
  /**
   * Parse HTML comment
   */
  parseComment() {
    const start = this.index + COMMENT_START.length;
    const end = this.html.indexOf(COMMENT_END, start);
    if (end === -1) return null;
    const content = this.html.substring(start, end);
    return {
      node: { type: "comment", content },
      endIndex: end + COMMENT_END.length
    };
  }
  /**
   * Parse DOCTYPE and other declarations
   */
  parseDoctype() {
    const end = this.html.indexOf(">", this.index + DOCTYPE_START.length);
    if (end === -1) return null;
    return {
      node: { type: "comment", content: "" },
      endIndex: end + 1
    };
  }
  /**
   * Parse HTML element
   */
  parseElement() {
    const tagEnd = this.html.indexOf(">", this.index);
    if (tagEnd === -1) return null;
    const tagContent = this.html.substring(this.index + 1, tagEnd);
    const { tag, attrs, selfClosing } = this.parseTagContent(tagContent);
    if (selfClosing) {
      return {
        node: { type: "element", tag, attrs, children: [] },
        endIndex: tagEnd + 1
      };
    }
    const endTagIndex = this.findMatchingEndTag(tag, tagEnd + 1);
    if (endTagIndex === -1) {
      return {
        node: { type: "element", tag, attrs, children: [] },
        endIndex: tagEnd + 1
      };
    }
    const innerHtml = this.html.substring(tagEnd + 1, endTagIndex);
    const children = innerHtml ? new HtmlParser(innerHtml).parse() : [];
    return {
      node: { type: "element", tag, attrs, children },
      endIndex: endTagIndex + `</${tag}>`.length
    };
  }
  // =============================================================================
  // Private Methods - Tag Content Parsing
  // =============================================================================
  /**
   * Parse tag content to extract tag name, attributes, and self-closing flag
   */
  parseTagContent(content) {
    const selfClosing = SELF_CLOSING_REGEX.test(content);
    const cleanContent = content.replace(SELF_CLOSING_REGEX, "").trim();
    if (!cleanContent) {
      return { tag: "", attrs: {}, selfClosing };
    }
    const spaceIndex = cleanContent.search(WHITESPACE_REGEX);
    const tag = spaceIndex === -1 ? cleanContent : cleanContent.substring(0, spaceIndex);
    if (spaceIndex === -1) {
      return { tag, attrs: {}, selfClosing };
    }
    const attrContent = cleanContent.substring(spaceIndex + 1);
    const attrs = this.parseAttributes(attrContent);
    return { tag, attrs, selfClosing };
  }
  /**
   * Parse attributes from attribute content string
   */
  parseAttributes(content) {
    const attrs = {};
    let i = 0;
    const length = content.length;
    while (i < length) {
      i = this.skipWhitespace(content, i);
      if (i >= length) break;
      const nameStart = i;
      while (i < length && !ATTRIBUTE_NAME_REGEX.test(content[i])) {
        i++;
      }
      if (i === nameStart) break;
      const name = content.substring(nameStart, i);
      i = this.skipWhitespace(content, i);
      if (i >= length || content[i] !== "=") {
        attrs[name] = name;
        continue;
      }
      i++;
      i = this.skipWhitespace(content, i);
      if (i >= length) {
        attrs[name] = "";
        continue;
      }
      const value = this.parseAttributeValue(content, i);
      attrs[name] = value.value;
      i = value.endIndex;
    }
    return attrs;
  }
  /**
   * Parse attribute value (quoted or unquoted)
   */
  parseAttributeValue(content, startIndex) {
    const quote = content[startIndex];
    if (quote === '"' || quote === "'") {
      const valueStart = startIndex + 1;
      let i = valueStart;
      while (i < content.length && content[i] !== quote) {
        i++;
      }
      const value = content.substring(valueStart, i);
      return {
        value,
        endIndex: i < content.length ? i + 1 : i
        // Skip closing quote if found
      };
    } else {
      const valueStart = startIndex;
      let i = valueStart;
      while (i < content.length && !WHITESPACE_REGEX.test(content[i])) {
        i++;
      }
      const value = content.substring(valueStart, i);
      return { value, endIndex: i };
    }
  }
  // =============================================================================
  // Private Methods - Utilities
  // =============================================================================
  /**
   * Skip whitespace characters starting from index
   */
  skipWhitespace(content, index) {
    while (index < content.length && WHITESPACE_REGEX.test(content[index])) {
      index++;
    }
    return index;
  }
  /**
   * Find matching end tag for given tag name
   */
  findMatchingEndTag(tag, startIndex) {
    const startTag = `<${tag}`;
    const endTag = `</${tag}>`;
    let depth = 1;
    let searchIndex = startIndex;
    while (depth > 0 && searchIndex < this.length) {
      const nextStart = this.html.indexOf(startTag, searchIndex);
      const nextEnd = this.html.indexOf(endTag, searchIndex);
      if (nextEnd === -1) break;
      if (nextStart !== -1 && nextStart < nextEnd) {
        const nextTagEnd = this.html.indexOf(">", nextStart);
        if (nextTagEnd !== -1 && nextTagEnd < nextEnd) {
          const nextTagContent = this.html.substring(nextStart + 1, nextTagEnd);
          if (!SELF_CLOSING_REGEX.test(nextTagContent)) {
            depth++;
          }
        }
        searchIndex = nextTagEnd + 1;
      } else {
        depth--;
        if (depth === 0) {
          return nextEnd;
        }
        searchIndex = nextEnd + endTag.length;
      }
    }
    return -1;
  }
}

class DomCodeGenerator {
  constructor(options) {
    this.parseStaticStyle = options.parseStaticStyle;
  }
  /**
   * 生成节点构造代码
   */
  generateNodeCode(node) {
    switch (node.type) {
      case "text":
        return `doc.createTextNode(${JSON.stringify(node.content || "")})`;
      case "comment":
        return `doc.createComment(${JSON.stringify(node.content || "")})`;
      case "element":
        return this.generateElementCode(node);
      default:
        return `doc.createComment('unknown')`;
    }
  }
  /**
   * 生成元素构造代码
   */
  generateElementCode(node) {
    const { tag, attrs, children } = node;
    const attrsParam = this.generateAttrsParam(attrs);
    const childrenParam = this.generateChildrenParam(children);
    const params = [`'${tag}'`];
    if (attrsParam) {
      params.push(attrsParam);
    } else if (childrenParam) {
      params.push("null");
    }
    if (childrenParam) {
      params.push(childrenParam);
    }
    return `doc.createElement(${params.join(", ")})`;
  }
  /**
   * 生成属性参数
   */
  generateAttrsParam(attrs) {
    if (!attrs || Object.keys(attrs).length === 0) {
      return null;
    }
    const entries = Object.entries(attrs).map(([name, value]) => {
      if (name === "style") {
        return `['style', ${this.parseStaticStyle(value)}]`;
      }
      return `['${name}', ${JSON.stringify(value)}]`;
    });
    return `new Map([${entries.join(", ")}])`;
  }
  /**
   * 生成子节点参数
   */
  generateChildrenParam(children) {
    if (!children || children.length === 0) {
      return null;
    }
    const childrenCode = children.map((child) => this.generateNodeCode(child));
    return `[${childrenCode.join(", ")}]`;
  }
}
class TemplateFactoryGenerator {
  constructor(options) {
    this.codeGenerator = new DomCodeGenerator(options);
    this.isTs = options.isTs || false;
  }
  /**
   * 生成工厂函数
   * 统一使用 createElement(tag, attrs, children) 形式
   */
  generateFactoryFunction(template, index) {
    try {
      const parser = new HtmlParser(template);
      const nodes = parser.parse();
      if (nodes.length === 0) {
        return this.generateEmptyFunction(index);
      }
      if (nodes.length === 1) {
        return this.generateSingleNodeFunction(nodes[0], index);
      }
      return this.generateEmptyFunction(index);
    } catch (error) {
      return this.generateEmptyFunction(index);
    }
  }
  /**
   * 生成空函数
   */
  generateEmptyFunction(index) {
    const paramType = this.isTs ? "doc: IDocument" : "doc";
    const returnType = this.isTs ? ": UniElement" : "";
    return `function f${index}(${paramType})${returnType} {
  return doc.createTextNode('')
}`;
  }
  /**
   * 生成单节点函数
   */
  generateSingleNodeFunction(node, index) {
    const nodeCode = this.codeGenerator.generateNodeCode(node);
    const paramType = this.isTs ? "doc: IDocument" : "doc";
    const returnType = this.isTs ? ": UniElement" : "";
    return `function f${index}(${paramType})${returnType} {
  return ${nodeCode}
}`;
  }
}
function generateFactoryFunctions(templates, context) {
  const generator = new TemplateFactoryGenerator({
    parseStaticStyle: context.options.parseStaticStyle,
    isTs: context.options.isTS
  });
  const functions = templates.map(
    (template, index) => generator.generateFactoryFunction(template, index)
  );
  return functions.join("\n");
}
function generateFactoryCallsInRender(templates, rootIndex, context) {
  const { helper } = context;
  const calls = templates.map((_, index) => {
    const rootParam = index === rootIndex ? ", true" : "";
    return `const t${index} = ${helper("factory")}($doc, f${index}${rootParam})`;
  });
  return calls.join("\n  ");
}

function genTemplates(templates, rootIndex, context) {
  const { helper, options } = context;
  if (options.templateMode === "factory") {
    const factoryFunctions = generateFactoryFunctions(templates, context);
    return factoryFunctions ? factoryFunctions + "\n" : "";
  } else {
    return templates.map(
      (template, i) => `const t${i} = ${helper("template")}(${JSON.stringify(
        template
      )}${i === rootIndex ? ", true" : ""})
`
    ).join("");
  }
}
function genSelf(dynamic, context) {
  const [frag, push] = buildCodeFragment();
  const { id, template, operation } = dynamic;
  if (id !== void 0 && template !== void 0) {
    push(NEWLINE, `const n${id} = t${template}()`);
    push(...genDirectivesForElement(id, context));
  }
  if (operation) {
    push(...genOperationWithInsertionState(operation, context));
  }
  return frag;
}
function genChildren(dynamic, context, pushBlock, from = `n${dynamic.id}`) {
  const { helper } = context;
  const [frag, push] = buildCodeFragment();
  const { children } = dynamic;
  let offset = 0;
  let prev;
  const childrenToGen = [];
  for (const [index, child] of children.entries()) {
    if (child.flags & 2) {
      offset--;
    }
    const id = child.flags & 1 ? child.flags & 4 ? child.anchor : child.id : void 0;
    if (id === void 0 && !child.hasDynamicChild) {
      push(...genSelf(child, context));
      continue;
    }
    const elementIndex = Number(index) + offset;
    const variable = id === void 0 ? `p${context.block.tempId++}` : `n${id}`;
    pushBlock(NEWLINE, `const ${variable} = `);
    if (prev) {
      if (elementIndex - prev[1] === 1) {
        pushBlock(...genCall(helper("next"), prev[0]));
      } else {
        pushBlock(...genCall(helper("nthChild"), from, String(elementIndex)));
      }
    } else {
      if (elementIndex === 0) {
        pushBlock(...genCall(helper("child"), from));
      } else {
        let init = genCall(helper("child"), from);
        if (elementIndex === 1) {
          init = genCall(helper("next"), init);
        } else if (elementIndex > 1) {
          init = genCall(helper("nthChild"), from, String(elementIndex));
        }
        pushBlock(...init);
      }
    }
    if (id === child.anchor) {
      push(...genSelf(child, context));
    }
    if (id !== void 0) {
      push(...genDirectivesForElement(id, context));
    }
    prev = [variable, elementIndex];
    childrenToGen.push([child, variable]);
  }
  if (childrenToGen.length) {
    for (const [child, from2] of childrenToGen) {
      push(...genChildren(child, context, pushBlock, from2));
    }
  }
  return frag;
}

function genBlock(oper, context, args = [], root, customReturns) {
  return [
    "(",
    ...args,
    ") => {",
    INDENT_START,
    ...genBlockContent(oper, context, root),
    INDENT_END,
    NEWLINE,
    "}"
  ];
}
function genBlockContent(block, context, root, customReturns) {
  const [frag, push] = buildCodeFragment();
  const { dynamic, effect, operation, returns } = block;
  const resetBlock = context.enterBlock(block);
  if (root) {
    for (let name of context.ir.component) {
      const id = toValidAssetId(name, "component");
      const maybeSelfReference = name.endsWith("__self");
      if (maybeSelfReference) name = name.slice(0, -6);
      push(
        NEWLINE,
        `const ${id} = `,
        ...genCall(
          context.helper("resolveComponent"),
          JSON.stringify(name),
          // pass additional `maybeSelfReference` flag
          maybeSelfReference ? "true" : void 0
        )
      );
    }
    genResolveAssets("directive", "resolveDirective");
  }
  for (const child of dynamic.children) {
    push(...genSelf(child, context));
  }
  for (const child of dynamic.children) {
    push(...genChildren(child, context, push, `n${child.id}`));
  }
  push(...genOperations(operation, context));
  push(...genEffects(effect, context));
  push(NEWLINE, `return `);
  const returnNodes = returns.map((n) => `n${n}`);
  const returnsCode = returnNodes.length > 1 ? genMulti(DELIMITERS_ARRAY, ...returnNodes) : [returnNodes[0] || "null"];
  push(...returnsCode);
  resetBlock();
  return frag;
  function genResolveAssets(kind, helper) {
    for (const name of context.ir[kind]) {
      push(
        NEWLINE,
        `const ${toValidAssetId(name, kind)} = `,
        ...genCall(context.helper(helper), JSON.stringify(name))
      );
    }
  }
}

class CodegenContext {
  constructor(ir, options) {
    this.ir = ir;
    this.helpers = /* @__PURE__ */ new Set([]);
    this.helper = (name) => {
      this.helpers.add(name);
      return `_${name}`;
    };
    this.delegates = /* @__PURE__ */ new Set();
    this.identifiers = /* @__PURE__ */ Object.create(null);
    this.seenInlineHandlerNames = /* @__PURE__ */ Object.create(null);
    this.scopeLevel = 0;
    const defaultOptions = {
      mode: "module",
      prefixIdentifiers: true,
      sourceMap: false,
      filename: `template.vue.html`,
      scopeId: null,
      runtimeGlobalName: `Vue`,
      runtimeModuleName: `vue`,
      ssrRuntimeModuleName: "vue/server-renderer",
      ssr: false,
      isTS: false,
      inSSR: false,
      inline: false,
      bindingMetadata: {},
      expressionPlugins: [],
      // fixed by uts
      templateMode: "string",
      disableEventDelegation: false,
      parseStaticStyle: (style) => JSON.stringify(style),
      disableClassBinding: false
    };
    this.options = extend(defaultOptions, options);
    this.block = ir.block;
  }
  withId(fn, map) {
    const { identifiers } = this;
    const ids = Object.keys(map);
    for (const id of ids) {
      identifiers[id] || (identifiers[id] = []);
      identifiers[id].unshift(map[id] || id);
    }
    const ret = fn();
    ids.forEach((id) => remove(identifiers[id], map[id] || id));
    return ret;
  }
  enterBlock(block) {
    const parent = this.block;
    this.block = block;
    return () => this.block = parent;
  }
  enterScope() {
    return [this.scopeLevel++, () => this.scopeLevel--];
  }
}
function generate(ir, options = {}) {
  const [frag, push] = buildCodeFragment();
  const context = new CodegenContext(ir, options);
  const { helpers } = context;
  const { inline, bindingMetadata } = options;
  const functionName = "render";
  const args = ["_ctx"];
  if (bindingMetadata && !inline) {
    args.push("$props", "$emit", "$attrs", "$slots");
  }
  const signature = (options.isTS ? args.map((arg) => `${arg}: any`) : args).join(
    ", "
  );
  if (!inline) {
    push(NEWLINE, `export function ${functionName}(${signature}) {`);
  }
  push(INDENT_START);
  if (ir.hasTemplateRef) {
    push(
      NEWLINE,
      `const ${setTemplateRefIdent} = ${context.helper("createTemplateRefSetter")}()`
    );
  }
  const codeFragments = genBlockContent(ir.block, context, true);
  if (options.templateMode === "factory") {
    if (ir.template.length > 0 || context.delegates.size > 0 || context.helpers.has("createDynamicComponent") || context.helpers.has("createComponentWithFallback")) {
      push(
        NEWLINE,
        `const $ins = ${context.helper("getCurrentGenericInstance")}()`
      );
      push(NEWLINE, `const $proxy = $ins.proxy${options.isTS ? "!" : ""}`);
      push(NEWLINE, `const $doc = $proxy.$nativePage.document`);
    }
    if (context.delegates.size) {
      const delegatesCall = genCall(
        context.helper("delegateEvents"),
        ...[`$doc`, ...Array.from(context.delegates).map((v) => `"${v}"`)]
      ).join("");
      push(NEWLINE, delegatesCall);
    }
    if (ir.template.length > 0) {
      const templateCalls = generateFactoryCallsInRender(
        ir.template,
        ir.rootTemplateIndex,
        context
      );
      push(NEWLINE, templateCalls);
    }
  }
  push(...codeFragments);
  push(INDENT_END, NEWLINE);
  if (!inline) {
    push("}");
  }
  const delegates = genDelegates(context);
  const templates = genTemplates(ir.template, ir.rootTemplateIndex, context);
  const imports = genHelperImports(context);
  const preamble = imports + templates + delegates;
  const newlineCount = [...preamble].filter((c) => c === "\n").length;
  if (newlineCount && !inline) {
    frag.unshift(...new Array(newlineCount).fill(LF));
  }
  let [code, map] = codeFragmentToString(frag, context);
  if (!inline) {
    code = preamble + code;
  }
  return {
    code,
    ast: ir,
    preamble,
    map: map && map.toJSON(),
    helpers
  };
}
function genDelegates({ delegates, helper, options }) {
  if (options.templateMode === "factory") {
    return "";
  }
  return delegates.size ? genCall(
    helper("delegateEvents"),
    ...Array.from(delegates).map((v) => `"${v}"`)
  ).join("") + "\n" : "";
}
function genHelperImports({ helpers, helper, options }) {
  let imports = "";
  if (helpers.size) {
    imports += `import { ${[...helpers].map((h) => `${h} as _${h}`).join(", ")} } from '${options.runtimeModuleName}';
`;
  }
  return imports;
}

const transformChildren = (node, context) => {
  const isFragment = node.type === 0 || node.type === 1 && (node.tagType === 3 || node.tagType === 1);
  if (!isFragment && node.type !== 1) return;
  for (const [i, child] of node.children.entries()) {
    const childContext = context.create(child, i);
    transformNode(childContext);
    const childDynamic = childContext.dynamic;
    if (isFragment) {
      childContext.reference();
      childContext.registerTemplate();
      if (!(childDynamic.flags & 2) || childDynamic.flags & 4) {
        context.block.returns.push(childContext.dynamic.id);
      }
    } else {
      context.childrenTemplate.push(childContext.template);
    }
    if (childDynamic.hasDynamicChild || childDynamic.id !== void 0 || childDynamic.flags & 2 || childDynamic.flags & 4) {
      context.dynamic.hasDynamicChild = true;
    }
    context.dynamic.children[i] = childDynamic;
  }
  if (!isFragment) {
    processDynamicChildren(context);
  }
};
function processDynamicChildren(context) {
  let prevDynamics = [];
  let hasStaticTemplate = false;
  const children = context.dynamic.children;
  for (const [index, child] of children.entries()) {
    if (child.flags & 4) {
      prevDynamics.push(child);
    }
    if (!(child.flags & 2)) {
      if (prevDynamics.length) {
        if (hasStaticTemplate) {
          context.childrenTemplate[index - prevDynamics.length] = `<!>`;
          prevDynamics[0].flags -= 2;
          const anchor = prevDynamics[0].anchor = context.increaseId();
          registerInsertion(prevDynamics, context, anchor);
        } else {
          registerInsertion(
            prevDynamics,
            context,
            -1
            /* prepend */
          );
        }
        prevDynamics = [];
      }
      hasStaticTemplate = true;
    }
  }
  if (prevDynamics.length) {
    registerInsertion(prevDynamics, context);
  }
}
function registerInsertion(dynamics, context, anchor) {
  for (const child of dynamics) {
    if (child.template != null) {
      context.registerOperation({
        type: 9,
        elements: dynamics.map((child2) => child2.id),
        parent: context.reference(),
        anchor
      });
    } else if (child.operation && isBlockOperation(child.operation)) {
      child.operation.parent = context.reference();
      child.operation.anchor = anchor;
    }
  }
}

const transformVOnce = (node, context) => {
  if (
    // !context.inSSR &&
    node.type === 1 && findDir$1(node, "once", true)
  ) {
    context.inVOnce = true;
  }
};

const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,"
);
const transformElement = (node, context) => {
  let effectIndex = context.block.effect.length;
  const getEffectIndex = () => effectIndex++;
  return function postTransformElement() {
    ({ node } = context);
    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1)))
      return;
    const isComponent = node.tagType === 1;
    const isDynamicComponent = isComponentTag(node.tag);
    const propsResult = buildProps(
      node,
      context,
      isComponent,
      isDynamicComponent,
      getEffectIndex
    );
    let { parent } = context;
    while (parent && parent.parent && parent.node.type === 1 && parent.node.tagType === 3) {
      parent = parent.parent;
    }
    const singleRoot = context.root === parent && parent.node.children.filter((child) => child.type !== 3).length === 1;
    if (isComponent) {
      transformComponentElement(
        node,
        propsResult,
        singleRoot,
        context,
        isDynamicComponent
      );
    } else {
      transformNativeElement(
        node,
        propsResult,
        singleRoot,
        context,
        getEffectIndex
      );
    }
  };
};
function transformComponentElement(node, propsResult, singleRoot, context, isDynamicComponent) {
  const dynamicComponent = isDynamicComponent ? resolveDynamicComponent(node) : void 0;
  let { tag } = node;
  let asset = true;
  if (!dynamicComponent) {
    const fromSetup = resolveSetupReference(tag, context);
    if (fromSetup) {
      tag = fromSetup;
      asset = false;
    }
    const dotIndex = tag.indexOf(".");
    if (dotIndex > 0) {
      const ns = resolveSetupReference(tag.slice(0, dotIndex), context);
      if (ns) {
        tag = ns + tag.slice(dotIndex);
        asset = false;
      }
    }
    if (asset) {
      if (context.selfName && capitalize(camelize(tag)) === context.selfName) {
        tag += `__self`;
      }
      context.component.add(tag);
    }
  }
  context.dynamic.flags |= 2 | 4;
  context.dynamic.operation = {
    type: 11,
    id: context.reference(),
    tag,
    props: propsResult[0] ? propsResult[1] : [propsResult[1]],
    asset,
    root: singleRoot && !context.inVFor,
    slots: [...context.slots],
    once: context.inVOnce,
    dynamic: dynamicComponent
  };
  context.slots = [];
}
function resolveDynamicComponent(node) {
  const isProp = findProp(
    node,
    "is",
    false,
    true
    /* allow empty */
  );
  if (!isProp) return;
  if (isProp.type === 6) {
    return isProp.value && createSimpleExpression(isProp.value.content, true);
  } else {
    return isProp.exp || // #10469 handle :is shorthand
    extend(createSimpleExpression(`is`, false, isProp.arg.loc), {
      ast: null
    });
  }
}
function resolveSetupReference(name, context) {
  const bindings = context.options.bindingMetadata;
  if (!bindings || bindings.__isScriptSetup === false) {
    return;
  }
  const camelName = camelize(name);
  const PascalName = capitalize(camelName);
  return bindings[name] ? name : bindings[camelName] ? camelName : bindings[PascalName] ? PascalName : void 0;
}
function transformNativeElement(node, propsResult, singleRoot, context, getEffectIndex) {
  const { tag } = node;
  const { scopeId } = context.options;
  let template = "";
  template += `<${tag}`;
  if (scopeId) template += ` ${scopeId}`;
  const dynamicProps = [];
  if (propsResult[0]) {
    const [, dynamicArgs, expressions] = propsResult;
    context.registerEffect(
      expressions,
      {
        type: 3,
        element: context.reference(),
        props: dynamicArgs,
        root: singleRoot
      },
      getEffectIndex
    );
  } else {
    for (const prop of propsResult[1]) {
      const { key, values } = prop;
      if (key.isStatic && values.length === 1 && values[0].isStatic) {
        if (context.options.disableClassBinding && key.content === "class") {
          dynamicProps.push(key.content);
          context.registerEffect(
            values,
            {
              type: 2,
              element: context.reference(),
              prop,
              root: singleRoot,
              tag
            },
            getEffectIndex
          );
          continue;
        }
        template += ` ${key.content}`;
        if (values[0].content) template += `="${values[0].content}"`;
      } else {
        dynamicProps.push(key.content);
        context.registerEffect(
          values,
          {
            type: 2,
            element: context.reference(),
            prop,
            root: singleRoot,
            tag
          },
          getEffectIndex
        );
      }
    }
  }
  template += `>` + context.childrenTemplate.join("");
  if (!isVoidTag(tag)) {
    template += `</${tag}>`;
  }
  if (singleRoot) {
    context.ir.rootTemplateIndex = context.ir.template.length;
  }
  if (context.parent && context.parent.node.type === 1 && !isValidHTMLNesting(context.parent.node.tag, tag)) {
    context.reference();
    context.dynamic.template = context.pushTemplate(template);
    context.dynamic.flags |= 4 | 2;
  } else {
    context.template += template;
  }
}
function buildProps(node, context, isComponent, isDynamicComponent, getEffectIndex) {
  const props = node.props;
  if (props.length === 0) return [false, []];
  const dynamicArgs = [];
  const dynamicExpr = [];
  let results = [];
  function pushMergeArg() {
    if (results.length) {
      dynamicArgs.push(dedupeProperties(results));
      results = [];
    }
  }
  for (const prop of props) {
    if (prop.type === 7 && !prop.arg) {
      if (prop.name === "bind") {
        if (prop.exp) {
          dynamicExpr.push(prop.exp);
          pushMergeArg();
          dynamicArgs.push({
            kind: 0,
            value: prop.exp
          });
        } else {
          context.options.onError(
            createCompilerError(34, prop.loc)
          );
        }
        continue;
      } else if (prop.name === "on") {
        if (prop.exp) {
          if (isComponent) {
            dynamicExpr.push(prop.exp);
            pushMergeArg();
            dynamicArgs.push({
              kind: 0,
              value: prop.exp,
              handler: true
            });
          } else {
            context.registerEffect(
              [prop.exp],
              {
                type: 6,
                element: context.reference(),
                event: prop.exp
              },
              getEffectIndex
            );
          }
        } else {
          context.options.onError(
            createCompilerError(35, prop.loc)
          );
        }
        continue;
      }
    }
    if (isDynamicComponent && prop.type === 6 && prop.name === "is" || prop.type === 7 && prop.name === "bind" && isStaticArgOf(prop.arg, "is")) {
      continue;
    }
    const result = transformProp(prop, node, context);
    if (result) {
      dynamicExpr.push(result.key, result.value);
      if (isComponent && !result.key.isStatic) {
        pushMergeArg();
        dynamicArgs.push(
          extend(resolveDirectiveResult(result), {
            kind: 1
          })
        );
      } else {
        results.push(result);
      }
    }
  }
  if (dynamicArgs.length || results.some(({ key }) => !key.isStatic)) {
    pushMergeArg();
    return [true, dynamicArgs, dynamicExpr];
  }
  const irProps = dedupeProperties(results);
  return [false, irProps];
}
function transformProp(prop, node, context) {
  let { name } = prop;
  if (prop.type === 6) {
    if (isReservedProp(name)) return;
    return {
      key: createSimpleExpression(prop.name, true, prop.nameLoc),
      value: prop.value ? createSimpleExpression(prop.value.content, true, prop.value.loc) : EMPTY_EXPRESSION
    };
  }
  const directiveTransform = context.options.directiveTransforms[name];
  if (directiveTransform) {
    return directiveTransform(prop, node, context);
  }
  if (!isBuiltInDirective(name)) {
    const fromSetup = resolveSetupReference(`v-${name}`, context);
    if (fromSetup) {
      name = fromSetup;
    } else {
      context.directive.add(name);
    }
    context.registerOperation({
      type: 13,
      element: context.reference(),
      dir: prop,
      name,
      asset: !fromSetup
    });
  }
}
function dedupeProperties(results) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (const result of results) {
    const prop = resolveDirectiveResult(result);
    if (!prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class") {
        mergePropValues(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function resolveDirectiveResult(prop) {
  return extend({}, prop, {
    value: void 0,
    values: [prop.value]
  });
}
function mergePropValues(existing, incoming) {
  const newValues = incoming.values;
  existing.values.push(...newValues);
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}

const transformVHtml = (dir, node, context) => {
  let { exp, loc } = dir;
  if (!exp) {
    context.options.onError(
      createDOMCompilerError(53, loc)
    );
    exp = EMPTY_EXPRESSION;
  }
  if (node.children.length) {
    context.options.onError(
      createDOMCompilerError(54, loc)
    );
    context.childrenTemplate.length = 0;
  }
  context.registerEffect([exp], {
    type: 7,
    element: context.reference(),
    value: exp
  });
};

const transformVText = (dir, node, context) => {
  let { exp, loc } = dir;
  if (!exp) {
    context.options.onError(
      createDOMCompilerError(55, loc)
    );
    exp = EMPTY_EXPRESSION;
  }
  if (node.children.length) {
    context.options.onError(
      createDOMCompilerError(56, loc)
    );
    context.childrenTemplate.length = 0;
  }
  if (isVoidTag(context.node.tag)) {
    return;
  }
  const literal = getLiteralExpressionValue(exp);
  if (literal != null) {
    context.childrenTemplate = [String(literal)];
  } else {
    context.childrenTemplate = [" "];
    context.registerOperation({
      type: 17,
      parent: context.reference()
    });
    context.registerEffect([exp], {
      type: 4,
      element: context.reference(),
      values: [exp],
      generated: true
    });
  }
};

function normalizeBindShorthand(arg, context) {
  if (arg.type !== 4 || !arg.isStatic) {
    context.options.onError(
      createCompilerError(
        52,
        arg.loc
      )
    );
    return createSimpleExpression("", true, arg.loc);
  }
  const propName = camelize(arg.content);
  const exp = createSimpleExpression(propName, false, arg.loc);
  exp.ast = null;
  return exp;
}
const transformVBind = (dir, node, context) => {
  const { loc, modifiers } = dir;
  let { exp } = dir;
  let arg = dir.arg;
  const modifiersString = modifiers.map((s) => s.content);
  if (!exp) exp = normalizeBindShorthand(arg, context);
  if (!exp.content.trim()) {
    context.options.onError(
      createCompilerError(34, loc)
    );
    exp = createSimpleExpression("", true, loc);
  }
  exp = resolveExpression(exp);
  arg = resolveExpression(arg);
  if (arg.isStatic && isReservedProp(arg.content)) return;
  let camel = false;
  if (modifiersString.includes("camel")) {
    if (arg.isStatic) {
      arg = extend({}, arg, { content: camelize(arg.content) });
    } else {
      camel = true;
    }
  }
  return {
    key: arg,
    value: exp,
    loc,
    runtimeCamelize: camel,
    modifier: modifiersString.includes("prop") ? "." : modifiersString.includes("attr") ? "^" : void 0
  };
};

const delegatedEvents = /* @__PURE__ */ makeMap(
  "beforeinput,click,dblclick,contextmenu,focusin,focusout,input,keydown,keyup,mousedown,mousemove,mouseout,mouseover,mouseup,pointerdown,pointermove,pointerout,pointerover,pointerup,touchend,touchmove,touchstart"
);
const transformVOn = (dir, node, context) => {
  let { arg, exp, loc, modifiers } = dir;
  const isComponent = node.tagType === 1;
  const isSlotOutlet = node.tag === "slot";
  if (!exp && !modifiers.length) {
    context.options.onError(
      createCompilerError(35, loc)
    );
  }
  arg = resolveExpression(arg);
  const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(
    arg.isStatic ? `on${arg.content}` : arg,
    modifiers);
  let keyOverride;
  const isStaticClick = arg.isStatic && arg.content.toLowerCase() === "click";
  if (nonKeyModifiers.includes("middle")) {
    if (isStaticClick) {
      arg = extend({}, arg, { content: "mouseup" });
    } else if (!arg.isStatic) {
      keyOverride = ["click", "mouseup"];
    }
  }
  if (nonKeyModifiers.includes("right")) {
    if (isStaticClick) {
      arg = extend({}, arg, { content: "contextmenu" });
    } else if (!arg.isStatic) {
      keyOverride = ["click", "contextmenu"];
    }
  }
  if (isComponent || isSlotOutlet) {
    const handler = exp || EMPTY_EXPRESSION;
    return {
      key: arg,
      value: handler,
      handler: true,
      handlerModifiers: eventOptionModifiers
    };
  }
  const delegate = !context.options.disableEventDelegation && arg.isStatic && !eventOptionModifiers.length && delegatedEvents(arg.content);
  const operation = {
    type: 5,
    element: context.reference(),
    key: arg,
    value: exp,
    modifiers: {
      keys: keyModifiers,
      nonKeys: nonKeyModifiers,
      options: eventOptionModifiers
    },
    keyOverride,
    delegate,
    effect: !arg.isStatic
  };
  context.registerEffect([arg], operation);
};

const transformVShow = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.options.onError(
      createDOMCompilerError(61, loc)
    );
    return;
  }
  if (node.tagType === 2) {
    context.options.onError(
      createCompilerError(
        36,
        loc
      )
    );
    return;
  }
  context.registerOperation({
    type: 13,
    element: context.reference(),
    dir,
    name: "show",
    builtin: true
  });
};

const transformTemplateRef = (node, context) => {
  if (node.type !== 1) return;
  const dir = findProp(node, "ref", false, true);
  if (!dir) return;
  context.ir.hasTemplateRef = true;
  let value;
  if (dir.type === 7) {
    value = dir.exp || normalizeBindShorthand(dir.arg, context);
  } else {
    value = dir.value ? createSimpleExpression(dir.value.content, true, dir.value.loc) : EMPTY_EXPRESSION;
  }
  return () => {
    const id = context.reference();
    const effect = !isConstantExpression(value);
    effect && context.registerOperation({
      type: 14,
      id
    });
    context.registerEffect([value], {
      type: 8,
      element: id,
      value,
      refFor: !!context.inVFor,
      effect
    });
  };
};

const seen = /* @__PURE__ */ new WeakMap();
function markNonTemplate(node, context) {
  seen.get(context.root).add(node);
}
const transformText = (node, context) => {
  if (!seen.has(context.root)) seen.set(context.root, /* @__PURE__ */ new WeakSet());
  if (seen.get(context.root).has(node)) {
    context.dynamic.flags |= 2;
    return;
  }
  const isFragment = node.type === 0 || node.type === 1 && (node.tagType === 3 || node.tagType === 1);
  if ((isFragment || node.type === 1 && node.tagType === 0) && node.children.length) {
    let hasInterp = false;
    let isAllTextLike = true;
    for (const c of node.children) {
      if (c.type === 5) {
        hasInterp = true;
      } else if (c.type !== 2) {
        isAllTextLike = false;
      }
    }
    if (!isFragment && isAllTextLike && hasInterp) {
      processTextContainer(
        node.children,
        context
      );
    } else if (hasInterp) {
      for (let i = 0; i < node.children.length; i++) {
        const c = node.children[i];
        const prev = node.children[i - 1];
        if (c.type === 5 && prev && prev.type === 2) {
          markNonTemplate(prev, context);
        }
      }
    }
  } else if (node.type === 5) {
    processInterpolation(context);
  } else if (node.type === 2) {
    context.template += node.content;
  }
};
function processInterpolation(context) {
  const children = context.parent.node.children;
  const nexts = children.slice(context.index);
  const idx = nexts.findIndex((n) => !isTextLike(n));
  const nodes = idx > -1 ? nexts.slice(0, idx) : nexts;
  const prev = children[context.index - 1];
  if (prev && prev.type === 2) {
    nodes.unshift(prev);
  }
  context.template += " ";
  const id = context.reference();
  const values = nodes.map((node) => createTextLikeExpression(node, context));
  const nonConstantExps = values.filter((v) => !isConstantExpression(v));
  const isStatic = !nonConstantExps.length || nonConstantExps.every(
    (e) => isStaticExpression(e, context.options.bindingMetadata)
  ) || context.inVOnce;
  if (isStatic) {
    context.registerOperation({
      type: 4,
      element: id,
      values
    });
  } else {
    context.registerEffect(values, {
      type: 4,
      element: id,
      values
    });
  }
}
function processTextContainer(children, context) {
  const values = children.map((child) => createTextLikeExpression(child, context));
  const literals = values.map(getLiteralExpressionValue);
  if (literals.every((l) => l != null)) {
    context.childrenTemplate = literals.map((l) => String(l));
  } else {
    context.childrenTemplate = [" "];
    context.registerOperation({
      type: 17,
      parent: context.reference()
    });
    context.registerEffect(values, {
      type: 4,
      element: context.reference(),
      values,
      // indicates this node is generated, so prefix should be "x" instead of "n"
      generated: true
    });
  }
}
function createTextLikeExpression(node, context) {
  markNonTemplate(node, context);
  if (node.type === 2) {
    return createSimpleExpression(node.content, true, node.loc);
  } else {
    return node.content;
  }
}
function isTextLike(node) {
  return node.type === 5 || node.type === 2;
}

const transformVModel = (dir, node, context) => {
  const { exp, arg } = dir;
  if (!exp) {
    context.options.onError(
      createCompilerError(41, dir.loc)
    );
    return;
  }
  const rawExp = exp.loc.source;
  const bindingType = context.options.bindingMetadata[rawExp];
  if (bindingType === "props" || bindingType === "props-aliased") {
    context.options.onError(
      createCompilerError(44, exp.loc)
    );
    return;
  }
  const expString = exp.content;
  const maybeRef = context.options.inline && (bindingType === "setup-let" || bindingType === "setup-ref" || bindingType === "setup-maybe-ref");
  if (!expString.trim() || !isMemberExpression$1(exp, context.options) && !maybeRef) {
    context.options.onError(
      createCompilerError(42, exp.loc)
    );
    return;
  }
  const isComponent = node.tagType === 1;
  if (isComponent) {
    return {
      key: arg ? arg : createSimpleExpression("modelValue", true),
      value: exp,
      model: true,
      modelModifiers: dir.modifiers.map((m) => m.content)
    };
  }
  if (dir.arg)
    context.options.onError(
      createDOMCompilerError(
        58,
        dir.arg.loc
      )
    );
  const { tag } = node;
  const isCustomElement = context.options.isCustomElement(tag);
  let modelType = "text";
  if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
    if (tag === "input" || isCustomElement) {
      const type = findProp$1(node, "type");
      if (type) {
        if (type.type === 7) {
          modelType = "dynamic";
        } else if (type.value) {
          switch (type.value.content) {
            case "radio":
              modelType = "radio";
              break;
            case "checkbox":
              modelType = "checkbox";
              break;
            case "file":
              modelType = void 0;
              context.options.onError(
                createDOMCompilerError(
                  59,
                  dir.loc
                )
              );
              break;
            default:
              checkDuplicatedValue();
              break;
          }
        }
      } else if (hasDynamicKeyVBind(node)) {
        modelType = "dynamic";
      } else {
        checkDuplicatedValue();
      }
    } else if (tag === "select") {
      modelType = "select";
    } else {
      checkDuplicatedValue();
    }
  } else {
    context.options.onError(
      createDOMCompilerError(
        57,
        dir.loc
      )
    );
  }
  if (modelType)
    context.registerOperation({
      type: 13,
      element: context.reference(),
      dir,
      name: "model",
      modelType,
      builtin: true
    });
  function checkDuplicatedValue() {
    const value = findDir$1(node, "bind");
    if (value && isStaticArgOf(value.arg, "value")) {
      context.options.onError(
        createDOMCompilerError(
          60,
          value.loc
        )
      );
    }
  }
};

const transformComment = (node, context) => {
  if (node.type !== 3) return;
  if (getSiblingIf(context)) {
    context.comment.push(node);
    context.dynamic.flags |= 2;
  } else {
    context.template += `<!--${node.content}-->`;
  }
};
function getSiblingIf(context, reverse) {
  const parent = context.parent;
  if (!parent) return;
  const siblings = parent.node.children;
  let sibling;
  let i = siblings.indexOf(context.node);
  while (reverse ? --i >= 0 : ++i < siblings.length) {
    sibling = siblings[i];
    if (!isCommentLike(sibling)) {
      break;
    }
  }
  if (sibling && sibling.type === 1 && sibling.props.some(
    ({ type, name }) => type === 7 && ["else-if", reverse ? "if" : "else"].includes(name)
  )) {
    return sibling;
  }
}
function isCommentLike(node) {
  return node.type === 3 || node.type === 2 && !node.content.trim().length;
}

const transformVIf = createStructuralDirectiveTransform(
  ["if", "else", "else-if"],
  processIf
);
function processIf(node, dir, context) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.options.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  context.dynamic.flags |= 2;
  if (dir.name === "if") {
    const id = context.reference();
    context.dynamic.flags |= 4;
    const [branch, onExit] = createIfBranch(node, context);
    return () => {
      onExit();
      context.dynamic.operation = {
        type: 15,
        id,
        condition: dir.exp,
        positive: branch,
        once: context.inVOnce || isStaticExpression(dir.exp, context.options.bindingMetadata)
      };
    };
  } else {
    const siblingIf = getSiblingIf(context, true);
    const siblings = context.parent && context.parent.dynamic.children;
    let lastIfNode;
    if (siblings) {
      let i = siblings.length;
      while (i--) {
        if (siblings[i].operation && siblings[i].operation.type === 15) {
          lastIfNode = siblings[i].operation;
          break;
        }
      }
    }
    if (
      // check if v-if is the sibling node
      !siblingIf || // check if IfNode is the last operation and get the root IfNode
      !lastIfNode || lastIfNode.type !== 15
    ) {
      context.options.onError(
        createCompilerError(30, node.loc)
      );
      return;
    }
    while (lastIfNode.negative && lastIfNode.negative.type === 15) {
      lastIfNode = lastIfNode.negative;
    }
    if (dir.name === "else-if" && lastIfNode.negative) {
      context.options.onError(
        createCompilerError(30, node.loc)
      );
    }
    if (context.root.comment.length) {
      node = wrapTemplate(node, ["else-if", "else"]);
      context.node = node = extend({}, node, {
        children: [...context.comment, ...node.children]
      });
    }
    context.root.comment = [];
    const [branch, onExit] = createIfBranch(node, context);
    if (dir.name === "else") {
      lastIfNode.negative = branch;
    } else {
      lastIfNode.negative = {
        type: 15,
        id: -1,
        condition: dir.exp,
        positive: branch,
        once: context.inVOnce
      };
    }
    return () => onExit();
  }
}
function createIfBranch(node, context) {
  context.node = node = wrapTemplate(node, ["if", "else-if", "else"]);
  const branch = newBlock(node);
  const exitBlock = context.enterBlock(branch);
  context.reference();
  return [branch, exitBlock];
}

const transformVFor = createStructuralDirectiveTransform(
  "for",
  processFor
);
function processFor(node, dir, context) {
  if (!dir.exp) {
    context.options.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = dir.forParseResult;
  if (!parseResult) {
    context.options.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  const { source, value, key, index } = parseResult;
  const keyProp = findProp(node, "key");
  const keyProperty = keyProp && propToExpression(keyProp);
  const isComponent = node.tagType === 1;
  context.node = node = wrapTemplate(node, ["for"]);
  context.dynamic.flags |= 2 | 4;
  const id = context.reference();
  const render = newBlock(node);
  const exitBlock = context.enterBlock(render, true);
  context.reference();
  return () => {
    exitBlock();
    const { parent } = context;
    const isOnlyChild = parent && parent.block.node !== parent.node && parent.node.children.length === 1;
    context.dynamic.operation = {
      type: 16,
      id,
      source,
      value,
      key,
      index,
      keyProp: keyProperty,
      render,
      once: context.inVOnce || isStaticExpression(
        source,
        context.options.bindingMetadata
      ),
      component: isComponent,
      onlyChild: !!isOnlyChild
    };
  };
}

const transformSlotOutlet = (node, context) => {
  if (node.type !== 1 || node.tag !== "slot") {
    return;
  }
  const id = context.reference();
  context.dynamic.flags |= 4 | 2;
  const [fallback, exitBlock] = createFallback(
    node,
    context
  );
  let slotName;
  const slotProps = [];
  for (const prop of node.props) {
    if (prop.type === 6) {
      if (prop.value) {
        if (prop.name === "name") {
          slotName = createSimpleExpression(prop.value.content, true, prop.loc);
        } else {
          slotProps.push(extend({}, prop, { name: camelize(prop.name) }));
        }
      }
    } else if (prop.name === "bind" && isStaticArgOf(prop.arg, "name")) {
      if (prop.exp) {
        slotName = prop.exp;
      } else {
        slotName = createSimpleExpression(
          camelize(prop.arg.content),
          false,
          prop.arg.loc
        );
        slotName.ast = null;
      }
    } else {
      let slotProp = prop;
      if (slotProp.name === "bind" && slotProp.arg && isStaticExp(slotProp.arg)) {
        slotProp = extend({}, prop, {
          arg: extend({}, slotProp.arg, {
            content: camelize(slotProp.arg.content)
          })
        });
      }
      slotProps.push(slotProp);
    }
  }
  slotName || (slotName = createSimpleExpression("default", true));
  let irProps = [];
  if (slotProps.length) {
    const [isDynamic, props] = buildProps(
      extend({}, node, { props: slotProps }),
      context,
      true
    );
    irProps = isDynamic ? props : [props];
    const runtimeDirective = context.block.operation.find(
      (oper) => oper.type === 13 && oper.element === id
    );
    if (runtimeDirective) {
      context.options.onError(
        createCompilerError(
          36,
          runtimeDirective.dir.loc
        )
      );
    }
  }
  return () => {
    exitBlock && exitBlock();
    context.dynamic.operation = {
      type: 12,
      id,
      name: slotName,
      props: irProps,
      fallback
    };
  };
};
function createFallback(node, context) {
  if (!node.children.length) {
    return [];
  }
  context.node = node = extend({}, node, {
    type: 1,
    tag: "template",
    props: [],
    tagType: 3,
    children: node.children
  });
  const fallback = newBlock(node);
  const exitBlock = context.enterBlock(fallback);
  context.reference();
  return [fallback, exitBlock];
}

const transformVSlot = (node, context) => {
  if (node.type !== 1) return;
  const dir = findDir(node, "slot", true);
  const { tagType, children } = node;
  const { parent } = context;
  const isComponent = tagType === 1;
  const isSlotTemplate = isTemplateNode(node) && parent && parent.node.type === 1 && parent.node.tagType === 1;
  if (isComponent && children.length) {
    return transformComponentSlot(
      node,
      dir,
      context
    );
  } else if (isSlotTemplate && dir) {
    return transformTemplateSlot(
      node,
      dir,
      context
    );
  } else if (!isComponent && dir) {
    context.options.onError(
      createCompilerError(40, dir.loc)
    );
  }
};
function transformComponentSlot(node, dir, context) {
  const { children } = node;
  const arg = dir && dir.arg;
  const emptyTextNodes = [];
  const nonSlotTemplateChildren = children.filter((n) => {
    if (isNonWhitespaceContent(n)) {
      return !(n.type === 1 && n.props.some(isVSlot));
    } else {
      emptyTextNodes.push(n);
    }
  });
  if (!nonSlotTemplateChildren.length) {
    emptyTextNodes.forEach((n) => {
      markNonTemplate(n, context);
    });
  }
  const [block, onExit] = createSlotBlock(node, dir, context);
  const { slots } = context;
  return () => {
    onExit();
    const hasOtherSlots = !!slots.length;
    if (dir && hasOtherSlots) {
      context.options.onError(
        createCompilerError(37, dir.loc)
      );
      return;
    }
    if (nonSlotTemplateChildren.length) {
      if (hasStaticSlot(slots, "default")) {
        context.options.onError(
          createCompilerError(
            39,
            nonSlotTemplateChildren[0].loc
          )
        );
      } else {
        registerSlot(slots, arg, block);
        context.slots = slots;
      }
    } else if (hasOtherSlots) {
      context.slots = slots;
    }
  };
}
function transformTemplateSlot(node, dir, context) {
  context.dynamic.flags |= 2;
  const arg = dir.arg && resolveExpression(dir.arg);
  const vFor = findDir(node, "for");
  const vIf = findDir(node, "if");
  const vElse = findDir(
    node,
    /^else(-if)?$/,
    true
    /* allowEmpty */
  );
  const { slots } = context;
  const [block, onExit] = createSlotBlock(node, dir, context);
  if (!vFor && !vIf && !vElse) {
    const slotName = arg ? arg.isStatic && arg.content : "default";
    if (slotName && hasStaticSlot(slots, slotName)) {
      context.options.onError(
        createCompilerError(38, dir.loc)
      );
    } else {
      registerSlot(slots, arg, block);
    }
  } else if (vIf) {
    registerDynamicSlot(slots, {
      slotType: 3,
      condition: vIf.exp,
      positive: {
        slotType: 1,
        name: arg,
        fn: block
      }
    });
  } else if (vElse) {
    const vIfSlot = slots[slots.length - 1];
    if (vIfSlot.slotType === 3) {
      let ifNode = vIfSlot;
      while (ifNode.negative && ifNode.negative.slotType === 3)
        ifNode = ifNode.negative;
      const negative = vElse.exp ? {
        slotType: 3,
        condition: vElse.exp,
        positive: {
          slotType: 1,
          name: arg,
          fn: block
        }
      } : {
        slotType: 1,
        name: arg,
        fn: block
      };
      ifNode.negative = negative;
    } else {
      context.options.onError(
        createCompilerError(30, vElse.loc)
      );
    }
  } else if (vFor) {
    if (vFor.forParseResult) {
      registerDynamicSlot(slots, {
        slotType: 2,
        name: arg,
        fn: block,
        loop: vFor.forParseResult
      });
    } else {
      context.options.onError(
        createCompilerError(32, vFor.loc)
      );
    }
  }
  return onExit;
}
function ensureStaticSlots(slots) {
  let lastSlots = slots[slots.length - 1];
  if (!slots.length || lastSlots.slotType !== 0) {
    slots.push(
      lastSlots = {
        slotType: 0,
        slots: {}
      }
    );
  }
  return lastSlots.slots;
}
function registerSlot(slots, name, block) {
  const isStatic = !name || name.isStatic;
  if (isStatic) {
    const staticSlots = ensureStaticSlots(slots);
    staticSlots[name ? name.content : "default"] = block;
  } else {
    slots.push({
      slotType: 1,
      name,
      fn: block
    });
  }
}
function registerDynamicSlot(allSlots, dynamic) {
  allSlots.push(dynamic);
}
function hasStaticSlot(slots, name) {
  return slots.some((slot) => {
    if (slot.slotType === 0) return !!slot.slots[name];
  });
}
function createSlotBlock(slotNode, dir, context) {
  const block = newBlock(slotNode);
  block.props = dir && dir.exp;
  const exitBlock = context.enterBlock(block);
  return [block, exitBlock];
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2) return true;
  return !!node.content.trim();
}

function compile$1(source, options = {}) {
  const resolvedOptions = extend({}, options);
  const ast = isString$1(source) ? parse$3(source, resolvedOptions) : source;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  if (options.isTS) {
    const { expressionPlugins } = options;
    if (!expressionPlugins || !expressionPlugins.includes("typescript")) {
      resolvedOptions.expressionPlugins = [
        ...expressionPlugins || [],
        "typescript"
      ];
    }
  }
  const ir = transform(
    ast,
    extend({}, resolvedOptions, {
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate(ir, resolvedOptions);
}
function getBaseTransformPreset() {
  return [
    [
      transformVOnce,
      transformVIf,
      transformVFor,
      transformSlotOutlet,
      transformTemplateRef,
      transformElement,
      transformText,
      transformVSlot,
      transformComment,
      transformChildren
    ],
    {
      bind: transformVBind,
      on: transformVOn,
      html: transformVHtml,
      text: transformVText,
      show: transformVShow,
      model: transformVModel
    }
  ];
}

function createVaporCompilerError(code, loc) {
  return createCompilerError(
    code,
    loc,
    VaporErrorMessages
  );
}
const VaporErrorCodes = {
  "X_V_PLACEHOLDER": 100,
  "100": "X_V_PLACEHOLDER",
  "__EXTEND_POINT__": 101,
  "101": "__EXTEND_POINT__"
};
const VaporErrorMessages = {
  [100]: `[placeholder]`,
  // just to fulfill types
  [101]: ``
};

var CompilerVapor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CodegenContext: CodegenContext,
  DynamicFlag: DynamicFlag,
  IRDynamicPropsKind: IRDynamicPropsKind,
  IRNodeTypes: IRNodeTypes,
  IRSlotType: IRSlotType,
  VaporErrorCodes: VaporErrorCodes,
  VaporErrorMessages: VaporErrorMessages,
  buildCodeFragment: buildCodeFragment,
  codeFragmentToString: codeFragmentToString,
  compile: compile$1,
  createStructuralDirectiveTransform: createStructuralDirectiveTransform,
  createVaporCompilerError: createVaporCompilerError,
  genCall: genCall,
  genMulti: genMulti,
  generate: generate,
  isBlockOperation: isBlockOperation,
  parse: parse$3,
  transform: transform,
  transformChildren: transformChildren,
  transformComment: transformComment,
  transformElement: transformElement,
  transformSlotOutlet: transformSlotOutlet,
  transformTemplateRef: transformTemplateRef,
  transformText: transformText,
  transformVBind: transformVBind,
  transformVFor: transformVFor,
  transformVHtml: transformVHtml,
  transformVIf: transformVIf,
  transformVModel: transformVModel,
  transformVOn: transformVOn,
  transformVOnce: transformVOnce,
  transformVShow: transformVShow,
  transformVSlot: transformVSlot,
  transformVText: transformVText,
  wrapTemplate: wrapTemplate
});

const SSR_INTERPOLATE = Symbol(`ssrInterpolate`);
const SSR_RENDER_VNODE = Symbol(`ssrRenderVNode`);
const SSR_RENDER_COMPONENT = Symbol(`ssrRenderComponent`);
const SSR_RENDER_SLOT = Symbol(`ssrRenderSlot`);
const SSR_RENDER_SLOT_INNER = Symbol(`ssrRenderSlotInner`);
const SSR_RENDER_CLASS = Symbol(`ssrRenderClass`);
const SSR_RENDER_STYLE = Symbol(`ssrRenderStyle`);
const SSR_RENDER_ATTRS = Symbol(`ssrRenderAttrs`);
const SSR_RENDER_ATTR = Symbol(`ssrRenderAttr`);
const SSR_RENDER_DYNAMIC_ATTR = Symbol(`ssrRenderDynamicAttr`);
const SSR_RENDER_LIST = Symbol(`ssrRenderList`);
const SSR_INCLUDE_BOOLEAN_ATTR = Symbol(
  `ssrIncludeBooleanAttr`
);
const SSR_LOOSE_EQUAL = Symbol(`ssrLooseEqual`);
const SSR_LOOSE_CONTAIN = Symbol(`ssrLooseContain`);
const SSR_RENDER_DYNAMIC_MODEL = Symbol(
  `ssrRenderDynamicModel`
);
const SSR_GET_DYNAMIC_MODEL_PROPS = Symbol(
  `ssrGetDynamicModelProps`
);
const SSR_RENDER_TELEPORT = Symbol(`ssrRenderTeleport`);
const SSR_RENDER_SUSPENSE = Symbol(`ssrRenderSuspense`);
const SSR_GET_DIRECTIVE_PROPS = Symbol(`ssrGetDirectiveProps`);
const ssrHelpers = {
  [SSR_INTERPOLATE]: `ssrInterpolate`,
  [SSR_RENDER_VNODE]: `ssrRenderVNode`,
  [SSR_RENDER_COMPONENT]: `ssrRenderComponent`,
  [SSR_RENDER_SLOT]: `ssrRenderSlot`,
  [SSR_RENDER_SLOT_INNER]: `ssrRenderSlotInner`,
  [SSR_RENDER_CLASS]: `ssrRenderClass`,
  [SSR_RENDER_STYLE]: `ssrRenderStyle`,
  [SSR_RENDER_ATTRS]: `ssrRenderAttrs`,
  [SSR_RENDER_ATTR]: `ssrRenderAttr`,
  [SSR_RENDER_DYNAMIC_ATTR]: `ssrRenderDynamicAttr`,
  [SSR_RENDER_LIST]: `ssrRenderList`,
  [SSR_INCLUDE_BOOLEAN_ATTR]: `ssrIncludeBooleanAttr`,
  [SSR_LOOSE_EQUAL]: `ssrLooseEqual`,
  [SSR_LOOSE_CONTAIN]: `ssrLooseContain`,
  [SSR_RENDER_DYNAMIC_MODEL]: `ssrRenderDynamicModel`,
  [SSR_GET_DYNAMIC_MODEL_PROPS]: `ssrGetDynamicModelProps`,
  [SSR_RENDER_TELEPORT]: `ssrRenderTeleport`,
  [SSR_RENDER_SUSPENSE]: `ssrRenderSuspense`,
  [SSR_GET_DIRECTIVE_PROPS]: `ssrGetDirectiveProps`
};
registerRuntimeHelpers(ssrHelpers);

const ssrTransformIf = createStructuralDirectiveTransform$1(
  /^(if|else|else-if)$/,
  processIf$1
);
function ssrProcessIf(node, context, disableNestedFragments = false, disableComment = false) {
  const [rootBranch] = node.branches;
  const ifStatement = createIfStatement(
    rootBranch.condition,
    processIfBranch(rootBranch, context, disableNestedFragments)
  );
  context.pushStatement(ifStatement);
  let currentIf = ifStatement;
  for (let i = 1; i < node.branches.length; i++) {
    const branch = node.branches[i];
    const branchBlockStatement = processIfBranch(
      branch,
      context,
      disableNestedFragments
    );
    if (branch.condition) {
      currentIf = currentIf.alternate = createIfStatement(
        branch.condition,
        branchBlockStatement
      );
    } else {
      currentIf.alternate = branchBlockStatement;
    }
  }
  if (!currentIf.alternate && !disableComment) {
    currentIf.alternate = createBlockStatement([
      createCallExpression(`_push`, ["`<!---->`"])
    ]);
  }
}
function processIfBranch(branch, context, disableNestedFragments = false) {
  const { children } = branch;
  const needFragmentWrapper = !disableNestedFragments && (children.length !== 1 || children[0].type !== 1) && // optimize away nested fragments when the only child is a ForNode
  !(children.length === 1 && children[0].type === 11);
  return processChildrenAsStatement(branch, context, needFragmentWrapper);
}

const ssrTransformFor = createStructuralDirectiveTransform$1("for", processFor$1);
function ssrProcessFor(node, context, disableNestedFragments = false) {
  const needFragmentWrapper = !disableNestedFragments && (node.children.length !== 1 || node.children[0].type !== 1);
  const renderLoop = createFunctionExpression(
    createForLoopParams(node.parseResult)
  );
  renderLoop.body = processChildrenAsStatement(
    node,
    context,
    needFragmentWrapper
  );
  if (!disableNestedFragments) {
    context.pushStringPart(`<!--[-->`);
  }
  context.pushStatement(
    createCallExpression(context.helper(SSR_RENDER_LIST), [
      node.source,
      renderLoop
    ])
  );
  if (!disableNestedFragments) {
    context.pushStringPart(`<!--]-->`);
  }
}

const ssrTransformSlotOutlet = (node, context) => {
  if (isSlotOutlet(node)) {
    const { slotName, slotProps } = processSlotOutlet(node, context);
    const args = [
      `_ctx.$slots`,
      slotName,
      slotProps || `{}`,
      // fallback content placeholder. will be replaced in the process phase
      `null`,
      `_push`,
      `_parent`
    ];
    if (context.scopeId && context.slotted !== false) {
      args.push(`"${context.scopeId}-s"`);
    }
    let method = SSR_RENDER_SLOT;
    let parent = context.parent;
    if (parent) {
      const children = parent.children;
      if (parent.type === 10) {
        parent = context.grandParent;
      }
      let componentType;
      if (parent.type === 1 && parent.tagType === 1 && ((componentType = resolveComponentType(parent, context, true)) === TRANSITION || componentType === TRANSITION_GROUP) && children.filter((c) => c.type === 1).length === 1) {
        method = SSR_RENDER_SLOT_INNER;
        if (!(context.scopeId && context.slotted !== false)) {
          args.push("null");
        }
        args.push("true");
      }
    }
    node.ssrCodegenNode = createCallExpression(context.helper(method), args);
  }
};
function ssrProcessSlotOutlet(node, context) {
  const renderCall = node.ssrCodegenNode;
  if (node.children.length) {
    const fallbackRenderFn = createFunctionExpression([]);
    fallbackRenderFn.body = processChildrenAsStatement(node, context);
    renderCall.arguments[3] = fallbackRenderFn;
  }
  if (context.withSlotScopeId) {
    const slotScopeId = renderCall.arguments[6];
    renderCall.arguments[6] = slotScopeId ? `${slotScopeId} + _scopeId` : `_scopeId`;
  }
  context.pushStatement(node.ssrCodegenNode);
}

function createSSRCompilerError(code, loc) {
  return createCompilerError(code, loc, SSRErrorMessages);
}
const SSRErrorMessages = {
  [65]: `Unsafe attribute name for SSR.`,
  [66]: `Missing the 'to' prop on teleport element.`,
  [67]: `Invalid AST node during SSR transform.`
};

function ssrProcessTeleport(node, context) {
  const targetProp = findProp$1(node, "to");
  if (!targetProp) {
    context.onError(
      createSSRCompilerError(66, node.loc)
    );
    return;
  }
  let target;
  if (targetProp.type === 6) {
    target = targetProp.value && createSimpleExpression(targetProp.value.content, true);
  } else {
    target = targetProp.exp;
  }
  if (!target) {
    context.onError(
      createSSRCompilerError(
        66,
        targetProp.loc
      )
    );
    return;
  }
  const disabledProp = findProp$1(
    node,
    "disabled",
    false,
    true
    /* allow empty */
  );
  const disabled = disabledProp ? disabledProp.type === 6 ? `true` : disabledProp.exp || `false` : `false`;
  const contentRenderFn = createFunctionExpression(
    [`_push`],
    void 0,
    // Body is added later
    true,
    // newline
    false,
    // isSlot
    node.loc
  );
  contentRenderFn.body = processChildrenAsStatement(node, context);
  context.pushStatement(
    createCallExpression(context.helper(SSR_RENDER_TELEPORT), [
      `_push`,
      contentRenderFn,
      target,
      disabled,
      `_parent`
    ])
  );
}

const wipMap$3 = /* @__PURE__ */ new WeakMap();
function ssrTransformSuspense(node, context) {
  return () => {
    if (node.children.length) {
      const wipEntry = {
        slotsExp: null,
        // to be immediately set
        wipSlots: []
      };
      wipMap$3.set(node, wipEntry);
      wipEntry.slotsExp = buildSlots(
        node,
        context,
        (_props, _vForExp, children, loc) => {
          const fn = createFunctionExpression(
            [],
            void 0,
            // no return, assign body later
            true,
            // newline
            false,
            // suspense slots are not treated as normal slots
            loc
          );
          wipEntry.wipSlots.push({
            fn,
            children
          });
          return fn;
        }
      ).slots;
    }
  };
}
function ssrProcessSuspense(node, context) {
  const wipEntry = wipMap$3.get(node);
  if (!wipEntry) {
    return;
  }
  const { slotsExp, wipSlots } = wipEntry;
  for (let i = 0; i < wipSlots.length; i++) {
    const slot = wipSlots[i];
    slot.fn.body = processChildrenAsStatement(slot, context);
  }
  context.pushStatement(
    createCallExpression(context.helper(SSR_RENDER_SUSPENSE), [
      `_push`,
      slotsExp
    ])
  );
}

const rawChildrenMap = /* @__PURE__ */ new WeakMap();
const ssrTransformElement = (node, context) => {
  if (node.type !== 1 || node.tagType !== 0) {
    return;
  }
  return function ssrPostTransformElement() {
    const openTag = [`<${node.tag}`];
    const needTagForRuntime = node.tag === "textarea" || node.tag.indexOf("-") > 0;
    const hasDynamicVBind = hasDynamicKeyVBind(node);
    const hasCustomDir = node.props.some(
      (p) => p.type === 7 && !isBuiltInDirective(p.name)
    );
    const needMergeProps = hasDynamicVBind || hasCustomDir;
    if (needMergeProps) {
      const { props, directives } = buildProps$1(
        node,
        context,
        node.props,
        false,
        false,
        true
      );
      if (props || directives.length) {
        const mergedProps = buildSSRProps(props, directives, context);
        const propsExp = createCallExpression(
          context.helper(SSR_RENDER_ATTRS),
          [mergedProps]
        );
        if (node.tag === "textarea") {
          const existingText = node.children[0];
          if (!existingText || existingText.type !== 5) {
            const tempId = `_temp${context.temps++}`;
            propsExp.arguments = [
              createAssignmentExpression(
                createSimpleExpression(tempId, false),
                mergedProps
              )
            ];
            rawChildrenMap.set(
              node,
              createCallExpression(context.helper(SSR_INTERPOLATE), [
                createConditionalExpression(
                  createSimpleExpression(`"value" in ${tempId}`, false),
                  createSimpleExpression(`${tempId}.value`, false),
                  createSimpleExpression(
                    existingText ? existingText.content : ``,
                    true
                  ),
                  false
                )
              ])
            );
          }
        } else if (node.tag === "input") {
          const vModel = findVModel(node);
          if (vModel) {
            const tempId = `_temp${context.temps++}`;
            const tempExp = createSimpleExpression(tempId, false);
            propsExp.arguments = [
              createSequenceExpression([
                createAssignmentExpression(tempExp, mergedProps),
                createCallExpression(context.helper(MERGE_PROPS), [
                  tempExp,
                  createCallExpression(
                    context.helper(SSR_GET_DYNAMIC_MODEL_PROPS),
                    [
                      tempExp,
                      // existing props
                      vModel.exp
                      // model
                    ]
                  )
                ])
              ])
            ];
          }
        } else if (directives.length && !node.children.length) {
          const vText = findDir$1(node, "text");
          if (!vText) {
            const tempId = `_temp${context.temps++}`;
            propsExp.arguments = [
              createAssignmentExpression(
                createSimpleExpression(tempId, false),
                mergedProps
              )
            ];
            rawChildrenMap.set(
              node,
              createConditionalExpression(
                createSimpleExpression(`"textContent" in ${tempId}`, false),
                createCallExpression(context.helper(SSR_INTERPOLATE), [
                  createSimpleExpression(`${tempId}.textContent`, false)
                ]),
                createSimpleExpression(`${tempId}.innerHTML ?? ''`, false),
                false
              )
            );
          }
        }
        if (needTagForRuntime) {
          propsExp.arguments.push(`"${node.tag}"`);
        }
        openTag.push(propsExp);
      }
    }
    let dynamicClassBinding = void 0;
    let staticClassBinding = void 0;
    let dynamicStyleBinding = void 0;
    for (let i = 0; i < node.props.length; i++) {
      const prop = node.props[i];
      if (node.tag === "input" && isTrueFalseValue(prop)) {
        continue;
      }
      if (prop.type === 7) {
        if (prop.name === "html" && prop.exp) {
          rawChildrenMap.set(
            node,
            createCompoundExpression([`(`, prop.exp, `) ?? ''`])
          );
        } else if (prop.name === "text" && prop.exp) {
          node.children = [createInterpolation(prop.exp, prop.loc)];
        } else if (prop.name === "slot") {
          context.onError(
            createCompilerError(40, prop.loc)
          );
        } else if (isTextareaWithValue(node, prop) && prop.exp) {
          if (!needMergeProps) {
            node.children = [createInterpolation(prop.exp, prop.loc)];
          }
        } else if (!needMergeProps && prop.name !== "on") {
          const directiveTransform = context.directiveTransforms[prop.name];
          if (directiveTransform) {
            const { props, ssrTagParts } = directiveTransform(
              prop,
              node,
              context
            );
            if (ssrTagParts) {
              openTag.push(...ssrTagParts);
            }
            for (let j = 0; j < props.length; j++) {
              const { key, value } = props[j];
              if (isStaticExp(key)) {
                let attrName = key.content;
                if (attrName === "key" || attrName === "ref") {
                  continue;
                }
                if (attrName === "class") {
                  openTag.push(
                    ` class="`,
                    dynamicClassBinding = createCallExpression(
                      context.helper(SSR_RENDER_CLASS),
                      [value]
                    ),
                    `"`
                  );
                } else if (attrName === "style") {
                  if (dynamicStyleBinding) {
                    mergeCall(dynamicStyleBinding, value);
                  } else {
                    openTag.push(
                      ` style="`,
                      dynamicStyleBinding = createCallExpression(
                        context.helper(SSR_RENDER_STYLE),
                        [value]
                      ),
                      `"`
                    );
                  }
                } else {
                  attrName = node.tag.indexOf("-") > 0 ? attrName : propsToAttrMap[attrName] || attrName.toLowerCase();
                  if (isBooleanAttr(attrName)) {
                    openTag.push(
                      createConditionalExpression(
                        createCallExpression(
                          context.helper(SSR_INCLUDE_BOOLEAN_ATTR),
                          [value]
                        ),
                        createSimpleExpression(" " + attrName, true),
                        createSimpleExpression("", true),
                        false
                      )
                    );
                  } else if (isSSRSafeAttrName(attrName)) {
                    openTag.push(
                      createCallExpression(context.helper(SSR_RENDER_ATTR), [
                        key,
                        value
                      ])
                    );
                  } else {
                    context.onError(
                      createSSRCompilerError(
                        65,
                        key.loc
                      )
                    );
                  }
                }
              } else {
                const args = [key, value];
                if (needTagForRuntime) {
                  args.push(`"${node.tag}"`);
                }
                openTag.push(
                  createCallExpression(
                    context.helper(SSR_RENDER_DYNAMIC_ATTR),
                    args
                  )
                );
              }
            }
          }
        }
      } else {
        const name = prop.name;
        if (node.tag === "textarea" && name === "value" && prop.value) {
          rawChildrenMap.set(node, escapeHtml(prop.value.content));
        } else if (!needMergeProps) {
          if (name === "key" || name === "ref") {
            continue;
          }
          if (name === "class" && prop.value) {
            staticClassBinding = JSON.stringify(prop.value.content);
          }
          openTag.push(
            ` ${prop.name}` + (prop.value ? `="${escapeHtml(prop.value.content)}"` : ``)
          );
        }
      }
    }
    if (dynamicClassBinding && staticClassBinding) {
      mergeCall(dynamicClassBinding, staticClassBinding);
      removeStaticBinding(openTag, "class");
    }
    if (context.scopeId) {
      openTag.push(` ${context.scopeId}`);
    }
    node.ssrCodegenNode = createTemplateLiteral(openTag);
  };
};
function buildSSRProps(props, directives, context) {
  let mergePropsArgs = [];
  if (props) {
    if (props.type === 14) {
      mergePropsArgs = props.arguments;
    } else {
      mergePropsArgs.push(props);
    }
  }
  if (directives.length) {
    for (const dir of directives) {
      mergePropsArgs.push(
        createCallExpression(context.helper(SSR_GET_DIRECTIVE_PROPS), [
          `_ctx`,
          ...buildDirectiveArgs(dir, context).elements
        ])
      );
    }
  }
  return mergePropsArgs.length > 1 ? createCallExpression(context.helper(MERGE_PROPS), mergePropsArgs) : mergePropsArgs[0];
}
function isTrueFalseValue(prop) {
  if (prop.type === 7) {
    return prop.name === "bind" && prop.arg && isStaticExp(prop.arg) && (prop.arg.content === "true-value" || prop.arg.content === "false-value");
  } else {
    return prop.name === "true-value" || prop.name === "false-value";
  }
}
function isTextareaWithValue(node, prop) {
  return !!(node.tag === "textarea" && prop.name === "bind" && isStaticArgOf(prop.arg, "value"));
}
function mergeCall(call, arg) {
  const existing = call.arguments[0];
  if (existing.type === 17) {
    existing.elements.push(arg);
  } else {
    call.arguments[0] = createArrayExpression([existing, arg]);
  }
}
function removeStaticBinding(tag, binding) {
  const regExp = new RegExp(`^ ${binding}=".+"$`);
  const i = tag.findIndex((e) => typeof e === "string" && regExp.test(e));
  if (i > -1) {
    tag.splice(i, 1);
  }
}
function findVModel(node) {
  return node.props.find(
    (p) => p.type === 7 && p.name === "model" && p.exp
  );
}
function ssrProcessElement(node, context) {
  const isVoidTag = context.options.isVoidTag || NO;
  const elementsToAdd = node.ssrCodegenNode.elements;
  for (let j = 0; j < elementsToAdd.length; j++) {
    context.pushStringPart(elementsToAdd[j]);
  }
  if (context.withSlotScopeId) {
    context.pushStringPart(createSimpleExpression(`_scopeId`, false));
  }
  context.pushStringPart(`>`);
  const rawChildren = rawChildrenMap.get(node);
  if (rawChildren) {
    context.pushStringPart(rawChildren);
  } else if (node.children.length) {
    processChildren(node, context);
  }
  if (!isVoidTag(node.tag)) {
    context.pushStringPart(`</${node.tag}>`);
  }
}

const wipMap$2 = /* @__PURE__ */ new WeakMap();
function ssrTransformTransitionGroup(node, context) {
  return () => {
    const tag = findProp$1(node, "tag");
    if (tag) {
      const otherProps = node.props.filter((p) => p !== tag);
      const { props, directives } = buildProps$1(
        node,
        context,
        otherProps,
        true,
        false,
        true
      );
      let propsExp = null;
      if (props || directives.length) {
        propsExp = createCallExpression(context.helper(SSR_RENDER_ATTRS), [
          buildSSRProps(props, directives, context)
        ]);
      }
      wipMap$2.set(node, {
        tag,
        propsExp,
        scopeId: context.scopeId || null
      });
    }
  };
}
function ssrProcessTransitionGroup(node, context) {
  const entry = wipMap$2.get(node);
  if (entry) {
    const { tag, propsExp, scopeId } = entry;
    if (tag.type === 7) {
      context.pushStringPart(`<`);
      context.pushStringPart(tag.exp);
      if (propsExp) {
        context.pushStringPart(propsExp);
      }
      if (scopeId) {
        context.pushStringPart(` ${scopeId}`);
      }
      context.pushStringPart(`>`);
      processChildren(
        node,
        context,
        false,
        /**
         * TransitionGroup has the special runtime behavior of flattening and
         * concatenating all children into a single fragment (in order for them to
         * be patched using the same key map) so we need to account for that here
         * by disabling nested fragment wrappers from being generated.
         */
        true,
        /**
         * TransitionGroup filters out comment children at runtime and thus
         * doesn't expect comments to be present during hydration. We need to
         * account for that by disabling the empty comment that is otherwise
         * rendered for a falsy v-if that has no v-else specified. (#6715)
         */
        true
      );
      context.pushStringPart(`</`);
      context.pushStringPart(tag.exp);
      context.pushStringPart(`>`);
    } else {
      context.pushStringPart(`<${tag.value.content}`);
      if (propsExp) {
        context.pushStringPart(propsExp);
      }
      if (scopeId) {
        context.pushStringPart(` ${scopeId}`);
      }
      context.pushStringPart(`>`);
      processChildren(node, context, false, true, true);
      context.pushStringPart(`</${tag.value.content}>`);
    }
  } else {
    processChildren(node, context, true, true, true);
  }
}

const wipMap$1 = /* @__PURE__ */ new WeakMap();
function ssrTransformTransition(node, context) {
  return () => {
    const appear = findProp$1(node, "appear", false, true);
    wipMap$1.set(node, !!appear);
  };
}
function ssrProcessTransition(node, context) {
  node.children = node.children.filter((c) => c.type !== 3);
  const appear = wipMap$1.get(node);
  if (appear) {
    context.pushStringPart(`<template>`);
    processChildren(node, context, false, true);
    context.pushStringPart(`</template>`);
  } else {
    processChildren(node, context, false, true);
  }
}

var __defProp$8 = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$8.call(b, prop))
      __defNormalProp$8(a, prop, b[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b)) {
      if (__propIsEnum$8.call(b, prop))
        __defNormalProp$8(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));
const wipMap = /* @__PURE__ */ new WeakMap();
const WIP_SLOT = Symbol();
const componentTypeMap = /* @__PURE__ */ new WeakMap();
const ssrTransformComponent = (node, context) => {
  if (node.type !== 1 || node.tagType !== 1) {
    return;
  }
  const component = resolveComponentType(
    node,
    context,
    true
    /* ssr */
  );
  const isDynamicComponent = isObject$2(component) && component.callee === RESOLVE_DYNAMIC_COMPONENT;
  componentTypeMap.set(node, component);
  if (isSymbol$1(component)) {
    if (component === SUSPENSE) {
      return ssrTransformSuspense(node, context);
    } else if (component === TRANSITION_GROUP) {
      return ssrTransformTransitionGroup(node, context);
    } else if (component === TRANSITION) {
      return ssrTransformTransition(node);
    }
    return;
  }
  const vnodeBranches = [];
  const clonedNode = clone(node);
  return function ssrPostTransformComponent() {
    if (clonedNode.children.length) {
      buildSlots(clonedNode, context, (props, vFor, children) => {
        vnodeBranches.push(
          createVNodeSlotBranch(props, vFor, children, context)
        );
        return createFunctionExpression(void 0);
      });
    }
    let propsExp = `null`;
    if (node.props.length) {
      const { props, directives } = buildProps$1(
        node,
        context,
        void 0,
        true,
        isDynamicComponent
      );
      if (props || directives.length) {
        propsExp = buildSSRProps(props, directives, context);
      }
    }
    const wipEntries = [];
    wipMap.set(node, wipEntries);
    const buildSSRSlotFn = (props, _vForExp, children, loc) => {
      const param0 = props && stringifyExpression(props) || `_`;
      const fn = createFunctionExpression(
        [param0, `_push`, `_parent`, `_scopeId`],
        void 0,
        // no return, assign body later
        true,
        // newline
        true,
        // isSlot
        loc
      );
      wipEntries.push({
        type: WIP_SLOT,
        fn,
        children,
        // also collect the corresponding vnode branch built earlier
        vnodeBranch: vnodeBranches[wipEntries.length]
      });
      return fn;
    };
    const slots = node.children.length ? buildSlots(node, context, buildSSRSlotFn).slots : `null`;
    if (typeof component !== "string") {
      node.ssrCodegenNode = createCallExpression(
        context.helper(SSR_RENDER_VNODE),
        [
          `_push`,
          createCallExpression(context.helper(CREATE_VNODE), [
            component,
            propsExp,
            slots
          ]),
          `_parent`
        ]
      );
    } else {
      node.ssrCodegenNode = createCallExpression(
        context.helper(SSR_RENDER_COMPONENT),
        [component, propsExp, slots, `_parent`]
      );
    }
  };
};
function ssrProcessComponent(node, context, parent) {
  const component = componentTypeMap.get(node);
  if (!node.ssrCodegenNode) {
    if (component === TELEPORT) {
      return ssrProcessTeleport(node, context);
    } else if (component === SUSPENSE) {
      return ssrProcessSuspense(node, context);
    } else if (component === TRANSITION_GROUP) {
      return ssrProcessTransitionGroup(node, context);
    } else {
      if (parent.type === WIP_SLOT) {
        context.pushStringPart(``);
      }
      if (component === TRANSITION) {
        return ssrProcessTransition(node, context);
      }
      processChildren(node, context);
    }
  } else {
    const wipEntries = wipMap.get(node) || [];
    for (let i = 0; i < wipEntries.length; i++) {
      const { fn, vnodeBranch } = wipEntries[i];
      fn.body = createIfStatement(
        createSimpleExpression(`_push`, false),
        processChildrenAsStatement(
          wipEntries[i],
          context,
          false,
          true
        ),
        vnodeBranch
      );
    }
    if (context.withSlotScopeId) {
      node.ssrCodegenNode.arguments.push(`_scopeId`);
    }
    if (typeof component === "string") {
      context.pushStatement(
        createCallExpression(`_push`, [node.ssrCodegenNode])
      );
    } else {
      context.pushStatement(node.ssrCodegenNode);
    }
  }
}
const rawOptionsMap = /* @__PURE__ */ new WeakMap();
const [baseNodeTransforms, baseDirectiveTransforms] = getBaseTransformPreset$1(true);
const vnodeNodeTransforms = [...baseNodeTransforms, ...DOMNodeTransforms];
const vnodeDirectiveTransforms = __spreadValues$8(__spreadValues$8({}, baseDirectiveTransforms), DOMDirectiveTransforms);
function createVNodeSlotBranch(slotProps, vFor, children, parentContext) {
  const rawOptions = rawOptionsMap.get(parentContext.root);
  const subOptions = __spreadProps$7(__spreadValues$8({}, rawOptions), {
    // overwrite with vnode-based transforms
    nodeTransforms: [
      ...vnodeNodeTransforms,
      ...rawOptions.nodeTransforms || []
    ],
    directiveTransforms: __spreadValues$8(__spreadValues$8({}, vnodeDirectiveTransforms), rawOptions.directiveTransforms || {})
  });
  const wrapperProps = [];
  if (slotProps) {
    wrapperProps.push({
      type: 7,
      name: "slot",
      exp: slotProps,
      arg: void 0,
      modifiers: [],
      loc: locStub
    });
  }
  if (vFor) {
    wrapperProps.push(extend({}, vFor));
  }
  const wrapperNode = {
    type: 1,
    ns: 0,
    tag: "template",
    tagType: 3,
    props: wrapperProps,
    children,
    loc: locStub,
    codegenNode: void 0
  };
  subTransform(wrapperNode, subOptions, parentContext);
  return createReturnStatement(children);
}
function subTransform(node, options, parentContext) {
  const childRoot = createRoot([node]);
  const childContext = createTransformContext(childRoot, options);
  childContext.ssr = false;
  childContext.scopes = __spreadValues$8({}, parentContext.scopes);
  childContext.identifiers = __spreadValues$8({}, parentContext.identifiers);
  childContext.imports = parentContext.imports;
  traverseNode(childRoot, childContext);
  ["helpers", "components", "directives"].forEach((key) => {
    childContext[key].forEach((value, helperKey) => {
      if (key === "helpers") {
        const parentCount = parentContext.helpers.get(helperKey);
        if (parentCount === void 0) {
          parentContext.helpers.set(helperKey, value);
        } else {
          parentContext.helpers.set(helperKey, value + parentCount);
        }
      } else {
        parentContext[key].add(value);
      }
    });
  });
}
function clone(v) {
  if (isArray$3(v)) {
    return v.map(clone);
  } else if (isPlainObject(v)) {
    const res = {};
    for (const key in v) {
      res[key] = clone(v[key]);
    }
    return res;
  } else {
    return v;
  }
}

function ssrCodegenTransform(ast, options) {
  const context = createSSRTransformContext(ast, options);
  if (options.ssrCssVars) {
    const cssContext = createTransformContext(createRoot([]), options);
    const varsExp = processExpression(
      createSimpleExpression(options.ssrCssVars, false),
      cssContext
    );
    context.body.push(
      createCompoundExpression([`const _cssVars = { style: `, varsExp, `}`])
    );
    Array.from(cssContext.helpers.keys()).forEach((helper) => {
      ast.helpers.add(helper);
    });
  }
  const isFragment = ast.children.length > 1 && ast.children.some((c) => !isText$1(c));
  processChildren(ast, context, isFragment);
  ast.codegenNode = createBlockStatement(context.body);
  ast.ssrHelpers = Array.from(
    /* @__PURE__ */ new Set([
      ...Array.from(ast.helpers).filter((h) => h in ssrHelpers),
      ...context.helpers
    ])
  );
  ast.helpers = new Set(Array.from(ast.helpers).filter((h) => !(h in ssrHelpers)));
}
function createSSRTransformContext(root, options, helpers = /* @__PURE__ */ new Set(), withSlotScopeId = false) {
  const body = [];
  let currentString = null;
  return {
    root,
    options,
    body,
    helpers,
    withSlotScopeId,
    onError: options.onError || ((e) => {
      throw e;
    }),
    helper(name) {
      helpers.add(name);
      return name;
    },
    pushStringPart(part) {
      if (!currentString) {
        const currentCall = createCallExpression(`_push`);
        body.push(currentCall);
        currentString = createTemplateLiteral([]);
        currentCall.arguments.push(currentString);
      }
      const bufferedElements = currentString.elements;
      const lastItem = bufferedElements[bufferedElements.length - 1];
      if (isString$1(part) && isString$1(lastItem)) {
        bufferedElements[bufferedElements.length - 1] += part;
      } else {
        bufferedElements.push(part);
      }
    },
    pushStatement(statement) {
      currentString = null;
      body.push(statement);
    }
  };
}
function createChildContext(parent, withSlotScopeId = parent.withSlotScopeId) {
  return createSSRTransformContext(
    parent.root,
    parent.options,
    parent.helpers,
    withSlotScopeId
  );
}
function processChildren(parent, context, asFragment = false, disableNestedFragments = false, disableComment = false) {
  if (asFragment) {
    context.pushStringPart(`<!--[-->`);
  }
  const { children } = parent;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        switch (child.tagType) {
          case 0:
            ssrProcessElement(child, context);
            break;
          case 1:
            ssrProcessComponent(child, context, parent);
            break;
          case 2:
            ssrProcessSlotOutlet(child, context);
            break;
          case 3:
            break;
          default:
            context.onError(
              createSSRCompilerError(
                67,
                child.loc
              )
            );
            const exhaustiveCheck2 = child;
            return exhaustiveCheck2;
        }
        break;
      case 2:
        context.pushStringPart(escapeHtml(child.content));
        break;
      case 3:
        if (!disableComment) {
          context.pushStringPart(`<!--${child.content}-->`);
        }
        break;
      case 5:
        context.pushStringPart(
          createCallExpression(context.helper(SSR_INTERPOLATE), [
            child.content
          ])
        );
        break;
      case 9:
        ssrProcessIf(child, context, disableNestedFragments, disableComment);
        break;
      case 11:
        ssrProcessFor(child, context, disableNestedFragments);
        break;
      case 10:
        break;
      case 12:
      case 8:
        break;
      default:
        context.onError(
          createSSRCompilerError(
            67,
            child.loc
          )
        );
        const exhaustiveCheck = child;
        return exhaustiveCheck;
    }
  }
  if (asFragment) {
    context.pushStringPart(`<!--]-->`);
  }
}
function processChildrenAsStatement(parent, parentContext, asFragment = false, withSlotScopeId = parentContext.withSlotScopeId) {
  const childContext = createChildContext(parentContext, withSlotScopeId);
  processChildren(parent, childContext, asFragment);
  return createBlockStatement(childContext.body);
}

const ssrTransformModel = (dir, node, context) => {
  const model = dir.exp;
  function checkDuplicatedValue() {
    const value = findProp$1(node, "value");
    if (value) {
      context.onError(
        createDOMCompilerError(
          60,
          value.loc
        )
      );
    }
  }
  function processOption(plainNode) {
    if (plainNode.tag === "option") {
      if (plainNode.props.findIndex((p) => p.name === "selected") === -1) {
        const value = findValueBinding(plainNode);
        plainNode.ssrCodegenNode.elements.push(
          createConditionalExpression(
            createCallExpression(context.helper(SSR_INCLUDE_BOOLEAN_ATTR), [
              createConditionalExpression(
                createCallExpression(`Array.isArray`, [model]),
                createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [
                  model,
                  value
                ]),
                createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
                  model,
                  value
                ])
              )
            ]),
            createSimpleExpression(" selected", true),
            createSimpleExpression("", true),
            false
          )
        );
      }
    } else if (plainNode.tag === "optgroup") {
      plainNode.children.forEach(
        (option) => processOption(option)
      );
    }
  }
  if (node.tagType === 0) {
    const res = { props: [] };
    const defaultProps = [
      // default value binding for text type inputs
      createObjectProperty(`value`, model)
    ];
    if (node.tag === "input") {
      const type = findProp$1(node, "type");
      if (type) {
        const value = findValueBinding(node);
        if (type.type === 7) {
          res.ssrTagParts = [
            createCallExpression(context.helper(SSR_RENDER_DYNAMIC_MODEL), [
              type.exp,
              model,
              value
            ])
          ];
        } else if (type.value) {
          switch (type.value.content) {
            case "radio":
              res.props = [
                createObjectProperty(
                  `checked`,
                  createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
                    model,
                    value
                  ])
                )
              ];
              break;
            case "checkbox":
              const trueValueBinding = findProp$1(node, "true-value");
              if (trueValueBinding) {
                const trueValue = trueValueBinding.type === 6 ? JSON.stringify(trueValueBinding.value.content) : trueValueBinding.exp;
                res.props = [
                  createObjectProperty(
                    `checked`,
                    createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
                      model,
                      trueValue
                    ])
                  )
                ];
              } else {
                res.props = [
                  createObjectProperty(
                    `checked`,
                    createConditionalExpression(
                      createCallExpression(`Array.isArray`, [model]),
                      createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [
                        model,
                        value
                      ]),
                      model
                    )
                  )
                ];
              }
              break;
            case "file":
              context.onError(
                createDOMCompilerError(
                  59,
                  dir.loc
                )
              );
              break;
            default:
              checkDuplicatedValue();
              res.props = defaultProps;
              break;
          }
        }
      } else if (hasDynamicKeyVBind(node)) ; else {
        checkDuplicatedValue();
        res.props = defaultProps;
      }
    } else if (node.tag === "textarea") {
      checkDuplicatedValue();
      node.children = [createInterpolation(model, model.loc)];
    } else if (node.tag === "select") {
      const processChildren = (children) => {
        children.forEach((child) => {
          if (child.type === 1) {
            processOption(child);
          } else if (child.type === 11) {
            processChildren(child.children);
          } else if (child.type === 9) {
            child.branches.forEach((b) => processChildren(b.children));
          }
        });
      };
      processChildren(node.children);
    } else {
      context.onError(
        createDOMCompilerError(
          57,
          dir.loc
        )
      );
    }
    return res;
  } else {
    return transformModel$1(dir, node, context);
  }
};
function findValueBinding(node) {
  const valueBinding = findProp$1(node, "value");
  return valueBinding ? valueBinding.type === 7 ? valueBinding.exp : createSimpleExpression(valueBinding.value.content, true) : createSimpleExpression(`null`, false);
}

const ssrTransformShow = (dir, node, context) => {
  if (!dir.exp) {
    context.onError(
      createDOMCompilerError(61)
    );
  }
  return {
    props: [
      createObjectProperty(
        `style`,
        createConditionalExpression(
          dir.exp,
          createSimpleExpression(`null`, false),
          createObjectExpression([
            createObjectProperty(
              `display`,
              createSimpleExpression(`none`, true)
            )
          ]),
          false
        )
      )
    ]
  };
};

const filterChild = (node) => node.children.filter((n) => n.type !== 3);
const hasSingleChild = (node) => filterChild(node).length === 1;
const ssrInjectFallthroughAttrs = (node, context) => {
  if (node.type === 0) {
    context.identifiers._attrs = 1;
  }
  if (node.type === 1 && node.tagType === 1 && (node.tag === "transition" || node.tag === "Transition" || node.tag === "KeepAlive" || node.tag === "keep-alive")) {
    const rootChildren = filterChild(context.root);
    if (rootChildren.length === 1 && rootChildren[0] === node) {
      if (hasSingleChild(node)) {
        injectFallthroughAttrs(node.children[0]);
      }
      return;
    }
  }
  const parent = context.parent;
  if (!parent || parent.type !== 0) {
    return;
  }
  if (node.type === 10 && hasSingleChild(node)) {
    let hasEncounteredIf = false;
    for (const c of filterChild(parent)) {
      if (c.type === 9 || c.type === 1 && findDir$1(c, "if")) {
        if (hasEncounteredIf) return;
        hasEncounteredIf = true;
      } else if (
        // node before v-if
        !hasEncounteredIf || // non else nodes
        !(c.type === 1 && findDir$1(c, /else/, true))
      ) {
        return;
      }
    }
    injectFallthroughAttrs(node.children[0]);
  } else if (hasSingleChild(parent)) {
    injectFallthroughAttrs(node);
  }
};
function injectFallthroughAttrs(node) {
  if (node.type === 1 && (node.tagType === 0 || node.tagType === 1) && !findDir$1(node, "for")) {
    node.props.push({
      type: 7,
      name: "bind",
      arg: void 0,
      exp: createSimpleExpression(`_attrs`, false),
      modifiers: [],
      loc: locStub
    });
  }
}

const ssrInjectCssVars = (node, context) => {
  if (!context.ssrCssVars) {
    return;
  }
  if (node.type === 0) {
    context.identifiers._cssVars = 1;
  }
  const parent = context.parent;
  if (!parent || parent.type !== 0) {
    return;
  }
  if (node.type === 10) {
    for (const child of node.children) {
      injectCssVars(child);
    }
  } else {
    injectCssVars(node);
  }
};
function injectCssVars(node) {
  if (node.type === 1 && (node.tagType === 0 || node.tagType === 1) && !findDir$1(node, "for")) {
    if (node.tag === "suspense" || node.tag === "Suspense") {
      for (const child of node.children) {
        if (child.type === 1 && child.tagType === 3) {
          child.children.forEach(injectCssVars);
        } else {
          injectCssVars(child);
        }
      }
    } else {
      node.props.push({
        type: 7,
        name: "bind",
        arg: void 0,
        exp: createSimpleExpression(`_cssVars`, false),
        modifiers: [],
        loc: locStub
      });
    }
  }
}

var __defProp$7 = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$7.call(b, prop))
      __defNormalProp$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b)) {
      if (__propIsEnum$7.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
function compile(source, options = {}) {
  options = __spreadProps$6(__spreadValues$7(__spreadValues$7({}, options), parserOptions), {
    ssr: true,
    inSSR: true,
    scopeId: options.mode === "function" ? null : options.scopeId,
    // always prefix since compiler-ssr doesn't have size concern
    prefixIdentifiers: true,
    // disable optimizations that are unnecessary for ssr
    cacheHandlers: false,
    hoistStatic: false
  });
  const ast = typeof source === "string" ? baseParse(source, options) : source;
  rawOptionsMap.set(ast, options);
  transform$1(ast, __spreadProps$6(__spreadValues$7({}, options), {
    hoistStatic: false,
    nodeTransforms: [
      ssrTransformIf,
      ssrTransformFor,
      trackVForSlotScopes,
      transformExpression,
      ssrTransformSlotOutlet,
      ssrInjectFallthroughAttrs,
      ssrInjectCssVars,
      ssrTransformElement,
      ssrTransformComponent,
      trackSlotScopes,
      transformStyle,
      ...options.nodeTransforms || []
      // user transforms
    ],
    directiveTransforms: __spreadValues$7({
      // reusing core v-bind
      bind: transformBind,
      on: transformOn$1,
      // model and show have dedicated SSR handling
      model: ssrTransformModel,
      show: ssrTransformShow,
      // the following are ignored during SSR
      // on: noopDirectiveTransform,
      cloak: noopDirectiveTransform,
      once: noopDirectiveTransform,
      memo: noopDirectiveTransform
    }, options.directiveTransforms || {})
  }));
  ssrCodegenTransform(ast, options);
  return generate$1(ast, options);
}

var CompilerSSR = /*#__PURE__*/Object.freeze({
  __proto__: null,
  compile: compile
});

var _polyfillNode_fs = {};

var _polyfillNode_fs$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  default: _polyfillNode_fs
});

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_fs$1);

var require$$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_path);

var require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_util$1);

const hasWarned = {};
function warnOnce$1(msg) {
  const isNodeProd = typeof process !== "undefined" && process.env.NODE_ENV === "production";
  if (!isNodeProd && true && !hasWarned[msg]) {
    hasWarned[msg] = true;
    warn(msg);
  }
}
function warn(msg) {
  console.warn(
    `\x1B[1m\x1B[33m[@vue/compiler-sfc]\x1B[0m\x1B[33m ${msg}\x1B[0m
`
  );
}

var __defProp$6 = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$6.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b)) {
      if (__propIsEnum$6.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
function preprocess$1({ source, filename, preprocessOptions }, preprocessor) {
  let res = "";
  let err = null;
  preprocessor.render(
    source,
    __spreadValues$6({ filename }, preprocessOptions),
    (_err, _res) => {
      if (_err) err = _err;
      res = _res;
    }
  );
  if (err) throw err;
  return res;
}
function compileTemplate(options) {
  const { preprocessLang, preprocessCustomRequire } = options;
  if (preprocessLang && !preprocessCustomRequire) {
    throw new Error(
      `[@vue/compiler-sfc] Template preprocessing in the browser build must provide the \`preprocessCustomRequire\` option to return the in-browser version of the preprocessor in the shape of { render(): string }.`
    );
  }
  const preprocessor = preprocessLang ? preprocessCustomRequire ? preprocessCustomRequire(preprocessLang) : void 0  : false;
  if (preprocessor) {
    try {
      return doCompileTemplate(__spreadProps$5(__spreadValues$6({}, options), {
        source: preprocess$1(options, preprocessor),
        ast: void 0
        // invalidate AST if template goes through preprocessor
      }));
    } catch (e) {
      return {
        code: `export default function render() {}`,
        source: options.source,
        tips: [],
        errors: [e]
      };
    }
  } else if (preprocessLang) {
    return {
      code: `export default function render() {}`,
      source: options.source,
      tips: [
        `Component ${options.filename} uses lang ${preprocessLang} for template. Please install the language preprocessor.`
      ],
      errors: [
        `Component ${options.filename} uses lang ${preprocessLang} for template, however it is not installed.`
      ]
    };
  } else {
    return doCompileTemplate(options);
  }
}
function doCompileTemplate({
  filename,
  id,
  scoped,
  slotted,
  inMap,
  source,
  ast: inAST,
  ssr = false,
  vapor = false,
  ssrCssVars,
  isProd = false,
  compiler,
  compilerOptions = {},
  transformAssetUrls
}) {
  const errors = [];
  const warnings = [];
  let nodeTransforms = [];
  if (isObject$2(transformAssetUrls)) {
    const assetOptions = normalizeOptions(transformAssetUrls);
    nodeTransforms = [
      createAssetUrlTransformWithOptions(assetOptions),
      createSrcsetTransformWithOptions(assetOptions)
    ];
  } else if (transformAssetUrls !== false) {
    nodeTransforms = [transformAssetUrl, transformSrcset];
  }
  if (ssr && !ssrCssVars) {
    warnOnce$1(
      `compileTemplate is called with \`ssr: true\` but no corresponding \`cssVars\` option.`
    );
  }
  if (!id) {
    warnOnce$1(`compileTemplate now requires the \`id\` option.`);
    id = "";
  }
  const shortId = id.replace(/^data-v-/, "");
  const longId = `data-v-${shortId}`;
  const defaultCompiler = ssr ? CompilerSSR : vapor ? CompilerVapor : CompilerDOM;
  compiler = compiler || defaultCompiler;
  if (compiler !== defaultCompiler) {
    inAST = void 0;
  }
  if (inAST == null ? void 0 : inAST.transformed) {
    const newAST = (ssr ? CompilerDOM : compiler).parse(inAST.source, __spreadProps$5(__spreadValues$6({
      prefixIdentifiers: true
    }, compilerOptions), {
      parseMode: "sfc",
      onError: (e) => errors.push(e)
    }));
    const template = newAST.children.find(
      (node) => node.type === 1 && node.tag === "template"
    );
    inAST = createRoot(template.children, inAST.source);
  }
  let { code, ast, preamble, map, helpers } = compiler.compile(
    inAST || source,
    __spreadProps$5(__spreadValues$6({
      mode: "module",
      prefixIdentifiers: true,
      hoistStatic: true,
      cacheHandlers: true,
      ssrCssVars: ssr && ssrCssVars && ssrCssVars.length ? genCssVarsFromList(ssrCssVars, shortId, isProd, true) : "",
      scopeId: scoped ? longId : void 0,
      slotted,
      sourceMap: true
    }, compilerOptions), {
      hmr: !isProd,
      nodeTransforms: nodeTransforms.concat(
        compilerOptions.nodeTransforms || []
      ),
      filename,
      onError: (e) => errors.push(e),
      onWarn: (w) => warnings.push(w)
    })
  );
  if (inMap && !inAST) {
    if (map) {
      map = mapLines(inMap, map);
    }
    if (errors.length) {
      patchErrors(errors, source, inMap);
    }
  }
  const tips = warnings.map((w) => {
    let msg = w.message;
    if (w.loc) {
      msg += `
${generateCodeFrame(
        (inAST == null ? void 0 : inAST.source) || source,
        w.loc.start.offset,
        w.loc.end.offset
      )}`;
    }
    return msg;
  });
  return {
    code,
    ast,
    preamble,
    source,
    errors,
    tips,
    map,
    helpers
  };
}
function mapLines(oldMap, newMap) {
  if (!oldMap) return newMap;
  if (!newMap) return oldMap;
  const oldMapConsumer = new sourceMapExports.SourceMapConsumer(oldMap);
  const newMapConsumer = new sourceMapExports.SourceMapConsumer(newMap);
  const mergedMapGenerator = new sourceMapExports.SourceMapGenerator();
  newMapConsumer.eachMapping((m) => {
    if (m.originalLine == null) {
      return;
    }
    const origPosInOldMap = oldMapConsumer.originalPositionFor({
      line: m.originalLine,
      column: m.originalColumn
    });
    if (origPosInOldMap.source == null) {
      return;
    }
    mergedMapGenerator.addMapping({
      generated: {
        line: m.generatedLine,
        column: m.generatedColumn
      },
      original: {
        line: origPosInOldMap.line,
        // map line
        // use current column, since the oldMap produced by @vue/compiler-sfc
        // does not
        column: m.originalColumn
      },
      source: origPosInOldMap.source,
      name: origPosInOldMap.name
    });
  });
  const generator = mergedMapGenerator;
  oldMapConsumer.sources.forEach((sourceFile) => {
    generator._sources.add(sourceFile);
    const sourceContent = oldMapConsumer.sourceContentFor(sourceFile);
    if (sourceContent != null) {
      mergedMapGenerator.setSourceContent(sourceFile, sourceContent);
    }
  });
  generator._sourceRoot = oldMap.sourceRoot;
  generator._file = oldMap.file;
  return generator.toJSON();
}
function patchErrors(errors, source, inMap) {
  const originalSource = inMap.sourcesContent[0];
  const offset = originalSource.indexOf(source);
  const lineOffset = originalSource.slice(0, offset).split(/\r?\n/).length - 1;
  errors.forEach((err) => {
    if (err.loc) {
      err.loc.start.line += lineOffset;
      err.loc.start.offset += offset;
      if (err.loc.end !== err.loc.start) {
        err.loc.end.line += lineOffset;
        err.loc.end.offset += offset;
      }
    }
  });
}

var picocolors = {exports: {}};

var hasRequiredPicocolors;

function requirePicocolors () {
	if (hasRequiredPicocolors) return picocolors.exports;
	hasRequiredPicocolors = 1;
	let p = browser$1 || {}, argv = p.argv || [], env = p.env || {};
	let isColorSupported =
		!(!!env.NO_COLOR || argv.includes("--no-color")) &&
		(!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || ((p.stdout || {}).isTTY && env.TERM !== "dumb") || !!env.CI);

	let formatter = (open, close, replace = open) =>
		input => {
			let string = "" + input, index = string.indexOf(close, open.length);
			return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close
		};

	let replaceClose = (string, close, replace, index) => {
		let result = "", cursor = 0;
		do {
			result += string.substring(cursor, index) + replace;
			cursor = index + close.length;
			index = string.indexOf(close, cursor);
		} while (~index)
		return result + string.substring(cursor)
	};

	let createColors = (enabled = isColorSupported) => {
		let f = enabled ? formatter : () => String;
		return {
			isColorSupported: enabled,
			reset: f("\x1b[0m", "\x1b[0m"),
			bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
			dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
			italic: f("\x1b[3m", "\x1b[23m"),
			underline: f("\x1b[4m", "\x1b[24m"),
			inverse: f("\x1b[7m", "\x1b[27m"),
			hidden: f("\x1b[8m", "\x1b[28m"),
			strikethrough: f("\x1b[9m", "\x1b[29m"),

			black: f("\x1b[30m", "\x1b[39m"),
			red: f("\x1b[31m", "\x1b[39m"),
			green: f("\x1b[32m", "\x1b[39m"),
			yellow: f("\x1b[33m", "\x1b[39m"),
			blue: f("\x1b[34m", "\x1b[39m"),
			magenta: f("\x1b[35m", "\x1b[39m"),
			cyan: f("\x1b[36m", "\x1b[39m"),
			white: f("\x1b[37m", "\x1b[39m"),
			gray: f("\x1b[90m", "\x1b[39m"),

			bgBlack: f("\x1b[40m", "\x1b[49m"),
			bgRed: f("\x1b[41m", "\x1b[49m"),
			bgGreen: f("\x1b[42m", "\x1b[49m"),
			bgYellow: f("\x1b[43m", "\x1b[49m"),
			bgBlue: f("\x1b[44m", "\x1b[49m"),
			bgMagenta: f("\x1b[45m", "\x1b[49m"),
			bgCyan: f("\x1b[46m", "\x1b[49m"),
			bgWhite: f("\x1b[47m", "\x1b[49m"),

			blackBright: f("\x1b[90m", "\x1b[39m"),
			redBright: f("\x1b[91m", "\x1b[39m"),
			greenBright: f("\x1b[92m", "\x1b[39m"),
			yellowBright: f("\x1b[93m", "\x1b[39m"),
			blueBright: f("\x1b[94m", "\x1b[39m"),
			magentaBright: f("\x1b[95m", "\x1b[39m"),
			cyanBright: f("\x1b[96m", "\x1b[39m"),
			whiteBright: f("\x1b[97m", "\x1b[39m"),

			bgBlackBright: f("\x1b[100m", "\x1b[49m"),
			bgRedBright: f("\x1b[101m", "\x1b[49m"),
			bgGreenBright: f("\x1b[102m", "\x1b[49m"),
			bgYellowBright: f("\x1b[103m", "\x1b[49m"),
			bgBlueBright: f("\x1b[104m", "\x1b[49m"),
			bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
			bgCyanBright: f("\x1b[106m", "\x1b[49m"),
			bgWhiteBright: f("\x1b[107m", "\x1b[49m"),
		}
	};

	picocolors.exports = createColors();
	picocolors.exports.createColors = createColors;
	return picocolors.exports;
}

var tokenize$1;
var hasRequiredTokenize$1;

function requireTokenize$1 () {
	if (hasRequiredTokenize$1) return tokenize$1;
	hasRequiredTokenize$1 = 1;

	const SINGLE_QUOTE = "'".charCodeAt(0);
	const DOUBLE_QUOTE = '"'.charCodeAt(0);
	const BACKSLASH = '\\'.charCodeAt(0);
	const SLASH = '/'.charCodeAt(0);
	const NEWLINE = '\n'.charCodeAt(0);
	const SPACE = ' '.charCodeAt(0);
	const FEED = '\f'.charCodeAt(0);
	const TAB = '\t'.charCodeAt(0);
	const CR = '\r'.charCodeAt(0);
	const OPEN_SQUARE = '['.charCodeAt(0);
	const CLOSE_SQUARE = ']'.charCodeAt(0);
	const OPEN_PARENTHESES = '('.charCodeAt(0);
	const CLOSE_PARENTHESES = ')'.charCodeAt(0);
	const OPEN_CURLY = '{'.charCodeAt(0);
	const CLOSE_CURLY = '}'.charCodeAt(0);
	const SEMICOLON = ';'.charCodeAt(0);
	const ASTERISK = '*'.charCodeAt(0);
	const COLON = ':'.charCodeAt(0);
	const AT = '@'.charCodeAt(0);

	const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
	const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
	const RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
	const RE_HEX_ESCAPE = /[\da-f]/i;

	tokenize$1 = function tokenizer(input, options = {}) {
	  let css = input.css.valueOf();
	  let ignore = options.ignoreErrors;

	  let code, content, escape, next, quote;
	  let currentToken, escaped, escapePos, n, prev;

	  let length = css.length;
	  let pos = 0;
	  let buffer = [];
	  let returned = [];

	  function position() {
	    return pos
	  }

	  function unclosed(what) {
	    throw input.error('Unclosed ' + what, pos)
	  }

	  function endOfFile() {
	    return returned.length === 0 && pos >= length
	  }

	  function nextToken(opts) {
	    if (returned.length) return returned.pop()
	    if (pos >= length) return

	    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;

	    code = css.charCodeAt(pos);

	    switch (code) {
	      case NEWLINE:
	      case SPACE:
	      case TAB:
	      case CR:
	      case FEED: {
	        next = pos;
	        do {
	          next += 1;
	          code = css.charCodeAt(next);
	        } while (
	          code === SPACE ||
	          code === NEWLINE ||
	          code === TAB ||
	          code === CR ||
	          code === FEED
	        )

	        currentToken = ['space', css.slice(pos, next)];
	        pos = next - 1;
	        break
	      }

	      case OPEN_SQUARE:
	      case CLOSE_SQUARE:
	      case OPEN_CURLY:
	      case CLOSE_CURLY:
	      case COLON:
	      case SEMICOLON:
	      case CLOSE_PARENTHESES: {
	        let controlChar = String.fromCharCode(code);
	        currentToken = [controlChar, controlChar, pos];
	        break
	      }

	      case OPEN_PARENTHESES: {
	        prev = buffer.length ? buffer.pop()[1] : '';
	        n = css.charCodeAt(pos + 1);
	        if (
	          prev === 'url' &&
	          n !== SINGLE_QUOTE &&
	          n !== DOUBLE_QUOTE &&
	          n !== SPACE &&
	          n !== NEWLINE &&
	          n !== TAB &&
	          n !== FEED &&
	          n !== CR
	        ) {
	          next = pos;
	          do {
	            escaped = false;
	            next = css.indexOf(')', next + 1);
	            if (next === -1) {
	              if (ignore || ignoreUnclosed) {
	                next = pos;
	                break
	              } else {
	                unclosed('bracket');
	              }
	            }
	            escapePos = next;
	            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
	              escapePos -= 1;
	              escaped = !escaped;
	            }
	          } while (escaped)

	          currentToken = ['brackets', css.slice(pos, next + 1), pos, next];

	          pos = next;
	        } else {
	          next = css.indexOf(')', pos + 1);
	          content = css.slice(pos, next + 1);

	          if (next === -1 || RE_BAD_BRACKET.test(content)) {
	            currentToken = ['(', '(', pos];
	          } else {
	            currentToken = ['brackets', content, pos, next];
	            pos = next;
	          }
	        }

	        break
	      }

	      case SINGLE_QUOTE:
	      case DOUBLE_QUOTE: {
	        quote = code === SINGLE_QUOTE ? "'" : '"';
	        next = pos;
	        do {
	          escaped = false;
	          next = css.indexOf(quote, next + 1);
	          if (next === -1) {
	            if (ignore || ignoreUnclosed) {
	              next = pos + 1;
	              break
	            } else {
	              unclosed('string');
	            }
	          }
	          escapePos = next;
	          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
	            escapePos -= 1;
	            escaped = !escaped;
	          }
	        } while (escaped)

	        currentToken = ['string', css.slice(pos, next + 1), pos, next];
	        pos = next;
	        break
	      }

	      case AT: {
	        RE_AT_END.lastIndex = pos + 1;
	        RE_AT_END.test(css);
	        if (RE_AT_END.lastIndex === 0) {
	          next = css.length - 1;
	        } else {
	          next = RE_AT_END.lastIndex - 2;
	        }

	        currentToken = ['at-word', css.slice(pos, next + 1), pos, next];

	        pos = next;
	        break
	      }

	      case BACKSLASH: {
	        next = pos;
	        escape = true;
	        while (css.charCodeAt(next + 1) === BACKSLASH) {
	          next += 1;
	          escape = !escape;
	        }
	        code = css.charCodeAt(next + 1);
	        if (
	          escape &&
	          code !== SLASH &&
	          code !== SPACE &&
	          code !== NEWLINE &&
	          code !== TAB &&
	          code !== CR &&
	          code !== FEED
	        ) {
	          next += 1;
	          if (RE_HEX_ESCAPE.test(css.charAt(next))) {
	            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
	              next += 1;
	            }
	            if (css.charCodeAt(next + 1) === SPACE) {
	              next += 1;
	            }
	          }
	        }

	        currentToken = ['word', css.slice(pos, next + 1), pos, next];

	        pos = next;
	        break
	      }

	      default: {
	        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
	          next = css.indexOf('*/', pos + 2) + 1;
	          if (next === 0) {
	            if (ignore || ignoreUnclosed) {
	              next = css.length;
	            } else {
	              unclosed('comment');
	            }
	          }

	          currentToken = ['comment', css.slice(pos, next + 1), pos, next];
	          pos = next;
	        } else {
	          RE_WORD_END.lastIndex = pos + 1;
	          RE_WORD_END.test(css);
	          if (RE_WORD_END.lastIndex === 0) {
	            next = css.length - 1;
	          } else {
	            next = RE_WORD_END.lastIndex - 2;
	          }

	          currentToken = ['word', css.slice(pos, next + 1), pos, next];
	          buffer.push(currentToken);
	          pos = next;
	        }

	        break
	      }
	    }

	    pos++;
	    return currentToken
	  }

	  function back(token) {
	    returned.push(token);
	  }

	  return {
	    back,
	    endOfFile,
	    nextToken,
	    position
	  }
	};
	return tokenize$1;
}

var terminalHighlight_1;
var hasRequiredTerminalHighlight;

function requireTerminalHighlight () {
	if (hasRequiredTerminalHighlight) return terminalHighlight_1;
	hasRequiredTerminalHighlight = 1;

	let pico = /*@__PURE__*/ requirePicocolors();

	let tokenizer = /*@__PURE__*/ requireTokenize$1();

	let Input;

	function registerInput(dependant) {
	  Input = dependant;
	}

	const HIGHLIGHT_THEME = {
	  ';': pico.yellow,
	  ':': pico.yellow,
	  '(': pico.cyan,
	  ')': pico.cyan,
	  '[': pico.yellow,
	  ']': pico.yellow,
	  '{': pico.yellow,
	  '}': pico.yellow,
	  'at-word': pico.cyan,
	  'brackets': pico.cyan,
	  'call': pico.cyan,
	  'class': pico.yellow,
	  'comment': pico.gray,
	  'hash': pico.magenta,
	  'string': pico.green
	};

	function getTokenType([type, value], processor) {
	  if (type === 'word') {
	    if (value[0] === '.') {
	      return 'class'
	    }
	    if (value[0] === '#') {
	      return 'hash'
	    }
	  }

	  if (!processor.endOfFile()) {
	    let next = processor.nextToken();
	    processor.back(next);
	    if (next[0] === 'brackets' || next[0] === '(') return 'call'
	  }

	  return type
	}

	function terminalHighlight(css) {
	  let processor = tokenizer(new Input(css), { ignoreErrors: true });
	  let result = '';
	  while (!processor.endOfFile()) {
	    let token = processor.nextToken();
	    let color = HIGHLIGHT_THEME[getTokenType(token, processor)];
	    if (color) {
	      result += token[1]
	        .split(/\r?\n/)
	        .map(i => color(i))
	        .join('\n');
	    } else {
	      result += token[1];
	    }
	  }
	  return result
	}

	terminalHighlight.registerInput = registerInput;

	terminalHighlight_1 = terminalHighlight;
	return terminalHighlight_1;
}

var cssSyntaxError;
var hasRequiredCssSyntaxError;

function requireCssSyntaxError () {
	if (hasRequiredCssSyntaxError) return cssSyntaxError;
	hasRequiredCssSyntaxError = 1;

	let pico = /*@__PURE__*/ requirePicocolors();

	let terminalHighlight = /*@__PURE__*/ requireTerminalHighlight();

	class CssSyntaxError extends Error {
	  constructor(message, line, column, source, file, plugin) {
	    super(message);
	    this.name = 'CssSyntaxError';
	    this.reason = message;

	    if (file) {
	      this.file = file;
	    }
	    if (source) {
	      this.source = source;
	    }
	    if (plugin) {
	      this.plugin = plugin;
	    }
	    if (typeof line !== 'undefined' && typeof column !== 'undefined') {
	      if (typeof line === 'number') {
	        this.line = line;
	        this.column = column;
	      } else {
	        this.line = line.line;
	        this.column = line.column;
	        this.endLine = column.line;
	        this.endColumn = column.column;
	      }
	    }

	    this.setMessage();

	    if (Error.captureStackTrace) {
	      Error.captureStackTrace(this, CssSyntaxError);
	    }
	  }

	  setMessage() {
	    this.message = this.plugin ? this.plugin + ': ' : '';
	    this.message += this.file ? this.file : '<css input>';
	    if (typeof this.line !== 'undefined') {
	      this.message += ':' + this.line + ':' + this.column;
	    }
	    this.message += ': ' + this.reason;
	  }

	  showSourceCode(color) {
	    if (!this.source) return ''

	    let css = this.source;
	    if (color == null) color = pico.isColorSupported;

	    let aside = text => text;
	    let mark = text => text;
	    let highlight = text => text;
	    if (color) {
	      let { bold, gray, red } = pico.createColors(true);
	      mark = text => bold(red(text));
	      aside = text => gray(text);
	      if (terminalHighlight) {
	        highlight = text => terminalHighlight(text);
	      }
	    }

	    let lines = css.split(/\r?\n/);
	    let start = Math.max(this.line - 3, 0);
	    let end = Math.min(this.line + 2, lines.length);
	    let maxWidth = String(end).length;

	    return lines
	      .slice(start, end)
	      .map((line, index) => {
	        let number = start + 1 + index;
	        let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';
	        if (number === this.line) {
	          if (line.length > 160) {
	            let padding = 20;
	            let subLineStart = Math.max(0, this.column - padding);
	            let subLineEnd = Math.max(
	              this.column + padding,
	              this.endColumn + padding
	            );
	            let subLine = line.slice(subLineStart, subLineEnd);

	            let spacing =
	              aside(gutter.replace(/\d/g, ' ')) +
	              line
	                .slice(0, Math.min(this.column - 1, padding - 1))
	                .replace(/[^\t]/g, ' ');

	            return (
	              mark('>') +
	              aside(gutter) +
	              highlight(subLine) +
	              '\n ' +
	              spacing +
	              mark('^')
	            )
	          }

	          let spacing =
	            aside(gutter.replace(/\d/g, ' ')) +
	            line.slice(0, this.column - 1).replace(/[^\t]/g, ' ');

	          return (
	            mark('>') +
	            aside(gutter) +
	            highlight(line) +
	            '\n ' +
	            spacing +
	            mark('^')
	          )
	        }

	        return ' ' + aside(gutter) + highlight(line)
	      })
	      .join('\n')
	  }

	  toString() {
	    let code = this.showSourceCode();
	    if (code) {
	      code = '\n\n' + code + '\n';
	    }
	    return this.name + ': ' + this.message + code
	  }
	}

	cssSyntaxError = CssSyntaxError;
	CssSyntaxError.default = CssSyntaxError;
	return cssSyntaxError;
}

var stringifier;
var hasRequiredStringifier;

function requireStringifier () {
	if (hasRequiredStringifier) return stringifier;
	hasRequiredStringifier = 1;

	const DEFAULT_RAW = {
	  after: '\n',
	  beforeClose: '\n',
	  beforeComment: '\n',
	  beforeDecl: '\n',
	  beforeOpen: ' ',
	  beforeRule: '\n',
	  colon: ': ',
	  commentLeft: ' ',
	  commentRight: ' ',
	  emptyBody: '',
	  indent: '    ',
	  semicolon: false
	};

	function capitalize(str) {
	  return str[0].toUpperCase() + str.slice(1)
	}

	class Stringifier {
	  constructor(builder) {
	    this.builder = builder;
	  }

	  atrule(node, semicolon) {
	    let name = '@' + node.name;
	    let params = node.params ? this.rawValue(node, 'params') : '';

	    if (typeof node.raws.afterName !== 'undefined') {
	      name += node.raws.afterName;
	    } else if (params) {
	      name += ' ';
	    }

	    if (node.nodes) {
	      this.block(node, name + params);
	    } else {
	      let end = (node.raws.between || '') + (semicolon ? ';' : '');
	      this.builder(name + params + end, node);
	    }
	  }

	  beforeAfter(node, detect) {
	    let value;
	    if (node.type === 'decl') {
	      value = this.raw(node, null, 'beforeDecl');
	    } else if (node.type === 'comment') {
	      value = this.raw(node, null, 'beforeComment');
	    } else if (detect === 'before') {
	      value = this.raw(node, null, 'beforeRule');
	    } else {
	      value = this.raw(node, null, 'beforeClose');
	    }

	    let buf = node.parent;
	    let depth = 0;
	    while (buf && buf.type !== 'root') {
	      depth += 1;
	      buf = buf.parent;
	    }

	    if (value.includes('\n')) {
	      let indent = this.raw(node, null, 'indent');
	      if (indent.length) {
	        for (let step = 0; step < depth; step++) value += indent;
	      }
	    }

	    return value
	  }

	  block(node, start) {
	    let between = this.raw(node, 'between', 'beforeOpen');
	    this.builder(start + between + '{', node, 'start');

	    let after;
	    if (node.nodes && node.nodes.length) {
	      this.body(node);
	      after = this.raw(node, 'after');
	    } else {
	      after = this.raw(node, 'after', 'emptyBody');
	    }

	    if (after) this.builder(after);
	    this.builder('}', node, 'end');
	  }

	  body(node) {
	    let last = node.nodes.length - 1;
	    while (last > 0) {
	      if (node.nodes[last].type !== 'comment') break
	      last -= 1;
	    }

	    let semicolon = this.raw(node, 'semicolon');
	    for (let i = 0; i < node.nodes.length; i++) {
	      let child = node.nodes[i];
	      let before = this.raw(child, 'before');
	      if (before) this.builder(before);
	      this.stringify(child, last !== i || semicolon);
	    }
	  }

	  comment(node) {
	    let left = this.raw(node, 'left', 'commentLeft');
	    let right = this.raw(node, 'right', 'commentRight');
	    this.builder('/*' + left + node.text + right + '*/', node);
	  }

	  decl(node, semicolon) {
	    let between = this.raw(node, 'between', 'colon');
	    let string = node.prop + between + this.rawValue(node, 'value');

	    if (node.important) {
	      string += node.raws.important || ' !important';
	    }

	    if (semicolon) string += ';';
	    this.builder(string, node);
	  }

	  document(node) {
	    this.body(node);
	  }

	  raw(node, own, detect) {
	    let value;
	    if (!detect) detect = own;

	    // Already had
	    if (own) {
	      value = node.raws[own];
	      if (typeof value !== 'undefined') return value
	    }

	    let parent = node.parent;

	    if (detect === 'before') {
	      // Hack for first rule in CSS
	      if (!parent || (parent.type === 'root' && parent.first === node)) {
	        return ''
	      }

	      // `root` nodes in `document` should use only their own raws
	      if (parent && parent.type === 'document') {
	        return ''
	      }
	    }

	    // Floating child without parent
	    if (!parent) return DEFAULT_RAW[detect]

	    // Detect style by other nodes
	    let root = node.root();
	    if (!root.rawCache) root.rawCache = {};
	    if (typeof root.rawCache[detect] !== 'undefined') {
	      return root.rawCache[detect]
	    }

	    if (detect === 'before' || detect === 'after') {
	      return this.beforeAfter(node, detect)
	    } else {
	      let method = 'raw' + capitalize(detect);
	      if (this[method]) {
	        value = this[method](root, node);
	      } else {
	        root.walk(i => {
	          value = i.raws[own];
	          if (typeof value !== 'undefined') return false
	        });
	      }
	    }

	    if (typeof value === 'undefined') value = DEFAULT_RAW[detect];

	    root.rawCache[detect] = value;
	    return value
	  }

	  rawBeforeClose(root) {
	    let value;
	    root.walk(i => {
	      if (i.nodes && i.nodes.length > 0) {
	        if (typeof i.raws.after !== 'undefined') {
	          value = i.raws.after;
	          if (value.includes('\n')) {
	            value = value.replace(/[^\n]+$/, '');
	          }
	          return false
	        }
	      }
	    });
	    if (value) value = value.replace(/\S/g, '');
	    return value
	  }

	  rawBeforeComment(root, node) {
	    let value;
	    root.walkComments(i => {
	      if (typeof i.raws.before !== 'undefined') {
	        value = i.raws.before;
	        if (value.includes('\n')) {
	          value = value.replace(/[^\n]+$/, '');
	        }
	        return false
	      }
	    });
	    if (typeof value === 'undefined') {
	      value = this.raw(node, null, 'beforeDecl');
	    } else if (value) {
	      value = value.replace(/\S/g, '');
	    }
	    return value
	  }

	  rawBeforeDecl(root, node) {
	    let value;
	    root.walkDecls(i => {
	      if (typeof i.raws.before !== 'undefined') {
	        value = i.raws.before;
	        if (value.includes('\n')) {
	          value = value.replace(/[^\n]+$/, '');
	        }
	        return false
	      }
	    });
	    if (typeof value === 'undefined') {
	      value = this.raw(node, null, 'beforeRule');
	    } else if (value) {
	      value = value.replace(/\S/g, '');
	    }
	    return value
	  }

	  rawBeforeOpen(root) {
	    let value;
	    root.walk(i => {
	      if (i.type !== 'decl') {
	        value = i.raws.between;
	        if (typeof value !== 'undefined') return false
	      }
	    });
	    return value
	  }

	  rawBeforeRule(root) {
	    let value;
	    root.walk(i => {
	      if (i.nodes && (i.parent !== root || root.first !== i)) {
	        if (typeof i.raws.before !== 'undefined') {
	          value = i.raws.before;
	          if (value.includes('\n')) {
	            value = value.replace(/[^\n]+$/, '');
	          }
	          return false
	        }
	      }
	    });
	    if (value) value = value.replace(/\S/g, '');
	    return value
	  }

	  rawColon(root) {
	    let value;
	    root.walkDecls(i => {
	      if (typeof i.raws.between !== 'undefined') {
	        value = i.raws.between.replace(/[^\s:]/g, '');
	        return false
	      }
	    });
	    return value
	  }

	  rawEmptyBody(root) {
	    let value;
	    root.walk(i => {
	      if (i.nodes && i.nodes.length === 0) {
	        value = i.raws.after;
	        if (typeof value !== 'undefined') return false
	      }
	    });
	    return value
	  }

	  rawIndent(root) {
	    if (root.raws.indent) return root.raws.indent
	    let value;
	    root.walk(i => {
	      let p = i.parent;
	      if (p && p !== root && p.parent && p.parent === root) {
	        if (typeof i.raws.before !== 'undefined') {
	          let parts = i.raws.before.split('\n');
	          value = parts[parts.length - 1];
	          value = value.replace(/\S/g, '');
	          return false
	        }
	      }
	    });
	    return value
	  }

	  rawSemicolon(root) {
	    let value;
	    root.walk(i => {
	      if (i.nodes && i.nodes.length && i.last.type === 'decl') {
	        value = i.raws.semicolon;
	        if (typeof value !== 'undefined') return false
	      }
	    });
	    return value
	  }

	  rawValue(node, prop) {
	    let value = node[prop];
	    let raw = node.raws[prop];
	    if (raw && raw.value === value) {
	      return raw.raw
	    }

	    return value
	  }

	  root(node) {
	    this.body(node);
	    if (node.raws.after) this.builder(node.raws.after);
	  }

	  rule(node) {
	    this.block(node, this.rawValue(node, 'selector'));
	    if (node.raws.ownSemicolon) {
	      this.builder(node.raws.ownSemicolon, node, 'end');
	    }
	  }

	  stringify(node, semicolon) {
	    /* c8 ignore start */
	    if (!this[node.type]) {
	      throw new Error(
	        'Unknown AST node type ' +
	          node.type +
	          '. ' +
	          'Maybe you need to change PostCSS stringifier.'
	      )
	    }
	    /* c8 ignore stop */
	    this[node.type](node, semicolon);
	  }
	}

	stringifier = Stringifier;
	Stringifier.default = Stringifier;
	return stringifier;
}

var stringify_1;
var hasRequiredStringify;

function requireStringify () {
	if (hasRequiredStringify) return stringify_1;
	hasRequiredStringify = 1;

	let Stringifier = /*@__PURE__*/ requireStringifier();

	function stringify(node, builder) {
	  let str = new Stringifier(builder);
	  str.stringify(node);
	}

	stringify_1 = stringify;
	stringify.default = stringify;
	return stringify_1;
}

var symbols = {};

var hasRequiredSymbols;

function requireSymbols () {
	if (hasRequiredSymbols) return symbols;
	hasRequiredSymbols = 1;

	symbols.isClean = Symbol('isClean');

	symbols.my = Symbol('my');
	return symbols;
}

var node$2;
var hasRequiredNode$2;

function requireNode$2 () {
	if (hasRequiredNode$2) return node$2;
	hasRequiredNode$2 = 1;

	let CssSyntaxError = /*@__PURE__*/ requireCssSyntaxError();
	let Stringifier = /*@__PURE__*/ requireStringifier();
	let stringify = /*@__PURE__*/ requireStringify();
	let { isClean, my } = /*@__PURE__*/ requireSymbols();

	function cloneNode(obj, parent) {
	  let cloned = new obj.constructor();

	  for (let i in obj) {
	    if (!Object.prototype.hasOwnProperty.call(obj, i)) {
	      /* c8 ignore next 2 */
	      continue
	    }
	    if (i === 'proxyCache') continue
	    let value = obj[i];
	    let type = typeof value;

	    if (i === 'parent' && type === 'object') {
	      if (parent) cloned[i] = parent;
	    } else if (i === 'source') {
	      cloned[i] = value;
	    } else if (Array.isArray(value)) {
	      cloned[i] = value.map(j => cloneNode(j, cloned));
	    } else {
	      if (type === 'object' && value !== null) value = cloneNode(value);
	      cloned[i] = value;
	    }
	  }

	  return cloned
	}

	function sourceOffset(inputCSS, position) {
	  // Not all custom syntaxes support `offset` in `source.start` and `source.end`
	  if (position && typeof position.offset !== 'undefined') {
	    return position.offset
	  }

	  let column = 1;
	  let line = 1;
	  let offset = 0;

	  for (let i = 0; i < inputCSS.length; i++) {
	    if (line === position.line && column === position.column) {
	      offset = i;
	      break
	    }

	    if (inputCSS[i] === '\n') {
	      column = 1;
	      line += 1;
	    } else {
	      column += 1;
	    }
	  }

	  return offset
	}

	class Node {
	  get proxyOf() {
	    return this
	  }

	  constructor(defaults = {}) {
	    this.raws = {};
	    this[isClean] = false;
	    this[my] = true;

	    for (let name in defaults) {
	      if (name === 'nodes') {
	        this.nodes = [];
	        for (let node of defaults[name]) {
	          if (typeof node.clone === 'function') {
	            this.append(node.clone());
	          } else {
	            this.append(node);
	          }
	        }
	      } else {
	        this[name] = defaults[name];
	      }
	    }
	  }

	  addToError(error) {
	    error.postcssNode = this;
	    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
	      let s = this.source;
	      error.stack = error.stack.replace(
	        /\n\s{4}at /,
	        `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
	      );
	    }
	    return error
	  }

	  after(add) {
	    this.parent.insertAfter(this, add);
	    return this
	  }

	  assign(overrides = {}) {
	    for (let name in overrides) {
	      this[name] = overrides[name];
	    }
	    return this
	  }

	  before(add) {
	    this.parent.insertBefore(this, add);
	    return this
	  }

	  cleanRaws(keepBetween) {
	    delete this.raws.before;
	    delete this.raws.after;
	    if (!keepBetween) delete this.raws.between;
	  }

	  clone(overrides = {}) {
	    let cloned = cloneNode(this);
	    for (let name in overrides) {
	      cloned[name] = overrides[name];
	    }
	    return cloned
	  }

	  cloneAfter(overrides = {}) {
	    let cloned = this.clone(overrides);
	    this.parent.insertAfter(this, cloned);
	    return cloned
	  }

	  cloneBefore(overrides = {}) {
	    let cloned = this.clone(overrides);
	    this.parent.insertBefore(this, cloned);
	    return cloned
	  }

	  error(message, opts = {}) {
	    if (this.source) {
	      let { end, start } = this.rangeBy(opts);
	      return this.source.input.error(
	        message,
	        { column: start.column, line: start.line },
	        { column: end.column, line: end.line },
	        opts
	      )
	    }
	    return new CssSyntaxError(message)
	  }

	  getProxyProcessor() {
	    return {
	      get(node, prop) {
	        if (prop === 'proxyOf') {
	          return node
	        } else if (prop === 'root') {
	          return () => node.root().toProxy()
	        } else {
	          return node[prop]
	        }
	      },

	      set(node, prop, value) {
	        if (node[prop] === value) return true
	        node[prop] = value;
	        if (
	          prop === 'prop' ||
	          prop === 'value' ||
	          prop === 'name' ||
	          prop === 'params' ||
	          prop === 'important' ||
	          /* c8 ignore next */
	          prop === 'text'
	        ) {
	          node.markDirty();
	        }
	        return true
	      }
	    }
	  }

	  /* c8 ignore next 3 */
	  markClean() {
	    this[isClean] = true;
	  }

	  markDirty() {
	    if (this[isClean]) {
	      this[isClean] = false;
	      let next = this;
	      while ((next = next.parent)) {
	        next[isClean] = false;
	      }
	    }
	  }

	  next() {
	    if (!this.parent) return undefined
	    let index = this.parent.index(this);
	    return this.parent.nodes[index + 1]
	  }

	  positionBy(opts = {}) {
	    let pos = this.source.start;
	    if (opts.index) {
	      pos = this.positionInside(opts.index);
	    } else if (opts.word) {
	      let inputString =
	        'document' in this.source.input
	          ? this.source.input.document
	          : this.source.input.css;
	      let stringRepresentation = inputString.slice(
	        sourceOffset(inputString, this.source.start),
	        sourceOffset(inputString, this.source.end)
	      );
	      let index = stringRepresentation.indexOf(opts.word);
	      if (index !== -1) pos = this.positionInside(index);
	    }
	    return pos
	  }

	  positionInside(index) {
	    let column = this.source.start.column;
	    let line = this.source.start.line;
	    let inputString =
	      'document' in this.source.input
	        ? this.source.input.document
	        : this.source.input.css;
	    let offset = sourceOffset(inputString, this.source.start);
	    let end = offset + index;

	    for (let i = offset; i < end; i++) {
	      if (inputString[i] === '\n') {
	        column = 1;
	        line += 1;
	      } else {
	        column += 1;
	      }
	    }

	    return { column, line, offset: end }
	  }

	  prev() {
	    if (!this.parent) return undefined
	    let index = this.parent.index(this);
	    return this.parent.nodes[index - 1]
	  }

	  rangeBy(opts = {}) {
	    let inputString =
	      'document' in this.source.input
	        ? this.source.input.document
	        : this.source.input.css;
	    let start = {
	      column: this.source.start.column,
	      line: this.source.start.line,
	      offset: sourceOffset(inputString, this.source.start)
	    };
	    let end = this.source.end
	      ? {
	          column: this.source.end.column + 1,
	          line: this.source.end.line,
	          offset:
	            typeof this.source.end.offset === 'number'
	              ? // `source.end.offset` is exclusive, so we don't need to add 1
	                this.source.end.offset
	              : // Since line/column in this.source.end is inclusive,
	                // the `sourceOffset(... , this.source.end)` returns an inclusive offset.
	                // So, we add 1 to convert it to exclusive.
	                sourceOffset(inputString, this.source.end) + 1
	        }
	      : {
	          column: start.column + 1,
	          line: start.line,
	          offset: start.offset + 1
	        };

	    if (opts.word) {
	      let stringRepresentation = inputString.slice(
	        sourceOffset(inputString, this.source.start),
	        sourceOffset(inputString, this.source.end)
	      );
	      let index = stringRepresentation.indexOf(opts.word);
	      if (index !== -1) {
	        start = this.positionInside(index);
	        end = this.positionInside(index + opts.word.length);
	      }
	    } else {
	      if (opts.start) {
	        start = {
	          column: opts.start.column,
	          line: opts.start.line,
	          offset: sourceOffset(inputString, opts.start)
	        };
	      } else if (opts.index) {
	        start = this.positionInside(opts.index);
	      }

	      if (opts.end) {
	        end = {
	          column: opts.end.column,
	          line: opts.end.line,
	          offset: sourceOffset(inputString, opts.end)
	        };
	      } else if (typeof opts.endIndex === 'number') {
	        end = this.positionInside(opts.endIndex);
	      } else if (opts.index) {
	        end = this.positionInside(opts.index + 1);
	      }
	    }

	    if (
	      end.line < start.line ||
	      (end.line === start.line && end.column <= start.column)
	    ) {
	      end = {
	        column: start.column + 1,
	        line: start.line,
	        offset: start.offset + 1
	      };
	    }

	    return { end, start }
	  }

	  raw(prop, defaultType) {
	    let str = new Stringifier();
	    return str.raw(this, prop, defaultType)
	  }

	  remove() {
	    if (this.parent) {
	      this.parent.removeChild(this);
	    }
	    this.parent = undefined;
	    return this
	  }

	  replaceWith(...nodes) {
	    if (this.parent) {
	      let bookmark = this;
	      let foundSelf = false;
	      for (let node of nodes) {
	        if (node === this) {
	          foundSelf = true;
	        } else if (foundSelf) {
	          this.parent.insertAfter(bookmark, node);
	          bookmark = node;
	        } else {
	          this.parent.insertBefore(bookmark, node);
	        }
	      }

	      if (!foundSelf) {
	        this.remove();
	      }
	    }

	    return this
	  }

	  root() {
	    let result = this;
	    while (result.parent && result.parent.type !== 'document') {
	      result = result.parent;
	    }
	    return result
	  }

	  toJSON(_, inputs) {
	    let fixed = {};
	    let emitInputs = inputs == null;
	    inputs = inputs || new Map();
	    let inputsNextIndex = 0;

	    for (let name in this) {
	      if (!Object.prototype.hasOwnProperty.call(this, name)) {
	        /* c8 ignore next 2 */
	        continue
	      }
	      if (name === 'parent' || name === 'proxyCache') continue
	      let value = this[name];

	      if (Array.isArray(value)) {
	        fixed[name] = value.map(i => {
	          if (typeof i === 'object' && i.toJSON) {
	            return i.toJSON(null, inputs)
	          } else {
	            return i
	          }
	        });
	      } else if (typeof value === 'object' && value.toJSON) {
	        fixed[name] = value.toJSON(null, inputs);
	      } else if (name === 'source') {
	        if (value == null) continue
	        let inputId = inputs.get(value.input);
	        if (inputId == null) {
	          inputId = inputsNextIndex;
	          inputs.set(value.input, inputsNextIndex);
	          inputsNextIndex++;
	        }
	        fixed[name] = {
	          end: value.end,
	          inputId,
	          start: value.start
	        };
	      } else {
	        fixed[name] = value;
	      }
	    }

	    if (emitInputs) {
	      fixed.inputs = [...inputs.keys()].map(input => input.toJSON());
	    }

	    return fixed
	  }

	  toProxy() {
	    if (!this.proxyCache) {
	      this.proxyCache = new Proxy(this, this.getProxyProcessor());
	    }
	    return this.proxyCache
	  }

	  toString(stringifier = stringify) {
	    if (stringifier.stringify) stringifier = stringifier.stringify;
	    let result = '';
	    stringifier(this, i => {
	      result += i;
	    });
	    return result
	  }

	  warn(result, text, opts = {}) {
	    let data = { node: this };
	    for (let i in opts) data[i] = opts[i];
	    return result.warn(text, data)
	  }
	}

	node$2 = Node;
	Node.default = Node;
	return node$2;
}

var comment$1;
var hasRequiredComment$1;

function requireComment$1 () {
	if (hasRequiredComment$1) return comment$1;
	hasRequiredComment$1 = 1;

	let Node = /*@__PURE__*/ requireNode$2();

	class Comment extends Node {
	  constructor(defaults) {
	    super(defaults);
	    this.type = 'comment';
	  }
	}

	comment$1 = Comment;
	Comment.default = Comment;
	return comment$1;
}

var declaration;
var hasRequiredDeclaration;

function requireDeclaration () {
	if (hasRequiredDeclaration) return declaration;
	hasRequiredDeclaration = 1;

	let Node = /*@__PURE__*/ requireNode$2();

	class Declaration extends Node {
	  get variable() {
	    return this.prop.startsWith('--') || this.prop[0] === '$'
	  }

	  constructor(defaults) {
	    if (
	      defaults &&
	      typeof defaults.value !== 'undefined' &&
	      typeof defaults.value !== 'string'
	    ) {
	      defaults = { ...defaults, value: String(defaults.value) };
	    }
	    super(defaults);
	    this.type = 'decl';
	  }
	}

	declaration = Declaration;
	Declaration.default = Declaration;
	return declaration;
}

var container$1;
var hasRequiredContainer$1;

function requireContainer$1 () {
	if (hasRequiredContainer$1) return container$1;
	hasRequiredContainer$1 = 1;

	let Comment = /*@__PURE__*/ requireComment$1();
	let Declaration = /*@__PURE__*/ requireDeclaration();
	let Node = /*@__PURE__*/ requireNode$2();
	let { isClean, my } = /*@__PURE__*/ requireSymbols();

	let AtRule, parse, Root, Rule;

	function cleanSource(nodes) {
	  return nodes.map(i => {
	    if (i.nodes) i.nodes = cleanSource(i.nodes);
	    delete i.source;
	    return i
	  })
	}

	function markTreeDirty(node) {
	  node[isClean] = false;
	  if (node.proxyOf.nodes) {
	    for (let i of node.proxyOf.nodes) {
	      markTreeDirty(i);
	    }
	  }
	}

	class Container extends Node {
	  get first() {
	    if (!this.proxyOf.nodes) return undefined
	    return this.proxyOf.nodes[0]
	  }

	  get last() {
	    if (!this.proxyOf.nodes) return undefined
	    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]
	  }

	  append(...children) {
	    for (let child of children) {
	      let nodes = this.normalize(child, this.last);
	      for (let node of nodes) this.proxyOf.nodes.push(node);
	    }

	    this.markDirty();

	    return this
	  }

	  cleanRaws(keepBetween) {
	    super.cleanRaws(keepBetween);
	    if (this.nodes) {
	      for (let node of this.nodes) node.cleanRaws(keepBetween);
	    }
	  }

	  each(callback) {
	    if (!this.proxyOf.nodes) return undefined
	    let iterator = this.getIterator();

	    let index, result;
	    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
	      index = this.indexes[iterator];
	      result = callback(this.proxyOf.nodes[index], index);
	      if (result === false) break

	      this.indexes[iterator] += 1;
	    }

	    delete this.indexes[iterator];
	    return result
	  }

	  every(condition) {
	    return this.nodes.every(condition)
	  }

	  getIterator() {
	    if (!this.lastEach) this.lastEach = 0;
	    if (!this.indexes) this.indexes = {};

	    this.lastEach += 1;
	    let iterator = this.lastEach;
	    this.indexes[iterator] = 0;

	    return iterator
	  }

	  getProxyProcessor() {
	    return {
	      get(node, prop) {
	        if (prop === 'proxyOf') {
	          return node
	        } else if (!node[prop]) {
	          return node[prop]
	        } else if (
	          prop === 'each' ||
	          (typeof prop === 'string' && prop.startsWith('walk'))
	        ) {
	          return (...args) => {
	            return node[prop](
	              ...args.map(i => {
	                if (typeof i === 'function') {
	                  return (child, index) => i(child.toProxy(), index)
	                } else {
	                  return i
	                }
	              })
	            )
	          }
	        } else if (prop === 'every' || prop === 'some') {
	          return cb => {
	            return node[prop]((child, ...other) =>
	              cb(child.toProxy(), ...other)
	            )
	          }
	        } else if (prop === 'root') {
	          return () => node.root().toProxy()
	        } else if (prop === 'nodes') {
	          return node.nodes.map(i => i.toProxy())
	        } else if (prop === 'first' || prop === 'last') {
	          return node[prop].toProxy()
	        } else {
	          return node[prop]
	        }
	      },

	      set(node, prop, value) {
	        if (node[prop] === value) return true
	        node[prop] = value;
	        if (prop === 'name' || prop === 'params' || prop === 'selector') {
	          node.markDirty();
	        }
	        return true
	      }
	    }
	  }

	  index(child) {
	    if (typeof child === 'number') return child
	    if (child.proxyOf) child = child.proxyOf;
	    return this.proxyOf.nodes.indexOf(child)
	  }

	  insertAfter(exist, add) {
	    let existIndex = this.index(exist);
	    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
	    existIndex = this.index(exist);
	    for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node);

	    let index;
	    for (let id in this.indexes) {
	      index = this.indexes[id];
	      if (existIndex < index) {
	        this.indexes[id] = index + nodes.length;
	      }
	    }

	    this.markDirty();

	    return this
	  }

	  insertBefore(exist, add) {
	    let existIndex = this.index(exist);
	    let type = existIndex === 0 ? 'prepend' : false;
	    let nodes = this.normalize(
	      add,
	      this.proxyOf.nodes[existIndex],
	      type
	    ).reverse();
	    existIndex = this.index(exist);
	    for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node);

	    let index;
	    for (let id in this.indexes) {
	      index = this.indexes[id];
	      if (existIndex <= index) {
	        this.indexes[id] = index + nodes.length;
	      }
	    }

	    this.markDirty();

	    return this
	  }

	  normalize(nodes, sample) {
	    if (typeof nodes === 'string') {
	      nodes = cleanSource(parse(nodes).nodes);
	    } else if (typeof nodes === 'undefined') {
	      nodes = [];
	    } else if (Array.isArray(nodes)) {
	      nodes = nodes.slice(0);
	      for (let i of nodes) {
	        if (i.parent) i.parent.removeChild(i, 'ignore');
	      }
	    } else if (nodes.type === 'root' && this.type !== 'document') {
	      nodes = nodes.nodes.slice(0);
	      for (let i of nodes) {
	        if (i.parent) i.parent.removeChild(i, 'ignore');
	      }
	    } else if (nodes.type) {
	      nodes = [nodes];
	    } else if (nodes.prop) {
	      if (typeof nodes.value === 'undefined') {
	        throw new Error('Value field is missed in node creation')
	      } else if (typeof nodes.value !== 'string') {
	        nodes.value = String(nodes.value);
	      }
	      nodes = [new Declaration(nodes)];
	    } else if (nodes.selector || nodes.selectors) {
	      nodes = [new Rule(nodes)];
	    } else if (nodes.name) {
	      nodes = [new AtRule(nodes)];
	    } else if (nodes.text) {
	      nodes = [new Comment(nodes)];
	    } else {
	      throw new Error('Unknown node type in node creation')
	    }

	    let processed = nodes.map(i => {
	      /* c8 ignore next */
	      if (!i[my]) Container.rebuild(i);
	      i = i.proxyOf;
	      if (i.parent) i.parent.removeChild(i);
	      if (i[isClean]) markTreeDirty(i);

	      if (!i.raws) i.raws = {};
	      if (typeof i.raws.before === 'undefined') {
	        if (sample && typeof sample.raws.before !== 'undefined') {
	          i.raws.before = sample.raws.before.replace(/\S/g, '');
	        }
	      }
	      i.parent = this.proxyOf;
	      return i
	    });

	    return processed
	  }

	  prepend(...children) {
	    children = children.reverse();
	    for (let child of children) {
	      let nodes = this.normalize(child, this.first, 'prepend').reverse();
	      for (let node of nodes) this.proxyOf.nodes.unshift(node);
	      for (let id in this.indexes) {
	        this.indexes[id] = this.indexes[id] + nodes.length;
	      }
	    }

	    this.markDirty();

	    return this
	  }

	  push(child) {
	    child.parent = this;
	    this.proxyOf.nodes.push(child);
	    return this
	  }

	  removeAll() {
	    for (let node of this.proxyOf.nodes) node.parent = undefined;
	    this.proxyOf.nodes = [];

	    this.markDirty();

	    return this
	  }

	  removeChild(child) {
	    child = this.index(child);
	    this.proxyOf.nodes[child].parent = undefined;
	    this.proxyOf.nodes.splice(child, 1);

	    let index;
	    for (let id in this.indexes) {
	      index = this.indexes[id];
	      if (index >= child) {
	        this.indexes[id] = index - 1;
	      }
	    }

	    this.markDirty();

	    return this
	  }

	  replaceValues(pattern, opts, callback) {
	    if (!callback) {
	      callback = opts;
	      opts = {};
	    }

	    this.walkDecls(decl => {
	      if (opts.props && !opts.props.includes(decl.prop)) return
	      if (opts.fast && !decl.value.includes(opts.fast)) return

	      decl.value = decl.value.replace(pattern, callback);
	    });

	    this.markDirty();

	    return this
	  }

	  some(condition) {
	    return this.nodes.some(condition)
	  }

	  walk(callback) {
	    return this.each((child, i) => {
	      let result;
	      try {
	        result = callback(child, i);
	      } catch (e) {
	        throw child.addToError(e)
	      }
	      if (result !== false && child.walk) {
	        result = child.walk(callback);
	      }

	      return result
	    })
	  }

	  walkAtRules(name, callback) {
	    if (!callback) {
	      callback = name;
	      return this.walk((child, i) => {
	        if (child.type === 'atrule') {
	          return callback(child, i)
	        }
	      })
	    }
	    if (name instanceof RegExp) {
	      return this.walk((child, i) => {
	        if (child.type === 'atrule' && name.test(child.name)) {
	          return callback(child, i)
	        }
	      })
	    }
	    return this.walk((child, i) => {
	      if (child.type === 'atrule' && child.name === name) {
	        return callback(child, i)
	      }
	    })
	  }

	  walkComments(callback) {
	    return this.walk((child, i) => {
	      if (child.type === 'comment') {
	        return callback(child, i)
	      }
	    })
	  }

	  walkDecls(prop, callback) {
	    if (!callback) {
	      callback = prop;
	      return this.walk((child, i) => {
	        if (child.type === 'decl') {
	          return callback(child, i)
	        }
	      })
	    }
	    if (prop instanceof RegExp) {
	      return this.walk((child, i) => {
	        if (child.type === 'decl' && prop.test(child.prop)) {
	          return callback(child, i)
	        }
	      })
	    }
	    return this.walk((child, i) => {
	      if (child.type === 'decl' && child.prop === prop) {
	        return callback(child, i)
	      }
	    })
	  }

	  walkRules(selector, callback) {
	    if (!callback) {
	      callback = selector;

	      return this.walk((child, i) => {
	        if (child.type === 'rule') {
	          return callback(child, i)
	        }
	      })
	    }
	    if (selector instanceof RegExp) {
	      return this.walk((child, i) => {
	        if (child.type === 'rule' && selector.test(child.selector)) {
	          return callback(child, i)
	        }
	      })
	    }
	    return this.walk((child, i) => {
	      if (child.type === 'rule' && child.selector === selector) {
	        return callback(child, i)
	      }
	    })
	  }
	}

	Container.registerParse = dependant => {
	  parse = dependant;
	};

	Container.registerRule = dependant => {
	  Rule = dependant;
	};

	Container.registerAtRule = dependant => {
	  AtRule = dependant;
	};

	Container.registerRoot = dependant => {
	  Root = dependant;
	};

	container$1 = Container;
	Container.default = Container;

	/* c8 ignore start */
	Container.rebuild = node => {
	  if (node.type === 'atrule') {
	    Object.setPrototypeOf(node, AtRule.prototype);
	  } else if (node.type === 'rule') {
	    Object.setPrototypeOf(node, Rule.prototype);
	  } else if (node.type === 'decl') {
	    Object.setPrototypeOf(node, Declaration.prototype);
	  } else if (node.type === 'comment') {
	    Object.setPrototypeOf(node, Comment.prototype);
	  } else if (node.type === 'root') {
	    Object.setPrototypeOf(node, Root.prototype);
	  }

	  node[my] = true;

	  if (node.nodes) {
	    node.nodes.forEach(child => {
	      Container.rebuild(child);
	    });
	  }
	};
	/* c8 ignore stop */
	return container$1;
}

var atRule;
var hasRequiredAtRule;

function requireAtRule () {
	if (hasRequiredAtRule) return atRule;
	hasRequiredAtRule = 1;

	let Container = /*@__PURE__*/ requireContainer$1();

	class AtRule extends Container {
	  constructor(defaults) {
	    super(defaults);
	    this.type = 'atrule';
	  }

	  append(...children) {
	    if (!this.proxyOf.nodes) this.nodes = [];
	    return super.append(...children)
	  }

	  prepend(...children) {
	    if (!this.proxyOf.nodes) this.nodes = [];
	    return super.prepend(...children)
	  }
	}

	atRule = AtRule;
	AtRule.default = AtRule;

	Container.registerAtRule(AtRule);
	return atRule;
}

var document;
var hasRequiredDocument;

function requireDocument () {
	if (hasRequiredDocument) return document;
	hasRequiredDocument = 1;

	let Container = /*@__PURE__*/ requireContainer$1();

	let LazyResult, Processor;

	class Document extends Container {
	  constructor(defaults) {
	    // type needs to be passed to super, otherwise child roots won't be normalized correctly
	    super({ type: 'document', ...defaults });

	    if (!this.nodes) {
	      this.nodes = [];
	    }
	  }

	  toResult(opts = {}) {
	    let lazy = new LazyResult(new Processor(), this, opts);

	    return lazy.stringify()
	  }
	}

	Document.registerLazyResult = dependant => {
	  LazyResult = dependant;
	};

	Document.registerProcessor = dependant => {
	  Processor = dependant;
	};

	document = Document;
	Document.default = Document;
	return document;
}

var nonSecure;
var hasRequiredNonSecure;

function requireNonSecure () {
	if (hasRequiredNonSecure) return nonSecure;
	hasRequiredNonSecure = 1;
	// This alphabet uses `A-Za-z0-9_-` symbols.
	// The order of characters is optimized for better gzip and brotli compression.
	// References to the same file (works both for gzip and brotli):
	// `'use`, `andom`, and `rict'`
	// References to the brotli default dictionary:
	// `-26T`, `1983`, `40px`, `75px`, `bush`, `jack`, `mind`, `very`, and `wolf`
	let urlAlphabet =
	  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';

	let customAlphabet = (alphabet, defaultSize = 21) => {
	  return (size = defaultSize) => {
	    let id = '';
	    // A compact alternative for `for (var i = 0; i < step; i++)`.
	    let i = size | 0;
	    while (i--) {
	      // `| 0` is more compact and faster than `Math.floor()`.
	      id += alphabet[(Math.random() * alphabet.length) | 0];
	    }
	    return id
	  }
	};

	let nanoid = (size = 21) => {
	  let id = '';
	  // A compact alternative for `for (var i = 0; i < step; i++)`.
	  let i = size | 0;
	  while (i--) {
	    // `| 0` is more compact and faster than `Math.floor()`.
	    id += urlAlphabet[(Math.random() * 64) | 0];
	  }
	  return id
	};

	nonSecure = { nanoid, customAlphabet };
	return nonSecure;
}

var require$$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_url$1);

var previousMap;
var hasRequiredPreviousMap;

function requirePreviousMap () {
	if (hasRequiredPreviousMap) return previousMap;
	hasRequiredPreviousMap = 1;

	let { existsSync, readFileSync } = require$$0$1;
	let { dirname, join } = require$$1;
	let { SourceMapConsumer, SourceMapGenerator } = /*@__PURE__*/ requireSourceMap$1();

	function fromBase64(str) {
	  if (Buffer$1) {
	    return Buffer$1.from(str, 'base64').toString()
	  } else {
	    /* c8 ignore next 2 */
	    return window.atob(str)
	  }
	}

	class PreviousMap {
	  constructor(css, opts) {
	    if (opts.map === false) return
	    this.loadAnnotation(css);
	    this.inline = this.startWith(this.annotation, 'data:');

	    let prev = opts.map ? opts.map.prev : undefined;
	    let text = this.loadMap(opts.from, prev);
	    if (!this.mapFile && opts.from) {
	      this.mapFile = opts.from;
	    }
	    if (this.mapFile) this.root = dirname(this.mapFile);
	    if (text) this.text = text;
	  }

	  consumer() {
	    if (!this.consumerCache) {
	      this.consumerCache = new SourceMapConsumer(this.text);
	    }
	    return this.consumerCache
	  }

	  decodeInline(text) {
	    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
	    let baseUri = /^data:application\/json;base64,/;
	    let charsetUri = /^data:application\/json;charset=utf-?8,/;
	    let uri = /^data:application\/json,/;

	    let uriMatch = text.match(charsetUri) || text.match(uri);
	    if (uriMatch) {
	      return decodeURIComponent(text.substr(uriMatch[0].length))
	    }

	    let baseUriMatch = text.match(baseCharsetUri) || text.match(baseUri);
	    if (baseUriMatch) {
	      return fromBase64(text.substr(baseUriMatch[0].length))
	    }

	    let encoding = text.match(/data:application\/json;([^,]+),/)[1];
	    throw new Error('Unsupported source map encoding ' + encoding)
	  }

	  getAnnotationURL(sourceMapString) {
	    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, '').trim()
	  }

	  isMap(map) {
	    if (typeof map !== 'object') return false
	    return (
	      typeof map.mappings === 'string' ||
	      typeof map._mappings === 'string' ||
	      Array.isArray(map.sections)
	    )
	  }

	  loadAnnotation(css) {
	    let comments = css.match(/\/\*\s*# sourceMappingURL=/g);
	    if (!comments) return

	    // sourceMappingURLs from comments, strings, etc.
	    let start = css.lastIndexOf(comments.pop());
	    let end = css.indexOf('*/', start);

	    if (start > -1 && end > -1) {
	      // Locate the last sourceMappingURL to avoid pickin
	      this.annotation = this.getAnnotationURL(css.substring(start, end));
	    }
	  }

	  loadFile(path) {
	    this.root = dirname(path);
	    if (existsSync(path)) {
	      this.mapFile = path;
	      return readFileSync(path, 'utf-8').toString().trim()
	    }
	  }

	  loadMap(file, prev) {
	    if (prev === false) return false

	    if (prev) {
	      if (typeof prev === 'string') {
	        return prev
	      } else if (typeof prev === 'function') {
	        let prevPath = prev(file);
	        if (prevPath) {
	          let map = this.loadFile(prevPath);
	          if (!map) {
	            throw new Error(
	              'Unable to load previous source map: ' + prevPath.toString()
	            )
	          }
	          return map
	        }
	      } else if (prev instanceof SourceMapConsumer) {
	        return SourceMapGenerator.fromSourceMap(prev).toString()
	      } else if (prev instanceof SourceMapGenerator) {
	        return prev.toString()
	      } else if (this.isMap(prev)) {
	        return JSON.stringify(prev)
	      } else {
	        throw new Error(
	          'Unsupported previous source map format: ' + prev.toString()
	        )
	      }
	    } else if (this.inline) {
	      return this.decodeInline(this.annotation)
	    } else if (this.annotation) {
	      let map = this.annotation;
	      if (file) map = join(dirname(file), map);
	      return this.loadFile(map)
	    }
	  }

	  startWith(string, start) {
	    if (!string) return false
	    return string.substr(0, start.length) === start
	  }

	  withContent() {
	    return !!(
	      this.consumer().sourcesContent &&
	      this.consumer().sourcesContent.length > 0
	    )
	  }
	}

	previousMap = PreviousMap;
	PreviousMap.default = PreviousMap;
	return previousMap;
}

var input;
var hasRequiredInput;

function requireInput () {
	if (hasRequiredInput) return input;
	hasRequiredInput = 1;

	let { nanoid } = /*@__PURE__*/ requireNonSecure();
	let { isAbsolute, resolve } = require$$1;
	let { SourceMapConsumer, SourceMapGenerator } = /*@__PURE__*/ requireSourceMap$1();
	let { fileURLToPath, pathToFileURL } = require$$2;

	let CssSyntaxError = /*@__PURE__*/ requireCssSyntaxError();
	let PreviousMap = /*@__PURE__*/ requirePreviousMap();
	let terminalHighlight = /*@__PURE__*/ requireTerminalHighlight();

	let lineToIndexCache = Symbol('lineToIndexCache');

	let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
	let pathAvailable = Boolean(resolve && isAbsolute);

	function getLineToIndex(input) {
	  if (input[lineToIndexCache]) return input[lineToIndexCache]
	  let lines = input.css.split('\n');
	  let lineToIndex = new Array(lines.length);
	  let prevIndex = 0;

	  for (let i = 0, l = lines.length; i < l; i++) {
	    lineToIndex[i] = prevIndex;
	    prevIndex += lines[i].length + 1;
	  }

	  input[lineToIndexCache] = lineToIndex;
	  return lineToIndex
	}

	class Input {
	  get from() {
	    return this.file || this.id
	  }

	  constructor(css, opts = {}) {
	    if (
	      css === null ||
	      typeof css === 'undefined' ||
	      (typeof css === 'object' && !css.toString)
	    ) {
	      throw new Error(`PostCSS received ${css} instead of CSS string`)
	    }

	    this.css = css.toString();

	    if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
	      this.hasBOM = true;
	      this.css = this.css.slice(1);
	    } else {
	      this.hasBOM = false;
	    }

	    this.document = this.css;
	    if (opts.document) this.document = opts.document.toString();

	    if (opts.from) {
	      if (
	        !pathAvailable ||
	        /^\w+:\/\//.test(opts.from) ||
	        isAbsolute(opts.from)
	      ) {
	        this.file = opts.from;
	      } else {
	        this.file = resolve(opts.from);
	      }
	    }

	    if (pathAvailable && sourceMapAvailable) {
	      let map = new PreviousMap(this.css, opts);
	      if (map.text) {
	        this.map = map;
	        let file = map.consumer().file;
	        if (!this.file && file) this.file = this.mapResolve(file);
	      }
	    }

	    if (!this.file) {
	      this.id = '<input css ' + nanoid(6) + '>';
	    }
	    if (this.map) this.map.file = this.from;
	  }

	  error(message, line, column, opts = {}) {
	    let endColumn, endLine, endOffset, offset, result;

	    if (line && typeof line === 'object') {
	      let start = line;
	      let end = column;
	      if (typeof start.offset === 'number') {
	        offset = start.offset;
	        let pos = this.fromOffset(offset);
	        line = pos.line;
	        column = pos.col;
	      } else {
	        line = start.line;
	        column = start.column;
	        offset = this.fromLineAndColumn(line, column);
	      }
	      if (typeof end.offset === 'number') {
	        endOffset = end.offset;
	        let pos = this.fromOffset(endOffset);
	        endLine = pos.line;
	        endColumn = pos.col;
	      } else {
	        endLine = end.line;
	        endColumn = end.column;
	        endOffset = this.fromLineAndColumn(end.line, end.column);
	      }
	    } else if (!column) {
	      offset = line;
	      let pos = this.fromOffset(offset);
	      line = pos.line;
	      column = pos.col;
	    } else {
	      offset = this.fromLineAndColumn(line, column);
	    }

	    let origin = this.origin(line, column, endLine, endColumn);
	    if (origin) {
	      result = new CssSyntaxError(
	        message,
	        origin.endLine === undefined
	          ? origin.line
	          : { column: origin.column, line: origin.line },
	        origin.endLine === undefined
	          ? origin.column
	          : { column: origin.endColumn, line: origin.endLine },
	        origin.source,
	        origin.file,
	        opts.plugin
	      );
	    } else {
	      result = new CssSyntaxError(
	        message,
	        endLine === undefined ? line : { column, line },
	        endLine === undefined ? column : { column: endColumn, line: endLine },
	        this.css,
	        this.file,
	        opts.plugin
	      );
	    }

	    result.input = { column, endColumn, endLine, endOffset, line, offset, source: this.css };
	    if (this.file) {
	      if (pathToFileURL) {
	        result.input.url = pathToFileURL(this.file).toString();
	      }
	      result.input.file = this.file;
	    }

	    return result
	  }

	  fromLineAndColumn(line, column) {
	    let lineToIndex = getLineToIndex(this);
	    let index = lineToIndex[line - 1];
	    return index + column - 1
	  }

	  fromOffset(offset) {
	    let lineToIndex = getLineToIndex(this);
	    let lastLine = lineToIndex[lineToIndex.length - 1];

	    let min = 0;
	    if (offset >= lastLine) {
	      min = lineToIndex.length - 1;
	    } else {
	      let max = lineToIndex.length - 2;
	      let mid;
	      while (min < max) {
	        mid = min + ((max - min) >> 1);
	        if (offset < lineToIndex[mid]) {
	          max = mid - 1;
	        } else if (offset >= lineToIndex[mid + 1]) {
	          min = mid + 1;
	        } else {
	          min = mid;
	          break
	        }
	      }
	    }
	    return {
	      col: offset - lineToIndex[min] + 1,
	      line: min + 1
	    }
	  }

	  mapResolve(file) {
	    if (/^\w+:\/\//.test(file)) {
	      return file
	    }
	    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file)
	  }

	  origin(line, column, endLine, endColumn) {
	    if (!this.map) return false
	    let consumer = this.map.consumer();

	    let from = consumer.originalPositionFor({ column, line });
	    if (!from.source) return false

	    let to;
	    if (typeof endLine === 'number') {
	      to = consumer.originalPositionFor({ column: endColumn, line: endLine });
	    }

	    let fromUrl;

	    if (isAbsolute(from.source)) {
	      fromUrl = pathToFileURL(from.source);
	    } else {
	      fromUrl = new URL(
	        from.source,
	        this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
	      );
	    }

	    let result = {
	      column: from.column,
	      endColumn: to && to.column,
	      endLine: to && to.line,
	      line: from.line,
	      url: fromUrl.toString()
	    };

	    if (fromUrl.protocol === 'file:') {
	      if (fileURLToPath) {
	        result.file = fileURLToPath(fromUrl);
	      } else {
	        /* c8 ignore next 2 */
	        throw new Error(`file: protocol is not available in this PostCSS build`)
	      }
	    }

	    let source = consumer.sourceContentFor(from.source);
	    if (source) result.source = source;

	    return result
	  }

	  toJSON() {
	    let json = {};
	    for (let name of ['hasBOM', 'css', 'file', 'id']) {
	      if (this[name] != null) {
	        json[name] = this[name];
	      }
	    }
	    if (this.map) {
	      json.map = { ...this.map };
	      if (json.map.consumerCache) {
	        json.map.consumerCache = undefined;
	      }
	    }
	    return json
	  }
	}

	input = Input;
	Input.default = Input;

	if (terminalHighlight && terminalHighlight.registerInput) {
	  terminalHighlight.registerInput(Input);
	}
	return input;
}

var root$1;
var hasRequiredRoot$1;

function requireRoot$1 () {
	if (hasRequiredRoot$1) return root$1;
	hasRequiredRoot$1 = 1;

	let Container = /*@__PURE__*/ requireContainer$1();

	let LazyResult, Processor;

	class Root extends Container {
	  constructor(defaults) {
	    super(defaults);
	    this.type = 'root';
	    if (!this.nodes) this.nodes = [];
	  }

	  normalize(child, sample, type) {
	    let nodes = super.normalize(child);

	    if (sample) {
	      if (type === 'prepend') {
	        if (this.nodes.length > 1) {
	          sample.raws.before = this.nodes[1].raws.before;
	        } else {
	          delete sample.raws.before;
	        }
	      } else if (this.first !== sample) {
	        for (let node of nodes) {
	          node.raws.before = sample.raws.before;
	        }
	      }
	    }

	    return nodes
	  }

	  removeChild(child, ignore) {
	    let index = this.index(child);

	    if (!ignore && index === 0 && this.nodes.length > 1) {
	      this.nodes[1].raws.before = this.nodes[index].raws.before;
	    }

	    return super.removeChild(child)
	  }

	  toResult(opts = {}) {
	    let lazy = new LazyResult(new Processor(), this, opts);
	    return lazy.stringify()
	  }
	}

	Root.registerLazyResult = dependant => {
	  LazyResult = dependant;
	};

	Root.registerProcessor = dependant => {
	  Processor = dependant;
	};

	root$1 = Root;
	Root.default = Root;

	Container.registerRoot(Root);
	return root$1;
}

var list_1;
var hasRequiredList;

function requireList () {
	if (hasRequiredList) return list_1;
	hasRequiredList = 1;

	let list = {
	  comma(string) {
	    return list.split(string, [','], true)
	  },

	  space(string) {
	    let spaces = [' ', '\n', '\t'];
	    return list.split(string, spaces)
	  },

	  split(string, separators, last) {
	    let array = [];
	    let current = '';
	    let split = false;

	    let func = 0;
	    let inQuote = false;
	    let prevQuote = '';
	    let escape = false;

	    for (let letter of string) {
	      if (escape) {
	        escape = false;
	      } else if (letter === '\\') {
	        escape = true;
	      } else if (inQuote) {
	        if (letter === prevQuote) {
	          inQuote = false;
	        }
	      } else if (letter === '"' || letter === "'") {
	        inQuote = true;
	        prevQuote = letter;
	      } else if (letter === '(') {
	        func += 1;
	      } else if (letter === ')') {
	        if (func > 0) func -= 1;
	      } else if (func === 0) {
	        if (separators.includes(letter)) split = true;
	      }

	      if (split) {
	        if (current !== '') array.push(current.trim());
	        current = '';
	        split = false;
	      } else {
	        current += letter;
	      }
	    }

	    if (last || current !== '') array.push(current.trim());
	    return array
	  }
	};

	list_1 = list;
	list.default = list;
	return list_1;
}

var rule;
var hasRequiredRule;

function requireRule () {
	if (hasRequiredRule) return rule;
	hasRequiredRule = 1;

	let Container = /*@__PURE__*/ requireContainer$1();
	let list = /*@__PURE__*/ requireList();

	class Rule extends Container {
	  get selectors() {
	    return list.comma(this.selector)
	  }

	  set selectors(values) {
	    let match = this.selector ? this.selector.match(/,\s*/) : null;
	    let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');
	    this.selector = values.join(sep);
	  }

	  constructor(defaults) {
	    super(defaults);
	    this.type = 'rule';
	    if (!this.nodes) this.nodes = [];
	  }
	}

	rule = Rule;
	Rule.default = Rule;

	Container.registerRule(Rule);
	return rule;
}

var fromJSON_1;
var hasRequiredFromJSON;

function requireFromJSON () {
	if (hasRequiredFromJSON) return fromJSON_1;
	hasRequiredFromJSON = 1;

	let AtRule = /*@__PURE__*/ requireAtRule();
	let Comment = /*@__PURE__*/ requireComment$1();
	let Declaration = /*@__PURE__*/ requireDeclaration();
	let Input = /*@__PURE__*/ requireInput();
	let PreviousMap = /*@__PURE__*/ requirePreviousMap();
	let Root = /*@__PURE__*/ requireRoot$1();
	let Rule = /*@__PURE__*/ requireRule();

	function fromJSON(json, inputs) {
	  if (Array.isArray(json)) return json.map(n => fromJSON(n))

	  let { inputs: ownInputs, ...defaults } = json;
	  if (ownInputs) {
	    inputs = [];
	    for (let input of ownInputs) {
	      let inputHydrated = { ...input, __proto__: Input.prototype };
	      if (inputHydrated.map) {
	        inputHydrated.map = {
	          ...inputHydrated.map,
	          __proto__: PreviousMap.prototype
	        };
	      }
	      inputs.push(inputHydrated);
	    }
	  }
	  if (defaults.nodes) {
	    defaults.nodes = json.nodes.map(n => fromJSON(n, inputs));
	  }
	  if (defaults.source) {
	    let { inputId, ...source } = defaults.source;
	    defaults.source = source;
	    if (inputId != null) {
	      defaults.source.input = inputs[inputId];
	    }
	  }
	  if (defaults.type === 'root') {
	    return new Root(defaults)
	  } else if (defaults.type === 'decl') {
	    return new Declaration(defaults)
	  } else if (defaults.type === 'rule') {
	    return new Rule(defaults)
	  } else if (defaults.type === 'comment') {
	    return new Comment(defaults)
	  } else if (defaults.type === 'atrule') {
	    return new AtRule(defaults)
	  } else {
	    throw new Error('Unknown node type: ' + json.type)
	  }
	}

	fromJSON_1 = fromJSON;
	fromJSON.default = fromJSON;
	return fromJSON_1;
}

var mapGenerator;
var hasRequiredMapGenerator;

function requireMapGenerator () {
	if (hasRequiredMapGenerator) return mapGenerator;
	hasRequiredMapGenerator = 1;

	let { dirname, relative, resolve, sep } = require$$1;
	let { SourceMapConsumer, SourceMapGenerator } = /*@__PURE__*/ requireSourceMap$1();
	let { pathToFileURL } = require$$2;

	let Input = /*@__PURE__*/ requireInput();

	let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
	let pathAvailable = Boolean(dirname && resolve && relative && sep);

	class MapGenerator {
	  constructor(stringify, root, opts, cssString) {
	    this.stringify = stringify;
	    this.mapOpts = opts.map || {};
	    this.root = root;
	    this.opts = opts;
	    this.css = cssString;
	    this.originalCSS = cssString;
	    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;

	    this.memoizedFileURLs = new Map();
	    this.memoizedPaths = new Map();
	    this.memoizedURLs = new Map();
	  }

	  addAnnotation() {
	    let content;

	    if (this.isInline()) {
	      content =
	        'data:application/json;base64,' + this.toBase64(this.map.toString());
	    } else if (typeof this.mapOpts.annotation === 'string') {
	      content = this.mapOpts.annotation;
	    } else if (typeof this.mapOpts.annotation === 'function') {
	      content = this.mapOpts.annotation(this.opts.to, this.root);
	    } else {
	      content = this.outputFile() + '.map';
	    }
	    let eol = '\n';
	    if (this.css.includes('\r\n')) eol = '\r\n';

	    this.css += eol + '/*# sourceMappingURL=' + content + ' */';
	  }

	  applyPrevMaps() {
	    for (let prev of this.previous()) {
	      let from = this.toUrl(this.path(prev.file));
	      let root = prev.root || dirname(prev.file);
	      let map;

	      if (this.mapOpts.sourcesContent === false) {
	        map = new SourceMapConsumer(prev.text);
	        if (map.sourcesContent) {
	          map.sourcesContent = null;
	        }
	      } else {
	        map = prev.consumer();
	      }

	      this.map.applySourceMap(map, from, this.toUrl(this.path(root)));
	    }
	  }

	  clearAnnotation() {
	    if (this.mapOpts.annotation === false) return

	    if (this.root) {
	      let node;
	      for (let i = this.root.nodes.length - 1; i >= 0; i--) {
	        node = this.root.nodes[i];
	        if (node.type !== 'comment') continue
	        if (node.text.startsWith('# sourceMappingURL=')) {
	          this.root.removeChild(i);
	        }
	      }
	    } else if (this.css) {
	      this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, '');
	    }
	  }

	  generate() {
	    this.clearAnnotation();
	    if (pathAvailable && sourceMapAvailable && this.isMap()) {
	      return this.generateMap()
	    } else {
	      let result = '';
	      this.stringify(this.root, i => {
	        result += i;
	      });
	      return [result]
	    }
	  }

	  generateMap() {
	    if (this.root) {
	      this.generateString();
	    } else if (this.previous().length === 1) {
	      let prev = this.previous()[0].consumer();
	      prev.file = this.outputFile();
	      this.map = SourceMapGenerator.fromSourceMap(prev, {
	        ignoreInvalidMapping: true
	      });
	    } else {
	      this.map = new SourceMapGenerator({
	        file: this.outputFile(),
	        ignoreInvalidMapping: true
	      });
	      this.map.addMapping({
	        generated: { column: 0, line: 1 },
	        original: { column: 0, line: 1 },
	        source: this.opts.from
	          ? this.toUrl(this.path(this.opts.from))
	          : '<no source>'
	      });
	    }

	    if (this.isSourcesContent()) this.setSourcesContent();
	    if (this.root && this.previous().length > 0) this.applyPrevMaps();
	    if (this.isAnnotation()) this.addAnnotation();

	    if (this.isInline()) {
	      return [this.css]
	    } else {
	      return [this.css, this.map]
	    }
	  }

	  generateString() {
	    this.css = '';
	    this.map = new SourceMapGenerator({
	      file: this.outputFile(),
	      ignoreInvalidMapping: true
	    });

	    let line = 1;
	    let column = 1;

	    let noSource = '<no source>';
	    let mapping = {
	      generated: { column: 0, line: 0 },
	      original: { column: 0, line: 0 },
	      source: ''
	    };

	    let last, lines;
	    this.stringify(this.root, (str, node, type) => {
	      this.css += str;

	      if (node && type !== 'end') {
	        mapping.generated.line = line;
	        mapping.generated.column = column - 1;
	        if (node.source && node.source.start) {
	          mapping.source = this.sourcePath(node);
	          mapping.original.line = node.source.start.line;
	          mapping.original.column = node.source.start.column - 1;
	          this.map.addMapping(mapping);
	        } else {
	          mapping.source = noSource;
	          mapping.original.line = 1;
	          mapping.original.column = 0;
	          this.map.addMapping(mapping);
	        }
	      }

	      lines = str.match(/\n/g);
	      if (lines) {
	        line += lines.length;
	        last = str.lastIndexOf('\n');
	        column = str.length - last;
	      } else {
	        column += str.length;
	      }

	      if (node && type !== 'start') {
	        let p = node.parent || { raws: {} };
	        let childless =
	          node.type === 'decl' || (node.type === 'atrule' && !node.nodes);
	        if (!childless || node !== p.last || p.raws.semicolon) {
	          if (node.source && node.source.end) {
	            mapping.source = this.sourcePath(node);
	            mapping.original.line = node.source.end.line;
	            mapping.original.column = node.source.end.column - 1;
	            mapping.generated.line = line;
	            mapping.generated.column = column - 2;
	            this.map.addMapping(mapping);
	          } else {
	            mapping.source = noSource;
	            mapping.original.line = 1;
	            mapping.original.column = 0;
	            mapping.generated.line = line;
	            mapping.generated.column = column - 1;
	            this.map.addMapping(mapping);
	          }
	        }
	      }
	    });
	  }

	  isAnnotation() {
	    if (this.isInline()) {
	      return true
	    }
	    if (typeof this.mapOpts.annotation !== 'undefined') {
	      return this.mapOpts.annotation
	    }
	    if (this.previous().length) {
	      return this.previous().some(i => i.annotation)
	    }
	    return true
	  }

	  isInline() {
	    if (typeof this.mapOpts.inline !== 'undefined') {
	      return this.mapOpts.inline
	    }

	    let annotation = this.mapOpts.annotation;
	    if (typeof annotation !== 'undefined' && annotation !== true) {
	      return false
	    }

	    if (this.previous().length) {
	      return this.previous().some(i => i.inline)
	    }
	    return true
	  }

	  isMap() {
	    if (typeof this.opts.map !== 'undefined') {
	      return !!this.opts.map
	    }
	    return this.previous().length > 0
	  }

	  isSourcesContent() {
	    if (typeof this.mapOpts.sourcesContent !== 'undefined') {
	      return this.mapOpts.sourcesContent
	    }
	    if (this.previous().length) {
	      return this.previous().some(i => i.withContent())
	    }
	    return true
	  }

	  outputFile() {
	    if (this.opts.to) {
	      return this.path(this.opts.to)
	    } else if (this.opts.from) {
	      return this.path(this.opts.from)
	    } else {
	      return 'to.css'
	    }
	  }

	  path(file) {
	    if (this.mapOpts.absolute) return file
	    if (file.charCodeAt(0) === 60 /* `<` */) return file
	    if (/^\w+:\/\//.test(file)) return file
	    let cached = this.memoizedPaths.get(file);
	    if (cached) return cached

	    let from = this.opts.to ? dirname(this.opts.to) : '.';

	    if (typeof this.mapOpts.annotation === 'string') {
	      from = dirname(resolve(from, this.mapOpts.annotation));
	    }

	    let path = relative(from, file);
	    this.memoizedPaths.set(file, path);

	    return path
	  }

	  previous() {
	    if (!this.previousMaps) {
	      this.previousMaps = [];
	      if (this.root) {
	        this.root.walk(node => {
	          if (node.source && node.source.input.map) {
	            let map = node.source.input.map;
	            if (!this.previousMaps.includes(map)) {
	              this.previousMaps.push(map);
	            }
	          }
	        });
	      } else {
	        let input = new Input(this.originalCSS, this.opts);
	        if (input.map) this.previousMaps.push(input.map);
	      }
	    }

	    return this.previousMaps
	  }

	  setSourcesContent() {
	    let already = {};
	    if (this.root) {
	      this.root.walk(node => {
	        if (node.source) {
	          let from = node.source.input.from;
	          if (from && !already[from]) {
	            already[from] = true;
	            let fromUrl = this.usesFileUrls
	              ? this.toFileUrl(from)
	              : this.toUrl(this.path(from));
	            this.map.setSourceContent(fromUrl, node.source.input.css);
	          }
	        }
	      });
	    } else if (this.css) {
	      let from = this.opts.from
	        ? this.toUrl(this.path(this.opts.from))
	        : '<no source>';
	      this.map.setSourceContent(from, this.css);
	    }
	  }

	  sourcePath(node) {
	    if (this.mapOpts.from) {
	      return this.toUrl(this.mapOpts.from)
	    } else if (this.usesFileUrls) {
	      return this.toFileUrl(node.source.input.from)
	    } else {
	      return this.toUrl(this.path(node.source.input.from))
	    }
	  }

	  toBase64(str) {
	    if (Buffer$1) {
	      return Buffer$1.from(str).toString('base64')
	    } else {
	      return window.btoa(unescape(encodeURIComponent(str)))
	    }
	  }

	  toFileUrl(path) {
	    let cached = this.memoizedFileURLs.get(path);
	    if (cached) return cached

	    if (pathToFileURL) {
	      let fileURL = pathToFileURL(path).toString();
	      this.memoizedFileURLs.set(path, fileURL);

	      return fileURL
	    } else {
	      throw new Error(
	        '`map.absolute` option is not available in this PostCSS build'
	      )
	    }
	  }

	  toUrl(path) {
	    let cached = this.memoizedURLs.get(path);
	    if (cached) return cached

	    if (sep === '\\') {
	      path = path.replace(/\\/g, '/');
	    }

	    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
	    this.memoizedURLs.set(path, url);

	    return url
	  }
	}

	mapGenerator = MapGenerator;
	return mapGenerator;
}

var parser$1;
var hasRequiredParser$1;

function requireParser$1 () {
	if (hasRequiredParser$1) return parser$1;
	hasRequiredParser$1 = 1;

	let AtRule = /*@__PURE__*/ requireAtRule();
	let Comment = /*@__PURE__*/ requireComment$1();
	let Declaration = /*@__PURE__*/ requireDeclaration();
	let Root = /*@__PURE__*/ requireRoot$1();
	let Rule = /*@__PURE__*/ requireRule();
	let tokenizer = /*@__PURE__*/ requireTokenize$1();

	const SAFE_COMMENT_NEIGHBOR = {
	  empty: true,
	  space: true
	};

	function findLastWithPosition(tokens) {
	  for (let i = tokens.length - 1; i >= 0; i--) {
	    let token = tokens[i];
	    let pos = token[3] || token[2];
	    if (pos) return pos
	  }
	}

	class Parser {
	  constructor(input) {
	    this.input = input;

	    this.root = new Root();
	    this.current = this.root;
	    this.spaces = '';
	    this.semicolon = false;

	    this.createTokenizer();
	    this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
	  }

	  atrule(token) {
	    let node = new AtRule();
	    node.name = token[1].slice(1);
	    if (node.name === '') {
	      this.unnamedAtrule(node, token);
	    }
	    this.init(node, token[2]);

	    let type;
	    let prev;
	    let shift;
	    let last = false;
	    let open = false;
	    let params = [];
	    let brackets = [];

	    while (!this.tokenizer.endOfFile()) {
	      token = this.tokenizer.nextToken();
	      type = token[0];

	      if (type === '(' || type === '[') {
	        brackets.push(type === '(' ? ')' : ']');
	      } else if (type === '{' && brackets.length > 0) {
	        brackets.push('}');
	      } else if (type === brackets[brackets.length - 1]) {
	        brackets.pop();
	      }

	      if (brackets.length === 0) {
	        if (type === ';') {
	          node.source.end = this.getPosition(token[2]);
	          node.source.end.offset++;
	          this.semicolon = true;
	          break
	        } else if (type === '{') {
	          open = true;
	          break
	        } else if (type === '}') {
	          if (params.length > 0) {
	            shift = params.length - 1;
	            prev = params[shift];
	            while (prev && prev[0] === 'space') {
	              prev = params[--shift];
	            }
	            if (prev) {
	              node.source.end = this.getPosition(prev[3] || prev[2]);
	              node.source.end.offset++;
	            }
	          }
	          this.end(token);
	          break
	        } else {
	          params.push(token);
	        }
	      } else {
	        params.push(token);
	      }

	      if (this.tokenizer.endOfFile()) {
	        last = true;
	        break
	      }
	    }

	    node.raws.between = this.spacesAndCommentsFromEnd(params);
	    if (params.length) {
	      node.raws.afterName = this.spacesAndCommentsFromStart(params);
	      this.raw(node, 'params', params);
	      if (last) {
	        token = params[params.length - 1];
	        node.source.end = this.getPosition(token[3] || token[2]);
	        node.source.end.offset++;
	        this.spaces = node.raws.between;
	        node.raws.between = '';
	      }
	    } else {
	      node.raws.afterName = '';
	      node.params = '';
	    }

	    if (open) {
	      node.nodes = [];
	      this.current = node;
	    }
	  }

	  checkMissedSemicolon(tokens) {
	    let colon = this.colon(tokens);
	    if (colon === false) return

	    let founded = 0;
	    let token;
	    for (let j = colon - 1; j >= 0; j--) {
	      token = tokens[j];
	      if (token[0] !== 'space') {
	        founded += 1;
	        if (founded === 2) break
	      }
	    }
	    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
	    // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
	    // And because we need it after that one we do +1 to get the next one.
	    throw this.input.error(
	      'Missed semicolon',
	      token[0] === 'word' ? token[3] + 1 : token[2]
	    )
	  }

	  colon(tokens) {
	    let brackets = 0;
	    let prev, token, type;
	    for (let [i, element] of tokens.entries()) {
	      token = element;
	      type = token[0];

	      if (type === '(') {
	        brackets += 1;
	      }
	      if (type === ')') {
	        brackets -= 1;
	      }
	      if (brackets === 0 && type === ':') {
	        if (!prev) {
	          this.doubleColon(token);
	        } else if (prev[0] === 'word' && prev[1] === 'progid') {
	          continue
	        } else {
	          return i
	        }
	      }

	      prev = token;
	    }
	    return false
	  }

	  comment(token) {
	    let node = new Comment();
	    this.init(node, token[2]);
	    node.source.end = this.getPosition(token[3] || token[2]);
	    node.source.end.offset++;

	    let text = token[1].slice(2, -2);
	    if (/^\s*$/.test(text)) {
	      node.text = '';
	      node.raws.left = text;
	      node.raws.right = '';
	    } else {
	      let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
	      node.text = match[2];
	      node.raws.left = match[1];
	      node.raws.right = match[3];
	    }
	  }

	  createTokenizer() {
	    this.tokenizer = tokenizer(this.input);
	  }

	  decl(tokens, customProperty) {
	    let node = new Declaration();
	    this.init(node, tokens[0][2]);

	    let last = tokens[tokens.length - 1];
	    if (last[0] === ';') {
	      this.semicolon = true;
	      tokens.pop();
	    }

	    node.source.end = this.getPosition(
	      last[3] || last[2] || findLastWithPosition(tokens)
	    );
	    node.source.end.offset++;

	    while (tokens[0][0] !== 'word') {
	      if (tokens.length === 1) this.unknownWord(tokens);
	      node.raws.before += tokens.shift()[1];
	    }
	    node.source.start = this.getPosition(tokens[0][2]);

	    node.prop = '';
	    while (tokens.length) {
	      let type = tokens[0][0];
	      if (type === ':' || type === 'space' || type === 'comment') {
	        break
	      }
	      node.prop += tokens.shift()[1];
	    }

	    node.raws.between = '';

	    let token;
	    while (tokens.length) {
	      token = tokens.shift();

	      if (token[0] === ':') {
	        node.raws.between += token[1];
	        break
	      } else {
	        if (token[0] === 'word' && /\w/.test(token[1])) {
	          this.unknownWord([token]);
	        }
	        node.raws.between += token[1];
	      }
	    }

	    if (node.prop[0] === '_' || node.prop[0] === '*') {
	      node.raws.before += node.prop[0];
	      node.prop = node.prop.slice(1);
	    }

	    let firstSpaces = [];
	    let next;
	    while (tokens.length) {
	      next = tokens[0][0];
	      if (next !== 'space' && next !== 'comment') break
	      firstSpaces.push(tokens.shift());
	    }

	    this.precheckMissedSemicolon(tokens);

	    for (let i = tokens.length - 1; i >= 0; i--) {
	      token = tokens[i];
	      if (token[1].toLowerCase() === '!important') {
	        node.important = true;
	        let string = this.stringFrom(tokens, i);
	        string = this.spacesFromEnd(tokens) + string;
	        if (string !== ' !important') node.raws.important = string;
	        break
	      } else if (token[1].toLowerCase() === 'important') {
	        let cache = tokens.slice(0);
	        let str = '';
	        for (let j = i; j > 0; j--) {
	          let type = cache[j][0];
	          if (str.trim().startsWith('!') && type !== 'space') {
	            break
	          }
	          str = cache.pop()[1] + str;
	        }
	        if (str.trim().startsWith('!')) {
	          node.important = true;
	          node.raws.important = str;
	          tokens = cache;
	        }
	      }

	      if (token[0] !== 'space' && token[0] !== 'comment') {
	        break
	      }
	    }

	    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment');

	    if (hasWord) {
	      node.raws.between += firstSpaces.map(i => i[1]).join('');
	      firstSpaces = [];
	    }
	    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty);

	    if (node.value.includes(':') && !customProperty) {
	      this.checkMissedSemicolon(tokens);
	    }
	  }

	  doubleColon(token) {
	    throw this.input.error(
	      'Double colon',
	      { offset: token[2] },
	      { offset: token[2] + token[1].length }
	    )
	  }

	  emptyRule(token) {
	    let node = new Rule();
	    this.init(node, token[2]);
	    node.selector = '';
	    node.raws.between = '';
	    this.current = node;
	  }

	  end(token) {
	    if (this.current.nodes && this.current.nodes.length) {
	      this.current.raws.semicolon = this.semicolon;
	    }
	    this.semicolon = false;

	    this.current.raws.after = (this.current.raws.after || '') + this.spaces;
	    this.spaces = '';

	    if (this.current.parent) {
	      this.current.source.end = this.getPosition(token[2]);
	      this.current.source.end.offset++;
	      this.current = this.current.parent;
	    } else {
	      this.unexpectedClose(token);
	    }
	  }

	  endFile() {
	    if (this.current.parent) this.unclosedBlock();
	    if (this.current.nodes && this.current.nodes.length) {
	      this.current.raws.semicolon = this.semicolon;
	    }
	    this.current.raws.after = (this.current.raws.after || '') + this.spaces;
	    this.root.source.end = this.getPosition(this.tokenizer.position());
	  }

	  freeSemicolon(token) {
	    this.spaces += token[1];
	    if (this.current.nodes) {
	      let prev = this.current.nodes[this.current.nodes.length - 1];
	      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
	        prev.raws.ownSemicolon = this.spaces;
	        this.spaces = '';
	        prev.source.end = this.getPosition(token[2]);
	        prev.source.end.offset += prev.raws.ownSemicolon.length;
	      }
	    }
	  }

	  // Helpers

	  getPosition(offset) {
	    let pos = this.input.fromOffset(offset);
	    return {
	      column: pos.col,
	      line: pos.line,
	      offset
	    }
	  }

	  init(node, offset) {
	    this.current.push(node);
	    node.source = {
	      input: this.input,
	      start: this.getPosition(offset)
	    };
	    node.raws.before = this.spaces;
	    this.spaces = '';
	    if (node.type !== 'comment') this.semicolon = false;
	  }

	  other(start) {
	    let end = false;
	    let type = null;
	    let colon = false;
	    let bracket = null;
	    let brackets = [];
	    let customProperty = start[1].startsWith('--');

	    let tokens = [];
	    let token = start;
	    while (token) {
	      type = token[0];
	      tokens.push(token);

	      if (type === '(' || type === '[') {
	        if (!bracket) bracket = token;
	        brackets.push(type === '(' ? ')' : ']');
	      } else if (customProperty && colon && type === '{') {
	        if (!bracket) bracket = token;
	        brackets.push('}');
	      } else if (brackets.length === 0) {
	        if (type === ';') {
	          if (colon) {
	            this.decl(tokens, customProperty);
	            return
	          } else {
	            break
	          }
	        } else if (type === '{') {
	          this.rule(tokens);
	          return
	        } else if (type === '}') {
	          this.tokenizer.back(tokens.pop());
	          end = true;
	          break
	        } else if (type === ':') {
	          colon = true;
	        }
	      } else if (type === brackets[brackets.length - 1]) {
	        brackets.pop();
	        if (brackets.length === 0) bracket = null;
	      }

	      token = this.tokenizer.nextToken();
	    }

	    if (this.tokenizer.endOfFile()) end = true;
	    if (brackets.length > 0) this.unclosedBracket(bracket);

	    if (end && colon) {
	      if (!customProperty) {
	        while (tokens.length) {
	          token = tokens[tokens.length - 1][0];
	          if (token !== 'space' && token !== 'comment') break
	          this.tokenizer.back(tokens.pop());
	        }
	      }
	      this.decl(tokens, customProperty);
	    } else {
	      this.unknownWord(tokens);
	    }
	  }

	  parse() {
	    let token;
	    while (!this.tokenizer.endOfFile()) {
	      token = this.tokenizer.nextToken();

	      switch (token[0]) {
	        case 'space':
	          this.spaces += token[1];
	          break

	        case ';':
	          this.freeSemicolon(token);
	          break

	        case '}':
	          this.end(token);
	          break

	        case 'comment':
	          this.comment(token);
	          break

	        case 'at-word':
	          this.atrule(token);
	          break

	        case '{':
	          this.emptyRule(token);
	          break

	        default:
	          this.other(token);
	          break
	      }
	    }
	    this.endFile();
	  }

	  precheckMissedSemicolon(/* tokens */) {
	    // Hook for Safe Parser
	  }

	  raw(node, prop, tokens, customProperty) {
	    let token, type;
	    let length = tokens.length;
	    let value = '';
	    let clean = true;
	    let next, prev;

	    for (let i = 0; i < length; i += 1) {
	      token = tokens[i];
	      type = token[0];
	      if (type === 'space' && i === length - 1 && !customProperty) {
	        clean = false;
	      } else if (type === 'comment') {
	        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty';
	        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty';
	        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
	          if (value.slice(-1) === ',') {
	            clean = false;
	          } else {
	            value += token[1];
	          }
	        } else {
	          clean = false;
	        }
	      } else {
	        value += token[1];
	      }
	    }
	    if (!clean) {
	      let raw = tokens.reduce((all, i) => all + i[1], '');
	      node.raws[prop] = { raw, value };
	    }
	    node[prop] = value;
	  }

	  rule(tokens) {
	    tokens.pop();

	    let node = new Rule();
	    this.init(node, tokens[0][2]);

	    node.raws.between = this.spacesAndCommentsFromEnd(tokens);
	    this.raw(node, 'selector', tokens);
	    this.current = node;
	  }

	  spacesAndCommentsFromEnd(tokens) {
	    let lastTokenType;
	    let spaces = '';
	    while (tokens.length) {
	      lastTokenType = tokens[tokens.length - 1][0];
	      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break
	      spaces = tokens.pop()[1] + spaces;
	    }
	    return spaces
	  }

	  // Errors

	  spacesAndCommentsFromStart(tokens) {
	    let next;
	    let spaces = '';
	    while (tokens.length) {
	      next = tokens[0][0];
	      if (next !== 'space' && next !== 'comment') break
	      spaces += tokens.shift()[1];
	    }
	    return spaces
	  }

	  spacesFromEnd(tokens) {
	    let lastTokenType;
	    let spaces = '';
	    while (tokens.length) {
	      lastTokenType = tokens[tokens.length - 1][0];
	      if (lastTokenType !== 'space') break
	      spaces = tokens.pop()[1] + spaces;
	    }
	    return spaces
	  }

	  stringFrom(tokens, from) {
	    let result = '';
	    for (let i = from; i < tokens.length; i++) {
	      result += tokens[i][1];
	    }
	    tokens.splice(from, tokens.length - from);
	    return result
	  }

	  unclosedBlock() {
	    let pos = this.current.source.start;
	    throw this.input.error('Unclosed block', pos.line, pos.column)
	  }

	  unclosedBracket(bracket) {
	    throw this.input.error(
	      'Unclosed bracket',
	      { offset: bracket[2] },
	      { offset: bracket[2] + 1 }
	    )
	  }

	  unexpectedClose(token) {
	    throw this.input.error(
	      'Unexpected }',
	      { offset: token[2] },
	      { offset: token[2] + 1 }
	    )
	  }

	  unknownWord(tokens) {
	    throw this.input.error(
	      'Unknown word ' + tokens[0][1],
	      { offset: tokens[0][2] },
	      { offset: tokens[0][2] + tokens[0][1].length }
	    )
	  }

	  unnamedAtrule(node, token) {
	    throw this.input.error(
	      'At-rule without name',
	      { offset: token[2] },
	      { offset: token[2] + token[1].length }
	    )
	  }
	}

	parser$1 = Parser;
	return parser$1;
}

var parse_1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1;

	let Container = /*@__PURE__*/ requireContainer$1();
	let Input = /*@__PURE__*/ requireInput();
	let Parser = /*@__PURE__*/ requireParser$1();

	function parse(css, opts) {
	  let input = new Input(css, opts);
	  let parser = new Parser(input);
	  try {
	    parser.parse();
	  } catch (e) {
	    if (browser$1.env.NODE_ENV !== 'production') {
	      if (e.name === 'CssSyntaxError' && opts && opts.from) {
	        if (/\.scss$/i.test(opts.from)) {
	          e.message +=
	            '\nYou tried to parse SCSS with ' +
	            'the standard CSS parser; ' +
	            'try again with the postcss-scss parser';
	        } else if (/\.sass/i.test(opts.from)) {
	          e.message +=
	            '\nYou tried to parse Sass with ' +
	            'the standard CSS parser; ' +
	            'try again with the postcss-sass parser';
	        } else if (/\.less$/i.test(opts.from)) {
	          e.message +=
	            '\nYou tried to parse Less with ' +
	            'the standard CSS parser; ' +
	            'try again with the postcss-less parser';
	        }
	      }
	    }
	    throw e
	  }

	  return parser.root
	}

	parse_1 = parse;
	parse.default = parse;

	Container.registerParse(parse);
	return parse_1;
}

var warning;
var hasRequiredWarning;

function requireWarning () {
	if (hasRequiredWarning) return warning;
	hasRequiredWarning = 1;

	class Warning {
	  constructor(text, opts = {}) {
	    this.type = 'warning';
	    this.text = text;

	    if (opts.node && opts.node.source) {
	      let range = opts.node.rangeBy(opts);
	      this.line = range.start.line;
	      this.column = range.start.column;
	      this.endLine = range.end.line;
	      this.endColumn = range.end.column;
	    }

	    for (let opt in opts) this[opt] = opts[opt];
	  }

	  toString() {
	    if (this.node) {
	      return this.node.error(this.text, {
	        index: this.index,
	        plugin: this.plugin,
	        word: this.word
	      }).message
	    }

	    if (this.plugin) {
	      return this.plugin + ': ' + this.text
	    }

	    return this.text
	  }
	}

	warning = Warning;
	Warning.default = Warning;
	return warning;
}

var result;
var hasRequiredResult;

function requireResult () {
	if (hasRequiredResult) return result;
	hasRequiredResult = 1;

	let Warning = /*@__PURE__*/ requireWarning();

	class Result {
	  get content() {
	    return this.css
	  }

	  constructor(processor, root, opts) {
	    this.processor = processor;
	    this.messages = [];
	    this.root = root;
	    this.opts = opts;
	    this.css = '';
	    this.map = undefined;
	  }

	  toString() {
	    return this.css
	  }

	  warn(text, opts = {}) {
	    if (!opts.plugin) {
	      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
	        opts.plugin = this.lastPlugin.postcssPlugin;
	      }
	    }

	    let warning = new Warning(text, opts);
	    this.messages.push(warning);

	    return warning
	  }

	  warnings() {
	    return this.messages.filter(i => i.type === 'warning')
	  }
	}

	result = Result;
	Result.default = Result;
	return result;
}

/* eslint-disable no-console */

var warnOnce;
var hasRequiredWarnOnce;

function requireWarnOnce () {
	if (hasRequiredWarnOnce) return warnOnce;
	hasRequiredWarnOnce = 1;

	let printed = {};

	warnOnce = function warnOnce(message) {
	  if (printed[message]) return
	  printed[message] = true;

	  if (typeof console !== 'undefined' && console.warn) {
	    console.warn(message);
	  }
	};
	return warnOnce;
}

var lazyResult;
var hasRequiredLazyResult;

function requireLazyResult () {
	if (hasRequiredLazyResult) return lazyResult;
	hasRequiredLazyResult = 1;

	let Container = /*@__PURE__*/ requireContainer$1();
	let Document = /*@__PURE__*/ requireDocument();
	let MapGenerator = /*@__PURE__*/ requireMapGenerator();
	let parse = /*@__PURE__*/ requireParse();
	let Result = /*@__PURE__*/ requireResult();
	let Root = /*@__PURE__*/ requireRoot$1();
	let stringify = /*@__PURE__*/ requireStringify();
	let { isClean, my } = /*@__PURE__*/ requireSymbols();
	let warnOnce = /*@__PURE__*/ requireWarnOnce();

	const TYPE_TO_CLASS_NAME = {
	  atrule: 'AtRule',
	  comment: 'Comment',
	  decl: 'Declaration',
	  document: 'Document',
	  root: 'Root',
	  rule: 'Rule'
	};

	const PLUGIN_PROPS = {
	  AtRule: true,
	  AtRuleExit: true,
	  Comment: true,
	  CommentExit: true,
	  Declaration: true,
	  DeclarationExit: true,
	  Document: true,
	  DocumentExit: true,
	  Once: true,
	  OnceExit: true,
	  postcssPlugin: true,
	  prepare: true,
	  Root: true,
	  RootExit: true,
	  Rule: true,
	  RuleExit: true
	};

	const NOT_VISITORS = {
	  Once: true,
	  postcssPlugin: true,
	  prepare: true
	};

	const CHILDREN = 0;

	function isPromise(obj) {
	  return typeof obj === 'object' && typeof obj.then === 'function'
	}

	function getEvents(node) {
	  let key = false;
	  let type = TYPE_TO_CLASS_NAME[node.type];
	  if (node.type === 'decl') {
	    key = node.prop.toLowerCase();
	  } else if (node.type === 'atrule') {
	    key = node.name.toLowerCase();
	  }

	  if (key && node.append) {
	    return [
	      type,
	      type + '-' + key,
	      CHILDREN,
	      type + 'Exit',
	      type + 'Exit-' + key
	    ]
	  } else if (key) {
	    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key]
	  } else if (node.append) {
	    return [type, CHILDREN, type + 'Exit']
	  } else {
	    return [type, type + 'Exit']
	  }
	}

	function toStack(node) {
	  let events;
	  if (node.type === 'document') {
	    events = ['Document', CHILDREN, 'DocumentExit'];
	  } else if (node.type === 'root') {
	    events = ['Root', CHILDREN, 'RootExit'];
	  } else {
	    events = getEvents(node);
	  }

	  return {
	    eventIndex: 0,
	    events,
	    iterator: 0,
	    node,
	    visitorIndex: 0,
	    visitors: []
	  }
	}

	function cleanMarks(node) {
	  node[isClean] = false;
	  if (node.nodes) node.nodes.forEach(i => cleanMarks(i));
	  return node
	}

	let postcss = {};

	class LazyResult {
	  get content() {
	    return this.stringify().content
	  }

	  get css() {
	    return this.stringify().css
	  }

	  get map() {
	    return this.stringify().map
	  }

	  get messages() {
	    return this.sync().messages
	  }

	  get opts() {
	    return this.result.opts
	  }

	  get processor() {
	    return this.result.processor
	  }

	  get root() {
	    return this.sync().root
	  }

	  get [Symbol.toStringTag]() {
	    return 'LazyResult'
	  }

	  constructor(processor, css, opts) {
	    this.stringified = false;
	    this.processed = false;

	    let root;
	    if (
	      typeof css === 'object' &&
	      css !== null &&
	      (css.type === 'root' || css.type === 'document')
	    ) {
	      root = cleanMarks(css);
	    } else if (css instanceof LazyResult || css instanceof Result) {
	      root = cleanMarks(css.root);
	      if (css.map) {
	        if (typeof opts.map === 'undefined') opts.map = {};
	        if (!opts.map.inline) opts.map.inline = false;
	        opts.map.prev = css.map;
	      }
	    } else {
	      let parser = parse;
	      if (opts.syntax) parser = opts.syntax.parse;
	      if (opts.parser) parser = opts.parser;
	      if (parser.parse) parser = parser.parse;

	      try {
	        root = parser(css, opts);
	      } catch (error) {
	        this.processed = true;
	        this.error = error;
	      }

	      if (root && !root[my]) {
	        /* c8 ignore next 2 */
	        Container.rebuild(root);
	      }
	    }

	    this.result = new Result(processor, root, opts);
	    this.helpers = { ...postcss, postcss, result: this.result };
	    this.plugins = this.processor.plugins.map(plugin => {
	      if (typeof plugin === 'object' && plugin.prepare) {
	        return { ...plugin, ...plugin.prepare(this.result) }
	      } else {
	        return plugin
	      }
	    });
	  }

	  async() {
	    if (this.error) return Promise.reject(this.error)
	    if (this.processed) return Promise.resolve(this.result)
	    if (!this.processing) {
	      this.processing = this.runAsync();
	    }
	    return this.processing
	  }

	  catch(onRejected) {
	    return this.async().catch(onRejected)
	  }

	  finally(onFinally) {
	    return this.async().then(onFinally, onFinally)
	  }

	  getAsyncError() {
	    throw new Error('Use process(css).then(cb) to work with async plugins')
	  }

	  handleError(error, node) {
	    let plugin = this.result.lastPlugin;
	    try {
	      if (node) node.addToError(error);
	      this.error = error;
	      if (error.name === 'CssSyntaxError' && !error.plugin) {
	        error.plugin = plugin.postcssPlugin;
	        error.setMessage();
	      } else if (plugin.postcssVersion) {
	        if (browser$1.env.NODE_ENV !== 'production') {
	          let pluginName = plugin.postcssPlugin;
	          let pluginVer = plugin.postcssVersion;
	          let runtimeVer = this.result.processor.version;
	          let a = pluginVer.split('.');
	          let b = runtimeVer.split('.');

	          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
	            // eslint-disable-next-line no-console
	            console.error(
	              'Unknown error from PostCSS plugin. Your current PostCSS ' +
	                'version is ' +
	                runtimeVer +
	                ', but ' +
	                pluginName +
	                ' uses ' +
	                pluginVer +
	                '. Perhaps this is the source of the error below.'
	            );
	          }
	        }
	      }
	    } catch (err) {
	      /* c8 ignore next 3 */
	      // eslint-disable-next-line no-console
	      if (console && console.error) console.error(err);
	    }
	    return error
	  }

	  prepareVisitors() {
	    this.listeners = {};
	    let add = (plugin, type, cb) => {
	      if (!this.listeners[type]) this.listeners[type] = [];
	      this.listeners[type].push([plugin, cb]);
	    };
	    for (let plugin of this.plugins) {
	      if (typeof plugin === 'object') {
	        for (let event in plugin) {
	          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
	            throw new Error(
	              `Unknown event ${event} in ${plugin.postcssPlugin}. ` +
	                `Try to update PostCSS (${this.processor.version} now).`
	            )
	          }
	          if (!NOT_VISITORS[event]) {
	            if (typeof plugin[event] === 'object') {
	              for (let filter in plugin[event]) {
	                if (filter === '*') {
	                  add(plugin, event, plugin[event][filter]);
	                } else {
	                  add(
	                    plugin,
	                    event + '-' + filter.toLowerCase(),
	                    plugin[event][filter]
	                  );
	                }
	              }
	            } else if (typeof plugin[event] === 'function') {
	              add(plugin, event, plugin[event]);
	            }
	          }
	        }
	      }
	    }
	    this.hasListener = Object.keys(this.listeners).length > 0;
	  }

	  async runAsync() {
	    this.plugin = 0;
	    for (let i = 0; i < this.plugins.length; i++) {
	      let plugin = this.plugins[i];
	      let promise = this.runOnRoot(plugin);
	      if (isPromise(promise)) {
	        try {
	          await promise;
	        } catch (error) {
	          throw this.handleError(error)
	        }
	      }
	    }

	    this.prepareVisitors();
	    if (this.hasListener) {
	      let root = this.result.root;
	      while (!root[isClean]) {
	        root[isClean] = true;
	        let stack = [toStack(root)];
	        while (stack.length > 0) {
	          let promise = this.visitTick(stack);
	          if (isPromise(promise)) {
	            try {
	              await promise;
	            } catch (e) {
	              let node = stack[stack.length - 1].node;
	              throw this.handleError(e, node)
	            }
	          }
	        }
	      }

	      if (this.listeners.OnceExit) {
	        for (let [plugin, visitor] of this.listeners.OnceExit) {
	          this.result.lastPlugin = plugin;
	          try {
	            if (root.type === 'document') {
	              let roots = root.nodes.map(subRoot =>
	                visitor(subRoot, this.helpers)
	              );

	              await Promise.all(roots);
	            } else {
	              await visitor(root, this.helpers);
	            }
	          } catch (e) {
	            throw this.handleError(e)
	          }
	        }
	      }
	    }

	    this.processed = true;
	    return this.stringify()
	  }

	  runOnRoot(plugin) {
	    this.result.lastPlugin = plugin;
	    try {
	      if (typeof plugin === 'object' && plugin.Once) {
	        if (this.result.root.type === 'document') {
	          let roots = this.result.root.nodes.map(root =>
	            plugin.Once(root, this.helpers)
	          );

	          if (isPromise(roots[0])) {
	            return Promise.all(roots)
	          }

	          return roots
	        }

	        return plugin.Once(this.result.root, this.helpers)
	      } else if (typeof plugin === 'function') {
	        return plugin(this.result.root, this.result)
	      }
	    } catch (error) {
	      throw this.handleError(error)
	    }
	  }

	  stringify() {
	    if (this.error) throw this.error
	    if (this.stringified) return this.result
	    this.stringified = true;

	    this.sync();

	    let opts = this.result.opts;
	    let str = stringify;
	    if (opts.syntax) str = opts.syntax.stringify;
	    if (opts.stringifier) str = opts.stringifier;
	    if (str.stringify) str = str.stringify;

	    let map = new MapGenerator(str, this.result.root, this.result.opts);
	    let data = map.generate();
	    this.result.css = data[0];
	    this.result.map = data[1];

	    return this.result
	  }

	  sync() {
	    if (this.error) throw this.error
	    if (this.processed) return this.result
	    this.processed = true;

	    if (this.processing) {
	      throw this.getAsyncError()
	    }

	    for (let plugin of this.plugins) {
	      let promise = this.runOnRoot(plugin);
	      if (isPromise(promise)) {
	        throw this.getAsyncError()
	      }
	    }

	    this.prepareVisitors();
	    if (this.hasListener) {
	      let root = this.result.root;
	      while (!root[isClean]) {
	        root[isClean] = true;
	        this.walkSync(root);
	      }
	      if (this.listeners.OnceExit) {
	        if (root.type === 'document') {
	          for (let subRoot of root.nodes) {
	            this.visitSync(this.listeners.OnceExit, subRoot);
	          }
	        } else {
	          this.visitSync(this.listeners.OnceExit, root);
	        }
	      }
	    }

	    return this.result
	  }

	  then(onFulfilled, onRejected) {
	    if (browser$1.env.NODE_ENV !== 'production') {
	      if (!('from' in this.opts)) {
	        warnOnce(
	          'Without `from` option PostCSS could generate wrong source map ' +
	            'and will not find Browserslist config. Set it to CSS file path ' +
	            'or to `undefined` to prevent this warning.'
	        );
	      }
	    }
	    return this.async().then(onFulfilled, onRejected)
	  }

	  toString() {
	    return this.css
	  }

	  visitSync(visitors, node) {
	    for (let [plugin, visitor] of visitors) {
	      this.result.lastPlugin = plugin;
	      let promise;
	      try {
	        promise = visitor(node, this.helpers);
	      } catch (e) {
	        throw this.handleError(e, node.proxyOf)
	      }
	      if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
	        return true
	      }
	      if (isPromise(promise)) {
	        throw this.getAsyncError()
	      }
	    }
	  }

	  visitTick(stack) {
	    let visit = stack[stack.length - 1];
	    let { node, visitors } = visit;

	    if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
	      stack.pop();
	      return
	    }

	    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
	      let [plugin, visitor] = visitors[visit.visitorIndex];
	      visit.visitorIndex += 1;
	      if (visit.visitorIndex === visitors.length) {
	        visit.visitors = [];
	        visit.visitorIndex = 0;
	      }
	      this.result.lastPlugin = plugin;
	      try {
	        return visitor(node.toProxy(), this.helpers)
	      } catch (e) {
	        throw this.handleError(e, node)
	      }
	    }

	    if (visit.iterator !== 0) {
	      let iterator = visit.iterator;
	      let child;
	      while ((child = node.nodes[node.indexes[iterator]])) {
	        node.indexes[iterator] += 1;
	        if (!child[isClean]) {
	          child[isClean] = true;
	          stack.push(toStack(child));
	          return
	        }
	      }
	      visit.iterator = 0;
	      delete node.indexes[iterator];
	    }

	    let events = visit.events;
	    while (visit.eventIndex < events.length) {
	      let event = events[visit.eventIndex];
	      visit.eventIndex += 1;
	      if (event === CHILDREN) {
	        if (node.nodes && node.nodes.length) {
	          node[isClean] = true;
	          visit.iterator = node.getIterator();
	        }
	        return
	      } else if (this.listeners[event]) {
	        visit.visitors = this.listeners[event];
	        return
	      }
	    }
	    stack.pop();
	  }

	  walkSync(node) {
	    node[isClean] = true;
	    let events = getEvents(node);
	    for (let event of events) {
	      if (event === CHILDREN) {
	        if (node.nodes) {
	          node.each(child => {
	            if (!child[isClean]) this.walkSync(child);
	          });
	        }
	      } else {
	        let visitors = this.listeners[event];
	        if (visitors) {
	          if (this.visitSync(visitors, node.toProxy())) return
	        }
	      }
	    }
	  }

	  warnings() {
	    return this.sync().warnings()
	  }
	}

	LazyResult.registerPostcss = dependant => {
	  postcss = dependant;
	};

	lazyResult = LazyResult;
	LazyResult.default = LazyResult;

	Root.registerLazyResult(LazyResult);
	Document.registerLazyResult(LazyResult);
	return lazyResult;
}

var noWorkResult;
var hasRequiredNoWorkResult;

function requireNoWorkResult () {
	if (hasRequiredNoWorkResult) return noWorkResult;
	hasRequiredNoWorkResult = 1;

	let MapGenerator = /*@__PURE__*/ requireMapGenerator();
	let parse = /*@__PURE__*/ requireParse();
	const Result = /*@__PURE__*/ requireResult();
	let stringify = /*@__PURE__*/ requireStringify();
	let warnOnce = /*@__PURE__*/ requireWarnOnce();

	class NoWorkResult {
	  get content() {
	    return this.result.css
	  }

	  get css() {
	    return this.result.css
	  }

	  get map() {
	    return this.result.map
	  }

	  get messages() {
	    return []
	  }

	  get opts() {
	    return this.result.opts
	  }

	  get processor() {
	    return this.result.processor
	  }

	  get root() {
	    if (this._root) {
	      return this._root
	    }

	    let root;
	    let parser = parse;

	    try {
	      root = parser(this._css, this._opts);
	    } catch (error) {
	      this.error = error;
	    }

	    if (this.error) {
	      throw this.error
	    } else {
	      this._root = root;
	      return root
	    }
	  }

	  get [Symbol.toStringTag]() {
	    return 'NoWorkResult'
	  }

	  constructor(processor, css, opts) {
	    css = css.toString();
	    this.stringified = false;

	    this._processor = processor;
	    this._css = css;
	    this._opts = opts;
	    this._map = undefined;
	    let root;

	    let str = stringify;
	    this.result = new Result(this._processor, root, this._opts);
	    this.result.css = css;

	    let self = this;
	    Object.defineProperty(this.result, 'root', {
	      get() {
	        return self.root
	      }
	    });

	    let map = new MapGenerator(str, root, this._opts, css);
	    if (map.isMap()) {
	      let [generatedCSS, generatedMap] = map.generate();
	      if (generatedCSS) {
	        this.result.css = generatedCSS;
	      }
	      if (generatedMap) {
	        this.result.map = generatedMap;
	      }
	    } else {
	      map.clearAnnotation();
	      this.result.css = map.css;
	    }
	  }

	  async() {
	    if (this.error) return Promise.reject(this.error)
	    return Promise.resolve(this.result)
	  }

	  catch(onRejected) {
	    return this.async().catch(onRejected)
	  }

	  finally(onFinally) {
	    return this.async().then(onFinally, onFinally)
	  }

	  sync() {
	    if (this.error) throw this.error
	    return this.result
	  }

	  then(onFulfilled, onRejected) {
	    if (browser$1.env.NODE_ENV !== 'production') {
	      if (!('from' in this._opts)) {
	        warnOnce(
	          'Without `from` option PostCSS could generate wrong source map ' +
	            'and will not find Browserslist config. Set it to CSS file path ' +
	            'or to `undefined` to prevent this warning.'
	        );
	      }
	    }

	    return this.async().then(onFulfilled, onRejected)
	  }

	  toString() {
	    return this._css
	  }

	  warnings() {
	    return []
	  }
	}

	noWorkResult = NoWorkResult;
	NoWorkResult.default = NoWorkResult;
	return noWorkResult;
}

var processor$1;
var hasRequiredProcessor$1;

function requireProcessor$1 () {
	if (hasRequiredProcessor$1) return processor$1;
	hasRequiredProcessor$1 = 1;

	let Document = /*@__PURE__*/ requireDocument();
	let LazyResult = /*@__PURE__*/ requireLazyResult();
	let NoWorkResult = /*@__PURE__*/ requireNoWorkResult();
	let Root = /*@__PURE__*/ requireRoot$1();

	class Processor {
	  constructor(plugins = []) {
	    this.version = '8.5.6';
	    this.plugins = this.normalize(plugins);
	  }

	  normalize(plugins) {
	    let normalized = [];
	    for (let i of plugins) {
	      if (i.postcss === true) {
	        i = i();
	      } else if (i.postcss) {
	        i = i.postcss;
	      }

	      if (typeof i === 'object' && Array.isArray(i.plugins)) {
	        normalized = normalized.concat(i.plugins);
	      } else if (typeof i === 'object' && i.postcssPlugin) {
	        normalized.push(i);
	      } else if (typeof i === 'function') {
	        normalized.push(i);
	      } else if (typeof i === 'object' && (i.parse || i.stringify)) {
	        if (browser$1.env.NODE_ENV !== 'production') {
	          throw new Error(
	            'PostCSS syntaxes cannot be used as plugins. Instead, please use ' +
	              'one of the syntax/parser/stringifier options as outlined ' +
	              'in your PostCSS runner documentation.'
	          )
	        }
	      } else {
	        throw new Error(i + ' is not a PostCSS plugin')
	      }
	    }
	    return normalized
	  }

	  process(css, opts = {}) {
	    if (
	      !this.plugins.length &&
	      !opts.parser &&
	      !opts.stringifier &&
	      !opts.syntax
	    ) {
	      return new NoWorkResult(this, css, opts)
	    } else {
	      return new LazyResult(this, css, opts)
	    }
	  }

	  use(plugin) {
	    this.plugins = this.plugins.concat(this.normalize([plugin]));
	    return this
	  }
	}

	processor$1 = Processor;
	Processor.default = Processor;

	Root.registerProcessor(Processor);
	Document.registerProcessor(Processor);
	return processor$1;
}

var postcss_1;
var hasRequiredPostcss;

function requirePostcss () {
	if (hasRequiredPostcss) return postcss_1;
	hasRequiredPostcss = 1;

	let AtRule = /*@__PURE__*/ requireAtRule();
	let Comment = /*@__PURE__*/ requireComment$1();
	let Container = /*@__PURE__*/ requireContainer$1();
	let CssSyntaxError = /*@__PURE__*/ requireCssSyntaxError();
	let Declaration = /*@__PURE__*/ requireDeclaration();
	let Document = /*@__PURE__*/ requireDocument();
	let fromJSON = /*@__PURE__*/ requireFromJSON();
	let Input = /*@__PURE__*/ requireInput();
	let LazyResult = /*@__PURE__*/ requireLazyResult();
	let list = /*@__PURE__*/ requireList();
	let Node = /*@__PURE__*/ requireNode$2();
	let parse = /*@__PURE__*/ requireParse();
	let Processor = /*@__PURE__*/ requireProcessor$1();
	let Result = /*@__PURE__*/ requireResult();
	let Root = /*@__PURE__*/ requireRoot$1();
	let Rule = /*@__PURE__*/ requireRule();
	let stringify = /*@__PURE__*/ requireStringify();
	let Warning = /*@__PURE__*/ requireWarning();

	function postcss(...plugins) {
	  if (plugins.length === 1 && Array.isArray(plugins[0])) {
	    plugins = plugins[0];
	  }
	  return new Processor(plugins)
	}

	postcss.plugin = function plugin(name, initializer) {
	  let warningPrinted = false;
	  function creator(...args) {
	    // eslint-disable-next-line no-console
	    if (console && console.warn && !warningPrinted) {
	      warningPrinted = true;
	      // eslint-disable-next-line no-console
	      console.warn(
	        name +
	          ': postcss.plugin was deprecated. Migration guide:\n' +
	          'https://evilmartians.com/chronicles/postcss-8-plugin-migration'
	      );
	      if (browser$1.env.LANG && browser$1.env.LANG.startsWith('cn')) {
	        /* c8 ignore next 7 */
	        // eslint-disable-next-line no-console
	        console.warn(
	          name +
	            ': 里面 postcss.plugin 被弃用. 迁移指南:\n' +
	            'https://www.w3ctech.com/topic/2226'
	        );
	      }
	    }
	    let transformer = initializer(...args);
	    transformer.postcssPlugin = name;
	    transformer.postcssVersion = new Processor().version;
	    return transformer
	  }

	  let cache;
	  Object.defineProperty(creator, 'postcss', {
	    get() {
	      if (!cache) cache = creator();
	      return cache
	    }
	  });

	  creator.process = function (css, processOpts, pluginOpts) {
	    return postcss([creator(pluginOpts)]).process(css, processOpts)
	  };

	  return creator
	};

	postcss.stringify = stringify;
	postcss.parse = parse;
	postcss.fromJSON = fromJSON;
	postcss.list = list;

	postcss.comment = defaults => new Comment(defaults);
	postcss.atRule = defaults => new AtRule(defaults);
	postcss.decl = defaults => new Declaration(defaults);
	postcss.rule = defaults => new Rule(defaults);
	postcss.root = defaults => new Root(defaults);
	postcss.document = defaults => new Document(defaults);

	postcss.CssSyntaxError = CssSyntaxError;
	postcss.Declaration = Declaration;
	postcss.Container = Container;
	postcss.Processor = Processor;
	postcss.Document = Document;
	postcss.Comment = Comment;
	postcss.Warning = Warning;
	postcss.AtRule = AtRule;
	postcss.Result = Result;
	postcss.Input = Input;
	postcss.Rule = Rule;
	postcss.Root = Root;
	postcss.Node = Node;

	LazyResult.registerPostcss(postcss);

	postcss_1 = postcss;
	postcss.default = postcss;
	return postcss_1;
}

var postcssExports = /*@__PURE__*/ requirePostcss();
var postcss = /*@__PURE__*/getDefaultExportFromCjs(postcssExports);

postcss.stringify;
postcss.fromJSON;
postcss.plugin;
postcss.parse;
postcss.list;

postcss.document;
postcss.comment;
postcss.atRule;
postcss.rule;
postcss.decl;
postcss.root;

postcss.CssSyntaxError;
postcss.Declaration;
postcss.Container;
postcss.Processor;
postcss.Document;
postcss.Comment;
postcss.Warning;
postcss.AtRule;
postcss.Result;
postcss.Input;
const Rule = postcss.Rule;
postcss.Root;
postcss.Node;

const trimPlugin = () => {
  return {
    postcssPlugin: "vue-sfc-trim",
    Once(root) {
      root.walk(({ type, raws }) => {
        if (type === "rule" || type === "atrule") {
          if (raws.before) raws.before = "\n";
          if ("after" in raws && raws.after) raws.after = "\n";
        }
      });
    }
  };
};
trimPlugin.postcss = true;

var dist = {exports: {}};

var processor = {exports: {}};

var parser = {exports: {}};

var root = {exports: {}};

var container = {exports: {}};

var node$1 = {exports: {}};

var util$1 = {};

var unesc = {exports: {}};

var hasRequiredUnesc;

function requireUnesc () {
	if (hasRequiredUnesc) return unesc.exports;
	hasRequiredUnesc = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = unesc;
		// Many thanks for this post which made this migration much easier.
		// https://mathiasbynens.be/notes/css-escapes

		/**
		 * 
		 * @param {string} str 
		 * @returns {[string, number]|undefined}
		 */
		function gobbleHex(str) {
		  var lower = str.toLowerCase();
		  var hex = '';
		  var spaceTerminated = false;
		  for (var i = 0; i < 6 && lower[i] !== undefined; i++) {
		    var code = lower.charCodeAt(i);
		    // check to see if we are dealing with a valid hex char [a-f|0-9]
		    var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
		    // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point
		    spaceTerminated = code === 32;
		    if (!valid) {
		      break;
		    }
		    hex += lower[i];
		  }
		  if (hex.length === 0) {
		    return undefined;
		  }
		  var codePoint = parseInt(hex, 16);
		  var isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF;
		  // Add special case for
		  // "If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point"
		  // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point
		  if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {
		    return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
		  }
		  return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
		}
		var CONTAINS_ESCAPE = /\\/;
		function unesc(str) {
		  var needToProcess = CONTAINS_ESCAPE.test(str);
		  if (!needToProcess) {
		    return str;
		  }
		  var ret = "";
		  for (var i = 0; i < str.length; i++) {
		    if (str[i] === "\\") {
		      var gobbled = gobbleHex(str.slice(i + 1, i + 7));
		      if (gobbled !== undefined) {
		        ret += gobbled[0];
		        i += gobbled[1];
		        continue;
		      }

		      // Retain a pair of \\ if double escaped `\\\\`
		      // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e
		      if (str[i + 1] === "\\") {
		        ret += "\\";
		        i++;
		        continue;
		      }

		      // if \\ is at the end of the string retain it
		      // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb
		      if (str.length === i + 1) {
		        ret += str[i];
		      }
		      continue;
		    }
		    ret += str[i];
		  }
		  return ret;
		}
		module.exports = exports.default; 
	} (unesc, unesc.exports));
	return unesc.exports;
}

var getProp = {exports: {}};

var hasRequiredGetProp;

function requireGetProp () {
	if (hasRequiredGetProp) return getProp.exports;
	hasRequiredGetProp = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = getProp;
		function getProp(obj) {
		  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		    props[_key - 1] = arguments[_key];
		  }
		  while (props.length > 0) {
		    var prop = props.shift();
		    if (!obj[prop]) {
		      return undefined;
		    }
		    obj = obj[prop];
		  }
		  return obj;
		}
		module.exports = exports.default; 
	} (getProp, getProp.exports));
	return getProp.exports;
}

var ensureObject = {exports: {}};

var hasRequiredEnsureObject;

function requireEnsureObject () {
	if (hasRequiredEnsureObject) return ensureObject.exports;
	hasRequiredEnsureObject = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = ensureObject;
		function ensureObject(obj) {
		  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		    props[_key - 1] = arguments[_key];
		  }
		  while (props.length > 0) {
		    var prop = props.shift();
		    if (!obj[prop]) {
		      obj[prop] = {};
		    }
		    obj = obj[prop];
		  }
		}
		module.exports = exports.default; 
	} (ensureObject, ensureObject.exports));
	return ensureObject.exports;
}

var stripComments = {exports: {}};

var hasRequiredStripComments;

function requireStripComments () {
	if (hasRequiredStripComments) return stripComments.exports;
	hasRequiredStripComments = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = stripComments;
		function stripComments(str) {
		  var s = "";
		  var commentStart = str.indexOf("/*");
		  var lastEnd = 0;
		  while (commentStart >= 0) {
		    s = s + str.slice(lastEnd, commentStart);
		    var commentEnd = str.indexOf("*/", commentStart + 2);
		    if (commentEnd < 0) {
		      return s;
		    }
		    lastEnd = commentEnd + 2;
		    commentStart = str.indexOf("/*", lastEnd);
		  }
		  s = s + str.slice(lastEnd);
		  return s;
		}
		module.exports = exports.default; 
	} (stripComments, stripComments.exports));
	return stripComments.exports;
}

var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1;
	hasRequiredUtil$1 = 1;

	util$1.__esModule = true;
	util$1.unesc = util$1.stripComments = util$1.getProp = util$1.ensureObject = void 0;
	var _unesc = _interopRequireDefault(/*@__PURE__*/ requireUnesc());
	util$1.unesc = _unesc["default"];
	var _getProp = _interopRequireDefault(/*@__PURE__*/ requireGetProp());
	util$1.getProp = _getProp["default"];
	var _ensureObject = _interopRequireDefault(/*@__PURE__*/ requireEnsureObject());
	util$1.ensureObject = _ensureObject["default"];
	var _stripComments = _interopRequireDefault(/*@__PURE__*/ requireStripComments());
	util$1.stripComments = _stripComments["default"];
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	return util$1;
}

var hasRequiredNode$1;

function requireNode$1 () {
	if (hasRequiredNode$1) return node$1.exports;
	hasRequiredNode$1 = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _util = /*@__PURE__*/ requireUtil$1();
		function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
		function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
		var cloneNode = function cloneNode(obj, parent) {
		  if (typeof obj !== 'object' || obj === null) {
		    return obj;
		  }
		  var cloned = new obj.constructor();
		  for (var i in obj) {
		    if (!obj.hasOwnProperty(i)) {
		      continue;
		    }
		    var value = obj[i];
		    var type = typeof value;
		    if (i === 'parent' && type === 'object') {
		      if (parent) {
		        cloned[i] = parent;
		      }
		    } else if (value instanceof Array) {
		      cloned[i] = value.map(function (j) {
		        return cloneNode(j, cloned);
		      });
		    } else {
		      cloned[i] = cloneNode(value, cloned);
		    }
		  }
		  return cloned;
		};
		var Node = /*#__PURE__*/function () {
		  function Node(opts) {
		    if (opts === void 0) {
		      opts = {};
		    }
		    Object.assign(this, opts);
		    this.spaces = this.spaces || {};
		    this.spaces.before = this.spaces.before || '';
		    this.spaces.after = this.spaces.after || '';
		  }
		  var _proto = Node.prototype;
		  _proto.remove = function remove() {
		    if (this.parent) {
		      this.parent.removeChild(this);
		    }
		    this.parent = undefined;
		    return this;
		  };
		  _proto.replaceWith = function replaceWith() {
		    if (this.parent) {
		      for (var index in arguments) {
		        this.parent.insertBefore(this, arguments[index]);
		      }
		      this.remove();
		    }
		    return this;
		  };
		  _proto.next = function next() {
		    return this.parent.at(this.parent.index(this) + 1);
		  };
		  _proto.prev = function prev() {
		    return this.parent.at(this.parent.index(this) - 1);
		  };
		  _proto.clone = function clone(overrides) {
		    if (overrides === void 0) {
		      overrides = {};
		    }
		    var cloned = cloneNode(this);
		    for (var name in overrides) {
		      cloned[name] = overrides[name];
		    }
		    return cloned;
		  }

		  /**
		   * Some non-standard syntax doesn't follow normal escaping rules for css.
		   * This allows non standard syntax to be appended to an existing property
		   * by specifying the escaped value. By specifying the escaped value,
		   * illegal characters are allowed to be directly inserted into css output.
		   * @param {string} name the property to set
		   * @param {any} value the unescaped value of the property
		   * @param {string} valueEscaped optional. the escaped value of the property.
		   */;
		  _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
		    if (!this.raws) {
		      this.raws = {};
		    }
		    var originalValue = this[name];
		    var originalEscaped = this.raws[name];
		    this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.
		    if (originalEscaped || valueEscaped !== value) {
		      this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
		    } else {
		      delete this.raws[name]; // delete any escaped value that was created by the setter.
		    }
		  }

		  /**
		   * Some non-standard syntax doesn't follow normal escaping rules for css.
		   * This allows the escaped value to be specified directly, allowing illegal
		   * characters to be directly inserted into css output.
		   * @param {string} name the property to set
		   * @param {any} value the unescaped value of the property
		   * @param {string} valueEscaped the escaped value of the property.
		   */;
		  _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
		    if (!this.raws) {
		      this.raws = {};
		    }
		    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.
		    this.raws[name] = valueEscaped;
		  }

		  /**
		   * When you want a value to passed through to CSS directly. This method
		   * deletes the corresponding raw value causing the stringifier to fallback
		   * to the unescaped value.
		   * @param {string} name the property to set.
		   * @param {any} value The value that is both escaped and unescaped.
		   */;
		  _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
		    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.
		    if (this.raws) {
		      delete this.raws[name];
		    }
		  }

		  /**
		   *
		   * @param {number} line The number (starting with 1)
		   * @param {number} column The column number (starting with 1)
		   */;
		  _proto.isAtPosition = function isAtPosition(line, column) {
		    if (this.source && this.source.start && this.source.end) {
		      if (this.source.start.line > line) {
		        return false;
		      }
		      if (this.source.end.line < line) {
		        return false;
		      }
		      if (this.source.start.line === line && this.source.start.column > column) {
		        return false;
		      }
		      if (this.source.end.line === line && this.source.end.column < column) {
		        return false;
		      }
		      return true;
		    }
		    return undefined;
		  };
		  _proto.stringifyProperty = function stringifyProperty(name) {
		    return this.raws && this.raws[name] || this[name];
		  };
		  _proto.valueToString = function valueToString() {
		    return String(this.stringifyProperty("value"));
		  };
		  _proto.toString = function toString() {
		    return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join('');
		  };
		  _createClass(Node, [{
		    key: "rawSpaceBefore",
		    get: function get() {
		      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
		      if (rawSpace === undefined) {
		        rawSpace = this.spaces && this.spaces.before;
		      }
		      return rawSpace || "";
		    },
		    set: function set(raw) {
		      (0, _util.ensureObject)(this, "raws", "spaces");
		      this.raws.spaces.before = raw;
		    }
		  }, {
		    key: "rawSpaceAfter",
		    get: function get() {
		      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
		      if (rawSpace === undefined) {
		        rawSpace = this.spaces.after;
		      }
		      return rawSpace || "";
		    },
		    set: function set(raw) {
		      (0, _util.ensureObject)(this, "raws", "spaces");
		      this.raws.spaces.after = raw;
		    }
		  }]);
		  return Node;
		}();
		exports["default"] = Node;
		module.exports = exports.default; 
	} (node$1, node$1.exports));
	return node$1.exports;
}

var types = {};

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;

	types.__esModule = true;
	types.UNIVERSAL = types.TAG = types.STRING = types.SELECTOR = types.ROOT = types.PSEUDO = types.NESTING = types.ID = types.COMMENT = types.COMBINATOR = types.CLASS = types.ATTRIBUTE = void 0;
	var TAG = 'tag';
	types.TAG = TAG;
	var STRING = 'string';
	types.STRING = STRING;
	var SELECTOR = 'selector';
	types.SELECTOR = SELECTOR;
	var ROOT = 'root';
	types.ROOT = ROOT;
	var PSEUDO = 'pseudo';
	types.PSEUDO = PSEUDO;
	var NESTING = 'nesting';
	types.NESTING = NESTING;
	var ID = 'id';
	types.ID = ID;
	var COMMENT = 'comment';
	types.COMMENT = COMMENT;
	var COMBINATOR = 'combinator';
	types.COMBINATOR = COMBINATOR;
	var CLASS = 'class';
	types.CLASS = CLASS;
	var ATTRIBUTE = 'attribute';
	types.ATTRIBUTE = ATTRIBUTE;
	var UNIVERSAL = 'universal';
	types.UNIVERSAL = UNIVERSAL;
	return types;
}

var hasRequiredContainer;

function requireContainer () {
	if (hasRequiredContainer) return container.exports;
	hasRequiredContainer = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _node = _interopRequireDefault(/*@__PURE__*/ requireNode$1());
		var types = _interopRequireWildcard(/*@__PURE__*/ requireTypes());
		function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
		function _interopRequireWildcard(obj, nodeInterop) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
		function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
		function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
		function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
		function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
		function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		var Container = /*#__PURE__*/function (_Node) {
		  _inheritsLoose(Container, _Node);
		  function Container(opts) {
		    var _this;
		    _this = _Node.call(this, opts) || this;
		    if (!_this.nodes) {
		      _this.nodes = [];
		    }
		    return _this;
		  }
		  var _proto = Container.prototype;
		  _proto.append = function append(selector) {
		    selector.parent = this;
		    this.nodes.push(selector);
		    return this;
		  };
		  _proto.prepend = function prepend(selector) {
		    selector.parent = this;
		    this.nodes.unshift(selector);
		    for (var id in this.indexes) {
		      this.indexes[id]++;
		    }
		    return this;
		  };
		  _proto.at = function at(index) {
		    return this.nodes[index];
		  };
		  _proto.index = function index(child) {
		    if (typeof child === 'number') {
		      return child;
		    }
		    return this.nodes.indexOf(child);
		  };
		  _proto.removeChild = function removeChild(child) {
		    child = this.index(child);
		    this.at(child).parent = undefined;
		    this.nodes.splice(child, 1);
		    var index;
		    for (var id in this.indexes) {
		      index = this.indexes[id];
		      if (index >= child) {
		        this.indexes[id] = index - 1;
		      }
		    }
		    return this;
		  };
		  _proto.removeAll = function removeAll() {
		    for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done;) {
		      var node = _step.value;
		      node.parent = undefined;
		    }
		    this.nodes = [];
		    return this;
		  };
		  _proto.empty = function empty() {
		    return this.removeAll();
		  };
		  _proto.insertAfter = function insertAfter(oldNode, newNode) {
		    var _this$nodes;
		    newNode.parent = this;
		    var oldIndex = this.index(oldNode);
		    var resetNode = [];
		    for (var i = 2; i < arguments.length; i++) {
		      resetNode.push(arguments[i]);
		    }
		    (_this$nodes = this.nodes).splice.apply(_this$nodes, [oldIndex + 1, 0, newNode].concat(resetNode));
		    newNode.parent = this;
		    var index;
		    for (var id in this.indexes) {
		      index = this.indexes[id];
		      if (oldIndex < index) {
		        this.indexes[id] = index + arguments.length - 1;
		      }
		    }
		    return this;
		  };
		  _proto.insertBefore = function insertBefore(oldNode, newNode) {
		    var _this$nodes2;
		    newNode.parent = this;
		    var oldIndex = this.index(oldNode);
		    var resetNode = [];
		    for (var i = 2; i < arguments.length; i++) {
		      resetNode.push(arguments[i]);
		    }
		    (_this$nodes2 = this.nodes).splice.apply(_this$nodes2, [oldIndex, 0, newNode].concat(resetNode));
		    newNode.parent = this;
		    var index;
		    for (var id in this.indexes) {
		      index = this.indexes[id];
		      if (index >= oldIndex) {
		        this.indexes[id] = index + arguments.length - 1;
		      }
		    }
		    return this;
		  };
		  _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
		    var found = undefined;
		    this.each(function (node) {
		      if (node.atPosition) {
		        var foundChild = node.atPosition(line, col);
		        if (foundChild) {
		          found = foundChild;
		          return false;
		        }
		      } else if (node.isAtPosition(line, col)) {
		        found = node;
		        return false;
		      }
		    });
		    return found;
		  }

		  /**
		   * Return the most specific node at the line and column number given.
		   * The source location is based on the original parsed location, locations aren't
		   * updated as selector nodes are mutated.
		   *
		   * Note that this location is relative to the location of the first character
		   * of the selector, and not the location of the selector in the overall document
		   * when used in conjunction with postcss.
		   *
		   * If not found, returns undefined.
		   * @param {number} line The line number of the node to find. (1-based index)
		   * @param {number} col  The column number of the node to find. (1-based index)
		   */;
		  _proto.atPosition = function atPosition(line, col) {
		    if (this.isAtPosition(line, col)) {
		      return this._findChildAtPosition(line, col) || this;
		    } else {
		      return undefined;
		    }
		  };
		  _proto._inferEndPosition = function _inferEndPosition() {
		    if (this.last && this.last.source && this.last.source.end) {
		      this.source = this.source || {};
		      this.source.end = this.source.end || {};
		      Object.assign(this.source.end, this.last.source.end);
		    }
		  };
		  _proto.each = function each(callback) {
		    if (!this.lastEach) {
		      this.lastEach = 0;
		    }
		    if (!this.indexes) {
		      this.indexes = {};
		    }
		    this.lastEach++;
		    var id = this.lastEach;
		    this.indexes[id] = 0;
		    if (!this.length) {
		      return undefined;
		    }
		    var index, result;
		    while (this.indexes[id] < this.length) {
		      index = this.indexes[id];
		      result = callback(this.at(index), index);
		      if (result === false) {
		        break;
		      }
		      this.indexes[id] += 1;
		    }
		    delete this.indexes[id];
		    if (result === false) {
		      return false;
		    }
		  };
		  _proto.walk = function walk(callback) {
		    return this.each(function (node, i) {
		      var result = callback(node, i);
		      if (result !== false && node.length) {
		        result = node.walk(callback);
		      }
		      if (result === false) {
		        return false;
		      }
		    });
		  };
		  _proto.walkAttributes = function walkAttributes(callback) {
		    var _this2 = this;
		    return this.walk(function (selector) {
		      if (selector.type === types.ATTRIBUTE) {
		        return callback.call(_this2, selector);
		      }
		    });
		  };
		  _proto.walkClasses = function walkClasses(callback) {
		    var _this3 = this;
		    return this.walk(function (selector) {
		      if (selector.type === types.CLASS) {
		        return callback.call(_this3, selector);
		      }
		    });
		  };
		  _proto.walkCombinators = function walkCombinators(callback) {
		    var _this4 = this;
		    return this.walk(function (selector) {
		      if (selector.type === types.COMBINATOR) {
		        return callback.call(_this4, selector);
		      }
		    });
		  };
		  _proto.walkComments = function walkComments(callback) {
		    var _this5 = this;
		    return this.walk(function (selector) {
		      if (selector.type === types.COMMENT) {
		        return callback.call(_this5, selector);
		      }
		    });
		  };
		  _proto.walkIds = function walkIds(callback) {
		    var _this6 = this;
		    return this.walk(function (selector) {
		      if (selector.type === types.ID) {
		        return callback.call(_this6, selector);
		      }
		    });
		  };
		  _proto.walkNesting = function walkNesting(callback) {
		    var _this7 = this;
		    return this.walk(function (selector) {
		      if (selector.type === types.NESTING) {
		        return callback.call(_this7, selector);
		      }
		    });
		  };
		  _proto.walkPseudos = function walkPseudos(callback) {
		    var _this8 = this;
		    return this.walk(function (selector) {
		      if (selector.type === types.PSEUDO) {
		        return callback.call(_this8, selector);
		      }
		    });
		  };
		  _proto.walkTags = function walkTags(callback) {
		    var _this9 = this;
		    return this.walk(function (selector) {
		      if (selector.type === types.TAG) {
		        return callback.call(_this9, selector);
		      }
		    });
		  };
		  _proto.walkUniversals = function walkUniversals(callback) {
		    var _this10 = this;
		    return this.walk(function (selector) {
		      if (selector.type === types.UNIVERSAL) {
		        return callback.call(_this10, selector);
		      }
		    });
		  };
		  _proto.split = function split(callback) {
		    var _this11 = this;
		    var current = [];
		    return this.reduce(function (memo, node, index) {
		      var split = callback.call(_this11, node);
		      current.push(node);
		      if (split) {
		        memo.push(current);
		        current = [];
		      } else if (index === _this11.length - 1) {
		        memo.push(current);
		      }
		      return memo;
		    }, []);
		  };
		  _proto.map = function map(callback) {
		    return this.nodes.map(callback);
		  };
		  _proto.reduce = function reduce(callback, memo) {
		    return this.nodes.reduce(callback, memo);
		  };
		  _proto.every = function every(callback) {
		    return this.nodes.every(callback);
		  };
		  _proto.some = function some(callback) {
		    return this.nodes.some(callback);
		  };
		  _proto.filter = function filter(callback) {
		    return this.nodes.filter(callback);
		  };
		  _proto.sort = function sort(callback) {
		    return this.nodes.sort(callback);
		  };
		  _proto.toString = function toString() {
		    return this.map(String).join('');
		  };
		  _createClass(Container, [{
		    key: "first",
		    get: function get() {
		      return this.at(0);
		    }
		  }, {
		    key: "last",
		    get: function get() {
		      return this.at(this.length - 1);
		    }
		  }, {
		    key: "length",
		    get: function get() {
		      return this.nodes.length;
		    }
		  }]);
		  return Container;
		}(_node["default"]);
		exports["default"] = Container;
		module.exports = exports.default; 
	} (container, container.exports));
	return container.exports;
}

var hasRequiredRoot;

function requireRoot () {
	if (hasRequiredRoot) return root.exports;
	hasRequiredRoot = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _container = _interopRequireDefault(/*@__PURE__*/ requireContainer());
		var _types = /*@__PURE__*/ requireTypes();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
		function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
		function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		var Root = /*#__PURE__*/function (_Container) {
		  _inheritsLoose(Root, _Container);
		  function Root(opts) {
		    var _this;
		    _this = _Container.call(this, opts) || this;
		    _this.type = _types.ROOT;
		    return _this;
		  }
		  var _proto = Root.prototype;
		  _proto.toString = function toString() {
		    var str = this.reduce(function (memo, selector) {
		      memo.push(String(selector));
		      return memo;
		    }, []).join(',');
		    return this.trailingComma ? str + ',' : str;
		  };
		  _proto.error = function error(message, options) {
		    if (this._error) {
		      return this._error(message, options);
		    } else {
		      return new Error(message);
		    }
		  };
		  _createClass(Root, [{
		    key: "errorGenerator",
		    set: function set(handler) {
		      this._error = handler;
		    }
		  }]);
		  return Root;
		}(_container["default"]);
		exports["default"] = Root;
		module.exports = exports.default; 
	} (root, root.exports));
	return root.exports;
}

var selector = {exports: {}};

var hasRequiredSelector;

function requireSelector () {
	if (hasRequiredSelector) return selector.exports;
	hasRequiredSelector = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _container = _interopRequireDefault(/*@__PURE__*/ requireContainer());
		var _types = /*@__PURE__*/ requireTypes();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		var Selector = /*#__PURE__*/function (_Container) {
		  _inheritsLoose(Selector, _Container);
		  function Selector(opts) {
		    var _this;
		    _this = _Container.call(this, opts) || this;
		    _this.type = _types.SELECTOR;
		    return _this;
		  }
		  return Selector;
		}(_container["default"]);
		exports["default"] = Selector;
		module.exports = exports.default; 
	} (selector, selector.exports));
	return selector.exports;
}

var className = {exports: {}};

/*! https://mths.be/cssesc v3.0.0 by @mathias */

var cssesc_1;
var hasRequiredCssesc;

function requireCssesc () {
	if (hasRequiredCssesc) return cssesc_1;
	hasRequiredCssesc = 1;

	var object = {};
	var hasOwnProperty = object.hasOwnProperty;
	var merge = function merge(options, defaults) {
		if (!options) {
			return defaults;
		}
		var result = {};
		for (var key in defaults) {
			// `if (defaults.hasOwnProperty(key) { … }` is not needed here, since
			// only recognized option names are used.
			result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
		}
		return result;
	};

	var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
	var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
	var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;

	// https://mathiasbynens.be/notes/css-escapes#css
	var cssesc = function cssesc(string, options) {
		options = merge(options, cssesc.options);
		if (options.quotes != 'single' && options.quotes != 'double') {
			options.quotes = 'single';
		}
		var quote = options.quotes == 'double' ? '"' : '\'';
		var isIdentifier = options.isIdentifier;

		var firstChar = string.charAt(0);
		var output = '';
		var counter = 0;
		var length = string.length;
		while (counter < length) {
			var character = string.charAt(counter++);
			var codePoint = character.charCodeAt();
			var value = void 0;
			// If it’s not a printable ASCII character…
			if (codePoint < 0x20 || codePoint > 0x7E) {
				if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
					// It’s a high surrogate, and there is a next character.
					var extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) {
						// next character is low surrogate
						codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
					} else {
						// It’s an unmatched surrogate; only append this code unit, in case
						// the next code unit is the high surrogate of a surrogate pair.
						counter--;
					}
				}
				value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
			} else {
				if (options.escapeEverything) {
					if (regexAnySingleEscape.test(character)) {
						value = '\\' + character;
					} else {
						value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
					}
				} else if (/[\t\n\f\r\x0B]/.test(character)) {
					value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
				} else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
					value = '\\' + character;
				} else {
					value = character;
				}
			}
			output += value;
		}

		if (isIdentifier) {
			if (/^-[-\d]/.test(output)) {
				output = '\\-' + output.slice(1);
			} else if (/\d/.test(firstChar)) {
				output = '\\3' + firstChar + ' ' + output.slice(1);
			}
		}

		// Remove spaces after `\HEX` escapes that are not followed by a hex digit,
		// since they’re redundant. Note that this is only possible if the escape
		// sequence isn’t preceded by an odd number of backslashes.
		output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {
			if ($1 && $1.length % 2) {
				// It’s not safe to remove the space, so don’t.
				return $0;
			}
			// Strip the space.
			return ($1 || '') + $2;
		});

		if (!isIdentifier && options.wrap) {
			return quote + output + quote;
		}
		return output;
	};

	// Expose default options (so they can be overridden globally).
	cssesc.options = {
		'escapeEverything': false,
		'isIdentifier': false,
		'quotes': 'single',
		'wrap': false
	};

	cssesc.version = '3.0.0';

	cssesc_1 = cssesc;
	return cssesc_1;
}

var hasRequiredClassName;

function requireClassName () {
	if (hasRequiredClassName) return className.exports;
	hasRequiredClassName = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _cssesc = _interopRequireDefault(/*@__PURE__*/ requireCssesc());
		var _util = /*@__PURE__*/ requireUtil$1();
		var _node = _interopRequireDefault(/*@__PURE__*/ requireNode$1());
		var _types = /*@__PURE__*/ requireTypes();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
		function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
		function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		var ClassName = /*#__PURE__*/function (_Node) {
		  _inheritsLoose(ClassName, _Node);
		  function ClassName(opts) {
		    var _this;
		    _this = _Node.call(this, opts) || this;
		    _this.type = _types.CLASS;
		    _this._constructed = true;
		    return _this;
		  }
		  var _proto = ClassName.prototype;
		  _proto.valueToString = function valueToString() {
		    return '.' + _Node.prototype.valueToString.call(this);
		  };
		  _createClass(ClassName, [{
		    key: "value",
		    get: function get() {
		      return this._value;
		    },
		    set: function set(v) {
		      if (this._constructed) {
		        var escaped = (0, _cssesc["default"])(v, {
		          isIdentifier: true
		        });
		        if (escaped !== v) {
		          (0, _util.ensureObject)(this, "raws");
		          this.raws.value = escaped;
		        } else if (this.raws) {
		          delete this.raws.value;
		        }
		      }
		      this._value = v;
		    }
		  }]);
		  return ClassName;
		}(_node["default"]);
		exports["default"] = ClassName;
		module.exports = exports.default; 
	} (className, className.exports));
	return className.exports;
}

var comment = {exports: {}};

var hasRequiredComment;

function requireComment () {
	if (hasRequiredComment) return comment.exports;
	hasRequiredComment = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _node = _interopRequireDefault(/*@__PURE__*/ requireNode$1());
		var _types = /*@__PURE__*/ requireTypes();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		var Comment = /*#__PURE__*/function (_Node) {
		  _inheritsLoose(Comment, _Node);
		  function Comment(opts) {
		    var _this;
		    _this = _Node.call(this, opts) || this;
		    _this.type = _types.COMMENT;
		    return _this;
		  }
		  return Comment;
		}(_node["default"]);
		exports["default"] = Comment;
		module.exports = exports.default; 
	} (comment, comment.exports));
	return comment.exports;
}

var id = {exports: {}};

var hasRequiredId;

function requireId () {
	if (hasRequiredId) return id.exports;
	hasRequiredId = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _node = _interopRequireDefault(/*@__PURE__*/ requireNode$1());
		var _types = /*@__PURE__*/ requireTypes();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		var ID = /*#__PURE__*/function (_Node) {
		  _inheritsLoose(ID, _Node);
		  function ID(opts) {
		    var _this;
		    _this = _Node.call(this, opts) || this;
		    _this.type = _types.ID;
		    return _this;
		  }
		  var _proto = ID.prototype;
		  _proto.valueToString = function valueToString() {
		    return '#' + _Node.prototype.valueToString.call(this);
		  };
		  return ID;
		}(_node["default"]);
		exports["default"] = ID;
		module.exports = exports.default; 
	} (id, id.exports));
	return id.exports;
}

var tag = {exports: {}};

var namespace = {exports: {}};

var hasRequiredNamespace;

function requireNamespace () {
	if (hasRequiredNamespace) return namespace.exports;
	hasRequiredNamespace = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _cssesc = _interopRequireDefault(/*@__PURE__*/ requireCssesc());
		var _util = /*@__PURE__*/ requireUtil$1();
		var _node = _interopRequireDefault(/*@__PURE__*/ requireNode$1());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
		function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
		function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		var Namespace = /*#__PURE__*/function (_Node) {
		  _inheritsLoose(Namespace, _Node);
		  function Namespace() {
		    return _Node.apply(this, arguments) || this;
		  }
		  var _proto = Namespace.prototype;
		  _proto.qualifiedName = function qualifiedName(value) {
		    if (this.namespace) {
		      return this.namespaceString + "|" + value;
		    } else {
		      return value;
		    }
		  };
		  _proto.valueToString = function valueToString() {
		    return this.qualifiedName(_Node.prototype.valueToString.call(this));
		  };
		  _createClass(Namespace, [{
		    key: "namespace",
		    get: function get() {
		      return this._namespace;
		    },
		    set: function set(namespace) {
		      if (namespace === true || namespace === "*" || namespace === "&") {
		        this._namespace = namespace;
		        if (this.raws) {
		          delete this.raws.namespace;
		        }
		        return;
		      }
		      var escaped = (0, _cssesc["default"])(namespace, {
		        isIdentifier: true
		      });
		      this._namespace = namespace;
		      if (escaped !== namespace) {
		        (0, _util.ensureObject)(this, "raws");
		        this.raws.namespace = escaped;
		      } else if (this.raws) {
		        delete this.raws.namespace;
		      }
		    }
		  }, {
		    key: "ns",
		    get: function get() {
		      return this._namespace;
		    },
		    set: function set(namespace) {
		      this.namespace = namespace;
		    }
		  }, {
		    key: "namespaceString",
		    get: function get() {
		      if (this.namespace) {
		        var ns = this.stringifyProperty("namespace");
		        if (ns === true) {
		          return '';
		        } else {
		          return ns;
		        }
		      } else {
		        return '';
		      }
		    }
		  }]);
		  return Namespace;
		}(_node["default"]);
		exports["default"] = Namespace;
		module.exports = exports.default; 
	} (namespace, namespace.exports));
	return namespace.exports;
}

var hasRequiredTag;

function requireTag () {
	if (hasRequiredTag) return tag.exports;
	hasRequiredTag = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _namespace = _interopRequireDefault(/*@__PURE__*/ requireNamespace());
		var _types = /*@__PURE__*/ requireTypes();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		var Tag = /*#__PURE__*/function (_Namespace) {
		  _inheritsLoose(Tag, _Namespace);
		  function Tag(opts) {
		    var _this;
		    _this = _Namespace.call(this, opts) || this;
		    _this.type = _types.TAG;
		    return _this;
		  }
		  return Tag;
		}(_namespace["default"]);
		exports["default"] = Tag;
		module.exports = exports.default; 
	} (tag, tag.exports));
	return tag.exports;
}

var string = {exports: {}};

var hasRequiredString;

function requireString () {
	if (hasRequiredString) return string.exports;
	hasRequiredString = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _node = _interopRequireDefault(/*@__PURE__*/ requireNode$1());
		var _types = /*@__PURE__*/ requireTypes();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		var String = /*#__PURE__*/function (_Node) {
		  _inheritsLoose(String, _Node);
		  function String(opts) {
		    var _this;
		    _this = _Node.call(this, opts) || this;
		    _this.type = _types.STRING;
		    return _this;
		  }
		  return String;
		}(_node["default"]);
		exports["default"] = String;
		module.exports = exports.default; 
	} (string, string.exports));
	return string.exports;
}

var pseudo = {exports: {}};

var hasRequiredPseudo;

function requirePseudo () {
	if (hasRequiredPseudo) return pseudo.exports;
	hasRequiredPseudo = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _container = _interopRequireDefault(/*@__PURE__*/ requireContainer());
		var _types = /*@__PURE__*/ requireTypes();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		var Pseudo = /*#__PURE__*/function (_Container) {
		  _inheritsLoose(Pseudo, _Container);
		  function Pseudo(opts) {
		    var _this;
		    _this = _Container.call(this, opts) || this;
		    _this.type = _types.PSEUDO;
		    return _this;
		  }
		  var _proto = Pseudo.prototype;
		  _proto.toString = function toString() {
		    var params = this.length ? '(' + this.map(String).join(',') + ')' : '';
		    return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join('');
		  };
		  return Pseudo;
		}(_container["default"]);
		exports["default"] = Pseudo;
		module.exports = exports.default; 
	} (pseudo, pseudo.exports));
	return pseudo.exports;
}

var attribute = {};

var node;
var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;
	/**
	 * For Node.js, simply re-export the core `util.deprecate` function.
	 */

	node = require$$0.deprecate;
	return node;
}

var hasRequiredAttribute;

function requireAttribute () {
	if (hasRequiredAttribute) return attribute;
	hasRequiredAttribute = 1;
	(function (exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		exports.unescapeValue = unescapeValue;
		var _cssesc = _interopRequireDefault(/*@__PURE__*/ requireCssesc());
		var _unesc = _interopRequireDefault(/*@__PURE__*/ requireUnesc());
		var _namespace = _interopRequireDefault(/*@__PURE__*/ requireNamespace());
		var _types = /*@__PURE__*/ requireTypes();
		var _CSSESC_QUOTE_OPTIONS;
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
		function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
		function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		var deprecate = /*@__PURE__*/ requireNode();
		var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
		var warnOfDeprecatedValueAssignment = deprecate(function () {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. " + "Call attribute.setValue() instead.");
		var warnOfDeprecatedQuotedAssignment = deprecate(function () {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
		var warnOfDeprecatedConstructor = deprecate(function () {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
		function unescapeValue(value) {
		  var deprecatedUsage = false;
		  var quoteMark = null;
		  var unescaped = value;
		  var m = unescaped.match(WRAPPED_IN_QUOTES);
		  if (m) {
		    quoteMark = m[1];
		    unescaped = m[2];
		  }
		  unescaped = (0, _unesc["default"])(unescaped);
		  if (unescaped !== value) {
		    deprecatedUsage = true;
		  }
		  return {
		    deprecatedUsage: deprecatedUsage,
		    unescaped: unescaped,
		    quoteMark: quoteMark
		  };
		}
		function handleDeprecatedContructorOpts(opts) {
		  if (opts.quoteMark !== undefined) {
		    return opts;
		  }
		  if (opts.value === undefined) {
		    return opts;
		  }
		  warnOfDeprecatedConstructor();
		  var _unescapeValue = unescapeValue(opts.value),
		    quoteMark = _unescapeValue.quoteMark,
		    unescaped = _unescapeValue.unescaped;
		  if (!opts.raws) {
		    opts.raws = {};
		  }
		  if (opts.raws.value === undefined) {
		    opts.raws.value = opts.value;
		  }
		  opts.value = unescaped;
		  opts.quoteMark = quoteMark;
		  return opts;
		}
		var Attribute = /*#__PURE__*/function (_Namespace) {
		  _inheritsLoose(Attribute, _Namespace);
		  function Attribute(opts) {
		    var _this;
		    if (opts === void 0) {
		      opts = {};
		    }
		    _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
		    _this.type = _types.ATTRIBUTE;
		    _this.raws = _this.raws || {};
		    Object.defineProperty(_this.raws, 'unquoted', {
		      get: deprecate(function () {
		        return _this.value;
		      }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
		      set: deprecate(function () {
		        return _this.value;
		      }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
		    });
		    _this._constructed = true;
		    return _this;
		  }

		  /**
		   * Returns the Attribute's value quoted such that it would be legal to use
		   * in the value of a css file. The original value's quotation setting
		   * used for stringification is left unchanged. See `setValue(value, options)`
		   * if you want to control the quote settings of a new value for the attribute.
		   *
		   * You can also change the quotation used for the current value by setting quoteMark.
		   *
		   * Options:
		   *   * quoteMark {'"' | "'" | null} - Use this value to quote the value. If this
		   *     option is not set, the original value for quoteMark will be used. If
		   *     indeterminate, a double quote is used. The legal values are:
		   *     * `null` - the value will be unquoted and characters will be escaped as necessary.
		   *     * `'` - the value will be quoted with a single quote and single quotes are escaped.
		   *     * `"` - the value will be quoted with a double quote and double quotes are escaped.
		   *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark
		   *     over the quoteMark option value.
		   *   * smart {boolean} - if true, will select a quote mark based on the value
		   *     and the other options specified here. See the `smartQuoteMark()`
		   *     method.
		   **/
		  var _proto = Attribute.prototype;
		  _proto.getQuotedValue = function getQuotedValue(options) {
		    if (options === void 0) {
		      options = {};
		    }
		    var quoteMark = this._determineQuoteMark(options);
		    var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
		    var escaped = (0, _cssesc["default"])(this._value, cssescopts);
		    return escaped;
		  };
		  _proto._determineQuoteMark = function _determineQuoteMark(options) {
		    return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
		  }

		  /**
		   * Set the unescaped value with the specified quotation options. The value
		   * provided must not include any wrapping quote marks -- those quotes will
		   * be interpreted as part of the value and escaped accordingly.
		   */;
		  _proto.setValue = function setValue(value, options) {
		    if (options === void 0) {
		      options = {};
		    }
		    this._value = value;
		    this._quoteMark = this._determineQuoteMark(options);
		    this._syncRawValue();
		  }

		  /**
		   * Intelligently select a quoteMark value based on the value's contents. If
		   * the value is a legal CSS ident, it will not be quoted. Otherwise a quote
		   * mark will be picked that minimizes the number of escapes.
		   *
		   * If there's no clear winner, the quote mark from these options is used,
		   * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is
		   * true). If the quoteMark is unspecified, a double quote is used.
		   *
		   * @param options This takes the quoteMark and preferCurrentQuoteMark options
		   * from the quoteValue method.
		   */;
		  _proto.smartQuoteMark = function smartQuoteMark(options) {
		    var v = this.value;
		    var numSingleQuotes = v.replace(/[^']/g, '').length;
		    var numDoubleQuotes = v.replace(/[^"]/g, '').length;
		    if (numSingleQuotes + numDoubleQuotes === 0) {
		      var escaped = (0, _cssesc["default"])(v, {
		        isIdentifier: true
		      });
		      if (escaped === v) {
		        return Attribute.NO_QUOTE;
		      } else {
		        var pref = this.preferredQuoteMark(options);
		        if (pref === Attribute.NO_QUOTE) {
		          // pick a quote mark that isn't none and see if it's smaller
		          var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;
		          var opts = CSSESC_QUOTE_OPTIONS[quote];
		          var quoteValue = (0, _cssesc["default"])(v, opts);
		          if (quoteValue.length < escaped.length) {
		            return quote;
		          }
		        }
		        return pref;
		      }
		    } else if (numDoubleQuotes === numSingleQuotes) {
		      return this.preferredQuoteMark(options);
		    } else if (numDoubleQuotes < numSingleQuotes) {
		      return Attribute.DOUBLE_QUOTE;
		    } else {
		      return Attribute.SINGLE_QUOTE;
		    }
		  }

		  /**
		   * Selects the preferred quote mark based on the options and the current quote mark value.
		   * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`
		   * instead.
		   */;
		  _proto.preferredQuoteMark = function preferredQuoteMark(options) {
		    var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;
		    if (quoteMark === undefined) {
		      quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
		    }
		    if (quoteMark === undefined) {
		      quoteMark = Attribute.DOUBLE_QUOTE;
		    }
		    return quoteMark;
		  };
		  _proto._syncRawValue = function _syncRawValue() {
		    var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
		    if (rawValue === this._value) {
		      if (this.raws) {
		        delete this.raws.value;
		      }
		    } else {
		      this.raws.value = rawValue;
		    }
		  };
		  _proto._handleEscapes = function _handleEscapes(prop, value) {
		    if (this._constructed) {
		      var escaped = (0, _cssesc["default"])(value, {
		        isIdentifier: true
		      });
		      if (escaped !== value) {
		        this.raws[prop] = escaped;
		      } else {
		        delete this.raws[prop];
		      }
		    }
		  };
		  _proto._spacesFor = function _spacesFor(name) {
		    var attrSpaces = {
		      before: '',
		      after: ''
		    };
		    var spaces = this.spaces[name] || {};
		    var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
		    return Object.assign(attrSpaces, spaces, rawSpaces);
		  };
		  _proto._stringFor = function _stringFor(name, spaceName, concat) {
		    if (spaceName === void 0) {
		      spaceName = name;
		    }
		    if (concat === void 0) {
		      concat = defaultAttrConcat;
		    }
		    var attrSpaces = this._spacesFor(spaceName);
		    return concat(this.stringifyProperty(name), attrSpaces);
		  }

		  /**
		   * returns the offset of the attribute part specified relative to the
		   * start of the node of the output string.
		   *
		   * * "ns" - alias for "namespace"
		   * * "namespace" - the namespace if it exists.
		   * * "attribute" - the attribute name
		   * * "attributeNS" - the start of the attribute or its namespace
		   * * "operator" - the match operator of the attribute
		   * * "value" - The value (string or identifier)
		   * * "insensitive" - the case insensitivity flag;
		   * @param part One of the possible values inside an attribute.
		   * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
		   */;
		  _proto.offsetOf = function offsetOf(name) {
		    var count = 1;
		    var attributeSpaces = this._spacesFor("attribute");
		    count += attributeSpaces.before.length;
		    if (name === "namespace" || name === "ns") {
		      return this.namespace ? count : -1;
		    }
		    if (name === "attributeNS") {
		      return count;
		    }
		    count += this.namespaceString.length;
		    if (this.namespace) {
		      count += 1;
		    }
		    if (name === "attribute") {
		      return count;
		    }
		    count += this.stringifyProperty("attribute").length;
		    count += attributeSpaces.after.length;
		    var operatorSpaces = this._spacesFor("operator");
		    count += operatorSpaces.before.length;
		    var operator = this.stringifyProperty("operator");
		    if (name === "operator") {
		      return operator ? count : -1;
		    }
		    count += operator.length;
		    count += operatorSpaces.after.length;
		    var valueSpaces = this._spacesFor("value");
		    count += valueSpaces.before.length;
		    var value = this.stringifyProperty("value");
		    if (name === "value") {
		      return value ? count : -1;
		    }
		    count += value.length;
		    count += valueSpaces.after.length;
		    var insensitiveSpaces = this._spacesFor("insensitive");
		    count += insensitiveSpaces.before.length;
		    if (name === "insensitive") {
		      return this.insensitive ? count : -1;
		    }
		    return -1;
		  };
		  _proto.toString = function toString() {
		    var _this2 = this;
		    var selector = [this.rawSpaceBefore, '['];
		    selector.push(this._stringFor('qualifiedAttribute', 'attribute'));
		    if (this.operator && (this.value || this.value === '')) {
		      selector.push(this._stringFor('operator'));
		      selector.push(this._stringFor('value'));
		      selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {
		        if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
		          attrSpaces.before = " ";
		        }
		        return defaultAttrConcat(attrValue, attrSpaces);
		      }));
		    }
		    selector.push(']');
		    selector.push(this.rawSpaceAfter);
		    return selector.join('');
		  };
		  _createClass(Attribute, [{
		    key: "quoted",
		    get: function get() {
		      var qm = this.quoteMark;
		      return qm === "'" || qm === '"';
		    },
		    set: function set(value) {
		      warnOfDeprecatedQuotedAssignment();
		    }

		    /**
		     * returns a single (`'`) or double (`"`) quote character if the value is quoted.
		     * returns `null` if the value is not quoted.
		     * returns `undefined` if the quotation state is unknown (this can happen when
		     * the attribute is constructed without specifying a quote mark.)
		     */
		  }, {
		    key: "quoteMark",
		    get: function get() {
		      return this._quoteMark;
		    }

		    /**
		     * Set the quote mark to be used by this attribute's value.
		     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute
		     * value is updated accordingly.
		     *
		     * @param {"'" | '"' | null} quoteMark The quote mark or `null` if the value should be unquoted.
		     */,
		    set: function set(quoteMark) {
		      if (!this._constructed) {
		        this._quoteMark = quoteMark;
		        return;
		      }
		      if (this._quoteMark !== quoteMark) {
		        this._quoteMark = quoteMark;
		        this._syncRawValue();
		      }
		    }
		  }, {
		    key: "qualifiedAttribute",
		    get: function get() {
		      return this.qualifiedName(this.raws.attribute || this.attribute);
		    }
		  }, {
		    key: "insensitiveFlag",
		    get: function get() {
		      return this.insensitive ? 'i' : '';
		    }
		  }, {
		    key: "value",
		    get: function get() {
		      return this._value;
		    },
		    set:
		    /**
		     * Before 3.0, the value had to be set to an escaped value including any wrapped
		     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
		     * is unescaped during parsing and any quote marks are removed.
		     *
		     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
		     * a deprecation warning is raised when the new value contains any characters that would
		     * require escaping (including if it contains wrapped quotes).
		     *
		     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
		     * how the new value is quoted.
		     */
		    function set(v) {
		      if (this._constructed) {
		        var _unescapeValue2 = unescapeValue(v),
		          deprecatedUsage = _unescapeValue2.deprecatedUsage,
		          unescaped = _unescapeValue2.unescaped,
		          quoteMark = _unescapeValue2.quoteMark;
		        if (deprecatedUsage) {
		          warnOfDeprecatedValueAssignment();
		        }
		        if (unescaped === this._value && quoteMark === this._quoteMark) {
		          return;
		        }
		        this._value = unescaped;
		        this._quoteMark = quoteMark;
		        this._syncRawValue();
		      } else {
		        this._value = v;
		      }
		    }
		  }, {
		    key: "insensitive",
		    get: function get() {
		      return this._insensitive;
		    }

		    /**
		     * Set the case insensitive flag.
		     * If the case insensitive flag changes, the raw (escaped) value at `attr.raws.insensitiveFlag`
		     * of the attribute is updated accordingly.
		     *
		     * @param {true | false} insensitive true if the attribute should match case-insensitively.
		     */,
		    set: function set(insensitive) {
		      if (!insensitive) {
		        this._insensitive = false;

		        // "i" and "I" can be used in "this.raws.insensitiveFlag" to store the original notation.
		        // When setting `attr.insensitive = false` both should be erased to ensure correct serialization.
		        if (this.raws && (this.raws.insensitiveFlag === 'I' || this.raws.insensitiveFlag === 'i')) {
		          this.raws.insensitiveFlag = undefined;
		        }
		      }
		      this._insensitive = insensitive;
		    }
		  }, {
		    key: "attribute",
		    get: function get() {
		      return this._attribute;
		    },
		    set: function set(name) {
		      this._handleEscapes("attribute", name);
		      this._attribute = name;
		    }
		  }]);
		  return Attribute;
		}(_namespace["default"]);
		exports["default"] = Attribute;
		Attribute.NO_QUOTE = null;
		Attribute.SINGLE_QUOTE = "'";
		Attribute.DOUBLE_QUOTE = '"';
		var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
		  "'": {
		    quotes: 'single',
		    wrap: true
		  },
		  '"': {
		    quotes: 'double',
		    wrap: true
		  }
		}, _CSSESC_QUOTE_OPTIONS[null] = {
		  isIdentifier: true
		}, _CSSESC_QUOTE_OPTIONS);
		function defaultAttrConcat(attrValue, attrSpaces) {
		  return "" + attrSpaces.before + attrValue + attrSpaces.after;
		} 
	} (attribute));
	return attribute;
}

var universal = {exports: {}};

var hasRequiredUniversal;

function requireUniversal () {
	if (hasRequiredUniversal) return universal.exports;
	hasRequiredUniversal = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _namespace = _interopRequireDefault(/*@__PURE__*/ requireNamespace());
		var _types = /*@__PURE__*/ requireTypes();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		var Universal = /*#__PURE__*/function (_Namespace) {
		  _inheritsLoose(Universal, _Namespace);
		  function Universal(opts) {
		    var _this;
		    _this = _Namespace.call(this, opts) || this;
		    _this.type = _types.UNIVERSAL;
		    _this.value = '*';
		    return _this;
		  }
		  return Universal;
		}(_namespace["default"]);
		exports["default"] = Universal;
		module.exports = exports.default; 
	} (universal, universal.exports));
	return universal.exports;
}

var combinator = {exports: {}};

var hasRequiredCombinator;

function requireCombinator () {
	if (hasRequiredCombinator) return combinator.exports;
	hasRequiredCombinator = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _node = _interopRequireDefault(/*@__PURE__*/ requireNode$1());
		var _types = /*@__PURE__*/ requireTypes();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		var Combinator = /*#__PURE__*/function (_Node) {
		  _inheritsLoose(Combinator, _Node);
		  function Combinator(opts) {
		    var _this;
		    _this = _Node.call(this, opts) || this;
		    _this.type = _types.COMBINATOR;
		    return _this;
		  }
		  return Combinator;
		}(_node["default"]);
		exports["default"] = Combinator;
		module.exports = exports.default; 
	} (combinator, combinator.exports));
	return combinator.exports;
}

var nesting = {exports: {}};

var hasRequiredNesting;

function requireNesting () {
	if (hasRequiredNesting) return nesting.exports;
	hasRequiredNesting = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _node = _interopRequireDefault(/*@__PURE__*/ requireNode$1());
		var _types = /*@__PURE__*/ requireTypes();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		var Nesting = /*#__PURE__*/function (_Node) {
		  _inheritsLoose(Nesting, _Node);
		  function Nesting(opts) {
		    var _this;
		    _this = _Node.call(this, opts) || this;
		    _this.type = _types.NESTING;
		    _this.value = '&';
		    return _this;
		  }
		  return Nesting;
		}(_node["default"]);
		exports["default"] = Nesting;
		module.exports = exports.default; 
	} (nesting, nesting.exports));
	return nesting.exports;
}

var sortAscending = {exports: {}};

var hasRequiredSortAscending;

function requireSortAscending () {
	if (hasRequiredSortAscending) return sortAscending.exports;
	hasRequiredSortAscending = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = sortAscending;
		function sortAscending(list) {
		  return list.sort(function (a, b) {
		    return a - b;
		  });
		}
		module.exports = exports.default; 
	} (sortAscending, sortAscending.exports));
	return sortAscending.exports;
}

var tokenize = {};

var tokenTypes = {};

var hasRequiredTokenTypes;

function requireTokenTypes () {
	if (hasRequiredTokenTypes) return tokenTypes;
	hasRequiredTokenTypes = 1;

	tokenTypes.__esModule = true;
	tokenTypes.word = tokenTypes.tilde = tokenTypes.tab = tokenTypes.str = tokenTypes.space = tokenTypes.slash = tokenTypes.singleQuote = tokenTypes.semicolon = tokenTypes.plus = tokenTypes.pipe = tokenTypes.openSquare = tokenTypes.openParenthesis = tokenTypes.newline = tokenTypes.greaterThan = tokenTypes.feed = tokenTypes.equals = tokenTypes.doubleQuote = tokenTypes.dollar = tokenTypes.cr = tokenTypes.comment = tokenTypes.comma = tokenTypes.combinator = tokenTypes.colon = tokenTypes.closeSquare = tokenTypes.closeParenthesis = tokenTypes.caret = tokenTypes.bang = tokenTypes.backslash = tokenTypes.at = tokenTypes.asterisk = tokenTypes.ampersand = void 0;
	var ampersand = 38; // `&`.charCodeAt(0);
	tokenTypes.ampersand = ampersand;
	var asterisk = 42; // `*`.charCodeAt(0);
	tokenTypes.asterisk = asterisk;
	var at = 64; // `@`.charCodeAt(0);
	tokenTypes.at = at;
	var comma = 44; // `,`.charCodeAt(0);
	tokenTypes.comma = comma;
	var colon = 58; // `:`.charCodeAt(0);
	tokenTypes.colon = colon;
	var semicolon = 59; // `;`.charCodeAt(0);
	tokenTypes.semicolon = semicolon;
	var openParenthesis = 40; // `(`.charCodeAt(0);
	tokenTypes.openParenthesis = openParenthesis;
	var closeParenthesis = 41; // `)`.charCodeAt(0);
	tokenTypes.closeParenthesis = closeParenthesis;
	var openSquare = 91; // `[`.charCodeAt(0);
	tokenTypes.openSquare = openSquare;
	var closeSquare = 93; // `]`.charCodeAt(0);
	tokenTypes.closeSquare = closeSquare;
	var dollar = 36; // `$`.charCodeAt(0);
	tokenTypes.dollar = dollar;
	var tilde = 126; // `~`.charCodeAt(0);
	tokenTypes.tilde = tilde;
	var caret = 94; // `^`.charCodeAt(0);
	tokenTypes.caret = caret;
	var plus = 43; // `+`.charCodeAt(0);
	tokenTypes.plus = plus;
	var equals = 61; // `=`.charCodeAt(0);
	tokenTypes.equals = equals;
	var pipe = 124; // `|`.charCodeAt(0);
	tokenTypes.pipe = pipe;
	var greaterThan = 62; // `>`.charCodeAt(0);
	tokenTypes.greaterThan = greaterThan;
	var space = 32; // ` `.charCodeAt(0);
	tokenTypes.space = space;
	var singleQuote = 39; // `'`.charCodeAt(0);
	tokenTypes.singleQuote = singleQuote;
	var doubleQuote = 34; // `"`.charCodeAt(0);
	tokenTypes.doubleQuote = doubleQuote;
	var slash = 47; // `/`.charCodeAt(0);
	tokenTypes.slash = slash;
	var bang = 33; // `!`.charCodeAt(0);
	tokenTypes.bang = bang;
	var backslash = 92; // '\\'.charCodeAt(0);
	tokenTypes.backslash = backslash;
	var cr = 13; // '\r'.charCodeAt(0);
	tokenTypes.cr = cr;
	var feed = 12; // '\f'.charCodeAt(0);
	tokenTypes.feed = feed;
	var newline = 10; // '\n'.charCodeAt(0);
	tokenTypes.newline = newline;
	var tab = 9; // '\t'.charCodeAt(0);

	// Expose aliases primarily for readability.
	tokenTypes.tab = tab;
	var str = singleQuote;

	// No good single character representation!
	tokenTypes.str = str;
	var comment = -1;
	tokenTypes.comment = comment;
	var word = -2;
	tokenTypes.word = word;
	var combinator = -3;
	tokenTypes.combinator = combinator;
	return tokenTypes;
}

var hasRequiredTokenize;

function requireTokenize () {
	if (hasRequiredTokenize) return tokenize;
	hasRequiredTokenize = 1;
	(function (exports) {

		exports.__esModule = true;
		exports.FIELDS = void 0;
		exports["default"] = tokenize;
		var t = _interopRequireWildcard(/*@__PURE__*/ requireTokenTypes());
		var _unescapable, _wordDelimiters;
		function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
		function _interopRequireWildcard(obj, nodeInterop) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
		var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
		var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
		var hex = {};
		var hexChars = "0123456789abcdefABCDEF";
		for (var i = 0; i < hexChars.length; i++) {
		  hex[hexChars.charCodeAt(i)] = true;
		}

		/**
		 *  Returns the last index of the bar css word
		 * @param {string} css The string in which the word begins
		 * @param {number} start The index into the string where word's first letter occurs
		 */
		function consumeWord(css, start) {
		  var next = start;
		  var code;
		  do {
		    code = css.charCodeAt(next);
		    if (wordDelimiters[code]) {
		      return next - 1;
		    } else if (code === t.backslash) {
		      next = consumeEscape(css, next) + 1;
		    } else {
		      // All other characters are part of the word
		      next++;
		    }
		  } while (next < css.length);
		  return next - 1;
		}

		/**
		 *  Returns the last index of the escape sequence
		 * @param {string} css The string in which the sequence begins
		 * @param {number} start The index into the string where escape character (`\`) occurs.
		 */
		function consumeEscape(css, start) {
		  var next = start;
		  var code = css.charCodeAt(next + 1);
		  if (unescapable[code]) ; else if (hex[code]) {
		    var hexDigits = 0;
		    // consume up to 6 hex chars
		    do {
		      next++;
		      hexDigits++;
		      code = css.charCodeAt(next + 1);
		    } while (hex[code] && hexDigits < 6);
		    // if fewer than 6 hex chars, a trailing space ends the escape
		    if (hexDigits < 6 && code === t.space) {
		      next++;
		    }
		  } else {
		    // the next char is part of the current word
		    next++;
		  }
		  return next;
		}
		var FIELDS = {
		  TYPE: 0,
		  START_LINE: 1,
		  START_COL: 2,
		  END_LINE: 3,
		  END_COL: 4,
		  START_POS: 5,
		  END_POS: 6
		};
		exports.FIELDS = FIELDS;
		function tokenize(input) {
		  var tokens = [];
		  var css = input.css.valueOf();
		  var _css = css,
		    length = _css.length;
		  var offset = -1;
		  var line = 1;
		  var start = 0;
		  var end = 0;
		  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;
		  function unclosed(what, fix) {
		    if (input.safe) {
		      // fyi: this is never set to true.
		      css += fix;
		      next = css.length - 1;
		    } else {
		      throw input.error('Unclosed ' + what, line, start - offset, start);
		    }
		  }
		  while (start < length) {
		    code = css.charCodeAt(start);
		    if (code === t.newline) {
		      offset = start;
		      line += 1;
		    }
		    switch (code) {
		      case t.space:
		      case t.tab:
		      case t.newline:
		      case t.cr:
		      case t.feed:
		        next = start;
		        do {
		          next += 1;
		          code = css.charCodeAt(next);
		          if (code === t.newline) {
		            offset = next;
		            line += 1;
		          }
		        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);
		        tokenType = t.space;
		        endLine = line;
		        endColumn = next - offset - 1;
		        end = next;
		        break;
		      case t.plus:
		      case t.greaterThan:
		      case t.tilde:
		      case t.pipe:
		        next = start;
		        do {
		          next += 1;
		          code = css.charCodeAt(next);
		        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);
		        tokenType = t.combinator;
		        endLine = line;
		        endColumn = start - offset;
		        end = next;
		        break;

		      // Consume these characters as single tokens.
		      case t.asterisk:
		      case t.ampersand:
		      case t.bang:
		      case t.comma:
		      case t.equals:
		      case t.dollar:
		      case t.caret:
		      case t.openSquare:
		      case t.closeSquare:
		      case t.colon:
		      case t.semicolon:
		      case t.openParenthesis:
		      case t.closeParenthesis:
		        next = start;
		        tokenType = code;
		        endLine = line;
		        endColumn = start - offset;
		        end = next + 1;
		        break;
		      case t.singleQuote:
		      case t.doubleQuote:
		        quote = code === t.singleQuote ? "'" : '"';
		        next = start;
		        do {
		          escaped = false;
		          next = css.indexOf(quote, next + 1);
		          if (next === -1) {
		            unclosed('quote', quote);
		          }
		          escapePos = next;
		          while (css.charCodeAt(escapePos - 1) === t.backslash) {
		            escapePos -= 1;
		            escaped = !escaped;
		          }
		        } while (escaped);
		        tokenType = t.str;
		        endLine = line;
		        endColumn = start - offset;
		        end = next + 1;
		        break;
		      default:
		        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
		          next = css.indexOf('*/', start + 2) + 1;
		          if (next === 0) {
		            unclosed('comment', '*/');
		          }
		          content = css.slice(start, next + 1);
		          lines = content.split('\n');
		          last = lines.length - 1;
		          if (last > 0) {
		            nextLine = line + last;
		            nextOffset = next - lines[last].length;
		          } else {
		            nextLine = line;
		            nextOffset = offset;
		          }
		          tokenType = t.comment;
		          line = nextLine;
		          endLine = nextLine;
		          endColumn = next - nextOffset;
		        } else if (code === t.slash) {
		          next = start;
		          tokenType = code;
		          endLine = line;
		          endColumn = start - offset;
		          end = next + 1;
		        } else {
		          next = consumeWord(css, start);
		          tokenType = t.word;
		          endLine = line;
		          endColumn = next - offset;
		        }
		        end = next + 1;
		        break;
		    }

		    // Ensure that the token structure remains consistent
		    tokens.push([tokenType,
		    // [0] Token type
		    line,
		    // [1] Starting line
		    start - offset,
		    // [2] Starting column
		    endLine,
		    // [3] Ending line
		    endColumn,
		    // [4] Ending column
		    start,
		    // [5] Start position / Source index
		    end // [6] End position
		    ]);

		    // Reset offset for the next token
		    if (nextOffset) {
		      offset = nextOffset;
		      nextOffset = null;
		    }
		    start = end;
		  }
		  return tokens;
		} 
	} (tokenize));
	return tokenize;
}

var hasRequiredParser;

function requireParser () {
	if (hasRequiredParser) return parser.exports;
	hasRequiredParser = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _root = _interopRequireDefault(/*@__PURE__*/ requireRoot());
		var _selector = _interopRequireDefault(/*@__PURE__*/ requireSelector());
		var _className = _interopRequireDefault(/*@__PURE__*/ requireClassName());
		var _comment = _interopRequireDefault(/*@__PURE__*/ requireComment());
		var _id = _interopRequireDefault(/*@__PURE__*/ requireId());
		var _tag = _interopRequireDefault(/*@__PURE__*/ requireTag());
		var _string = _interopRequireDefault(/*@__PURE__*/ requireString());
		var _pseudo = _interopRequireDefault(/*@__PURE__*/ requirePseudo());
		var _attribute = _interopRequireWildcard(/*@__PURE__*/ requireAttribute());
		var _universal = _interopRequireDefault(/*@__PURE__*/ requireUniversal());
		var _combinator = _interopRequireDefault(/*@__PURE__*/ requireCombinator());
		var _nesting = _interopRequireDefault(/*@__PURE__*/ requireNesting());
		var _sortAscending = _interopRequireDefault(/*@__PURE__*/ requireSortAscending());
		var _tokenize = _interopRequireWildcard(/*@__PURE__*/ requireTokenize());
		var tokens = _interopRequireWildcard(/*@__PURE__*/ requireTokenTypes());
		var types = _interopRequireWildcard(/*@__PURE__*/ requireTypes());
		var _util = /*@__PURE__*/ requireUtil$1();
		var _WHITESPACE_TOKENS, _Object$assign;
		function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
		function _interopRequireWildcard(obj, nodeInterop) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
		function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
		var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
		var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
		function tokenStart(token) {
		  return {
		    line: token[_tokenize.FIELDS.START_LINE],
		    column: token[_tokenize.FIELDS.START_COL]
		  };
		}
		function tokenEnd(token) {
		  return {
		    line: token[_tokenize.FIELDS.END_LINE],
		    column: token[_tokenize.FIELDS.END_COL]
		  };
		}
		function getSource(startLine, startColumn, endLine, endColumn) {
		  return {
		    start: {
		      line: startLine,
		      column: startColumn
		    },
		    end: {
		      line: endLine,
		      column: endColumn
		    }
		  };
		}
		function getTokenSource(token) {
		  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
		}
		function getTokenSourceSpan(startToken, endToken) {
		  if (!startToken) {
		    return undefined;
		  }
		  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
		}
		function unescapeProp(node, prop) {
		  var value = node[prop];
		  if (typeof value !== "string") {
		    return;
		  }
		  if (value.indexOf("\\") !== -1) {
		    (0, _util.ensureObject)(node, 'raws');
		    node[prop] = (0, _util.unesc)(value);
		    if (node.raws[prop] === undefined) {
		      node.raws[prop] = value;
		    }
		  }
		  return node;
		}
		function indexesOf(array, item) {
		  var i = -1;
		  var indexes = [];
		  while ((i = array.indexOf(item, i + 1)) !== -1) {
		    indexes.push(i);
		  }
		  return indexes;
		}
		function uniqs() {
		  var list = Array.prototype.concat.apply([], arguments);
		  return list.filter(function (item, i) {
		    return i === list.indexOf(item);
		  });
		}
		var Parser = /*#__PURE__*/function () {
		  function Parser(rule, options) {
		    if (options === void 0) {
		      options = {};
		    }
		    this.rule = rule;
		    this.options = Object.assign({
		      lossy: false,
		      safe: false
		    }, options);
		    this.position = 0;
		    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;
		    this.tokens = (0, _tokenize["default"])({
		      css: this.css,
		      error: this._errorGenerator(),
		      safe: this.options.safe
		    });
		    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
		    this.root = new _root["default"]({
		      source: rootSource
		    });
		    this.root.errorGenerator = this._errorGenerator();
		    var selector = new _selector["default"]({
		      source: {
		        start: {
		          line: 1,
		          column: 1
		        }
		      },
		      sourceIndex: 0
		    });
		    this.root.append(selector);
		    this.current = selector;
		    this.loop();
		  }
		  var _proto = Parser.prototype;
		  _proto._errorGenerator = function _errorGenerator() {
		    var _this = this;
		    return function (message, errorOptions) {
		      if (typeof _this.rule === 'string') {
		        return new Error(message);
		      }
		      return _this.rule.error(message, errorOptions);
		    };
		  };
		  _proto.attribute = function attribute() {
		    var attr = [];
		    var startingToken = this.currToken;
		    this.position++;
		    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
		      attr.push(this.currToken);
		      this.position++;
		    }
		    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
		      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
		    }
		    var len = attr.length;
		    var node = {
		      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
		      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
		    };
		    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
		      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);
		    }
		    var pos = 0;
		    var spaceBefore = '';
		    var commentBefore = '';
		    var lastAdded = null;
		    var spaceAfterMeaningfulToken = false;
		    while (pos < len) {
		      var token = attr[pos];
		      var content = this.content(token);
		      var next = attr[pos + 1];
		      switch (token[_tokenize.FIELDS.TYPE]) {
		        case tokens.space:
		          // if (
		          //     len === 1 ||
		          //     pos === 0 && this.content(next) === '|'
		          // ) {
		          //     return this.expected('attribute', token[TOKEN.START_POS], content);
		          // }
		          spaceAfterMeaningfulToken = true;
		          if (this.options.lossy) {
		            break;
		          }
		          if (lastAdded) {
		            (0, _util.ensureObject)(node, 'spaces', lastAdded);
		            var prevContent = node.spaces[lastAdded].after || '';
		            node.spaces[lastAdded].after = prevContent + content;
		            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;
		            if (existingComment) {
		              node.raws.spaces[lastAdded].after = existingComment + content;
		            }
		          } else {
		            spaceBefore = spaceBefore + content;
		            commentBefore = commentBefore + content;
		          }
		          break;
		        case tokens.asterisk:
		          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
		            node.operator = content;
		            lastAdded = 'operator';
		          } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
		            if (spaceBefore) {
		              (0, _util.ensureObject)(node, 'spaces', 'attribute');
		              node.spaces.attribute.before = spaceBefore;
		              spaceBefore = '';
		            }
		            if (commentBefore) {
		              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
		              node.raws.spaces.attribute.before = spaceBefore;
		              commentBefore = '';
		            }
		            node.namespace = (node.namespace || "") + content;
		            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;
		            if (rawValue) {
		              node.raws.namespace += content;
		            }
		            lastAdded = 'namespace';
		          }
		          spaceAfterMeaningfulToken = false;
		          break;
		        case tokens.dollar:
		          if (lastAdded === "value") {
		            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');
		            node.value += "$";
		            if (oldRawValue) {
		              node.raws.value = oldRawValue + "$";
		            }
		            break;
		          }
		        // Falls through
		        case tokens.caret:
		          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
		            node.operator = content;
		            lastAdded = 'operator';
		          }
		          spaceAfterMeaningfulToken = false;
		          break;
		        case tokens.combinator:
		          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
		            node.operator = content;
		            lastAdded = 'operator';
		          }
		          if (content !== '|') {
		            spaceAfterMeaningfulToken = false;
		            break;
		          }
		          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
		            node.operator = content;
		            lastAdded = 'operator';
		          } else if (!node.namespace && !node.attribute) {
		            node.namespace = true;
		          }
		          spaceAfterMeaningfulToken = false;
		          break;
		        case tokens.word:
		          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals &&
		          // this look-ahead probably fails with comment nodes involved.
		          !node.operator && !node.namespace) {
		            node.namespace = content;
		            lastAdded = 'namespace';
		          } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
		            if (spaceBefore) {
		              (0, _util.ensureObject)(node, 'spaces', 'attribute');
		              node.spaces.attribute.before = spaceBefore;
		              spaceBefore = '';
		            }
		            if (commentBefore) {
		              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
		              node.raws.spaces.attribute.before = commentBefore;
		              commentBefore = '';
		            }
		            node.attribute = (node.attribute || "") + content;
		            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;
		            if (_rawValue) {
		              node.raws.attribute += content;
		            }
		            lastAdded = 'attribute';
		          } else if (!node.value && node.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node.quoteMark)) {
		            var _unescaped = (0, _util.unesc)(content);
		            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';
		            var oldValue = node.value || '';
		            node.value = oldValue + _unescaped;
		            node.quoteMark = null;
		            if (_unescaped !== content || _oldRawValue) {
		              (0, _util.ensureObject)(node, 'raws');
		              node.raws.value = (_oldRawValue || oldValue) + content;
		            }
		            lastAdded = 'value';
		          } else {
		            var insensitive = content === 'i' || content === "I";
		            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {
		              node.insensitive = insensitive;
		              if (!insensitive || content === "I") {
		                (0, _util.ensureObject)(node, 'raws');
		                node.raws.insensitiveFlag = content;
		              }
		              lastAdded = 'insensitive';
		              if (spaceBefore) {
		                (0, _util.ensureObject)(node, 'spaces', 'insensitive');
		                node.spaces.insensitive.before = spaceBefore;
		                spaceBefore = '';
		              }
		              if (commentBefore) {
		                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');
		                node.raws.spaces.insensitive.before = commentBefore;
		                commentBefore = '';
		              }
		            } else if (node.value || node.value === '') {
		              lastAdded = 'value';
		              node.value += content;
		              if (node.raws.value) {
		                node.raws.value += content;
		              }
		            }
		          }
		          spaceAfterMeaningfulToken = false;
		          break;
		        case tokens.str:
		          if (!node.attribute || !node.operator) {
		            return this.error("Expected an attribute followed by an operator preceding the string.", {
		              index: token[_tokenize.FIELDS.START_POS]
		            });
		          }
		          var _unescapeValue = (0, _attribute.unescapeValue)(content),
		            unescaped = _unescapeValue.unescaped,
		            quoteMark = _unescapeValue.quoteMark;
		          node.value = unescaped;
		          node.quoteMark = quoteMark;
		          lastAdded = 'value';
		          (0, _util.ensureObject)(node, 'raws');
		          node.raws.value = content;
		          spaceAfterMeaningfulToken = false;
		          break;
		        case tokens.equals:
		          if (!node.attribute) {
		            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);
		          }
		          if (node.value) {
		            return this.error('Unexpected "=" found; an operator was already defined.', {
		              index: token[_tokenize.FIELDS.START_POS]
		            });
		          }
		          node.operator = node.operator ? node.operator + content : content;
		          lastAdded = 'operator';
		          spaceAfterMeaningfulToken = false;
		          break;
		        case tokens.comment:
		          if (lastAdded) {
		            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {
		              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';
		              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;
		              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);
		              node.raws.spaces[lastAdded].after = rawLastComment + content;
		            } else {
		              var lastValue = node[lastAdded] || '';
		              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;
		              (0, _util.ensureObject)(node, 'raws');
		              node.raws[lastAdded] = rawLastValue + content;
		            }
		          } else {
		            commentBefore = commentBefore + content;
		          }
		          break;
		        default:
		          return this.error("Unexpected \"" + content + "\" found.", {
		            index: token[_tokenize.FIELDS.START_POS]
		          });
		      }
		      pos++;
		    }
		    unescapeProp(node, "attribute");
		    unescapeProp(node, "namespace");
		    this.newNode(new _attribute["default"](node));
		    this.position++;
		  }

		  /**
		   * return a node containing meaningless garbage up to (but not including) the specified token position.
		   * if the token position is negative, all remaining tokens are consumed.
		   *
		   * This returns an array containing a single string node if all whitespace,
		   * otherwise an array of comment nodes with space before and after.
		   *
		   * These tokens are not added to the current selector, the caller can add them or use them to amend
		   * a previous node's space metadata.
		   *
		   * In lossy mode, this returns only comments.
		   */;
		  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
		    if (stopPosition < 0) {
		      stopPosition = this.tokens.length;
		    }
		    var startPosition = this.position;
		    var nodes = [];
		    var space = "";
		    var lastComment = undefined;
		    do {
		      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
		        if (!this.options.lossy) {
		          space += this.content();
		        }
		      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
		        var spaces = {};
		        if (space) {
		          spaces.before = space;
		          space = "";
		        }
		        lastComment = new _comment["default"]({
		          value: this.content(),
		          source: getTokenSource(this.currToken),
		          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
		          spaces: spaces
		        });
		        nodes.push(lastComment);
		      }
		    } while (++this.position < stopPosition);
		    if (space) {
		      if (lastComment) {
		        lastComment.spaces.after = space;
		      } else if (!this.options.lossy) {
		        var firstToken = this.tokens[startPosition];
		        var lastToken = this.tokens[this.position - 1];
		        nodes.push(new _string["default"]({
		          value: '',
		          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
		          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
		          spaces: {
		            before: space,
		            after: ''
		          }
		        }));
		      }
		    }
		    return nodes;
		  }

		  /**
		   *
		   * @param {*} nodes
		   */;
		  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
		    var _this2 = this;
		    if (requiredSpace === void 0) {
		      requiredSpace = false;
		    }
		    var space = "";
		    var rawSpace = "";
		    nodes.forEach(function (n) {
		      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);
		      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);
		      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
		      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
		    });
		    if (rawSpace === space) {
		      rawSpace = undefined;
		    }
		    var result = {
		      space: space,
		      rawSpace: rawSpace
		    };
		    return result;
		  };
		  _proto.isNamedCombinator = function isNamedCombinator(position) {
		    if (position === void 0) {
		      position = this.position;
		    }
		    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
		  };
		  _proto.namedCombinator = function namedCombinator() {
		    if (this.isNamedCombinator()) {
		      var nameRaw = this.content(this.tokens[this.position + 1]);
		      var name = (0, _util.unesc)(nameRaw).toLowerCase();
		      var raws = {};
		      if (name !== nameRaw) {
		        raws.value = "/" + nameRaw + "/";
		      }
		      var node = new _combinator["default"]({
		        value: "/" + name + "/",
		        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
		        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
		        raws: raws
		      });
		      this.position = this.position + 3;
		      return node;
		    } else {
		      this.unexpected();
		    }
		  };
		  _proto.combinator = function combinator() {
		    var _this3 = this;
		    if (this.content() === '|') {
		      return this.namespace();
		    }
		    // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.
		    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
		    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
		      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
		      if (nodes.length > 0) {
		        var last = this.current.last;
		        if (last) {
		          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),
		            space = _this$convertWhitespa.space,
		            rawSpace = _this$convertWhitespa.rawSpace;
		          if (rawSpace !== undefined) {
		            last.rawSpaceAfter += rawSpace;
		          }
		          last.spaces.after += space;
		        } else {
		          nodes.forEach(function (n) {
		            return _this3.newNode(n);
		          });
		        }
		      }
		      return;
		    }
		    var firstToken = this.currToken;
		    var spaceOrDescendantSelectorNodes = undefined;
		    if (nextSigTokenPos > this.position) {
		      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
		    }
		    var node;
		    if (this.isNamedCombinator()) {
		      node = this.namedCombinator();
		    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
		      node = new _combinator["default"]({
		        value: this.content(),
		        source: getTokenSource(this.currToken),
		        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
		      });
		      this.position++;
		    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) ; else if (!spaceOrDescendantSelectorNodes) {
		      this.unexpected();
		    }
		    if (node) {
		      if (spaceOrDescendantSelectorNodes) {
		        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),
		          _space = _this$convertWhitespa2.space,
		          _rawSpace = _this$convertWhitespa2.rawSpace;
		        node.spaces.before = _space;
		        node.rawSpaceBefore = _rawSpace;
		      }
		    } else {
		      // descendant combinator
		      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),
		        _space2 = _this$convertWhitespa3.space,
		        _rawSpace2 = _this$convertWhitespa3.rawSpace;
		      if (!_rawSpace2) {
		        _rawSpace2 = _space2;
		      }
		      var spaces = {};
		      var raws = {
		        spaces: {}
		      };
		      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {
		        spaces.before = _space2.slice(0, _space2.length - 1);
		        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
		      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {
		        spaces.after = _space2.slice(1);
		        raws.spaces.after = _rawSpace2.slice(1);
		      } else {
		        raws.value = _rawSpace2;
		      }
		      node = new _combinator["default"]({
		        value: ' ',
		        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
		        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
		        spaces: spaces,
		        raws: raws
		      });
		    }
		    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
		      node.spaces.after = this.optionalSpace(this.content());
		      this.position++;
		    }
		    return this.newNode(node);
		  };
		  _proto.comma = function comma() {
		    if (this.position === this.tokens.length - 1) {
		      this.root.trailingComma = true;
		      this.position++;
		      return;
		    }
		    this.current._inferEndPosition();
		    var selector = new _selector["default"]({
		      source: {
		        start: tokenStart(this.tokens[this.position + 1])
		      },
		      sourceIndex: this.tokens[this.position + 1][_tokenize.FIELDS.START_POS]
		    });
		    this.current.parent.append(selector);
		    this.current = selector;
		    this.position++;
		  };
		  _proto.comment = function comment() {
		    var current = this.currToken;
		    this.newNode(new _comment["default"]({
		      value: this.content(),
		      source: getTokenSource(current),
		      sourceIndex: current[_tokenize.FIELDS.START_POS]
		    }));
		    this.position++;
		  };
		  _proto.error = function error(message, opts) {
		    throw this.root.error(message, opts);
		  };
		  _proto.missingBackslash = function missingBackslash() {
		    return this.error('Expected a backslash preceding the semicolon.', {
		      index: this.currToken[_tokenize.FIELDS.START_POS]
		    });
		  };
		  _proto.missingParenthesis = function missingParenthesis() {
		    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
		  };
		  _proto.missingSquareBracket = function missingSquareBracket() {
		    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
		  };
		  _proto.unexpected = function unexpected() {
		    return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
		  };
		  _proto.unexpectedPipe = function unexpectedPipe() {
		    return this.error("Unexpected '|'.", this.currToken[_tokenize.FIELDS.START_POS]);
		  };
		  _proto.namespace = function namespace() {
		    var before = this.prevToken && this.content(this.prevToken) || true;
		    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
		      this.position++;
		      return this.word(before);
		    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
		      this.position++;
		      return this.universal(before);
		    }
		    this.unexpectedPipe();
		  };
		  _proto.nesting = function nesting() {
		    if (this.nextToken) {
		      var nextContent = this.content(this.nextToken);
		      if (nextContent === "|") {
		        this.position++;
		        return;
		      }
		    }
		    var current = this.currToken;
		    this.newNode(new _nesting["default"]({
		      value: this.content(),
		      source: getTokenSource(current),
		      sourceIndex: current[_tokenize.FIELDS.START_POS]
		    }));
		    this.position++;
		  };
		  _proto.parentheses = function parentheses() {
		    var last = this.current.last;
		    var unbalanced = 1;
		    this.position++;
		    if (last && last.type === types.PSEUDO) {
		      var selector = new _selector["default"]({
		        source: {
		          start: tokenStart(this.tokens[this.position])
		        },
		        sourceIndex: this.tokens[this.position][_tokenize.FIELDS.START_POS]
		      });
		      var cache = this.current;
		      last.append(selector);
		      this.current = selector;
		      while (this.position < this.tokens.length && unbalanced) {
		        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
		          unbalanced++;
		        }
		        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
		          unbalanced--;
		        }
		        if (unbalanced) {
		          this.parse();
		        } else {
		          this.current.source.end = tokenEnd(this.currToken);
		          this.current.parent.source.end = tokenEnd(this.currToken);
		          this.position++;
		        }
		      }
		      this.current = cache;
		    } else {
		      // I think this case should be an error. It's used to implement a basic parse of media queries
		      // but I don't think it's a good idea.
		      var parenStart = this.currToken;
		      var parenValue = "(";
		      var parenEnd;
		      while (this.position < this.tokens.length && unbalanced) {
		        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
		          unbalanced++;
		        }
		        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
		          unbalanced--;
		        }
		        parenEnd = this.currToken;
		        parenValue += this.parseParenthesisToken(this.currToken);
		        this.position++;
		      }
		      if (last) {
		        last.appendToPropertyAndEscape("value", parenValue, parenValue);
		      } else {
		        this.newNode(new _string["default"]({
		          value: parenValue,
		          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
		          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
		        }));
		      }
		    }
		    if (unbalanced) {
		      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
		    }
		  };
		  _proto.pseudo = function pseudo() {
		    var _this4 = this;
		    var pseudoStr = '';
		    var startingToken = this.currToken;
		    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
		      pseudoStr += this.content();
		      this.position++;
		    }
		    if (!this.currToken) {
		      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
		    }
		    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
		      this.splitWord(false, function (first, length) {
		        pseudoStr += first;
		        _this4.newNode(new _pseudo["default"]({
		          value: pseudoStr,
		          source: getTokenSourceSpan(startingToken, _this4.currToken),
		          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
		        }));
		        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
		          _this4.error('Misplaced parenthesis.', {
		            index: _this4.nextToken[_tokenize.FIELDS.START_POS]
		          });
		        }
		      });
		    } else {
		      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);
		    }
		  };
		  _proto.space = function space() {
		    var content = this.content();
		    // Handle space before and after the selector
		    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {
		      return node.type === 'comment';
		    })) {
		      this.spaces = this.optionalSpace(content);
		      this.position++;
		    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
		      this.current.last.spaces.after = this.optionalSpace(content);
		      this.position++;
		    } else {
		      this.combinator();
		    }
		  };
		  _proto.string = function string() {
		    var current = this.currToken;
		    this.newNode(new _string["default"]({
		      value: this.content(),
		      source: getTokenSource(current),
		      sourceIndex: current[_tokenize.FIELDS.START_POS]
		    }));
		    this.position++;
		  };
		  _proto.universal = function universal(namespace) {
		    var nextToken = this.nextToken;
		    if (nextToken && this.content(nextToken) === '|') {
		      this.position++;
		      return this.namespace();
		    }
		    var current = this.currToken;
		    this.newNode(new _universal["default"]({
		      value: this.content(),
		      source: getTokenSource(current),
		      sourceIndex: current[_tokenize.FIELDS.START_POS]
		    }), namespace);
		    this.position++;
		  };
		  _proto.splitWord = function splitWord(namespace, firstCallback) {
		    var _this5 = this;
		    var nextToken = this.nextToken;
		    var word = this.content();
		    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
		      this.position++;
		      var current = this.content();
		      word += current;
		      if (current.lastIndexOf('\\') === current.length - 1) {
		        var next = this.nextToken;
		        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
		          word += this.requiredSpace(this.content(next));
		          this.position++;
		        }
		      }
		      nextToken = this.nextToken;
		    }
		    var hasClass = indexesOf(word, '.').filter(function (i) {
		      // Allow escaped dot within class name
		      var escapedDot = word[i - 1] === '\\';
		      // Allow decimal numbers percent in @keyframes
		      var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
		      return !escapedDot && !isKeyframesPercent;
		    });
		    var hasId = indexesOf(word, '#').filter(function (i) {
		      return word[i - 1] !== '\\';
		    });
		    // Eliminate Sass interpolations from the list of id indexes
		    var interpolations = indexesOf(word, '#{');
		    if (interpolations.length) {
		      hasId = hasId.filter(function (hashIndex) {
		        return !~interpolations.indexOf(hashIndex);
		      });
		    }
		    var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
		    indices.forEach(function (ind, i) {
		      var index = indices[i + 1] || word.length;
		      var value = word.slice(ind, index);
		      if (i === 0 && firstCallback) {
		        return firstCallback.call(_this5, value, indices.length);
		      }
		      var node;
		      var current = _this5.currToken;
		      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];
		      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));
		      if (~hasClass.indexOf(ind)) {
		        var classNameOpts = {
		          value: value.slice(1),
		          source: source,
		          sourceIndex: sourceIndex
		        };
		        node = new _className["default"](unescapeProp(classNameOpts, "value"));
		      } else if (~hasId.indexOf(ind)) {
		        var idOpts = {
		          value: value.slice(1),
		          source: source,
		          sourceIndex: sourceIndex
		        };
		        node = new _id["default"](unescapeProp(idOpts, "value"));
		      } else {
		        var tagOpts = {
		          value: value,
		          source: source,
		          sourceIndex: sourceIndex
		        };
		        unescapeProp(tagOpts, "value");
		        node = new _tag["default"](tagOpts);
		      }
		      _this5.newNode(node, namespace);
		      // Ensure that the namespace is used only once
		      namespace = null;
		    });
		    this.position++;
		  };
		  _proto.word = function word(namespace) {
		    var nextToken = this.nextToken;
		    if (nextToken && this.content(nextToken) === '|') {
		      this.position++;
		      return this.namespace();
		    }
		    return this.splitWord(namespace);
		  };
		  _proto.loop = function loop() {
		    while (this.position < this.tokens.length) {
		      this.parse(true);
		    }
		    this.current._inferEndPosition();
		    return this.root;
		  };
		  _proto.parse = function parse(throwOnParenthesis) {
		    switch (this.currToken[_tokenize.FIELDS.TYPE]) {
		      case tokens.space:
		        this.space();
		        break;
		      case tokens.comment:
		        this.comment();
		        break;
		      case tokens.openParenthesis:
		        this.parentheses();
		        break;
		      case tokens.closeParenthesis:
		        if (throwOnParenthesis) {
		          this.missingParenthesis();
		        }
		        break;
		      case tokens.openSquare:
		        this.attribute();
		        break;
		      case tokens.dollar:
		      case tokens.caret:
		      case tokens.equals:
		      case tokens.word:
		        this.word();
		        break;
		      case tokens.colon:
		        this.pseudo();
		        break;
		      case tokens.comma:
		        this.comma();
		        break;
		      case tokens.asterisk:
		        this.universal();
		        break;
		      case tokens.ampersand:
		        this.nesting();
		        break;
		      case tokens.slash:
		      case tokens.combinator:
		        this.combinator();
		        break;
		      case tokens.str:
		        this.string();
		        break;
		      // These cases throw; no break needed.
		      case tokens.closeSquare:
		        this.missingSquareBracket();
		      case tokens.semicolon:
		        this.missingBackslash();
		      default:
		        this.unexpected();
		    }
		  }

		  /**
		   * Helpers
		   */;
		  _proto.expected = function expected(description, index, found) {
		    if (Array.isArray(description)) {
		      var last = description.pop();
		      description = description.join(', ') + " or " + last;
		    }
		    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';
		    if (!found) {
		      return this.error("Expected " + an + " " + description + ".", {
		        index: index
		      });
		    }
		    return this.error("Expected " + an + " " + description + ", found \"" + found + "\" instead.", {
		      index: index
		    });
		  };
		  _proto.requiredSpace = function requiredSpace(space) {
		    return this.options.lossy ? ' ' : space;
		  };
		  _proto.optionalSpace = function optionalSpace(space) {
		    return this.options.lossy ? '' : space;
		  };
		  _proto.lossySpace = function lossySpace(space, required) {
		    if (this.options.lossy) {
		      return required ? ' ' : '';
		    } else {
		      return space;
		    }
		  };
		  _proto.parseParenthesisToken = function parseParenthesisToken(token) {
		    var content = this.content(token);
		    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
		      return this.requiredSpace(content);
		    } else {
		      return content;
		    }
		  };
		  _proto.newNode = function newNode(node, namespace) {
		    if (namespace) {
		      if (/^ +$/.test(namespace)) {
		        if (!this.options.lossy) {
		          this.spaces = (this.spaces || '') + namespace;
		        }
		        namespace = true;
		      }
		      node.namespace = namespace;
		      unescapeProp(node, "namespace");
		    }
		    if (this.spaces) {
		      node.spaces.before = this.spaces;
		      this.spaces = '';
		    }
		    return this.current.append(node);
		  };
		  _proto.content = function content(token) {
		    if (token === void 0) {
		      token = this.currToken;
		    }
		    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
		  };
		  /**
		   * returns the index of the next non-whitespace, non-comment token.
		   * returns -1 if no meaningful token is found.
		   */
		  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
		    if (startPosition === void 0) {
		      startPosition = this.position + 1;
		    }
		    var searchPosition = startPosition;
		    while (searchPosition < this.tokens.length) {
		      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
		        searchPosition++;
		        continue;
		      } else {
		        return searchPosition;
		      }
		    }
		    return -1;
		  };
		  _createClass(Parser, [{
		    key: "currToken",
		    get: function get() {
		      return this.tokens[this.position];
		    }
		  }, {
		    key: "nextToken",
		    get: function get() {
		      return this.tokens[this.position + 1];
		    }
		  }, {
		    key: "prevToken",
		    get: function get() {
		      return this.tokens[this.position - 1];
		    }
		  }]);
		  return Parser;
		}();
		exports["default"] = Parser;
		module.exports = exports.default; 
	} (parser, parser.exports));
	return parser.exports;
}

var hasRequiredProcessor;

function requireProcessor () {
	if (hasRequiredProcessor) return processor.exports;
	hasRequiredProcessor = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _parser = _interopRequireDefault(/*@__PURE__*/ requireParser());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		var Processor = /*#__PURE__*/function () {
		  function Processor(func, options) {
		    this.func = func || function noop() {};
		    this.funcRes = null;
		    this.options = options;
		  }
		  var _proto = Processor.prototype;
		  _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
		    if (options === void 0) {
		      options = {};
		    }
		    var merged = Object.assign({}, this.options, options);
		    if (merged.updateSelector === false) {
		      return false;
		    } else {
		      return typeof rule !== "string";
		    }
		  };
		  _proto._isLossy = function _isLossy(options) {
		    if (options === void 0) {
		      options = {};
		    }
		    var merged = Object.assign({}, this.options, options);
		    if (merged.lossless === false) {
		      return true;
		    } else {
		      return false;
		    }
		  };
		  _proto._root = function _root(rule, options) {
		    if (options === void 0) {
		      options = {};
		    }
		    var parser = new _parser["default"](rule, this._parseOptions(options));
		    return parser.root;
		  };
		  _proto._parseOptions = function _parseOptions(options) {
		    return {
		      lossy: this._isLossy(options)
		    };
		  };
		  _proto._run = function _run(rule, options) {
		    var _this = this;
		    if (options === void 0) {
		      options = {};
		    }
		    return new Promise(function (resolve, reject) {
		      try {
		        var root = _this._root(rule, options);
		        Promise.resolve(_this.func(root)).then(function (transform) {
		          var string = undefined;
		          if (_this._shouldUpdateSelector(rule, options)) {
		            string = root.toString();
		            rule.selector = string;
		          }
		          return {
		            transform: transform,
		            root: root,
		            string: string
		          };
		        }).then(resolve, reject);
		      } catch (e) {
		        reject(e);
		        return;
		      }
		    });
		  };
		  _proto._runSync = function _runSync(rule, options) {
		    if (options === void 0) {
		      options = {};
		    }
		    var root = this._root(rule, options);
		    var transform = this.func(root);
		    if (transform && typeof transform.then === "function") {
		      throw new Error("Selector processor returned a promise to a synchronous call.");
		    }
		    var string = undefined;
		    if (options.updateSelector && typeof rule !== "string") {
		      string = root.toString();
		      rule.selector = string;
		    }
		    return {
		      transform: transform,
		      root: root,
		      string: string
		    };
		  }

		  /**
		   * Process rule into a selector AST.
		   *
		   * @param rule {postcss.Rule | string} The css selector to be processed
		   * @param options The options for processing
		   * @returns {Promise<parser.Root>} The AST of the selector after processing it.
		   */;
		  _proto.ast = function ast(rule, options) {
		    return this._run(rule, options).then(function (result) {
		      return result.root;
		    });
		  }

		  /**
		   * Process rule into a selector AST synchronously.
		   *
		   * @param rule {postcss.Rule | string} The css selector to be processed
		   * @param options The options for processing
		   * @returns {parser.Root} The AST of the selector after processing it.
		   */;
		  _proto.astSync = function astSync(rule, options) {
		    return this._runSync(rule, options).root;
		  }

		  /**
		   * Process a selector into a transformed value asynchronously
		   *
		   * @param rule {postcss.Rule | string} The css selector to be processed
		   * @param options The options for processing
		   * @returns {Promise<any>} The value returned by the processor.
		   */;
		  _proto.transform = function transform(rule, options) {
		    return this._run(rule, options).then(function (result) {
		      return result.transform;
		    });
		  }

		  /**
		   * Process a selector into a transformed value synchronously.
		   *
		   * @param rule {postcss.Rule | string} The css selector to be processed
		   * @param options The options for processing
		   * @returns {any} The value returned by the processor.
		   */;
		  _proto.transformSync = function transformSync(rule, options) {
		    return this._runSync(rule, options).transform;
		  }

		  /**
		   * Process a selector into a new selector string asynchronously.
		   *
		   * @param rule {postcss.Rule | string} The css selector to be processed
		   * @param options The options for processing
		   * @returns {string} the selector after processing.
		   */;
		  _proto.process = function process(rule, options) {
		    return this._run(rule, options).then(function (result) {
		      return result.string || result.root.toString();
		    });
		  }

		  /**
		   * Process a selector into a new selector string synchronously.
		   *
		   * @param rule {postcss.Rule | string} The css selector to be processed
		   * @param options The options for processing
		   * @returns {string} the selector after processing.
		   */;
		  _proto.processSync = function processSync(rule, options) {
		    var result = this._runSync(rule, options);
		    return result.string || result.root.toString();
		  };
		  return Processor;
		}();
		exports["default"] = Processor;
		module.exports = exports.default; 
	} (processor, processor.exports));
	return processor.exports;
}

var selectors = {};

var constructors = {};

var hasRequiredConstructors;

function requireConstructors () {
	if (hasRequiredConstructors) return constructors;
	hasRequiredConstructors = 1;

	constructors.__esModule = true;
	constructors.universal = constructors.tag = constructors.string = constructors.selector = constructors.root = constructors.pseudo = constructors.nesting = constructors.id = constructors.comment = constructors.combinator = constructors.className = constructors.attribute = void 0;
	var _attribute = _interopRequireDefault(/*@__PURE__*/ requireAttribute());
	var _className = _interopRequireDefault(/*@__PURE__*/ requireClassName());
	var _combinator = _interopRequireDefault(/*@__PURE__*/ requireCombinator());
	var _comment = _interopRequireDefault(/*@__PURE__*/ requireComment());
	var _id = _interopRequireDefault(/*@__PURE__*/ requireId());
	var _nesting = _interopRequireDefault(/*@__PURE__*/ requireNesting());
	var _pseudo = _interopRequireDefault(/*@__PURE__*/ requirePseudo());
	var _root = _interopRequireDefault(/*@__PURE__*/ requireRoot());
	var _selector = _interopRequireDefault(/*@__PURE__*/ requireSelector());
	var _string = _interopRequireDefault(/*@__PURE__*/ requireString());
	var _tag = _interopRequireDefault(/*@__PURE__*/ requireTag());
	var _universal = _interopRequireDefault(/*@__PURE__*/ requireUniversal());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	var attribute = function attribute(opts) {
	  return new _attribute["default"](opts);
	};
	constructors.attribute = attribute;
	var className = function className(opts) {
	  return new _className["default"](opts);
	};
	constructors.className = className;
	var combinator = function combinator(opts) {
	  return new _combinator["default"](opts);
	};
	constructors.combinator = combinator;
	var comment = function comment(opts) {
	  return new _comment["default"](opts);
	};
	constructors.comment = comment;
	var id = function id(opts) {
	  return new _id["default"](opts);
	};
	constructors.id = id;
	var nesting = function nesting(opts) {
	  return new _nesting["default"](opts);
	};
	constructors.nesting = nesting;
	var pseudo = function pseudo(opts) {
	  return new _pseudo["default"](opts);
	};
	constructors.pseudo = pseudo;
	var root = function root(opts) {
	  return new _root["default"](opts);
	};
	constructors.root = root;
	var selector = function selector(opts) {
	  return new _selector["default"](opts);
	};
	constructors.selector = selector;
	var string = function string(opts) {
	  return new _string["default"](opts);
	};
	constructors.string = string;
	var tag = function tag(opts) {
	  return new _tag["default"](opts);
	};
	constructors.tag = tag;
	var universal = function universal(opts) {
	  return new _universal["default"](opts);
	};
	constructors.universal = universal;
	return constructors;
}

var guards = {};

var hasRequiredGuards;

function requireGuards () {
	if (hasRequiredGuards) return guards;
	hasRequiredGuards = 1;

	guards.__esModule = true;
	guards.isComment = guards.isCombinator = guards.isClassName = guards.isAttribute = void 0;
	guards.isContainer = isContainer;
	guards.isIdentifier = void 0;
	guards.isNamespace = isNamespace;
	guards.isNesting = void 0;
	guards.isNode = isNode;
	guards.isPseudo = void 0;
	guards.isPseudoClass = isPseudoClass;
	guards.isPseudoElement = isPseudoElement;
	guards.isUniversal = guards.isTag = guards.isString = guards.isSelector = guards.isRoot = void 0;
	var _types = /*@__PURE__*/ requireTypes();
	var _IS_TYPE;
	var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
	function isNode(node) {
	  return typeof node === "object" && IS_TYPE[node.type];
	}
	function isNodeType(type, node) {
	  return isNode(node) && node.type === type;
	}
	var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
	guards.isAttribute = isAttribute;
	var isClassName = isNodeType.bind(null, _types.CLASS);
	guards.isClassName = isClassName;
	var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
	guards.isCombinator = isCombinator;
	var isComment = isNodeType.bind(null, _types.COMMENT);
	guards.isComment = isComment;
	var isIdentifier = isNodeType.bind(null, _types.ID);
	guards.isIdentifier = isIdentifier;
	var isNesting = isNodeType.bind(null, _types.NESTING);
	guards.isNesting = isNesting;
	var isPseudo = isNodeType.bind(null, _types.PSEUDO);
	guards.isPseudo = isPseudo;
	var isRoot = isNodeType.bind(null, _types.ROOT);
	guards.isRoot = isRoot;
	var isSelector = isNodeType.bind(null, _types.SELECTOR);
	guards.isSelector = isSelector;
	var isString = isNodeType.bind(null, _types.STRING);
	guards.isString = isString;
	var isTag = isNodeType.bind(null, _types.TAG);
	guards.isTag = isTag;
	var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
	guards.isUniversal = isUniversal;
	function isPseudoElement(node) {
	  return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after" || node.value.toLowerCase() === ":first-letter" || node.value.toLowerCase() === ":first-line");
	}
	function isPseudoClass(node) {
	  return isPseudo(node) && !isPseudoElement(node);
	}
	function isContainer(node) {
	  return !!(isNode(node) && node.walk);
	}
	function isNamespace(node) {
	  return isAttribute(node) || isTag(node);
	}
	return guards;
}

var hasRequiredSelectors;

function requireSelectors () {
	if (hasRequiredSelectors) return selectors;
	hasRequiredSelectors = 1;
	(function (exports) {

		exports.__esModule = true;
		var _types = /*@__PURE__*/ requireTypes();
		Object.keys(_types).forEach(function (key) {
		  if (key === "default" || key === "__esModule") return;
		  if (key in exports && exports[key] === _types[key]) return;
		  exports[key] = _types[key];
		});
		var _constructors = /*@__PURE__*/ requireConstructors();
		Object.keys(_constructors).forEach(function (key) {
		  if (key === "default" || key === "__esModule") return;
		  if (key in exports && exports[key] === _constructors[key]) return;
		  exports[key] = _constructors[key];
		});
		var _guards = /*@__PURE__*/ requireGuards();
		Object.keys(_guards).forEach(function (key) {
		  if (key === "default" || key === "__esModule") return;
		  if (key in exports && exports[key] === _guards[key]) return;
		  exports[key] = _guards[key];
		}); 
	} (selectors));
	return selectors;
}

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist.exports;
	hasRequiredDist = 1;
	(function (module, exports) {

		exports.__esModule = true;
		exports["default"] = void 0;
		var _processor = _interopRequireDefault(/*@__PURE__*/ requireProcessor());
		var selectors = _interopRequireWildcard(/*@__PURE__*/ requireSelectors());
		function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
		function _interopRequireWildcard(obj, nodeInterop) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		var parser = function parser(processor) {
		  return new _processor["default"](processor);
		};
		Object.assign(parser, selectors);
		delete parser.__esModule;
		var _default = parser;
		exports["default"] = _default;
		module.exports = exports.default; 
	} (dist, dist.exports));
	return dist.exports;
}

var distExports = /*@__PURE__*/ requireDist();
var selectorParser = /*@__PURE__*/getDefaultExportFromCjs(distExports);

const animationNameRE = /^(-\w+-)?animation-name$/;
const animationRE = /^(-\w+-)?animation$/;
const scopedPlugin = (id = "") => {
  const keyframes = /* @__PURE__ */ Object.create(null);
  const shortId = id.replace(/^data-v-/, "");
  return {
    postcssPlugin: "vue-sfc-scoped",
    Rule(rule) {
      processRule(id, rule);
    },
    AtRule(node) {
      if (/-?keyframes$/.test(node.name) && !node.params.endsWith(`-${shortId}`)) {
        keyframes[node.params] = node.params = node.params + "-" + shortId;
      }
    },
    OnceExit(root) {
      if (Object.keys(keyframes).length) {
        root.walkDecls((decl) => {
          if (animationNameRE.test(decl.prop)) {
            decl.value = decl.value.split(",").map((v) => keyframes[v.trim()] || v.trim()).join(",");
          }
          if (animationRE.test(decl.prop)) {
            decl.value = decl.value.split(",").map((v) => {
              const vals = v.trim().split(/\s+/);
              const i = vals.findIndex((val) => keyframes[val]);
              if (i !== -1) {
                vals.splice(i, 1, keyframes[vals[i]]);
                return vals.join(" ");
              } else {
                return v;
              }
            }).join(",");
          }
        });
      }
    }
  };
};
const processedRules = /* @__PURE__ */ new WeakSet();
function processRule(id, rule) {
  if (processedRules.has(rule) || rule.parent && rule.parent.type === "atrule" && /-?keyframes$/.test(rule.parent.name)) {
    return;
  }
  processedRules.add(rule);
  let deep = false;
  let parent = rule.parent;
  while (parent && parent.type !== "root") {
    if (parent.__deep) {
      deep = true;
      break;
    }
    parent = parent.parent;
  }
  rule.selector = selectorParser((selectorRoot) => {
    selectorRoot.each((selector) => {
      rewriteSelector(id, rule, selector, selectorRoot, deep);
    });
  }).processSync(rule.selector);
}
function rewriteSelector(id, rule, selector, selectorRoot, deep, slotted = false) {
  let node = null;
  let shouldInject = !deep;
  selector.each((n) => {
    if (n.type === "combinator" && (n.value === ">>>" || n.value === "/deep/")) {
      n.value = " ";
      n.spaces.before = n.spaces.after = "";
      warn(
        `the >>> and /deep/ combinators have been deprecated. Use :deep() instead.`
      );
      return false;
    }
    if (n.type === "pseudo") {
      const { value } = n;
      if (value === ":deep" || value === "::v-deep") {
        rule.__deep = true;
        if (n.nodes.length) {
          let last = n;
          n.nodes[0].each((ss) => {
            selector.insertAfter(last, ss);
            last = ss;
          });
          const prev = selector.at(selector.index(n) - 1);
          if (!prev || !isSpaceCombinator(prev)) {
            selector.insertAfter(
              n,
              selectorParser.combinator({
                value: " "
              })
            );
          }
          selector.removeChild(n);
        } else {
          warn(
            `${value} usage as a combinator has been deprecated. Use :deep(<inner-selector>) instead of ${value} <inner-selector>.`
          );
          const prev = selector.at(selector.index(n) - 1);
          if (prev && isSpaceCombinator(prev)) {
            selector.removeChild(prev);
          }
          selector.removeChild(n);
        }
        return false;
      }
      if (value === ":slotted" || value === "::v-slotted") {
        rewriteSelector(
          id,
          rule,
          n.nodes[0],
          selectorRoot,
          deep,
          true
        );
        let last = n;
        n.nodes[0].each((ss) => {
          selector.insertAfter(last, ss);
          last = ss;
        });
        selector.removeChild(n);
        shouldInject = false;
        return false;
      }
      if (value === ":global" || value === "::v-global") {
        selector.replaceWith(n.nodes[0]);
        return false;
      }
    }
    if (n.type === "universal") {
      const prev = selector.at(selector.index(n) - 1);
      const next = selector.at(selector.index(n) + 1);
      if (!prev) {
        if (next) {
          if (next.type === "combinator" && next.value === " ") {
            selector.removeChild(next);
          }
          selector.removeChild(n);
          return;
        } else {
          node = selectorParser.combinator({
            value: ""
          });
          selector.insertBefore(n, node);
          selector.removeChild(n);
          return false;
        }
      }
      if (node) return;
    }
    if (n.type !== "pseudo" && n.type !== "combinator" || n.type === "pseudo" && (n.value === ":is" || n.value === ":where") && !node) {
      node = n;
    }
  });
  if (rule.nodes.some((node2) => node2.type === "rule")) {
    const deep2 = rule.__deep;
    if (!deep2) {
      extractAndWrapNodes(rule);
      const atruleNodes = rule.nodes.filter((node2) => node2.type === "atrule");
      for (const atnode of atruleNodes) {
        extractAndWrapNodes(atnode);
      }
    }
    shouldInject = deep2;
  }
  if (node) {
    const { type, value } = node;
    if (type === "pseudo" && (value === ":is" || value === ":where")) {
      node.nodes.forEach(
        (value2) => rewriteSelector(id, rule, value2, selectorRoot, deep, slotted)
      );
      shouldInject = false;
    }
  }
  if (node) {
    node.spaces.after = "";
  } else {
    selector.first.spaces.before = "";
  }
  if (shouldInject) {
    const idToAdd = slotted ? id + "-s" : id;
    selector.insertAfter(
      // If node is null it means we need to inject [id] at the start
      // insertAfter can handle `null` here
      node,
      selectorParser.attribute({
        attribute: idToAdd,
        value: idToAdd,
        raws: {},
        quoteMark: `"`
      })
    );
  }
}
function isSpaceCombinator(node) {
  return node.type === "combinator" && /^\s+$/.test(node.value);
}
function extractAndWrapNodes(parentNode) {
  if (!parentNode.nodes) return;
  const nodes = parentNode.nodes.filter(
    (node) => node.type === "decl" || node.type === "comment"
  );
  if (nodes.length) {
    for (const node of nodes) {
      parentNode.removeChild(node);
    }
    const wrappedRule = new Rule({
      nodes,
      selector: "&"
    });
    parentNode.prepend(wrappedRule);
  }
}
scopedPlugin.postcss = true;

var sourceMap = {};

var sourceMapGenerator = {};

var base64Vlq = {};

var base64 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBase64;

function requireBase64 () {
	if (hasRequiredBase64) return base64;
	hasRequiredBase64 = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	base64.encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	base64.decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};
	return base64;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBase64Vlq;

function requireBase64Vlq () {
	if (hasRequiredBase64Vlq) return base64Vlq;
	hasRequiredBase64Vlq = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	var base64 = /*@__PURE__*/ requireBase64();

	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	base64Vlq.encode = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};
	return base64Vlq;
}

var util = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	(function (exports) {
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		/**
		 * This is a helper function for getting values from parameter/options
		 * objects.
		 *
		 * @param args The object we are extracting values from
		 * @param name The name of the property we are getting.
		 * @param defaultValue An optional value to return if the property is missing
		 * from the object. If this is not specified and the property is missing, an
		 * error will be thrown.
		 */
		function getArg(aArgs, aName, aDefaultValue) {
		  if (aName in aArgs) {
		    return aArgs[aName];
		  } else if (arguments.length === 3) {
		    return aDefaultValue;
		  } else {
		    throw new Error('"' + aName + '" is a required argument.');
		  }
		}
		exports.getArg = getArg;

		var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
		var dataUrlRegexp = /^data:.+\,.+$/;

		function urlParse(aUrl) {
		  var match = aUrl.match(urlRegexp);
		  if (!match) {
		    return null;
		  }
		  return {
		    scheme: match[1],
		    auth: match[2],
		    host: match[3],
		    port: match[4],
		    path: match[5]
		  };
		}
		exports.urlParse = urlParse;

		function urlGenerate(aParsedUrl) {
		  var url = '';
		  if (aParsedUrl.scheme) {
		    url += aParsedUrl.scheme + ':';
		  }
		  url += '//';
		  if (aParsedUrl.auth) {
		    url += aParsedUrl.auth + '@';
		  }
		  if (aParsedUrl.host) {
		    url += aParsedUrl.host;
		  }
		  if (aParsedUrl.port) {
		    url += ":" + aParsedUrl.port;
		  }
		  if (aParsedUrl.path) {
		    url += aParsedUrl.path;
		  }
		  return url;
		}
		exports.urlGenerate = urlGenerate;

		/**
		 * Normalizes a path, or the path portion of a URL:
		 *
		 * - Replaces consecutive slashes with one slash.
		 * - Removes unnecessary '.' parts.
		 * - Removes unnecessary '<dir>/..' parts.
		 *
		 * Based on code in the Node.js 'path' core module.
		 *
		 * @param aPath The path or url to normalize.
		 */
		function normalize(aPath) {
		  var path = aPath;
		  var url = urlParse(aPath);
		  if (url) {
		    if (!url.path) {
		      return aPath;
		    }
		    path = url.path;
		  }
		  var isAbsolute = exports.isAbsolute(path);

		  var parts = path.split(/\/+/);
		  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
		    part = parts[i];
		    if (part === '.') {
		      parts.splice(i, 1);
		    } else if (part === '..') {
		      up++;
		    } else if (up > 0) {
		      if (part === '') {
		        // The first part is blank if the path is absolute. Trying to go
		        // above the root is a no-op. Therefore we can remove all '..' parts
		        // directly after the root.
		        parts.splice(i + 1, up);
		        up = 0;
		      } else {
		        parts.splice(i, 2);
		        up--;
		      }
		    }
		  }
		  path = parts.join('/');

		  if (path === '') {
		    path = isAbsolute ? '/' : '.';
		  }

		  if (url) {
		    url.path = path;
		    return urlGenerate(url);
		  }
		  return path;
		}
		exports.normalize = normalize;

		/**
		 * Joins two paths/URLs.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be joined with the root.
		 *
		 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
		 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
		 *   first.
		 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
		 *   is updated with the result and aRoot is returned. Otherwise the result
		 *   is returned.
		 *   - If aPath is absolute, the result is aPath.
		 *   - Otherwise the two paths are joined with a slash.
		 * - Joining for example 'http://' and 'www.example.com' is also supported.
		 */
		function join(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }
		  if (aPath === "") {
		    aPath = ".";
		  }
		  var aPathUrl = urlParse(aPath);
		  var aRootUrl = urlParse(aRoot);
		  if (aRootUrl) {
		    aRoot = aRootUrl.path || '/';
		  }

		  // `join(foo, '//www.example.org')`
		  if (aPathUrl && !aPathUrl.scheme) {
		    if (aRootUrl) {
		      aPathUrl.scheme = aRootUrl.scheme;
		    }
		    return urlGenerate(aPathUrl);
		  }

		  if (aPathUrl || aPath.match(dataUrlRegexp)) {
		    return aPath;
		  }

		  // `join('http://', 'www.example.com')`
		  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
		    aRootUrl.host = aPath;
		    return urlGenerate(aRootUrl);
		  }

		  var joined = aPath.charAt(0) === '/'
		    ? aPath
		    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

		  if (aRootUrl) {
		    aRootUrl.path = joined;
		    return urlGenerate(aRootUrl);
		  }
		  return joined;
		}
		exports.join = join;

		exports.isAbsolute = function (aPath) {
		  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
		};

		/**
		 * Make a path relative to a URL or another path.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be made relative to aRoot.
		 */
		function relative(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }

		  aRoot = aRoot.replace(/\/$/, '');

		  // It is possible for the path to be above the root. In this case, simply
		  // checking whether the root is a prefix of the path won't work. Instead, we
		  // need to remove components from the root one by one, until either we find
		  // a prefix that fits, or we run out of components to remove.
		  var level = 0;
		  while (aPath.indexOf(aRoot + '/') !== 0) {
		    var index = aRoot.lastIndexOf("/");
		    if (index < 0) {
		      return aPath;
		    }

		    // If the only part of the root that is left is the scheme (i.e. http://,
		    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
		    // have exhausted all components, so the path is not relative to the root.
		    aRoot = aRoot.slice(0, index);
		    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
		      return aPath;
		    }

		    ++level;
		  }

		  // Make sure we add a "../" for each component we removed from the root.
		  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
		}
		exports.relative = relative;

		var supportsNullProto = (function () {
		  var obj = Object.create(null);
		  return !('__proto__' in obj);
		}());

		function identity (s) {
		  return s;
		}

		/**
		 * Because behavior goes wacky when you set `__proto__` on objects, we
		 * have to prefix all the strings in our set with an arbitrary character.
		 *
		 * See https://github.com/mozilla/source-map/pull/31 and
		 * https://github.com/mozilla/source-map/issues/30
		 *
		 * @param String aStr
		 */
		function toSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return '$' + aStr;
		  }

		  return aStr;
		}
		exports.toSetString = supportsNullProto ? identity : toSetString;

		function fromSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return aStr.slice(1);
		  }

		  return aStr;
		}
		exports.fromSetString = supportsNullProto ? identity : fromSetString;

		function isProtoString(s) {
		  if (!s) {
		    return false;
		  }

		  var length = s.length;

		  if (length < 9 /* "__proto__".length */) {
		    return false;
		  }

		  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
		      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
		      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
		      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 9) !== 95  /* '_' */) {
		    return false;
		  }

		  for (var i = length - 10; i >= 0; i--) {
		    if (s.charCodeAt(i) !== 36 /* '$' */) {
		      return false;
		    }
		  }

		  return true;
		}

		/**
		 * Comparator between two mappings where the original positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same original source/line/column, but different generated
		 * line and column the same. Useful when searching for a mapping with a
		 * stubbed out mapping.
		 */
		function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
		  var cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0 || onlyCompareOriginal) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByOriginalPositions = compareByOriginalPositions;

		/**
		 * Comparator between two mappings with deflated source and name indices where
		 * the generated positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same generated line and column, but different
		 * source/name/original line and column the same. Useful when searching for a
		 * mapping with a stubbed out mapping.
		 */
		function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0 || onlyCompareGenerated) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

		function strcmp(aStr1, aStr2) {
		  if (aStr1 === aStr2) {
		    return 0;
		  }

		  if (aStr1 === null) {
		    return 1; // aStr2 !== null
		  }

		  if (aStr2 === null) {
		    return -1; // aStr1 !== null
		  }

		  if (aStr1 > aStr2) {
		    return 1;
		  }

		  return -1;
		}

		/**
		 * Comparator between two mappings with inflated source and name strings where
		 * the generated positions are compared.
		 */
		function compareByGeneratedPositionsInflated(mappingA, mappingB) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

		/**
		 * Strip any JSON XSSI avoidance prefix from the string (as documented
		 * in the source maps specification), and then parse the string as
		 * JSON.
		 */
		function parseSourceMapInput(str) {
		  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
		}
		exports.parseSourceMapInput = parseSourceMapInput;

		/**
		 * Compute the URL of a source given the the source root, the source's
		 * URL, and the source map's URL.
		 */
		function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
		  sourceURL = sourceURL || '';

		  if (sourceRoot) {
		    // This follows what Chrome does.
		    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
		      sourceRoot += '/';
		    }
		    // The spec says:
		    //   Line 4: An optional source root, useful for relocating source
		    //   files on a server or removing repeated values in the
		    //   “sources” entry.  This value is prepended to the individual
		    //   entries in the “source” field.
		    sourceURL = sourceRoot + sourceURL;
		  }

		  // Historically, SourceMapConsumer did not take the sourceMapURL as
		  // a parameter.  This mode is still somewhat supported, which is why
		  // this code block is conditional.  However, it's preferable to pass
		  // the source map URL to SourceMapConsumer, so that this function
		  // can implement the source URL resolution algorithm as outlined in
		  // the spec.  This block is basically the equivalent of:
		  //    new URL(sourceURL, sourceMapURL).toString()
		  // ... except it avoids using URL, which wasn't available in the
		  // older releases of node still supported by this library.
		  //
		  // The spec says:
		  //   If the sources are not absolute URLs after prepending of the
		  //   “sourceRoot”, the sources are resolved relative to the
		  //   SourceMap (like resolving script src in a html document).
		  if (sourceMapURL) {
		    var parsed = urlParse(sourceMapURL);
		    if (!parsed) {
		      throw new Error("sourceMapURL could not be parsed");
		    }
		    if (parsed.path) {
		      // Strip the last path component, but keep the "/".
		      var index = parsed.path.lastIndexOf('/');
		      if (index >= 0) {
		        parsed.path = parsed.path.substring(0, index + 1);
		      }
		    }
		    sourceURL = join(urlGenerate(parsed), sourceURL);
		  }

		  return normalize(sourceURL);
		}
		exports.computeSourceURL = computeSourceURL; 
	} (util));
	return util;
}

var arraySet = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredArraySet;

function requireArraySet () {
	if (hasRequiredArraySet) return arraySet;
	hasRequiredArraySet = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = /*@__PURE__*/ requireUtil();
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	arraySet.ArraySet = ArraySet;
	return arraySet;
}

var mappingList = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredMappingList;

function requireMappingList () {
	if (hasRequiredMappingList) return mappingList;
	hasRequiredMappingList = 1;
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = /*@__PURE__*/ requireUtil();

	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	mappingList.MappingList = MappingList;
	return mappingList;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceMapGenerator;

function requireSourceMapGenerator () {
	if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
	hasRequiredSourceMapGenerator = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var base64VLQ = /*@__PURE__*/ requireBase64Vlq();
	var util = /*@__PURE__*/ requireUtil();
	var ArraySet = /*@__PURE__*/ requireArraySet().ArraySet;
	var MappingList = /*@__PURE__*/ requireMappingList().MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  this._mappings = new MappingList();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet();
	    var newNames = new ArraySet();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64VLQ.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64VLQ.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64VLQ.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64VLQ.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64VLQ.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
	return sourceMapGenerator;
}

var sourceMapConsumer = {};

var binarySearch = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBinarySearch;

function requireBinarySearch () {
	if (hasRequiredBinarySearch) return binarySearch;
	hasRequiredBinarySearch = 1;
	(function (exports) {
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		exports.GREATEST_LOWER_BOUND = 1;
		exports.LEAST_UPPER_BOUND = 2;

		/**
		 * Recursive implementation of binary search.
		 *
		 * @param aLow Indices here and lower do not contain the needle.
		 * @param aHigh Indices here and higher do not contain the needle.
		 * @param aNeedle The element being searched for.
		 * @param aHaystack The non-empty array being searched.
		 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
		 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
		 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 */
		function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
		  // This function terminates when one of the following is true:
		  //
		  //   1. We find the exact element we are looking for.
		  //
		  //   2. We did not find the exact element, but we can return the index of
		  //      the next-closest element.
		  //
		  //   3. We did not find the exact element, and there is no next-closest
		  //      element than the one we are searching for, so we return -1.
		  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
		  var cmp = aCompare(aNeedle, aHaystack[mid], true);
		  if (cmp === 0) {
		    // Found the element we are looking for.
		    return mid;
		  }
		  else if (cmp > 0) {
		    // Our needle is greater than aHaystack[mid].
		    if (aHigh - mid > 1) {
		      // The element is in the upper half.
		      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
		    }

		    // The exact needle element was not found in this haystack. Determine if
		    // we are in termination case (3) or (2) and return the appropriate thing.
		    if (aBias == exports.LEAST_UPPER_BOUND) {
		      return aHigh < aHaystack.length ? aHigh : -1;
		    } else {
		      return mid;
		    }
		  }
		  else {
		    // Our needle is less than aHaystack[mid].
		    if (mid - aLow > 1) {
		      // The element is in the lower half.
		      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
		    }

		    // we are in termination case (3) or (2) and return the appropriate thing.
		    if (aBias == exports.LEAST_UPPER_BOUND) {
		      return mid;
		    } else {
		      return aLow < 0 ? -1 : aLow;
		    }
		  }
		}

		/**
		 * This is an implementation of binary search which will always try and return
		 * the index of the closest element if there is no exact hit. This is because
		 * mappings between original and generated line/col pairs are single points,
		 * and there is an implicit region between each of them, so a miss just means
		 * that you aren't on the very start of a region.
		 *
		 * @param aNeedle The element you are looking for.
		 * @param aHaystack The array that is being searched.
		 * @param aCompare A function which takes the needle and an element in the
		 *     array and returns -1, 0, or 1 depending on whether the needle is less
		 *     than, equal to, or greater than the element, respectively.
		 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
		 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
		 */
		exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
		  if (aHaystack.length === 0) {
		    return -1;
		  }

		  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
		                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
		  if (index < 0) {
		    return -1;
		  }

		  // We have found either the exact element, or the next-closest element than
		  // the one we are searching for. However, there may be more than one such
		  // element. Make sure we always return the smallest of these.
		  while (index - 1 >= 0) {
		    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
		      break;
		    }
		    --index;
		  }

		  return index;
		}; 
	} (binarySearch));
	return binarySearch;
}

var quickSort = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredQuickSort;

function requireQuickSort () {
	if (hasRequiredQuickSort) return quickSort;
	hasRequiredQuickSort = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.

	/**
	 * Swap the elements indexed by `x` and `y` in the array `ary`.
	 *
	 * @param {Array} ary
	 *        The array.
	 * @param {Number} x
	 *        The index of the first item.
	 * @param {Number} y
	 *        The index of the second item.
	 */
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}

	/**
	 * Returns a random integer within the range `low .. high` inclusive.
	 *
	 * @param {Number} low
	 *        The lower bound on the range.
	 * @param {Number} high
	 *        The upper bound on the range.
	 */
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}

	/**
	 * The Quick Sort algorithm.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 * @param {Number} p
	 *        Start index of the array
	 * @param {Number} r
	 *        End index of the array
	 */
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.

	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.

	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;

	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];

	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }

	    swap(ary, i + 1, j);
	    var q = i + 1;

	    // (2) Recurse on each half.

	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}

	/**
	 * Sort the given array in-place with the given comparator function.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 */
	quickSort.quickSort = function (ary, comparator) {
	  doQuickSort(ary, comparator, 0, ary.length - 1);
	};
	return quickSort;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceMapConsumer;

function requireSourceMapConsumer () {
	if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
	hasRequiredSourceMapConsumer = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = /*@__PURE__*/ requireUtil();
	var binarySearch = /*@__PURE__*/ requireBinarySearch();
	var ArraySet = /*@__PURE__*/ requireArraySet().ArraySet;
	var base64VLQ = /*@__PURE__*/ requireBase64Vlq();
	var quickSort = /*@__PURE__*/ requireQuickSort().quickSort;

	function SourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
	    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	}

	SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	};

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	SourceMapConsumer.prototype._version = 3;

	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.

	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__generatedMappings;
	  }
	});

	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__originalMappings;
	  }
	});

	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };

	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;

	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;

	/**
	 * Iterate over each mapping between an original source/line/column and a
	 * generated line/column in this source map.
	 *
	 * @param Function aCallback
	 *        The function that is called with each mapping.
	 * @param Object aContext
	 *        Optional. If specified, this object will be the value of `this` every
	 *        time that `aCallback` is called.
	 * @param aOrder
	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	 *        iterate over the mappings sorted by the generated file's line/column
	 *        order or the original's source/line/column order, respectively. Defaults to
	 *        `SourceMapConsumer.GENERATED_ORDER`.
	 */
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }

	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };

	/**
	 * Returns all generated line and column information for the original source,
	 * line, and column provided. If no column is provided, returns all mappings
	 * corresponding to a either the line we are searching for or the next
	 * closest line that has any mappings. Otherwise, returns all mappings
	 * corresponding to the given line and either the column we are searching for
	 * or the next closest column that has any offsets.
	 *
	 * The only argument is an object with the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number is 1-based.
	 *   - column: Optional. the column number in the original source.
	 *    The column number is 0-based.
	 *
	 * and an array of objects is returned, each with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *    line number is 1-based.
	 *   - column: The column number in the generated source, or null.
	 *    The column number is 0-based.
	 */
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');

	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };

	    needle.source = this._findSourceIndex(needle.source);
	    if (needle.source < 0) {
	      return [];
	    }

	    var mappings = [];

	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      }
	    }

	    return mappings;
	  };

	sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;

	/**
	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
	 * query for information about the original file positions by giving it a file
	 * position in the generated source.
	 *
	 * The first parameter is the raw source map (either as a JSON string, or
	 * already parsed to an object). According to the spec, source maps have the
	 * following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - sources: An array of URLs to the original source files.
	 *   - names: An array of identifiers which can be referrenced by individual mappings.
	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
	 *   - sourcesContent: Optional. An array of contents of the original source files.
	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
	 *   - file: Optional. The generated file this source map is associated with.
	 *
	 * Here is an example source map, taken from the source map spec[0]:
	 *
	 *     {
	 *       version : 3,
	 *       file: "out.js",
	 *       sourceRoot : "",
	 *       sources: ["foo.js", "bar.js"],
	 *       names: ["src", "maps", "are", "fun"],
	 *       mappings: "AA,AB;;ABCDE;"
	 *     }
	 *
	 * The second parameter, if given, is a string whose value is the URL
	 * at which the source map was found.  This URL is used to compute the
	 * sources array.
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	 */
	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);

	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  if (sourceRoot) {
	    sourceRoot = util.normalize(sourceRoot);
	  }

	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });

	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet.fromArray(names.map(String), true);
	  this._sources = ArraySet.fromArray(sources, true);

	  this._absoluteSources = this._sources.toArray().map(function (s) {
	    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
	  });

	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this._sourceMapURL = aSourceMapURL;
	  this.file = file;
	}

	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

	/**
	 * Utility function to find the index of a source.  Returns -1 if not
	 * found.
	 */
	BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
	  var relativeSource = aSource;
	  if (this.sourceRoot != null) {
	    relativeSource = util.relative(this.sourceRoot, relativeSource);
	  }

	  if (this._sources.has(relativeSource)) {
	    return this._sources.indexOf(relativeSource);
	  }

	  // Maybe aSource is an absolute URL as returned by |sources|.  In
	  // this case we can't simply undo the transform.
	  var i;
	  for (i = 0; i < this._absoluteSources.length; ++i) {
	    if (this._absoluteSources[i] == aSource) {
	      return i;
	    }
	  }

	  return -1;
	};

	/**
	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	 *
	 * @param SourceMapGenerator aSourceMap
	 *        The source map that will be consumed.
	 * @param String aSourceMapURL
	 *        The URL at which the source map can be found (optional)
	 * @returns BasicSourceMapConsumer
	 */
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);

	    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;
	    smc._sourceMapURL = aSourceMapURL;
	    smc._absoluteSources = smc._sources.toArray().map(function (s) {
	      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
	    });

	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.

	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];

	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;

	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;

	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }

	        destOriginalMappings.push(destMapping);
	      }

	      destGeneratedMappings.push(destMapping);
	    }

	    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

	    return smc;
	  };

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	BasicSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._absoluteSources.slice();
	  }
	});

	/**
	 * Provide the JIT with a nice shape / hidden class.
	 */
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;

	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;

	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);

	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64VLQ.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }

	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }

	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }

	          cachedSegments[str] = segment;
	        }

	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;

	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];

	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;

	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;

	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }

	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }

	    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;

	    quickSort(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };

	/**
	 * Find the mapping that best matches the hypothetical "needle" mapping that
	 * we are searching for in the given "haystack" of mappings.
	 */
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.

	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }

	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };

	/**
	 * Compute the last column for each generated mapping. The last column is
	 * inclusive.
	 */
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];

	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];

	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }

	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the generated source.  The column
	 *     number is 0-based.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the original source, or null.  The
	 *     column number is 0-based.
	 *   - name: The original identifier, or null.
	 */
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];

	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }

	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }

	    var index = this._findSourceIndex(aSource);
	    if (index >= 0) {
	      return this.sourcesContent[index];
	    }

	    var relativeSource = aSource;
	    if (this.sourceRoot != null) {
	      relativeSource = util.relative(this.sourceRoot, relativeSource);
	    }

	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }

	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + relativeSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
	      }
	    }

	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the original source.  The column
	 *     number is 0-based.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the generated source, or null.
	 *     The column number is 0-based.
	 */
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    source = this._findSourceIndex(source);
	    if (source < 0) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }

	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }

	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };

	sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;

	/**
	 * An IndexedSourceMapConsumer instance represents a parsed source map which
	 * we can query for information. It differs from BasicSourceMapConsumer in
	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	 * input.
	 *
	 * The first parameter is a raw source map (either as a JSON string, or already
	 * parsed to an object). According to the spec for indexed source maps, they
	 * have the following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - file: Optional. The generated file this source map is associated with.
	 *   - sections: A list of section definitions.
	 *
	 * Each value under the "sections" field has two fields:
	 *   - offset: The offset into the original specified at which this section
	 *       begins to apply, defined as an object with a "line" and "column"
	 *       field.
	 *   - map: A source map definition. This source map could also be indexed,
	 *       but doesn't have to be.
	 *
	 * Instead of the "map" field, it's also possible to have a "url" field
	 * specifying a URL to retrieve a source map from, but that's currently
	 * unsupported.
	 *
	 * Here's an example source map, taken from the source map spec[0], but
	 * modified to omit a section which uses the "url" field.
	 *
	 *  {
	 *    version : 3,
	 *    file: "app.js",
	 *    sections: [{
	 *      offset: {line:100, column:10},
	 *      map: {
	 *        version : 3,
	 *        file: "section.js",
	 *        sources: ["foo.js", "bar.js"],
	 *        names: ["src", "maps", "are", "fun"],
	 *        mappings: "AAAA,E;;ABCDE;"
	 *      }
	 *    }],
	 *  }
	 *
	 * The second parameter, if given, is a string whose value is the URL
	 * at which the source map was found.  This URL is used to compute the
	 * sources array.
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	 */
	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');

	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  this._sources = new ArraySet();
	  this._names = new ArraySet();

	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');

	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;

	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
	    }
	  });
	}

	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	IndexedSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the generated source.  The column
	 *     number is 0-based.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.  The
	 *     line number is 1-based.
	 *   - column: The column number in the original source, or null.  The
	 *     column number is 0-based.
	 *   - name: The original identifier, or null.
	 */
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }

	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];

	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }

	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.  The line number
	 *     is 1-based.
	 *   - column: The column number in the original source.  The column
	 *     number is 0-based.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.  The
	 *     line number is 1-based. 
	 *   - column: The column number in the generated source, or null.
	 *     The column number is 0-based.
	 */
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }

	    return {
	      line: null,
	      column: null
	    };
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];

	        var source = section.consumer._sources.at(mapping.source);
	        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
	        this._sources.add(source);
	        source = this._sources.indexOf(source);

	        var name = null;
	        if (mapping.name) {
	          name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	        }

	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };

	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }

	    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort(this.__originalMappings, util.compareByOriginalPositions);
	  };

	sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	return sourceMapConsumer;
}

var sourceNode = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceNode;

function requireSourceNode () {
	if (hasRequiredSourceNode) return sourceNode;
	hasRequiredSourceNode = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var SourceMapGenerator = /*@__PURE__*/ requireSourceMapGenerator().SourceMapGenerator;
	var util = /*@__PURE__*/ requireUtil();

	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	// operating systems these days (capturing the result).
	var REGEX_NEWLINE = /(\r?\n)/;

	// Newline character code for charCodeAt() comparisons
	var NEWLINE_CODE = 10;

	// Private symbol for identifying `SourceNode`s when multiple versions of
	// the source-map library are loaded. This MUST NOT CHANGE across
	// versions!
	var isSourceNode = "$$$isSourceNode$$$";

	/**
	 * SourceNodes provide a way to abstract over interpolating/concatenating
	 * snippets of generated JavaScript source code while maintaining the line and
	 * column information associated with the original source code.
	 *
	 * @param aLine The original line number.
	 * @param aColumn The original column number.
	 * @param aSource The original source's filename.
	 * @param aChunks Optional. An array of strings which are snippets of
	 *        generated JS, or other SourceNodes.
	 * @param aName The original identifier.
	 */
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}

	/**
	 * Creates a SourceNode from generated code and a SourceMapConsumer.
	 *
	 * @param aGeneratedCode The generated code
	 * @param aSourceMapConsumer The SourceMap for the generated code
	 * @param aRelativePath Optional. The path that relative sources in the
	 *        SourceMapConsumer should be relative to.
	 */
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();

	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are accessed by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var remainingLinesIndex = 0;
	    var shiftNextLine = function() {
	      var lineContents = getNextLine();
	      // The last line of a file might not have a newline.
	      var newLine = getNextLine() || "";
	      return lineContents + newLine;

	      function getNextLine() {
	        return remainingLinesIndex < remainingLines.length ?
	            remainingLines[remainingLinesIndex++] : undefined;
	      }
	    };

	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;

	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[remainingLinesIndex] || '';
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[remainingLinesIndex] || '';
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLinesIndex < remainingLines.length) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.splice(remainingLinesIndex).join(""));
	    }

	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });

	    return node;

	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };

	/**
	 * Add a chunk of generated JS to this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Add a chunk of generated JS to the beginning of this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Walk over the tree of JS snippets in this node and its children. The
	 * walking function is called once for each snippet of JS and is passed that
	 * snippet and the its original associated source's line/column location.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};

	/**
	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	 * each of `this.children`.
	 *
	 * @param aSep The separator.
	 */
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};

	/**
	 * Call String.prototype.replace on the very right-most source snippet. Useful
	 * for trimming whitespace from the end of a source node, etc.
	 *
	 * @param aPattern The pattern to replace.
	 * @param aReplacement The thing to replace the pattern with.
	 */
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};

	/**
	 * Set the source content for a source file. This will be added to the SourceMapGenerator
	 * in the sourcesContent field.
	 *
	 * @param aSourceFile The filename of the source file
	 * @param aSourceContent The content of the source file
	 */
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };

	/**
	 * Walk over the tree of SourceNodes. The walking function is called for each
	 * source file content and is passed the filename and source content.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }

	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };

	/**
	 * Return the string representation of this source node. Walks over the tree
	 * and concatenates all the various snippets together to one string.
	 */
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};

	/**
	 * Returns the string representation of this source node along with a source
	 * map.
	 */
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        // Mappings end at eol
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });

	  return { code: generated.code, map: map };
	};

	sourceNode.SourceNode = SourceNode;
	return sourceNode;
}

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var hasRequiredSourceMap;

function requireSourceMap () {
	if (hasRequiredSourceMap) return sourceMap;
	hasRequiredSourceMap = 1;
	sourceMap.SourceMapGenerator = /*@__PURE__*/ requireSourceMapGenerator().SourceMapGenerator;
	sourceMap.SourceMapConsumer = /*@__PURE__*/ requireSourceMapConsumer().SourceMapConsumer;
	sourceMap.SourceNode = /*@__PURE__*/ requireSourceNode().SourceNode;
	return sourceMap;
}

var mergeSourceMap;
var hasRequiredMergeSourceMap;

function requireMergeSourceMap () {
	if (hasRequiredMergeSourceMap) return mergeSourceMap;
	hasRequiredMergeSourceMap = 1;
	var sourceMap = /*@__PURE__*/ requireSourceMap();
	var SourceMapConsumer = sourceMap.SourceMapConsumer;
	var SourceMapGenerator = sourceMap.SourceMapGenerator;

	mergeSourceMap = merge;

	/**
	 * Merge old source map and new source map and return merged.
	 * If old or new source map value is falsy, return another one as it is.
	 *
	 * @param {object|string} [oldMap] old source map object
	 * @param {object|string} [newmap] new source map object
	 * @return {object|undefined} merged source map object, or undefined when both old and new source map are undefined
	 */
	function merge(oldMap, newMap) {
	  if (!oldMap) return newMap
	  if (!newMap) return oldMap

	  var oldMapConsumer = new SourceMapConsumer(oldMap);
	  var newMapConsumer = new SourceMapConsumer(newMap);
	  var mergedMapGenerator = new SourceMapGenerator();

	  // iterate on new map and overwrite original position of new map with one of old map
	  newMapConsumer.eachMapping(function(m) {
	    // pass when `originalLine` is null.
	    // It occurs in case that the node does not have origin in original code.
	    if (m.originalLine == null) return

	    var origPosInOldMap = oldMapConsumer.originalPositionFor({
	      line: m.originalLine,
	      column: m.originalColumn
	    });

	    if (origPosInOldMap.source == null) return

	    mergedMapGenerator.addMapping({
	      original: {
	        line: origPosInOldMap.line,
	        column: origPosInOldMap.column
	      },
	      generated: {
	        line: m.generatedLine,
	        column: m.generatedColumn
	      },
	      source: origPosInOldMap.source,
	      name: origPosInOldMap.name
	    });
	  });

	  var consumers = [oldMapConsumer, newMapConsumer];
	  consumers.forEach(function(consumer) {
	    consumer.sources.forEach(function(sourceFile) {
	      mergedMapGenerator._sources.add(sourceFile);
	      var sourceContent = consumer.sourceContentFor(sourceFile);
	      if (sourceContent != null) {
	        mergedMapGenerator.setSourceContent(sourceFile, sourceContent);
	      }
	    });
	  });

	  mergedMapGenerator._sourceRoot = oldMap.sourceRoot;
	  mergedMapGenerator._file = oldMap.file;

	  return JSON.parse(mergedMapGenerator.toString())
	}
	return mergeSourceMap;
}

var mergeSourceMapExports = /*@__PURE__*/ requireMergeSourceMap();
var merge = /*@__PURE__*/getDefaultExportFromCjs(mergeSourceMapExports);

var __defProp$5 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b)) {
      if (__propIsEnum$5.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
const scss = (source, map, options, load = require) => {
  const nodeSass = load("sass");
  const { compileString, renderSync } = nodeSass;
  const data = getSource(source, options.filename, options.additionalData);
  let css;
  let dependencies;
  let sourceMap;
  try {
    if (compileString) {
      const { pathToFileURL, fileURLToPath } = load("url");
      const result = compileString(data, __spreadProps$4(__spreadValues$5({}, options), {
        url: pathToFileURL(options.filename),
        sourceMap: !!map
      }));
      css = result.css;
      dependencies = result.loadedUrls.map((url) => fileURLToPath(url));
      sourceMap = map ? result.sourceMap : void 0;
    } else {
      const result = renderSync(__spreadProps$4(__spreadValues$5({}, options), {
        data,
        file: options.filename,
        outFile: options.filename,
        sourceMap: !!map
      }));
      css = result.css.toString();
      dependencies = result.stats.includedFiles;
      sourceMap = map ? JSON.parse(result.map.toString()) : void 0;
    }
    if (map) {
      return {
        code: css,
        errors: [],
        dependencies,
        map: merge(map, sourceMap)
      };
    }
    return { code: css, errors: [], dependencies };
  } catch (e) {
    return { code: "", errors: [e], dependencies: [] };
  }
};
const sass = (source, map, options, load) => scss(
  source,
  map,
  __spreadProps$4(__spreadValues$5({}, options), {
    indentedSyntax: true
  }),
  load
);
const less = (source, map, options, load = require) => {
  const nodeLess = load("less");
  let result;
  let error = null;
  nodeLess.render(
    getSource(source, options.filename, options.additionalData),
    __spreadProps$4(__spreadValues$5({}, options), { syncImport: true }),
    (err, output) => {
      error = err;
      result = output;
    }
  );
  if (error) return { code: "", errors: [error], dependencies: [] };
  const dependencies = result.imports;
  if (map) {
    return {
      code: result.css.toString(),
      map: merge(map, result.map),
      errors: [],
      dependencies
    };
  }
  return {
    code: result.css.toString(),
    errors: [],
    dependencies
  };
};
const styl = (source, map, options, load = require) => {
  const nodeStylus = load("stylus");
  try {
    const ref = nodeStylus(source, options);
    if (map) ref.set("sourcemap", { inline: false, comment: false });
    const result = ref.render();
    const dependencies = ref.deps();
    if (map) {
      return {
        code: result,
        map: merge(map, ref.sourcemap),
        errors: [],
        dependencies
      };
    }
    return { code: result, errors: [], dependencies };
  } catch (e) {
    return { code: "", errors: [e], dependencies: [] };
  }
};
function getSource(source, filename, additionalData) {
  if (!additionalData) return source;
  if (isFunction$1(additionalData)) {
    return additionalData(source, filename);
  }
  return additionalData + source;
}
const processors = {
  less,
  sass,
  scss,
  styl,
  stylus: styl
};

var __defProp$4 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
function compileStyle(options) {
  return doCompileStyle(__spreadProps$3(__spreadValues$4({}, options), {
    isAsync: false
  }));
}
function compileStyleAsync(options) {
  return doCompileStyle(__spreadProps$3(__spreadValues$4({}, options), {
    isAsync: true
  }));
}
function doCompileStyle(options) {
  const {
    filename,
    id,
    scoped = false,
    trim = true,
    isProd = false,
    modules = false,
    modulesOptions = {},
    preprocessLang,
    postcssOptions,
    postcssPlugins
  } = options;
  const preprocessor = preprocessLang && processors[preprocessLang];
  const preProcessedSource = preprocessor && preprocess(options, preprocessor);
  const map = preProcessedSource ? preProcessedSource.map : options.inMap || options.map;
  const source = preProcessedSource ? preProcessedSource.code : options.source;
  const shortId = id.replace(/^data-v-/, "");
  const longId = `data-v-${shortId}`;
  const plugins = (postcssPlugins || []).slice();
  plugins.unshift(cssVarsPlugin({ id: shortId, isProd }));
  if (trim) {
    plugins.push(trimPlugin());
  }
  if (scoped) {
    plugins.push(scopedPlugin(longId));
  }
  let cssModules;
  if (modules) {
    {
      throw new Error(
        "[@vue/compiler-sfc] `modules` option is not supported in the browser build."
      );
    }
  }
  const postCSSOptions = __spreadProps$3(__spreadValues$4({}, postcssOptions), {
    to: filename,
    from: filename
  });
  if (map) {
    postCSSOptions.map = {
      inline: false,
      annotation: false,
      prev: map
    };
  }
  let result;
  let code;
  let outMap;
  const dependencies = new Set(
    preProcessedSource ? preProcessedSource.dependencies : []
  );
  dependencies.delete(filename);
  const errors = [];
  if (preProcessedSource && preProcessedSource.errors.length) {
    errors.push(...preProcessedSource.errors);
  }
  const recordPlainCssDependencies = (messages) => {
    messages.forEach((msg) => {
      if (msg.type === "dependency") {
        dependencies.add(msg.file);
      }
    });
    return dependencies;
  };
  try {
    result = postcss(plugins).process(source, postCSSOptions);
    if (options.isAsync) {
      return result.then((result2) => ({
        code: result2.css || "",
        map: result2.map && result2.map.toJSON(),
        errors,
        modules: cssModules,
        rawResult: result2,
        dependencies: recordPlainCssDependencies(result2.messages)
      })).catch((error) => ({
        code: "",
        map: void 0,
        errors: [...errors, error],
        rawResult: void 0,
        dependencies
      }));
    }
    recordPlainCssDependencies(result.messages);
    code = result.css;
    outMap = result.map;
  } catch (e) {
    errors.push(e);
  }
  return {
    code: code || ``,
    map: outMap && outMap.toJSON(),
    errors,
    rawResult: result,
    dependencies
  };
}
function preprocess(options, preprocessor) {
  if (!options.preprocessCustomRequire) {
    throw new Error(
      `[@vue/compiler-sfc] Style preprocessing in the browser build must provide the \`preprocessCustomRequire\` option to return the in-browser version of the preprocessor.`
    );
  }
  return preprocessor(
    options.source,
    options.inMap || options.map,
    __spreadValues$4({
      filename: options.filename
    }, options.preprocessOptions),
    options.preprocessCustomRequire
  );
}

const UNKNOWN_TYPE = "Unknown";
function resolveObjectKey(node, computed) {
  switch (node.type) {
    case "StringLiteral":
    case "NumericLiteral":
      return String(node.value);
    case "Identifier":
      if (!computed) return node.name;
  }
  return void 0;
}
function concatStrings(strs) {
  return strs.filter((s) => !!s).join(", ");
}
function isLiteralNode(node) {
  return node.type.endsWith("Literal");
}
function isCallOf(node, test) {
  return !!(node && test && node.type === "CallExpression" && node.callee.type === "Identifier" && (typeof test === "string" ? node.callee.name === test : test(node.callee.name)));
}
function toRuntimeTypeString(types) {
  return types.length > 1 ? `[${types.join(", ")}]` : types[0];
}
function getImportedName(specifier) {
  if (specifier.type === "ImportSpecifier")
    return specifier.imported.type === "Identifier" ? specifier.imported.name : specifier.imported.value;
  else if (specifier.type === "ImportNamespaceSpecifier") return "*";
  return "default";
}
function getId(node) {
  return node.type === "Identifier" ? node.name : node.type === "StringLiteral" ? node.value : null;
}
const normalize = (path.posix || path).normalize;
const windowsSlashRE = /\\/g;
function normalizePath(p) {
  return normalize(p.replace(windowsSlashRE, "/"));
}
const joinPaths = (path.posix || path).join;
const propNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~\-]/;
function getEscapedPropName(key) {
  return propNameEscapeSymbolsRE.test(key) ? JSON.stringify(key) : key;
}

function analyzeScriptBindings(ast) {
  for (const node of ast) {
    if (node.type === "ExportDefaultDeclaration" && node.declaration.type === "ObjectExpression") {
      return analyzeBindingsFromOptions(node.declaration);
    }
  }
  return {};
}
function analyzeBindingsFromOptions(node) {
  const bindings = {};
  Object.defineProperty(bindings, "__isScriptSetup", {
    enumerable: false,
    value: false
  });
  for (const property of node.properties) {
    if (property.type === "ObjectProperty" && !property.computed && property.key.type === "Identifier") {
      if (property.key.name === "props") {
        for (const key of getObjectOrArrayExpressionKeys(property.value)) {
          bindings[key] = "props";
        }
      } else if (property.key.name === "inject") {
        for (const key of getObjectOrArrayExpressionKeys(property.value)) {
          bindings[key] = "options";
        }
      } else if (property.value.type === "ObjectExpression" && (property.key.name === "computed" || property.key.name === "methods")) {
        for (const key of getObjectExpressionKeys(property.value)) {
          bindings[key] = "options";
        }
      }
    } else if (property.type === "ObjectMethod" && property.key.type === "Identifier" && (property.key.name === "setup" || property.key.name === "data")) {
      for (const bodyItem of property.body.body) {
        if (bodyItem.type === "ReturnStatement" && bodyItem.argument && bodyItem.argument.type === "ObjectExpression") {
          for (const key of getObjectExpressionKeys(bodyItem.argument)) {
            bindings[key] = property.key.name === "setup" ? "setup-maybe-ref" : "data";
          }
        }
      }
    }
  }
  return bindings;
}
function getObjectExpressionKeys(node) {
  const keys = [];
  for (const prop of node.properties) {
    if (prop.type === "SpreadElement") continue;
    const key = resolveObjectKey(prop.key, prop.computed);
    if (key) keys.push(String(key));
  }
  return keys;
}
function getArrayExpressionKeys(node) {
  const keys = [];
  for (const element of node.elements) {
    if (element && element.type === "StringLiteral") {
      keys.push(element.value);
    }
  }
  return keys;
}
function getObjectOrArrayExpressionKeys(value) {
  if (value.type === "ArrayExpression") {
    return getArrayExpressionKeys(value);
  }
  if (value.type === "ObjectExpression") {
    return getObjectExpressionKeys(value);
  }
  return [];
}

const comma = ','.charCodeAt(0);
const semicolon = ';'.charCodeAt(0);
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const intToChar = new Uint8Array(64); // 64 possible chars.
const charToInt = new Uint8Array(128); // z is 122 in ASCII
for (let i = 0; i < chars.length; i++) {
    const c = chars.charCodeAt(i);
    intToChar[i] = c;
    charToInt[c] = i;
}
function encodeInteger(builder, num, relative) {
    let delta = num - relative;
    delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;
    do {
        let clamped = delta & 0b011111;
        delta >>>= 5;
        if (delta > 0)
            clamped |= 0b100000;
        builder.write(intToChar[clamped]);
    } while (delta > 0);
    return num;
}

const bufLength = 1024 * 16;
// Provide a fallback for older environments.
const td = typeof TextDecoder !== 'undefined'
    ? /* #__PURE__ */ new TextDecoder()
    : typeof Buffer !== 'undefined'
        ? {
            decode(buf) {
                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
                return out.toString();
            },
        }
        : {
            decode(buf) {
                let out = '';
                for (let i = 0; i < buf.length; i++) {
                    out += String.fromCharCode(buf[i]);
                }
                return out;
            },
        };
class StringWriter {
    constructor() {
        this.pos = 0;
        this.out = '';
        this.buffer = new Uint8Array(bufLength);
    }
    write(v) {
        const { buffer } = this;
        buffer[this.pos++] = v;
        if (this.pos === bufLength) {
            this.out += td.decode(buffer);
            this.pos = 0;
        }
    }
    flush() {
        const { buffer, out, pos } = this;
        return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
    }
}
function encode(decoded) {
    const writer = new StringWriter();
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    for (let i = 0; i < decoded.length; i++) {
        const line = decoded[i];
        if (i > 0)
            writer.write(semicolon);
        if (line.length === 0)
            continue;
        let genColumn = 0;
        for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (j > 0)
                writer.write(comma);
            genColumn = encodeInteger(writer, segment[0], genColumn);
            if (segment.length === 1)
                continue;
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            if (segment.length === 4)
                continue;
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
        }
    }
    return writer.flush();
}

class BitSet {
	constructor(arg) {
		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
	}

	add(n) {
		this.bits[n >> 5] |= 1 << (n & 31);
	}

	has(n) {
		return !!(this.bits[n >> 5] & (1 << (n & 31)));
	}
}

class Chunk {
	constructor(start, end, content) {
		this.start = start;
		this.end = end;
		this.original = content;

		this.intro = '';
		this.outro = '';

		this.content = content;
		this.storeName = false;
		this.edited = false;

		{
			this.previous = null;
			this.next = null;
		}
	}

	appendLeft(content) {
		this.outro += content;
	}

	appendRight(content) {
		this.intro = this.intro + content;
	}

	clone() {
		const chunk = new Chunk(this.start, this.end, this.original);

		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;

		return chunk;
	}

	contains(index) {
		return this.start < index && index < this.end;
	}

	eachNext(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.next;
		}
	}

	eachPrevious(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.previous;
		}
	}

	edit(content, storeName, contentOnly) {
		this.content = content;
		if (!contentOnly) {
			this.intro = '';
			this.outro = '';
		}
		this.storeName = storeName;

		this.edited = true;

		return this;
	}

	prependLeft(content) {
		this.outro = content + this.outro;
	}

	prependRight(content) {
		this.intro = content + this.intro;
	}

	reset() {
		this.intro = '';
		this.outro = '';
		if (this.edited) {
			this.content = this.original;
			this.storeName = false;
			this.edited = false;
		}
	}

	split(index) {
		const sliceIndex = index - this.start;

		const originalBefore = this.original.slice(0, sliceIndex);
		const originalAfter = this.original.slice(sliceIndex);

		this.original = originalBefore;

		const newChunk = new Chunk(index, this.end, originalAfter);
		newChunk.outro = this.outro;
		this.outro = '';

		this.end = index;

		if (this.edited) {
			// after split we should save the edit content record into the correct chunk
			// to make sure sourcemap correct
			// For example:
			// '  test'.trim()
			//     split   -> '  ' + 'test'
			//   ✔️ edit    -> '' + 'test'
			//   ✖️ edit    -> 'test' + ''
			// TODO is this block necessary?...
			newChunk.edit('', false);
			this.content = '';
		} else {
			this.content = originalBefore;
		}

		newChunk.next = this.next;
		if (newChunk.next) newChunk.next.previous = newChunk;
		newChunk.previous = this;
		this.next = newChunk;

		return newChunk;
	}

	toString() {
		return this.intro + this.content + this.outro;
	}

	trimEnd(rx) {
		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) return true;

		const trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.start + trimmed.length).edit('', undefined, true);
				if (this.edited) {
					// save the change, if it has been edited
					this.edit(trimmed, this.storeName, true);
				}
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.intro = this.intro.replace(rx, '');
			if (this.intro.length) return true;
		}
	}

	trimStart(rx) {
		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) return true;

		const trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				const newChunk = this.split(this.end - trimmed.length);
				if (this.edited) {
					// save the change, if it has been edited
					newChunk.edit(trimmed, this.storeName, true);
				}
				this.edit('', undefined, true);
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.outro = this.outro.replace(rx, '');
			if (this.outro.length) return true;
		}
	}
}

function getBtoa() {
	if (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {
		return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
	} else if (typeof Buffer === 'function') {
		return (str) => Buffer.from(str, 'utf-8').toString('base64');
	} else {
		return () => {
			throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
		};
	}
}

const btoa = /*#__PURE__*/ getBtoa();

class SourceMap {
	constructor(properties) {
		this.version = 3;
		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = encode(properties.mappings);
		if (typeof properties.x_google_ignoreList !== 'undefined') {
			this.x_google_ignoreList = properties.x_google_ignoreList;
		}
		if (typeof properties.debugId !== 'undefined') {
			this.debugId = properties.debugId;
		}
	}

	toString() {
		return JSON.stringify(this);
	}

	toUrl() {
		return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
	}
}

function guessIndent(code) {
	const lines = code.split('\n');

	const tabbed = lines.filter((line) => /^\t+/.test(line));
	const spaced = lines.filter((line) => /^ {2,}/.test(line));

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	const min = spaced.reduce((previous, current) => {
		const numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);

	return new Array(min + 1).join(' ');
}

function getRelativePath(from, to) {
	const fromParts = from.split(/[/\\]/);
	const toParts = to.split(/[/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}

	if (fromParts.length) {
		let i = fromParts.length;
		while (i--) fromParts[i] = '..';
	}

	return fromParts.concat(toParts).join('/');
}

const toString = Object.prototype.toString;

function isObject(thing) {
	return toString.call(thing) === '[object Object]';
}

function getLocator(source) {
	const originalLines = source.split('\n');
	const lineOffsets = [];

	for (let i = 0, pos = 0; i < originalLines.length; i++) {
		lineOffsets.push(pos);
		pos += originalLines[i].length + 1;
	}

	return function locate(index) {
		let i = 0;
		let j = lineOffsets.length;
		while (i < j) {
			const m = (i + j) >> 1;
			if (index < lineOffsets[m]) {
				j = m;
			} else {
				i = m + 1;
			}
		}
		const line = i - 1;
		const column = index - lineOffsets[line];
		return { line, column };
	};
}

const wordRegex = /\w/;

class Mappings {
	constructor(hires) {
		this.hires = hires;
		this.generatedCodeLine = 0;
		this.generatedCodeColumn = 0;
		this.raw = [];
		this.rawSegments = this.raw[this.generatedCodeLine] = [];
		this.pending = null;
	}

	addEdit(sourceIndex, content, loc, nameIndex) {
		if (content.length) {
			const contentLengthMinusOne = content.length - 1;
			let contentLineEnd = content.indexOf('\n', 0);
			let previousContentLineEnd = -1;
			// Loop through each line in the content and add a segment, but stop if the last line is empty,
			// else code afterwards would fill one line too many
			while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
				const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
				if (nameIndex >= 0) {
					segment.push(nameIndex);
				}
				this.rawSegments.push(segment);

				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;

				previousContentLineEnd = contentLineEnd;
				contentLineEnd = content.indexOf('\n', contentLineEnd + 1);
			}

			const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
			if (nameIndex >= 0) {
				segment.push(nameIndex);
			}
			this.rawSegments.push(segment);

			this.advance(content.slice(previousContentLineEnd + 1));
		} else if (this.pending) {
			this.rawSegments.push(this.pending);
			this.advance(content);
		}

		this.pending = null;
	}

	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
		let originalCharIndex = chunk.start;
		let first = true;
		// when iterating each char, check if it's in a word boundary
		let charInHiresBoundary = false;

		while (originalCharIndex < chunk.end) {
			if (original[originalCharIndex] === '\n') {
				loc.line += 1;
				loc.column = 0;
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				first = true;
				charInHiresBoundary = false;
			} else {
				if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
					const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];

					if (this.hires === 'boundary') {
						// in hires "boundary", group segments per word boundary than per char
						if (wordRegex.test(original[originalCharIndex])) {
							// for first char in the boundary found, start the boundary by pushing a segment
							if (!charInHiresBoundary) {
								this.rawSegments.push(segment);
								charInHiresBoundary = true;
							}
						} else {
							// for non-word char, end the boundary by pushing a segment
							this.rawSegments.push(segment);
							charInHiresBoundary = false;
						}
					} else {
						this.rawSegments.push(segment);
					}
				}

				loc.column += 1;
				this.generatedCodeColumn += 1;
				first = false;
			}

			originalCharIndex += 1;
		}

		this.pending = null;
	}

	advance(str) {
		if (!str) return;

		const lines = str.split('\n');

		if (lines.length > 1) {
			for (let i = 0; i < lines.length - 1; i++) {
				this.generatedCodeLine++;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
			}
			this.generatedCodeColumn = 0;
		}

		this.generatedCodeColumn += lines[lines.length - 1].length;
	}
}

const n = '\n';

const warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false,
};

class MagicString {
	constructor(string, options = {}) {
		const chunk = new Chunk(0, string.length, string);

		Object.defineProperties(this, {
			original: { writable: true, value: string },
			outro: { writable: true, value: '' },
			intro: { writable: true, value: '' },
			firstChunk: { writable: true, value: chunk },
			lastChunk: { writable: true, value: chunk },
			lastSearchedChunk: { writable: true, value: chunk },
			byStart: { writable: true, value: {} },
			byEnd: { writable: true, value: {} },
			filename: { writable: true, value: options.filename },
			indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
			sourcemapLocations: { writable: true, value: new BitSet() },
			storedNames: { writable: true, value: {} },
			indentStr: { writable: true, value: undefined },
			ignoreList: { writable: true, value: options.ignoreList },
			offset: { writable: true, value: options.offset || 0 },
		});

		this.byStart[0] = chunk;
		this.byEnd[string.length] = chunk;
	}

	addSourcemapLocation(char) {
		this.sourcemapLocations.add(char);
	}

	append(content) {
		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

		this.outro += content;
		return this;
	}

	appendLeft(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byEnd[index];

		if (chunk) {
			chunk.appendLeft(content);
		} else {
			this.intro += content;
		}
		return this;
	}

	appendRight(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byStart[index];

		if (chunk) {
			chunk.appendRight(content);
		} else {
			this.outro += content;
		}
		return this;
	}

	clone() {
		const cloned = new MagicString(this.original, { filename: this.filename, offset: this.offset });

		let originalChunk = this.firstChunk;
		let clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

		while (originalChunk) {
			cloned.byStart[clonedChunk.start] = clonedChunk;
			cloned.byEnd[clonedChunk.end] = clonedChunk;

			const nextOriginalChunk = originalChunk.next;
			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

			if (nextClonedChunk) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;

				clonedChunk = nextClonedChunk;
			}

			originalChunk = nextOriginalChunk;
		}

		cloned.lastChunk = clonedChunk;

		if (this.indentExclusionRanges) {
			cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
		}

		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);

		cloned.intro = this.intro;
		cloned.outro = this.outro;

		return cloned;
	}

	generateDecodedMap(options) {
		options = options || {};

		const sourceIndex = 0;
		const names = Object.keys(this.storedNames);
		const mappings = new Mappings(options.hires);

		const locate = getLocator(this.original);

		if (this.intro) {
			mappings.advance(this.intro);
		}

		this.firstChunk.eachNext((chunk) => {
			const loc = locate(chunk.start);

			if (chunk.intro.length) mappings.advance(chunk.intro);

			if (chunk.edited) {
				mappings.addEdit(
					sourceIndex,
					chunk.content,
					loc,
					chunk.storeName ? names.indexOf(chunk.original) : -1,
				);
			} else {
				mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
			}

			if (chunk.outro.length) mappings.advance(chunk.outro);
		});

		return {
			file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
			sources: [
				options.source ? getRelativePath(options.file || '', options.source) : options.file || '',
			],
			sourcesContent: options.includeContent ? [this.original] : undefined,
			names,
			mappings: mappings.raw,
			x_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,
		};
	}

	generateMap(options) {
		return new SourceMap(this.generateDecodedMap(options));
	}

	_ensureindentStr() {
		if (this.indentStr === undefined) {
			this.indentStr = guessIndent(this.original);
		}
	}

	_getRawIndentString() {
		this._ensureindentStr();
		return this.indentStr;
	}

	getIndentString() {
		this._ensureindentStr();
		return this.indentStr === null ? '\t' : this.indentStr;
	}

	indent(indentStr, options) {
		const pattern = /^[^\r\n]/gm;

		if (isObject(indentStr)) {
			options = indentStr;
			indentStr = undefined;
		}

		if (indentStr === undefined) {
			this._ensureindentStr();
			indentStr = this.indentStr || '\t';
		}

		if (indentStr === '') return this; // noop

		options = options || {};

		// Process exclusion ranges
		const isExcluded = {};

		if (options.exclude) {
			const exclusions =
				typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
			exclusions.forEach((exclusion) => {
				for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
					isExcluded[i] = true;
				}
			});
		}

		let shouldIndentNextCharacter = options.indentStart !== false;
		const replacer = (match) => {
			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
			shouldIndentNextCharacter = true;
			return match;
		};

		this.intro = this.intro.replace(pattern, replacer);

		let charIndex = 0;
		let chunk = this.firstChunk;

		while (chunk) {
			const end = chunk.end;

			if (chunk.edited) {
				if (!isExcluded[charIndex]) {
					chunk.content = chunk.content.replace(pattern, replacer);

					if (chunk.content.length) {
						shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
					}
				}
			} else {
				charIndex = chunk.start;

				while (charIndex < end) {
					if (!isExcluded[charIndex]) {
						const char = this.original[charIndex];

						if (char === '\n') {
							shouldIndentNextCharacter = true;
						} else if (char !== '\r' && shouldIndentNextCharacter) {
							shouldIndentNextCharacter = false;

							if (charIndex === chunk.start) {
								chunk.prependRight(indentStr);
							} else {
								this._splitChunk(chunk, charIndex);
								chunk = chunk.next;
								chunk.prependRight(indentStr);
							}
						}
					}

					charIndex += 1;
				}
			}

			charIndex = chunk.end;
			chunk = chunk.next;
		}

		this.outro = this.outro.replace(pattern, replacer);

		return this;
	}

	insert() {
		throw new Error(
			'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',
		);
	}

	insertLeft(index, content) {
		if (!warned.insertLeft) {
			console.warn(
				'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',
			);
			warned.insertLeft = true;
		}

		return this.appendLeft(index, content);
	}

	insertRight(index, content) {
		if (!warned.insertRight) {
			console.warn(
				'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',
			);
			warned.insertRight = true;
		}

		return this.prependRight(index, content);
	}

	move(start, end, index) {
		start = start + this.offset;
		end = end + this.offset;
		index = index + this.offset;

		if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');

		this._split(start);
		this._split(end);
		this._split(index);

		const first = this.byStart[start];
		const last = this.byEnd[end];

		const oldLeft = first.previous;
		const oldRight = last.next;

		const newRight = this.byStart[index];
		if (!newRight && last === this.lastChunk) return this;
		const newLeft = newRight ? newRight.previous : this.lastChunk;

		if (oldLeft) oldLeft.next = oldRight;
		if (oldRight) oldRight.previous = oldLeft;

		if (newLeft) newLeft.next = first;
		if (newRight) newRight.previous = last;

		if (!first.previous) this.firstChunk = last.next;
		if (!last.next) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}

		first.previous = newLeft;
		last.next = newRight || null;

		if (!newLeft) this.firstChunk = first;
		if (!newRight) this.lastChunk = last;
		return this;
	}

	overwrite(start, end, content, options) {
		options = options || {};
		return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
	}

	update(start, end, content, options) {
		start = start + this.offset;
		end = end + this.offset;

		if (typeof content !== 'string') throw new TypeError('replacement content must be a string');

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		if (end > this.original.length) throw new Error('end is out of bounds');
		if (start === end)
			throw new Error(
				'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',
			);

		this._split(start);
		this._split(end);

		if (options === true) {
			if (!warned.storeName) {
				console.warn(
					'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',
				);
				warned.storeName = true;
			}

			options = { storeName: true };
		}
		const storeName = options !== undefined ? options.storeName : false;
		const overwrite = options !== undefined ? options.overwrite : false;

		if (storeName) {
			const original = this.original.slice(start, end);
			Object.defineProperty(this.storedNames, original, {
				writable: true,
				value: true,
				enumerable: true,
			});
		}

		const first = this.byStart[start];
		const last = this.byEnd[end];

		if (first) {
			let chunk = first;
			while (chunk !== last) {
				if (chunk.next !== this.byStart[chunk.end]) {
					throw new Error('Cannot overwrite across a split point');
				}
				chunk = chunk.next;
				chunk.edit('', false);
			}

			first.edit(content, storeName, !overwrite);
		} else {
			// must be inserting at the end
			const newChunk = new Chunk(start, end, '').edit(content, storeName);

			// TODO last chunk in the array may not be the last chunk, if it's moved...
			last.next = newChunk;
			newChunk.previous = last;
		}
		return this;
	}

	prepend(content) {
		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

		this.intro = content + this.intro;
		return this;
	}

	prependLeft(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byEnd[index];

		if (chunk) {
			chunk.prependLeft(content);
		} else {
			this.intro = content + this.intro;
		}
		return this;
	}

	prependRight(index, content) {
		index = index + this.offset;

		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byStart[index];

		if (chunk) {
			chunk.prependRight(content);
		} else {
			this.outro = content + this.outro;
		}
		return this;
	}

	remove(start, end) {
		start = start + this.offset;
		end = end + this.offset;

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		if (start === end) return this;

		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
		if (start > end) throw new Error('end must be greater than start');

		this._split(start);
		this._split(end);

		let chunk = this.byStart[start];

		while (chunk) {
			chunk.intro = '';
			chunk.outro = '';
			chunk.edit('');

			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}

	reset(start, end) {
		start = start + this.offset;
		end = end + this.offset;

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		if (start === end) return this;

		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
		if (start > end) throw new Error('end must be greater than start');

		this._split(start);
		this._split(end);

		let chunk = this.byStart[start];

		while (chunk) {
			chunk.reset();

			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}

	lastChar() {
		if (this.outro.length) return this.outro[this.outro.length - 1];
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
		} while ((chunk = chunk.previous));
		if (this.intro.length) return this.intro[this.intro.length - 1];
		return '';
	}

	lastLine() {
		let lineIndex = this.outro.lastIndexOf(n);
		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
		let lineStr = this.outro;
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length > 0) {
				lineIndex = chunk.outro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.outro + lineStr;
			}

			if (chunk.content.length > 0) {
				lineIndex = chunk.content.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.content + lineStr;
			}

			if (chunk.intro.length > 0) {
				lineIndex = chunk.intro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.intro + lineStr;
			}
		} while ((chunk = chunk.previous));
		lineIndex = this.intro.lastIndexOf(n);
		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
		return this.intro + lineStr;
	}

	slice(start = 0, end = this.original.length - this.offset) {
		start = start + this.offset;
		end = end + this.offset;

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		let result = '';

		// find start chunk
		let chunk = this.firstChunk;
		while (chunk && (chunk.start > start || chunk.end <= start)) {
			// found end chunk before start
			if (chunk.start < end && chunk.end >= end) {
				return result;
			}

			chunk = chunk.next;
		}

		if (chunk && chunk.edited && chunk.start !== start)
			throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);

		const startChunk = chunk;
		while (chunk) {
			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
				result += chunk.intro;
			}

			const containsEnd = chunk.start < end && chunk.end >= end;
			if (containsEnd && chunk.edited && chunk.end !== end)
				throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);

			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

			result += chunk.content.slice(sliceStart, sliceEnd);

			if (chunk.outro && (!containsEnd || chunk.end === end)) {
				result += chunk.outro;
			}

			if (containsEnd) {
				break;
			}

			chunk = chunk.next;
		}

		return result;
	}

	// TODO deprecate this? not really very useful
	snip(start, end) {
		const clone = this.clone();
		clone.remove(0, start);
		clone.remove(end, clone.original.length);

		return clone;
	}

	_split(index) {
		if (this.byStart[index] || this.byEnd[index]) return;

		let chunk = this.lastSearchedChunk;
		const searchForward = index > chunk.end;

		while (chunk) {
			if (chunk.contains(index)) return this._splitChunk(chunk, index);

			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
		}
	}

	_splitChunk(chunk, index) {
		if (chunk.edited && chunk.content.length) {
			// zero-length edited chunks are a special case (overlapping replacements)
			const loc = getLocator(this.original)(index);
			throw new Error(
				`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`,
			);
		}

		const newChunk = chunk.split(index);

		this.byEnd[index] = chunk;
		this.byStart[index] = newChunk;
		this.byEnd[newChunk.end] = newChunk;

		if (chunk === this.lastChunk) this.lastChunk = newChunk;

		this.lastSearchedChunk = chunk;
		return true;
	}

	toString() {
		let str = this.intro;

		let chunk = this.firstChunk;
		while (chunk) {
			str += chunk.toString();
			chunk = chunk.next;
		}

		return str + this.outro;
	}

	isEmpty() {
		let chunk = this.firstChunk;
		do {
			if (
				(chunk.intro.length && chunk.intro.trim()) ||
				(chunk.content.length && chunk.content.trim()) ||
				(chunk.outro.length && chunk.outro.trim())
			)
				return false;
		} while ((chunk = chunk.next));
		return true;
	}

	length() {
		let chunk = this.firstChunk;
		let length = 0;
		do {
			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
		} while ((chunk = chunk.next));
		return length;
	}

	trimLines() {
		return this.trim('[\\r\\n]');
	}

	trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	}

	trimEndAborted(charType) {
		const rx = new RegExp((charType || '\\s') + '+$');

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) return true;

		let chunk = this.lastChunk;

		do {
			const end = chunk.end;
			const aborted = chunk.trimEnd(rx);

			// if chunk was trimmed, we have a new lastChunk
			if (chunk.end !== end) {
				if (this.lastChunk === chunk) {
					this.lastChunk = chunk.next;
				}

				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}

			if (aborted) return true;
			chunk = chunk.previous;
		} while (chunk);

		return false;
	}

	trimEnd(charType) {
		this.trimEndAborted(charType);
		return this;
	}
	trimStartAborted(charType) {
		const rx = new RegExp('^' + (charType || '\\s') + '+');

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) return true;

		let chunk = this.firstChunk;

		do {
			const end = chunk.end;
			const aborted = chunk.trimStart(rx);

			if (chunk.end !== end) {
				// special case...
				if (chunk === this.lastChunk) this.lastChunk = chunk.next;

				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}

			if (aborted) return true;
			chunk = chunk.next;
		} while (chunk);

		return false;
	}

	trimStart(charType) {
		this.trimStartAborted(charType);
		return this;
	}

	hasChanged() {
		return this.original !== this.toString();
	}

	_replaceRegexp(searchValue, replacement) {
		function getReplacement(match, str) {
			if (typeof replacement === 'string') {
				return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter
					if (i === '$') return '$';
					if (i === '&') return match[0];
					const num = +i;
					if (num < match.length) return match[+i];
					return `$${i}`;
				});
			} else {
				return replacement(...match, match.index, str, match.groups);
			}
		}
		function matchAll(re, str) {
			let match;
			const matches = [];
			while ((match = re.exec(str))) {
				matches.push(match);
			}
			return matches;
		}
		if (searchValue.global) {
			const matches = matchAll(searchValue, this.original);
			matches.forEach((match) => {
				if (match.index != null) {
					const replacement = getReplacement(match, this.original);
					if (replacement !== match[0]) {
						this.overwrite(match.index, match.index + match[0].length, replacement);
					}
				}
			});
		} else {
			const match = this.original.match(searchValue);
			if (match && match.index != null) {
				const replacement = getReplacement(match, this.original);
				if (replacement !== match[0]) {
					this.overwrite(match.index, match.index + match[0].length, replacement);
				}
			}
		}
		return this;
	}

	_replaceString(string, replacement) {
		const { original } = this;
		const index = original.indexOf(string);

		if (index !== -1) {
			this.overwrite(index, index + string.length, replacement);
		}

		return this;
	}

	replace(searchValue, replacement) {
		if (typeof searchValue === 'string') {
			return this._replaceString(searchValue, replacement);
		}

		return this._replaceRegexp(searchValue, replacement);
	}

	_replaceAllString(string, replacement) {
		const { original } = this;
		const stringLength = string.length;
		for (
			let index = original.indexOf(string);
			index !== -1;
			index = original.indexOf(string, index + stringLength)
		) {
			const previous = original.slice(index, index + stringLength);
			if (previous !== replacement) this.overwrite(index, index + stringLength, replacement);
		}

		return this;
	}

	replaceAll(searchValue, replacement) {
		if (typeof searchValue === 'string') {
			return this._replaceAllString(searchValue, replacement);
		}

		if (!searchValue.global) {
			throw new TypeError(
				'MagicString.prototype.replaceAll called with a non-global RegExp argument',
			);
		}

		return this._replaceRegexp(searchValue, replacement);
	}
}

var _a, _b;
class ScriptCompileContext {
  constructor(descriptor, options) {
    this.descriptor = descriptor;
    this.options = options;
    this.isCE = false;
    this.source = this.descriptor.source;
    this.filename = this.descriptor.filename;
    this.s = new MagicString(this.source);
    this.startOffset = (_a = this.descriptor.scriptSetup) == null ? void 0 : _a.loc.start.offset;
    this.endOffset = (_b = this.descriptor.scriptSetup) == null ? void 0 : _b.loc.end.offset;
    this.userImports = /* @__PURE__ */ Object.create(null);
    // macros presence check
    this.hasDefinePropsCall = false;
    this.hasDefineEmitCall = false;
    this.hasDefineExposeCall = false;
    this.hasDefaultExportName = false;
    this.hasDefaultExportRender = false;
    this.hasDefineOptionsCall = false;
    this.hasDefineSlotsCall = false;
    this.hasDefineModelCall = false;
    this.propsDestructuredBindings = /* @__PURE__ */ Object.create(null);
    // defineModel
    this.modelDecls = /* @__PURE__ */ Object.create(null);
    // codegen
    this.bindingMetadata = {};
    this.helperImports = /* @__PURE__ */ new Set();
    const { script, scriptSetup } = descriptor;
    const scriptLang = script && script.lang;
    const scriptSetupLang = scriptSetup && scriptSetup.lang;
    this.isJS = scriptLang === "js" || scriptLang === "jsx" || scriptSetupLang === "js" || scriptSetupLang === "jsx";
    this.isTS = scriptLang === "ts" || scriptLang === "tsx" || scriptSetupLang === "ts" || scriptSetupLang === "tsx";
    this.isUTS = scriptLang === "uts" || scriptSetupLang === "uts";
    const customElement = options.customElement;
    const filename = this.descriptor.filename;
    if (customElement) {
      this.isCE = typeof customElement === "boolean" ? customElement : customElement(filename);
    }
    const plugins = resolveParserPlugins(
      scriptLang || scriptSetupLang,
      options.babelParserPlugins
    );
    function parse(input, offset, startLine) {
      try {
        return libExports.parse(input, {
          plugins,
          sourceType: "module"
        }).program;
      } catch (e) {
        if (e.loc && startLine) {
          e.loc.line = e.loc.line + (startLine - 1);
        }
        e.message = `[vue/compiler-sfc] ${e.message}

${descriptor.filename}
${generateCodeFrame(
          descriptor.source,
          e.pos + offset,
          e.pos + offset + 1
        )}`;
        throw e;
      }
    }
    this.scriptAst = descriptor.script && parse(
      descriptor.script.content,
      descriptor.script.loc.start.offset,
      // fixed by uts
      descriptor.script.loc.start.line
    );
    this.scriptSetupAst = descriptor.scriptSetup && parse(
      descriptor.scriptSetup.content,
      this.startOffset,
      // fixed by uts
      descriptor.scriptSetup.loc.start.line
    );
  }
  helper(key) {
    this.helperImports.add(key);
    return `_${key}`;
  }
  getString(node, scriptSetup = true) {
    const block = scriptSetup ? this.descriptor.scriptSetup : this.descriptor.script;
    return block.content.slice(node.start, node.end);
  }
  warn(msg, node, scope) {
    warn(generateError(msg, node, this, scope));
  }
  error(msg, node, scope) {
    throw new Error(
      `[@vue/compiler-sfc] ${generateError(msg, node, this, scope)}`
    );
  }
}
function generateError(msg, node, ctx, scope) {
  const offset = scope ? scope.offset : ctx.startOffset;
  return `${msg}

${(scope || ctx.descriptor).filename}
${generateCodeFrame(
    (scope || ctx.descriptor).source,
    node.start + offset,
    node.end + offset
  )}`;
}
function resolveParserPlugins(lang, userPlugins, dts = false) {
  const plugins = [];
  if (!userPlugins || !userPlugins.some(
    (p) => p === "importAssertions" || p === "importAttributes" || isArray$3(p) && p[0] === "importAttributes"
  )) {
    plugins.push("importAttributes");
  }
  if (lang === "jsx" || lang === "tsx" || lang === "mtsx") {
    plugins.push("jsx");
  } else if (userPlugins) {
    userPlugins = userPlugins.filter((p) => p !== "jsx");
  }
  if (lang === "uts" || lang === "ts" || lang === "mts" || lang === "tsx" || lang === "mtsx") {
    plugins.push(["typescript", { dts }], "explicitResourceManagement");
    if (!userPlugins || !userPlugins.includes("decorators")) {
      plugins.push("decorators-legacy");
    }
  }
  if (userPlugins) {
    plugins.push(...userPlugins);
  }
  return plugins;
}

function rewriteDefault(input, as, parserPlugins) {
  const ast = libExports.parse(input, {
    sourceType: "module",
    plugins: resolveParserPlugins("js", parserPlugins)
  }).program.body;
  const s = new MagicString(input);
  rewriteDefaultAST(ast, s, as);
  return s.toString();
}
function rewriteDefaultAST(ast, s, as) {
  if (!hasDefaultExport(ast)) {
    s.append(`
const ${as} = {}`);
    return;
  }
  ast.forEach((node) => {
    if (node.type === "ExportDefaultDeclaration") {
      if (node.declaration.type === "ClassDeclaration" && node.declaration.id) {
        const start = node.declaration.decorators && node.declaration.decorators.length > 0 ? node.declaration.decorators[node.declaration.decorators.length - 1].end : node.start;
        s.overwrite(start, node.declaration.id.start, ` class `);
        s.append(`
const ${as} = ${node.declaration.id.name}`);
      } else {
        s.overwrite(node.start, node.declaration.start, `const ${as} = `);
      }
    } else if (node.type === "ExportNamedDeclaration") {
      for (const specifier of node.specifiers) {
        if (specifier.type === "ExportSpecifier" && specifier.exported.type === "Identifier" && specifier.exported.name === "default") {
          if (node.source) {
            if (specifier.local.name === "default") {
              s.prepend(
                `import { default as __VUE_DEFAULT__ } from '${node.source.value}'
`
              );
              const end2 = specifierEnd(s, specifier.local.end, node.end);
              s.remove(specifier.start, end2);
              s.append(`
const ${as} = __VUE_DEFAULT__`);
              continue;
            } else {
              s.prepend(
                `import { ${s.slice(
                  specifier.local.start,
                  specifier.local.end
                )} as __VUE_DEFAULT__ } from '${node.source.value}'
`
              );
              const end2 = specifierEnd(s, specifier.exported.end, node.end);
              s.remove(specifier.start, end2);
              s.append(`
const ${as} = __VUE_DEFAULT__`);
              continue;
            }
          }
          const end = specifierEnd(s, specifier.end, node.end);
          s.remove(specifier.start, end);
          s.append(`
const ${as} = ${specifier.local.name}`);
        }
      }
    }
  });
}
function hasDefaultExport(ast) {
  for (const stmt of ast) {
    if (stmt.type === "ExportDefaultDeclaration") {
      return true;
    } else if (stmt.type === "ExportNamedDeclaration" && stmt.specifiers.some(
      (spec) => spec.exported.name === "default"
    )) {
      return true;
    }
  }
  return false;
}
function specifierEnd(s, end, nodeEnd) {
  let hasCommas = false;
  let oldEnd = end;
  while (end < nodeEnd) {
    if (/\s/.test(s.slice(end, end + 1))) {
      end++;
    } else if (s.slice(end, end + 1) === ",") {
      end++;
      hasCommas = true;
      break;
    } else if (s.slice(end, end + 1) === "}") {
      break;
    }
  }
  return hasCommas ? end : oldEnd;
}

var __defProp$3 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
const normalScriptDefaultVar = `__default__`;
function processNormalScript(ctx, scopeId) {
  var _a;
  const script = ctx.descriptor.script;
  if (script.lang && !ctx.isJS && !ctx.isTS && !ctx.isUTS) {
    return script;
  }
  try {
    let content = script.content;
    let map = script.map;
    const scriptAst = ctx.scriptAst;
    const bindings = analyzeScriptBindings(scriptAst.body);
    const { cssVars } = ctx.descriptor;
    const { genDefaultAs, isProd } = ctx.options;
    if (cssVars.length || genDefaultAs) {
      const defaultVar = genDefaultAs || normalScriptDefaultVar;
      const s = new MagicString(content);
      rewriteDefaultAST(scriptAst.body, s, defaultVar);
      if (ctx.isUTS) {
        scriptAst.body.forEach((node) => {
          if (node.type === "ExportDefaultDeclaration") {
            if (node.declaration.type === "ObjectExpression") {
              s.appendLeft(
                node.declaration.start,
                ctx.descriptor.vapor ? `defineVaporComponent(` : `defineComponent(`
              );
              s.appendRight(node.declaration.end, `)`);
            }
          }
        });
      }
      content = s.toString();
      if (cssVars.length && !((_a = ctx.options.templateOptions) == null ? void 0 : _a.ssr)) {
        content += genNormalScriptCssVarsCode(
          cssVars,
          bindings,
          scopeId,
          !!isProd,
          defaultVar
        );
      }
      if (!genDefaultAs) {
        content += `
export default ${defaultVar}`;
      }
    }
    return __spreadProps$2(__spreadValues$3({}, script), {
      content,
      map,
      bindings,
      scriptAst: scriptAst.body
    });
  } catch (e) {
    return script;
  }
}

var __defProp$2 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
class TypeScope {
  constructor(filename, source, offset = 0, imports = /* @__PURE__ */ Object.create(null), types = /* @__PURE__ */ Object.create(null), declares = /* @__PURE__ */ Object.create(null)) {
    this.filename = filename;
    this.source = source;
    this.offset = offset;
    this.imports = imports;
    this.types = types;
    this.declares = declares;
    this.isGenericScope = false;
    this.resolvedImportSources = /* @__PURE__ */ Object.create(null);
    this.exportedTypes = /* @__PURE__ */ Object.create(null);
    this.exportedDeclares = /* @__PURE__ */ Object.create(null);
  }
}
function resolveTypeElements(ctx, node, scope, typeParameters) {
  const canCache = !typeParameters;
  if (canCache && node._resolvedElements) {
    return node._resolvedElements;
  }
  const resolved = innerResolveTypeElements(
    ctx,
    node,
    node._ownerScope || scope || ctxToScope(ctx),
    typeParameters
  );
  return canCache ? node._resolvedElements = resolved : resolved;
}
function innerResolveTypeElements(ctx, node, scope, typeParameters) {
  var _a, _b;
  if (node.leadingComments && node.leadingComments.some((c) => c.value.includes("@vue-ignore"))) {
    return { props: {} };
  }
  switch (node.type) {
    case "TSTypeLiteral":
      return typeElementsToMap(ctx, node.members, scope, typeParameters);
    case "TSInterfaceDeclaration":
      return resolveInterfaceMembers(ctx, node, scope, typeParameters);
    case "TSTypeAliasDeclaration":
    case "TSTypeAnnotation":
    case "TSParenthesizedType":
      return resolveTypeElements(
        ctx,
        node.typeAnnotation,
        scope,
        typeParameters
      );
    case "TSFunctionType": {
      return { props: {}, calls: [node] };
    }
    case "TSUnionType":
    case "TSIntersectionType":
      return mergeElements(
        node.types.map((t) => resolveTypeElements(ctx, t, scope, typeParameters)),
        node.type
      );
    case "TSMappedType":
      return resolveMappedType(ctx, node, scope, typeParameters);
    case "TSIndexedAccessType": {
      const types = resolveIndexType(ctx, node, scope);
      return mergeElements(
        types.map((t) => resolveTypeElements(ctx, t, t._ownerScope)),
        "TSUnionType"
      );
    }
    case "TSExpressionWithTypeArguments":
    // referenced by interface extends
    case "TSTypeReference": {
      const typeName = getReferenceName(node);
      if ((typeName === "ExtractPropTypes" || typeName === "ExtractPublicPropTypes") && node.typeParameters && ((_a = scope.imports[typeName]) == null ? void 0 : _a.source) === "vue") {
        return resolveExtractPropTypes(
          resolveTypeElements(
            ctx,
            node.typeParameters.params[0],
            scope,
            typeParameters
          ),
          scope
        );
      }
      const resolved = resolveTypeReference(ctx, node, scope);
      if (resolved) {
        let typeParams;
        if ((resolved.type === "TSTypeAliasDeclaration" || resolved.type === "TSInterfaceDeclaration") && resolved.typeParameters && node.typeParameters) {
          typeParams = /* @__PURE__ */ Object.create(null);
          resolved.typeParameters.params.forEach((p, i) => {
            let param = typeParameters && typeParameters[p.name];
            if (!param) param = node.typeParameters.params[i];
            typeParams[p.name] = param;
          });
        }
        return resolveTypeElements(
          ctx,
          resolved,
          resolved._ownerScope,
          typeParams
        );
      } else {
        if (typeof typeName === "string") {
          if (typeParameters && typeParameters[typeName]) {
            return resolveTypeElements(
              ctx,
              typeParameters[typeName],
              scope,
              typeParameters
            );
          }
          if (
            // @ts-expect-error
            SupportedBuiltinsSet.has(typeName)
          ) {
            return resolveBuiltin(
              ctx,
              node,
              typeName,
              scope,
              typeParameters
            );
          } else if (typeName === "ReturnType" && node.typeParameters) {
            const ret = resolveReturnType(
              ctx,
              node.typeParameters.params[0],
              scope
            );
            if (ret) {
              return resolveTypeElements(ctx, ret, scope);
            }
          }
        }
        return ctx.error(
          `Unresolvable type reference or unsupported built-in utility type`,
          node,
          scope
        );
      }
    }
    case "TSImportType": {
      if (getId(node.argument) === "vue" && ((_b = node.qualifier) == null ? void 0 : _b.type) === "Identifier" && node.qualifier.name === "ExtractPropTypes" && node.typeParameters) {
        return resolveExtractPropTypes(
          resolveTypeElements(ctx, node.typeParameters.params[0], scope),
          scope
        );
      }
      const sourceScope = importSourceToScope(
        ctx,
        node.argument,
        scope,
        node.argument.value
      );
      const resolved = resolveTypeReference(ctx, node, sourceScope);
      if (resolved) {
        return resolveTypeElements(ctx, resolved, resolved._ownerScope);
      }
      break;
    }
    case "TSTypeQuery":
      {
        const resolved = resolveTypeReference(ctx, node, scope);
        if (resolved) {
          return resolveTypeElements(ctx, resolved, resolved._ownerScope);
        }
      }
      break;
  }
  return ctx.error(`Unresolvable type: ${node.type}`, node, scope);
}
function typeElementsToMap(ctx, elements, scope = ctxToScope(ctx), typeParameters) {
  const res = { props: {} };
  for (const e of elements) {
    if (e.type === "TSPropertySignature" || e.type === "TSMethodSignature") {
      if (typeParameters) {
        scope = createChildScope(scope);
        scope.isGenericScope = true;
        Object.assign(scope.types, typeParameters);
      }
      e._ownerScope = scope;
      const name = getId(e.key);
      if (name && !e.computed) {
        res.props[name] = e;
      } else if (e.key.type === "TemplateLiteral") {
        for (const key of resolveTemplateKeys(ctx, e.key, scope)) {
          res.props[key] = e;
        }
      } else {
        ctx.error(
          `Unsupported computed key in type referenced by a macro`,
          e.key,
          scope
        );
      }
    } else if (e.type === "TSCallSignatureDeclaration") {
      (res.calls || (res.calls = [])).push(e);
    }
  }
  return res;
}
function mergeElements(maps, type) {
  if (maps.length === 1) return maps[0];
  const res = { props: {} };
  const { props: baseProps } = res;
  for (const { props, calls } of maps) {
    for (const key in props) {
      if (!hasOwn(baseProps, key)) {
        baseProps[key] = props[key];
      } else {
        baseProps[key] = createProperty(
          baseProps[key].key,
          {
            type,
            // @ts-expect-error
            types: [baseProps[key], props[key]]
          },
          baseProps[key]._ownerScope,
          baseProps[key].optional || props[key].optional
        );
      }
    }
    if (calls) {
      (res.calls || (res.calls = [])).push(...calls);
    }
  }
  return res;
}
function createProperty(key, typeAnnotation, scope, optional) {
  return {
    type: "TSPropertySignature",
    key,
    kind: "get",
    optional,
    typeAnnotation: {
      type: "TSTypeAnnotation",
      typeAnnotation
    },
    _ownerScope: scope
  };
}
function resolveInterfaceMembers(ctx, node, scope, typeParameters) {
  const base = typeElementsToMap(
    ctx,
    node.body.body,
    node._ownerScope,
    typeParameters
  );
  if (node.extends) {
    for (const ext of node.extends) {
      try {
        const { props, calls } = resolveTypeElements(ctx, ext, scope);
        for (const key in props) {
          if (!hasOwn(base.props, key)) {
            base.props[key] = props[key];
          }
        }
        if (calls) {
          ;
          (base.calls || (base.calls = [])).push(...calls);
        }
      } catch (e) {
        ctx.error(
          `Failed to resolve extends base type.
If this previously worked in 3.2, you can instruct the compiler to ignore this extend by adding /* @vue-ignore */ before it, for example:

interface Props extends /* @vue-ignore */ Base {}

Note: both in 3.2 or with the ignore, the properties in the base type are treated as fallthrough attrs at runtime.`,
          ext,
          scope
        );
      }
    }
  }
  return base;
}
function resolveMappedType(ctx, node, scope, typeParameters) {
  const res = { props: {} };
  let keys;
  if (node.nameType) {
    const { name, constraint } = node.typeParameter;
    scope = createChildScope(scope);
    Object.assign(scope.types, __spreadProps$1(__spreadValues$2({}, typeParameters), { [name]: constraint }));
    keys = resolveStringType(ctx, node.nameType, scope);
  } else {
    keys = resolveStringType(ctx, node.typeParameter.constraint, scope);
  }
  for (const key of keys) {
    res.props[key] = createProperty(
      {
        type: "Identifier",
        name: key
      },
      node.typeAnnotation,
      scope,
      !!node.optional
    );
  }
  return res;
}
function resolveIndexType(ctx, node, scope) {
  var _a, _b;
  if (node.indexType.type === "TSNumberKeyword") {
    return resolveArrayElementType(ctx, node.objectType, scope);
  }
  const { indexType, objectType } = node;
  const types = [];
  let keys;
  let resolved;
  if (indexType.type === "TSStringKeyword") {
    resolved = resolveTypeElements(ctx, objectType, scope);
    keys = Object.keys(resolved.props);
  } else {
    keys = resolveStringType(ctx, indexType, scope);
    resolved = resolveTypeElements(ctx, objectType, scope);
  }
  for (const key of keys) {
    const targetType = (_b = (_a = resolved.props[key]) == null ? void 0 : _a.typeAnnotation) == null ? void 0 : _b.typeAnnotation;
    if (targetType) {
      targetType._ownerScope = resolved.props[key]._ownerScope;
      types.push(targetType);
    }
  }
  return types;
}
function resolveArrayElementType(ctx, node, scope) {
  if (node.type === "TSArrayType") {
    return [node.elementType];
  }
  if (node.type === "TSTupleType") {
    return node.elementTypes.map(
      (t) => t.type === "TSNamedTupleMember" ? t.elementType : t
    );
  }
  if (node.type === "TSTypeReference") {
    if (getReferenceName(node) === "Array" && node.typeParameters) {
      return node.typeParameters.params;
    } else {
      const resolved = resolveTypeReference(ctx, node, scope);
      if (resolved) {
        return resolveArrayElementType(ctx, resolved, scope);
      }
    }
  }
  return ctx.error(
    "Failed to resolve element type from target type",
    node,
    scope
  );
}
function resolveStringType(ctx, node, scope) {
  switch (node.type) {
    case "StringLiteral":
      return [node.value];
    case "TSLiteralType":
      return resolveStringType(ctx, node.literal, scope);
    case "TSUnionType":
      return node.types.map((t) => resolveStringType(ctx, t, scope)).flat();
    case "TemplateLiteral": {
      return resolveTemplateKeys(ctx, node, scope);
    }
    case "TSTypeReference": {
      const resolved = resolveTypeReference(ctx, node, scope);
      if (resolved) {
        return resolveStringType(ctx, resolved, scope);
      }
      if (node.typeName.type === "Identifier") {
        const getParam = (index = 0) => resolveStringType(ctx, node.typeParameters.params[index], scope);
        switch (node.typeName.name) {
          case "Extract":
            return getParam(1);
          case "Exclude": {
            const excluded = getParam(1);
            return getParam().filter((s) => !excluded.includes(s));
          }
          case "Uppercase":
            return getParam().map((s) => s.toUpperCase());
          case "Lowercase":
            return getParam().map((s) => s.toLowerCase());
          case "Capitalize":
            return getParam().map(capitalize);
          case "Uncapitalize":
            return getParam().map((s) => s[0].toLowerCase() + s.slice(1));
          default:
            ctx.error(
              "Unsupported type when resolving index type",
              node.typeName,
              scope
            );
        }
      }
    }
  }
  return ctx.error("Failed to resolve index type into finite keys", node, scope);
}
function resolveTemplateKeys(ctx, node, scope) {
  if (!node.expressions.length) {
    return [node.quasis[0].value.raw];
  }
  const res = [];
  const e = node.expressions[0];
  const q = node.quasis[0];
  const leading = q ? q.value.raw : ``;
  const resolved = resolveStringType(ctx, e, scope);
  const restResolved = resolveTemplateKeys(
    ctx,
    __spreadProps$1(__spreadValues$2({}, node), {
      expressions: node.expressions.slice(1),
      quasis: q ? node.quasis.slice(1) : node.quasis
    }),
    scope
  );
  for (const r of resolved) {
    for (const rr of restResolved) {
      res.push(leading + r + rr);
    }
  }
  return res;
}
const SupportedBuiltinsSet = /* @__PURE__ */ new Set([
  "Partial",
  "Required",
  "Readonly",
  "Pick",
  "Omit"
]);
function resolveBuiltin(ctx, node, name, scope, typeParameters) {
  const t = resolveTypeElements(
    ctx,
    node.typeParameters.params[0],
    scope,
    typeParameters
  );
  switch (name) {
    case "Partial": {
      const res2 = { props: {}, calls: t.calls };
      Object.keys(t.props).forEach((key) => {
        res2.props[key] = __spreadProps$1(__spreadValues$2({}, t.props[key]), { optional: true });
      });
      return res2;
    }
    case "Required": {
      const res2 = { props: {}, calls: t.calls };
      Object.keys(t.props).forEach((key) => {
        res2.props[key] = __spreadProps$1(__spreadValues$2({}, t.props[key]), { optional: false });
      });
      return res2;
    }
    case "Readonly":
      return t;
    case "Pick": {
      const picked = resolveStringType(
        ctx,
        node.typeParameters.params[1],
        scope
      );
      const res2 = { props: {}, calls: t.calls };
      for (const key of picked) {
        res2.props[key] = t.props[key];
      }
      return res2;
    }
    case "Omit":
      const omitted = resolveStringType(
        ctx,
        node.typeParameters.params[1],
        scope
      );
      const res = { props: {}, calls: t.calls };
      for (const key in t.props) {
        if (!omitted.includes(key)) {
          res.props[key] = t.props[key];
        }
      }
      return res;
  }
}
function resolveTypeReference(ctx, node, scope, name, onlyExported = false) {
  const canCache = !(scope == null ? void 0 : scope.isGenericScope);
  if (canCache && node._resolvedReference) {
    return node._resolvedReference;
  }
  const resolved = innerResolveTypeReference(
    ctx,
    scope || ctxToScope(ctx),
    name || getReferenceName(node),
    node,
    onlyExported
  );
  return canCache ? node._resolvedReference = resolved : resolved;
}
function innerResolveTypeReference(ctx, scope, name, node, onlyExported) {
  if (typeof name === "string") {
    if (scope.imports[name]) {
      return resolveTypeFromImport(ctx, node, name, scope);
    } else {
      const lookupSource = node.type === "TSTypeQuery" ? onlyExported ? scope.exportedDeclares : scope.declares : onlyExported ? scope.exportedTypes : scope.types;
      if (lookupSource[name]) {
        return lookupSource[name];
      } else {
        const globalScopes = resolveGlobalScope(ctx);
        if (globalScopes) {
          for (const s of globalScopes) {
            const src = node.type === "TSTypeQuery" ? s.declares : s.types;
            if (src[name]) {
              (ctx.deps || (ctx.deps = /* @__PURE__ */ new Set())).add(s.filename);
              return src[name];
            }
          }
        }
      }
    }
  } else {
    let ns = innerResolveTypeReference(ctx, scope, name[0], node, onlyExported);
    if (ns) {
      if (ns.type !== "TSModuleDeclaration") {
        ns = ns._ns;
      }
      if (ns) {
        const childScope = moduleDeclToScope(ctx, ns, ns._ownerScope || scope);
        return innerResolveTypeReference(
          ctx,
          childScope,
          name.length > 2 ? name.slice(1) : name[name.length - 1],
          node,
          !ns.declare
        );
      }
    }
  }
}
function getReferenceName(node) {
  const ref = node.type === "TSTypeReference" ? node.typeName : node.type === "TSExpressionWithTypeArguments" ? node.expression : node.type === "TSImportType" ? node.qualifier : node.exprName;
  if ((ref == null ? void 0 : ref.type) === "Identifier") {
    return ref.name;
  } else if ((ref == null ? void 0 : ref.type) === "TSQualifiedName") {
    return qualifiedNameToPath(ref);
  } else {
    return "default";
  }
}
function qualifiedNameToPath(node) {
  if (node.type === "Identifier") {
    return [node.name];
  } else {
    return [...qualifiedNameToPath(node.left), node.right.name];
  }
}
function resolveGlobalScope(ctx) {
  if (ctx.options.globalTypeFiles) {
    const fs = resolveFS(ctx);
    if (!fs) {
      throw new Error("[vue/compiler-sfc] globalTypeFiles requires fs access.");
    }
    return ctx.options.globalTypeFiles.map(
      (file) => fileToScope(ctx, normalizePath(file), true)
    );
  }
}
let ts;
let loadTS;
function registerTS(_loadTS) {
  loadTS = () => {
    try {
      return _loadTS();
    } catch (err) {
      if (typeof err.message === "string" && err.message.includes("Cannot find module")) {
        throw new Error(
          'Failed to load TypeScript, which is required for resolving imported types. Please make sure "typescript" is installed as a project dependency.'
        );
      } else {
        throw new Error(
          "Failed to load TypeScript for resolving imported types."
        );
      }
    }
  };
}
function resolveFS(ctx) {
  if (ctx.fs) {
    return ctx.fs;
  }
  if (!ts && loadTS) {
    ts = loadTS();
  }
  const fs = ctx.options.fs || (ts == null ? void 0 : ts.sys);
  if (!fs) {
    return;
  }
  return ctx.fs = {
    fileExists(file) {
      if (file.endsWith(".vue.ts")) {
        file = file.replace(/\.ts$/, "");
      }
      return fs.fileExists(file);
    },
    readFile(file) {
      if (file.endsWith(".vue.ts")) {
        file = file.replace(/\.ts$/, "");
      }
      return fs.readFile(file);
    },
    realpath: fs.realpath
  };
}
function resolveTypeFromImport(ctx, node, name, scope) {
  const { source, imported } = scope.imports[name];
  const sourceScope = importSourceToScope(ctx, node, scope, source);
  return resolveTypeReference(ctx, node, sourceScope, imported, true);
}
function importSourceToScope(ctx, node, scope, source) {
  let fs;
  try {
    fs = resolveFS(ctx);
  } catch (err) {
    return ctx.error(err.message, node, scope);
  }
  if (!fs) {
    return ctx.error(
      `No fs option provided to \`compileScript\` in non-Node environment. File system access is required for resolving imported types.`,
      node,
      scope
    );
  }
  let resolved = scope.resolvedImportSources[source];
  if (!resolved) {
    if (source.startsWith("..")) {
      const osSpecificJoinFn = joinPaths;
      const filename = osSpecificJoinFn(dirname(scope.filename), source);
      resolved = resolveExt(filename, fs);
    } else if (source[0] === ".") {
      const filename = joinPaths(dirname(scope.filename), source);
      resolved = resolveExt(filename, fs);
    } else if (env.UNI_INPUT_DIR && source.startsWith("@/")) {
      resolved = resolveExt(
        joinPaths(env.UNI_INPUT_DIR, source.replace("@/", "")),
        fs
      );
    } else {
      {
        return ctx.error(
          `Type import from non-relative sources is not supported in the browser build.`,
          node,
          scope
        );
      }
    }
    if (resolved) {
      resolved = scope.resolvedImportSources[source] = normalizePath(resolved);
    }
  }
  if (resolved) {
    (ctx.deps || (ctx.deps = /* @__PURE__ */ new Set())).add(resolved);
    return fileToScope(ctx, resolved);
  } else {
    return ctx.error(
      `Failed to resolve import source ${JSON.stringify(source)}.`,
      node,
      scope
    );
  }
}
function resolveExt(filename, fs) {
  filename = filename.replace(/\.js$/, "");
  const tryResolve = (filename2) => {
    if (fs.fileExists(filename2)) return filename2;
  };
  return tryResolve(filename) || tryResolve(filename + `.ts`) || tryResolve(filename + `.tsx`) || tryResolve(filename + `.d.ts`) || tryResolve(joinPaths(filename, `index.ts`)) || tryResolve(joinPaths(filename, `index.tsx`)) || tryResolve(joinPaths(filename, `index.d.ts`));
}
const tsConfigCache = createCache();
const tsConfigRefMap = /* @__PURE__ */ new Map();
const fileToScopeCache = createCache();
function invalidateTypeCache(filename) {
  filename = normalizePath(filename);
  fileToScopeCache.delete(filename);
  tsConfigCache.delete(filename);
  const affectedConfig = tsConfigRefMap.get(filename);
  if (affectedConfig) tsConfigCache.delete(affectedConfig);
}
function fileToScope(ctx, filename, asGlobal = false) {
  const cached = fileToScopeCache.get(filename);
  if (cached) {
    return cached;
  }
  const fs = resolveFS(ctx);
  const source = fs.readFile(filename) || "";
  const body = parseFile(filename, source, ctx.options.babelParserPlugins);
  const scope = new TypeScope(filename, source, 0, recordImports(body));
  recordTypes(ctx, body, scope, asGlobal);
  fileToScopeCache.set(filename, scope);
  return scope;
}
function parseFile(filename, content, parserPlugins) {
  const ext = extname(filename);
  if (ext === ".uts" || ext === ".ts" || ext === ".mts" || ext === ".tsx" || ext === ".mtsx") {
    return libExports.parse(content, {
      plugins: resolveParserPlugins(
        ext.slice(1),
        parserPlugins,
        /\.d\.m?ts$/.test(filename)
      ),
      sourceType: "module"
    }).program.body;
  } else if (ext === ".uvue" || ext === ".nvue" || ext === ".vue") {
    const {
      descriptor: { script, scriptSetup }
    } = parse$2(content);
    if (!script && !scriptSetup) {
      return [];
    }
    const scriptOffset = script ? script.loc.start.offset : Infinity;
    const scriptSetupOffset = scriptSetup ? scriptSetup.loc.start.offset : Infinity;
    const firstBlock = scriptOffset < scriptSetupOffset ? script : scriptSetup;
    const secondBlock = scriptOffset < scriptSetupOffset ? scriptSetup : script;
    let scriptContent = " ".repeat(Math.min(scriptOffset, scriptSetupOffset)) + firstBlock.content;
    if (secondBlock) {
      scriptContent += " ".repeat(secondBlock.loc.start.offset - script.loc.end.offset) + secondBlock.content;
    }
    const lang = (script == null ? void 0 : script.lang) || (scriptSetup == null ? void 0 : scriptSetup.lang);
    return libExports.parse(scriptContent, {
      plugins: resolveParserPlugins(lang, parserPlugins),
      sourceType: "module"
    }).program.body;
  }
  return [];
}
function ctxToScope(ctx) {
  if (ctx.scope) {
    return ctx.scope;
  }
  const body = "ast" in ctx ? ctx.ast : ctx.scriptAst ? [...ctx.scriptAst.body, ...ctx.scriptSetupAst.body] : ctx.scriptSetupAst.body;
  const scope = new TypeScope(
    ctx.filename,
    ctx.source,
    "startOffset" in ctx ? ctx.startOffset : 0,
    "userImports" in ctx ? Object.create(ctx.userImports) : recordImports(body)
  );
  recordTypes(ctx, body, scope);
  return ctx.scope = scope;
}
function moduleDeclToScope(ctx, node, parentScope) {
  if (node._resolvedChildScope) {
    return node._resolvedChildScope;
  }
  const scope = createChildScope(parentScope);
  if (node.body.type === "TSModuleDeclaration") {
    const decl = node.body;
    decl._ownerScope = scope;
    const id = getId(decl.id);
    scope.types[id] = scope.exportedTypes[id] = decl;
  } else {
    recordTypes(ctx, node.body.body, scope);
  }
  return node._resolvedChildScope = scope;
}
function createChildScope(parentScope) {
  return new TypeScope(
    parentScope.filename,
    parentScope.source,
    parentScope.offset,
    Object.create(parentScope.imports),
    Object.create(parentScope.types),
    Object.create(parentScope.declares)
  );
}
const importExportRE = /^Import|^Export/;
function recordTypes(ctx, body, scope, asGlobal = false) {
  const { types, declares, exportedTypes, exportedDeclares, imports } = scope;
  const isAmbient = asGlobal ? !body.some((s) => importExportRE.test(s.type)) : false;
  for (const stmt of body) {
    if (asGlobal) {
      if (isAmbient) {
        if (stmt.declare) {
          recordType(stmt, types, declares);
        }
      } else if (stmt.type === "TSModuleDeclaration" && stmt.global) {
        for (const s of stmt.body.body) {
          recordType(s, types, declares);
        }
      }
    } else {
      recordType(stmt, types, declares);
    }
  }
  if (!asGlobal) {
    for (const stmt of body) {
      if (stmt.type === "ExportNamedDeclaration") {
        if (stmt.declaration) {
          recordType(stmt.declaration, types, declares);
          recordType(stmt.declaration, exportedTypes, exportedDeclares);
        } else {
          for (const spec of stmt.specifiers) {
            if (spec.type === "ExportSpecifier") {
              const local = spec.local.name;
              const exported = getId(spec.exported);
              if (stmt.source) {
                imports[exported] = {
                  source: stmt.source.value,
                  imported: local
                };
                exportedTypes[exported] = {
                  type: "TSTypeReference",
                  typeName: {
                    type: "Identifier",
                    name: local
                  },
                  _ownerScope: scope
                };
              } else if (types[local]) {
                exportedTypes[exported] = types[local];
              }
            }
          }
        }
      } else if (stmt.type === "ExportAllDeclaration") {
        const sourceScope = importSourceToScope(
          ctx,
          stmt.source,
          scope,
          stmt.source.value
        );
        Object.assign(scope.exportedTypes, sourceScope.exportedTypes);
      } else if (stmt.type === "ExportDefaultDeclaration" && stmt.declaration) {
        if (stmt.declaration.type !== "Identifier") {
          recordType(stmt.declaration, types, declares, "default");
          recordType(
            stmt.declaration,
            exportedTypes,
            exportedDeclares,
            "default"
          );
        } else if (types[stmt.declaration.name]) {
          exportedTypes["default"] = types[stmt.declaration.name];
        }
      }
    }
  }
  for (const key of Object.keys(types)) {
    const node = types[key];
    node._ownerScope = scope;
    if (node._ns) node._ns._ownerScope = scope;
  }
  for (const key of Object.keys(declares)) {
    declares[key]._ownerScope = scope;
  }
}
function recordType(node, types, declares, overwriteId) {
  switch (node.type) {
    case "TSInterfaceDeclaration":
    case "TSEnumDeclaration":
    case "TSModuleDeclaration": {
      const id = overwriteId || getId(node.id);
      let existing = types[id];
      if (existing) {
        if (node.type === "TSModuleDeclaration") {
          if (existing.type === "TSModuleDeclaration") {
            mergeNamespaces(existing, node);
          } else {
            attachNamespace(existing, node);
          }
          break;
        }
        if (existing.type === "TSModuleDeclaration") {
          types[id] = node;
          attachNamespace(node, existing);
          break;
        }
        if (existing.type !== node.type) {
          break;
        }
        if (node.type === "TSInterfaceDeclaration") {
          existing.body.body.push(...node.body.body);
        } else {
          existing.members.push(...node.members);
        }
      } else {
        types[id] = node;
      }
      break;
    }
    case "ClassDeclaration":
      if (overwriteId || node.id) types[overwriteId || getId(node.id)] = node;
      break;
    case "TSTypeAliasDeclaration":
      types[node.id.name] = node.typeParameters ? node : node.typeAnnotation;
      break;
    case "TSDeclareFunction":
      if (node.id) declares[node.id.name] = node;
      break;
    case "VariableDeclaration": {
      if (node.declare) {
        for (const decl of node.declarations) {
          if (decl.id.type === "Identifier" && decl.id.typeAnnotation) {
            declares[decl.id.name] = decl.id.typeAnnotation.typeAnnotation;
          }
        }
      }
      break;
    }
  }
}
function mergeNamespaces(to, from) {
  const toBody = to.body;
  const fromBody = from.body;
  if (toBody.type === "TSModuleDeclaration") {
    if (fromBody.type === "TSModuleDeclaration") {
      mergeNamespaces(toBody, fromBody);
    } else {
      fromBody.body.push({
        type: "ExportNamedDeclaration",
        declaration: toBody,
        exportKind: "type",
        specifiers: []
      });
    }
  } else if (fromBody.type === "TSModuleDeclaration") {
    toBody.body.push({
      type: "ExportNamedDeclaration",
      declaration: fromBody,
      exportKind: "type",
      specifiers: []
    });
  } else {
    toBody.body.push(...fromBody.body);
  }
}
function attachNamespace(to, ns) {
  if (!to._ns) {
    to._ns = ns;
  } else {
    mergeNamespaces(to._ns, ns);
  }
}
function recordImports(body) {
  const imports = /* @__PURE__ */ Object.create(null);
  for (const s of body) {
    recordImport(s, imports);
  }
  return imports;
}
function recordImport(node, imports) {
  if (node.type !== "ImportDeclaration") {
    return;
  }
  for (const s of node.specifiers) {
    imports[s.local.name] = {
      imported: getImportedName(s),
      source: node.source.value
    };
  }
}
function inferRuntimeType(ctx, node, scope = node._ownerScope || ctxToScope(ctx), isKeyOf = false) {
  try {
    switch (node.type) {
      case "TSStringKeyword":
        return ["String"];
      case "TSNumberKeyword":
        return ["Number"];
      case "TSBooleanKeyword":
        return ["Boolean"];
      case "TSObjectKeyword":
        return ["Object"];
      case "TSNullKeyword":
        return ["null"];
      case "TSTypeLiteral":
      case "TSInterfaceDeclaration": {
        const types = /* @__PURE__ */ new Set();
        const members = node.type === "TSTypeLiteral" ? node.members : node.body.body;
        for (const m of members) {
          if (isKeyOf) {
            if (m.type === "TSPropertySignature" && m.key.type === "NumericLiteral") {
              types.add("Number");
            } else if (m.type === "TSIndexSignature") {
              const annotation = m.parameters[0].typeAnnotation;
              if (annotation && annotation.type !== "Noop") {
                const type = inferRuntimeType(
                  ctx,
                  annotation.typeAnnotation,
                  scope
                )[0];
                if (type === UNKNOWN_TYPE) return [UNKNOWN_TYPE];
                types.add(type);
              }
            } else {
              types.add("String");
            }
          } else if (m.type === "TSCallSignatureDeclaration" || m.type === "TSConstructSignatureDeclaration") {
            types.add("Function");
          } else {
            types.add("Object");
          }
        }
        return types.size ? Array.from(types) : [isKeyOf ? UNKNOWN_TYPE : "Object"];
      }
      case "TSPropertySignature":
        if (node.typeAnnotation) {
          return inferRuntimeType(
            ctx,
            node.typeAnnotation.typeAnnotation,
            scope
          );
        }
        break;
      case "TSMethodSignature":
      case "TSFunctionType":
        return ["Function"];
      case "TSArrayType":
      case "TSTupleType":
        return ["Array"];
      case "TSLiteralType":
        switch (node.literal.type) {
          case "StringLiteral":
            return ["String"];
          case "BooleanLiteral":
            return ["Boolean"];
          case "NumericLiteral":
          case "BigIntLiteral":
            return ["Number"];
          default:
            return [UNKNOWN_TYPE];
        }
      case "TSTypeReference": {
        const resolved = resolveTypeReference(ctx, node, scope);
        if (resolved) {
          return inferRuntimeType(ctx, resolved, resolved._ownerScope, isKeyOf);
        }
        if (node.typeName.type === "Identifier") {
          if (isKeyOf) {
            switch (node.typeName.name) {
              case "String":
              case "Array":
              case "ArrayLike":
              case "Parameters":
              case "ConstructorParameters":
              case "ReadonlyArray":
                return ["String", "Number"];
              // TS built-in utility types
              case "Record":
              case "Partial":
              case "Required":
              case "Readonly":
                if (node.typeParameters && node.typeParameters.params[0]) {
                  return inferRuntimeType(
                    ctx,
                    node.typeParameters.params[0],
                    scope,
                    true
                  );
                }
                break;
              case "Pick":
              case "Extract":
                if (node.typeParameters && node.typeParameters.params[1]) {
                  return inferRuntimeType(
                    ctx,
                    node.typeParameters.params[1],
                    scope
                  );
                }
                break;
              case "Function":
              case "Object":
              case "Set":
              case "Map":
              case "WeakSet":
              case "WeakMap":
              case "Date":
              case "Promise":
              case "Error":
              case "Uppercase":
              case "Lowercase":
              case "Capitalize":
              case "Uncapitalize":
              case "ReadonlyMap":
              case "ReadonlySet":
                return ["String"];
            }
          } else {
            switch (node.typeName.name) {
              case "Array":
              case "Function":
              case "Object":
              case "Set":
              case "Map":
              case "WeakSet":
              case "WeakMap":
              case "Date":
              case "Promise":
              case "Error":
                return [node.typeName.name];
              // TS built-in utility types
              // https://www.typescriptlang.org/docs/handbook/utility-types.html
              case "Partial":
              case "Required":
              case "Readonly":
              case "Record":
              case "Pick":
              case "Omit":
              case "InstanceType":
                return ["Object"];
              case "Uppercase":
              case "Lowercase":
              case "Capitalize":
              case "Uncapitalize":
                return ["String"];
              case "Parameters":
              case "ConstructorParameters":
              case "ReadonlyArray":
                return ["Array"];
              case "ReadonlyMap":
                return ["Map"];
              case "ReadonlySet":
                return ["Set"];
              case "NonNullable":
                if (node.typeParameters && node.typeParameters.params[0]) {
                  return inferRuntimeType(
                    ctx,
                    node.typeParameters.params[0],
                    scope
                  ).filter((t) => t !== "null");
                }
                break;
              case "Extract":
                if (node.typeParameters && node.typeParameters.params[1]) {
                  return inferRuntimeType(
                    ctx,
                    node.typeParameters.params[1],
                    scope
                  );
                }
                break;
              case "Exclude":
              case "OmitThisParameter":
                if (node.typeParameters && node.typeParameters.params[0]) {
                  return inferRuntimeType(
                    ctx,
                    node.typeParameters.params[0],
                    scope
                  );
                }
                break;
            }
          }
        }
        break;
      }
      case "TSParenthesizedType":
        return inferRuntimeType(ctx, node.typeAnnotation, scope);
      case "TSUnionType":
        return flattenTypes(ctx, node.types, scope, isKeyOf);
      case "TSIntersectionType": {
        return flattenTypes(ctx, node.types, scope, isKeyOf).filter(
          (t) => t !== UNKNOWN_TYPE
        );
      }
      case "TSEnumDeclaration":
        return inferEnumType(node);
      case "TSSymbolKeyword":
        return ["Symbol"];
      case "TSIndexedAccessType": {
        const types = resolveIndexType(ctx, node, scope);
        return flattenTypes(ctx, types, scope, isKeyOf);
      }
      case "ClassDeclaration":
        return ["Object"];
      case "TSImportType": {
        const sourceScope = importSourceToScope(
          ctx,
          node.argument,
          scope,
          node.argument.value
        );
        const resolved = resolveTypeReference(ctx, node, sourceScope);
        if (resolved) {
          return inferRuntimeType(ctx, resolved, resolved._ownerScope);
        }
        break;
      }
      case "TSTypeQuery": {
        const id = node.exprName;
        if (id.type === "Identifier") {
          const matched = scope.declares[id.name];
          if (matched) {
            return inferRuntimeType(ctx, matched, matched._ownerScope, isKeyOf);
          }
        }
        break;
      }
      // e.g. readonly
      case "TSTypeOperator": {
        return inferRuntimeType(
          ctx,
          node.typeAnnotation,
          scope,
          node.operator === "keyof"
        );
      }
      case "TSAnyKeyword": {
        if (isKeyOf) {
          return ["String", "Number", "Symbol"];
        }
        break;
      }
    }
  } catch (e) {
  }
  return [UNKNOWN_TYPE];
}
function flattenTypes(ctx, types, scope, isKeyOf = false) {
  if (types.length === 1) {
    return inferRuntimeType(ctx, types[0], scope, isKeyOf);
  }
  return [
    ...new Set(
      [].concat(
        ...types.map((t) => inferRuntimeType(ctx, t, scope, isKeyOf))
      )
    )
  ];
}
function inferEnumType(node) {
  const types = /* @__PURE__ */ new Set();
  for (const m of node.members) {
    if (m.initializer) {
      switch (m.initializer.type) {
        case "StringLiteral":
          types.add("String");
          break;
        case "NumericLiteral":
          types.add("Number");
          break;
      }
    }
  }
  return types.size ? [...types] : ["Number"];
}
function resolveExtractPropTypes({ props }, scope) {
  const res = { props: {} };
  for (const key in props) {
    const raw = props[key];
    res.props[key] = reverseInferType(
      raw.key,
      raw.typeAnnotation.typeAnnotation,
      scope
    );
  }
  return res;
}
function reverseInferType(key, node, scope, optional = true, checkObjectSyntax = true) {
  if (checkObjectSyntax && node.type === "TSTypeLiteral") {
    const typeType = findStaticPropertyType(node, "type");
    if (typeType) {
      const requiredType = findStaticPropertyType(node, "required");
      const optional2 = requiredType && requiredType.type === "TSLiteralType" && requiredType.literal.type === "BooleanLiteral" ? !requiredType.literal.value : true;
      return reverseInferType(key, typeType, scope, optional2, false);
    }
  } else if (node.type === "TSTypeReference" && node.typeName.type === "Identifier") {
    if (node.typeName.name.endsWith("Constructor")) {
      return createProperty(
        key,
        ctorToType(node.typeName.name),
        scope,
        optional
      );
    } else if (node.typeName.name === "PropType" && node.typeParameters) {
      return createProperty(key, node.typeParameters.params[0], scope, optional);
    }
  }
  if ((node.type === "TSTypeReference" || node.type === "TSImportType") && node.typeParameters) {
    for (const t of node.typeParameters.params) {
      const inferred = reverseInferType(key, t, scope, optional);
      if (inferred) return inferred;
    }
  }
  return createProperty(key, { type: `TSNullKeyword` }, scope, optional);
}
function ctorToType(ctorType) {
  const ctor = ctorType.slice(0, -11);
  switch (ctor) {
    case "String":
    case "Number":
    case "Boolean":
      return { type: `TS${ctor}Keyword` };
    case "Array":
    case "Function":
    case "Object":
    case "Set":
    case "Map":
    case "WeakSet":
    case "WeakMap":
    case "Date":
    case "Promise":
      return {
        type: "TSTypeReference",
        typeName: { type: "Identifier", name: ctor }
      };
  }
  return { type: `TSNullKeyword` };
}
function findStaticPropertyType(node, key) {
  const prop = node.members.find(
    (m) => m.type === "TSPropertySignature" && !m.computed && getId(m.key) === key && m.typeAnnotation
  );
  return prop && prop.typeAnnotation.typeAnnotation;
}
function resolveReturnType(ctx, arg, scope) {
  var _a;
  let resolved = arg;
  if (arg.type === "TSTypeReference" || arg.type === "TSTypeQuery" || arg.type === "TSImportType") {
    resolved = resolveTypeReference(ctx, arg, scope);
  }
  if (!resolved) return;
  if (resolved.type === "TSFunctionType") {
    return (_a = resolved.typeAnnotation) == null ? void 0 : _a.typeAnnotation;
  }
  if (resolved.type === "TSDeclareFunction") {
    return resolved.returnType;
  }
}
function resolveUnionType(ctx, node, scope) {
  if (node.type === "TSTypeReference") {
    const resolved = resolveTypeReference(ctx, node, scope);
    if (resolved) node = resolved;
  }
  let types;
  if (node.type === "TSUnionType") {
    types = node.types.flatMap((node2) => resolveUnionType(ctx, node2, scope));
  } else {
    types = [node];
  }
  return types;
}

const DEFINE_MODEL = "defineModel";
function processDefineModel(ctx, node, declId) {
  if (!isCallOf(node, DEFINE_MODEL)) {
    return false;
  }
  ctx.hasDefineModelCall = true;
  const type = node.typeParameters && node.typeParameters.params[0] || void 0;
  let modelName;
  let options;
  const arg0 = node.arguments[0] && unwrapTSNode(node.arguments[0]);
  const hasName = arg0 && arg0.type === "StringLiteral";
  if (hasName) {
    modelName = arg0.value;
    options = node.arguments[1];
  } else {
    modelName = "modelValue";
    options = arg0;
  }
  if (ctx.modelDecls[modelName]) {
    ctx.error(`duplicate model name ${JSON.stringify(modelName)}`, node);
  }
  let optionsString = options && ctx.getString(options);
  let optionsRemoved = !options;
  const runtimeOptionNodes = [];
  if (options && options.type === "ObjectExpression" && !options.properties.some((p) => p.type === "SpreadElement" || p.computed)) {
    let removed = 0;
    for (let i = options.properties.length - 1; i >= 0; i--) {
      const p = options.properties[i];
      const next = options.properties[i + 1];
      const start = p.start;
      const end = next ? next.start : options.end - 1;
      if ((p.type === "ObjectProperty" || p.type === "ObjectMethod") && (p.key.type === "Identifier" && (p.key.name === "get" || p.key.name === "set") || p.key.type === "StringLiteral" && (p.key.value === "get" || p.key.value === "set"))) {
        optionsString = optionsString.slice(0, start - options.start) + optionsString.slice(end - options.start);
      } else {
        removed++;
        ctx.s.remove(ctx.startOffset + start, ctx.startOffset + end);
        runtimeOptionNodes.push(p);
      }
    }
    if (removed === options.properties.length) {
      optionsRemoved = true;
      ctx.s.remove(
        ctx.startOffset + (hasName ? arg0.end : options.start),
        ctx.startOffset + options.end
      );
    }
  }
  ctx.modelDecls[modelName] = {
    type,
    options: optionsString,
    runtimeOptionNodes,
    identifier: declId && declId.type === "Identifier" ? declId.name : void 0
  };
  ctx.bindingMetadata[modelName] = "props";
  ctx.s.overwrite(
    ctx.startOffset + node.callee.start,
    ctx.startOffset + node.callee.end,
    ctx.helper("useModel")
  );
  ctx.s.appendLeft(
    ctx.startOffset + (node.arguments.length ? node.arguments[0].start : node.end - 1),
    `__props, ` + (hasName ? `` : `${JSON.stringify(modelName)}${optionsRemoved ? `` : `, `}`)
  );
  return true;
}
function genModelProps(ctx) {
  if (!ctx.hasDefineModelCall) return;
  const isProd = !!ctx.options.isProd;
  let modelPropsDecl = "";
  for (const [name, { type, options: runtimeOptions }] of Object.entries(
    ctx.modelDecls
  )) {
    let skipCheck = false;
    let codegenOptions = ``;
    let runtimeTypes = type && inferRuntimeType(ctx, type);
    if (runtimeTypes) {
      const hasBoolean = runtimeTypes.includes("Boolean");
      const hasFunction = runtimeTypes.includes("Function");
      const hasUnknownType = runtimeTypes.includes(UNKNOWN_TYPE);
      if (hasUnknownType) {
        if (hasBoolean || hasFunction) {
          runtimeTypes = runtimeTypes.filter((t) => t !== UNKNOWN_TYPE);
          skipCheck = true;
        } else {
          runtimeTypes = ["null"];
        }
      }
      if (!isProd) {
        codegenOptions = `type: ${toRuntimeTypeString(runtimeTypes)}` + (skipCheck ? ", skipCheck: true" : "");
      } else if (hasBoolean || runtimeOptions && hasFunction) {
        codegenOptions = `type: ${toRuntimeTypeString(runtimeTypes)}`;
      } else ;
    }
    let decl;
    if (codegenOptions && runtimeOptions) {
      decl = ctx.isTS || ctx.isUTS ? `{ ${codegenOptions}, ...${runtimeOptions} }` : `Object.assign({ ${codegenOptions} }, ${runtimeOptions})`;
    } else if (codegenOptions) {
      decl = `{ ${codegenOptions} }`;
    } else if (runtimeOptions) {
      decl = runtimeOptions;
    } else {
      decl = `{}`;
    }
    modelPropsDecl += `
    ${JSON.stringify(name)}: ${decl},`;
    const modifierPropName = JSON.stringify(
      name === "modelValue" ? `modelModifiers` : `${name}Modifiers`
    );
    modelPropsDecl += `
    ${modifierPropName}: {},`;
  }
  return `{${modelPropsDecl}
  }`;
}

const DEFINE_PROPS = "defineProps";
const WITH_DEFAULTS = "withDefaults";
function processDefineProps(ctx, node, declId, isWithDefaults = false) {
  if (!isCallOf(node, DEFINE_PROPS)) {
    return processWithDefaults(ctx, node, declId);
  }
  if (ctx.hasDefinePropsCall) {
    ctx.error(`duplicate ${DEFINE_PROPS}() call`, node);
  }
  ctx.hasDefinePropsCall = true;
  ctx.propsRuntimeDecl = node.arguments[0];
  if (ctx.propsRuntimeDecl) {
    for (const key of getObjectOrArrayExpressionKeys(ctx.propsRuntimeDecl)) {
      if (!(key in ctx.bindingMetadata)) {
        ctx.bindingMetadata[key] = "props";
      }
    }
  }
  if (node.typeParameters) {
    if (ctx.propsRuntimeDecl) {
      ctx.error(
        `${DEFINE_PROPS}() cannot accept both type and non-type arguments at the same time. Use one or the other.`,
        node
      );
    }
    ctx.propsTypeDecl = node.typeParameters.params[0];
    const { props } = resolveTypeElements(ctx, ctx.propsTypeDecl);
    if (props) {
      for (const key in props) {
        if (!(key in ctx.bindingMetadata)) {
          ctx.bindingMetadata[key] = "props";
        }
      }
    }
  }
  if (!isWithDefaults && declId && declId.type === "ObjectPattern") {
    processPropsDestructure(ctx, declId);
  }
  ctx.propsCall = node;
  ctx.propsDecl = declId;
  return true;
}
function processWithDefaults(ctx, node, declId) {
  if (!isCallOf(node, WITH_DEFAULTS)) {
    return false;
  }
  if (!processDefineProps(
    ctx,
    node.arguments[0],
    declId,
    true
  )) {
    ctx.error(
      `${WITH_DEFAULTS}' first argument must be a ${DEFINE_PROPS} call.`,
      node.arguments[0] || node
    );
  }
  if (ctx.propsRuntimeDecl) {
    ctx.error(
      `${WITH_DEFAULTS} can only be used with type-based ${DEFINE_PROPS} declaration.`,
      node
    );
  }
  if (declId && declId.type === "ObjectPattern") {
    ctx.warn(
      `${WITH_DEFAULTS}() is unnecessary when using destructure with ${DEFINE_PROPS}().
Reactive destructure will be disabled when using withDefaults().
Prefer using destructure default values, e.g. const { foo = 1 } = defineProps(...). `,
      node.callee
    );
  }
  ctx.propsRuntimeDefaults = node.arguments[1];
  if (!ctx.propsRuntimeDefaults) {
    ctx.error(`The 2nd argument of ${WITH_DEFAULTS} is required.`, node);
  }
  ctx.propsCall = node;
  return true;
}
function genRuntimeProps(ctx) {
  let propsDecls;
  if (ctx.propsRuntimeDecl) {
    propsDecls = ctx.getString(ctx.propsRuntimeDecl).trim();
    if (ctx.propsDestructureDecl) {
      const defaults = [];
      for (const key in ctx.propsDestructuredBindings) {
        const d = genDestructuredDefaultValue(ctx, key);
        const finalKey = getEscapedPropName(key);
        if (d)
          defaults.push(
            `${finalKey}: ${d.valueString}${d.needSkipFactory ? `, __skip_${finalKey}: true` : ``}`
          );
      }
      if (defaults.length) {
        propsDecls = `/*@__PURE__*/${ctx.helper(
          `mergeDefaults`
        )}(${propsDecls}, {
  ${defaults.join(",\n  ")}
})`;
      }
    }
  } else if (ctx.propsTypeDecl) {
    propsDecls = extractRuntimeProps(ctx);
  }
  const modelsDecls = genModelProps(ctx);
  if (propsDecls && modelsDecls) {
    return `/*@__PURE__*/${ctx.helper(
      "mergeModels"
    )}(${propsDecls}, ${modelsDecls})`;
  } else {
    return modelsDecls || propsDecls;
  }
}
function extractRuntimeProps(ctx) {
  const props = resolveRuntimePropsFromType(ctx, ctx.propsTypeDecl);
  if (!props.length) {
    return;
  }
  const propStrings = [];
  const hasStaticDefaults = hasStaticWithDefaults(ctx);
  for (const prop of props) {
    propStrings.push(genRuntimePropFromType(ctx, prop, hasStaticDefaults));
  }
  let propsDecls = `{
    ${propStrings.join(",\n    ")}
  }`;
  if (ctx.propsRuntimeDefaults && !hasStaticDefaults) {
    propsDecls = `/*@__PURE__*/${ctx.helper(
      "mergeDefaults"
    )}(${propsDecls}, ${ctx.getString(ctx.propsRuntimeDefaults)})`;
  }
  return propsDecls;
}
function resolveRuntimePropsFromType(ctx, node) {
  const props = [];
  const elements = resolveTypeElements(ctx, node);
  for (const key in elements.props) {
    const e = elements.props[key];
    let type = inferRuntimeType(ctx, e);
    let skipCheck = false;
    if (type.includes(UNKNOWN_TYPE)) {
      if (type.includes("Boolean") || type.includes("Function")) {
        type = type.filter((t) => t !== UNKNOWN_TYPE);
        skipCheck = true;
      } else {
        type = ["null"];
      }
    }
    props.push({
      key,
      required: !e.optional,
      type: type || [`null`],
      skipCheck
    });
  }
  return props;
}
function genRuntimePropFromType(ctx, { key, required, type, skipCheck }, hasStaticDefaults) {
  let defaultString;
  const destructured = genDestructuredDefaultValue(ctx, key, type);
  if (destructured) {
    defaultString = `default: ${destructured.valueString}${destructured.needSkipFactory ? `, skipFactory: true` : ``}`;
  } else if (hasStaticDefaults) {
    const prop = ctx.propsRuntimeDefaults.properties.find(
      (node) => {
        if (node.type === "SpreadElement") return false;
        return resolveObjectKey(node.key, node.computed) === key;
      }
    );
    if (prop) {
      if (prop.type === "ObjectProperty") {
        defaultString = `default: ${ctx.getString(prop.value)}`;
      } else {
        defaultString = `${prop.async ? "async " : ""}${prop.kind !== "method" ? `${prop.kind} ` : ""}default() ${ctx.getString(prop.body)}`;
      }
    }
  }
  const finalKey = getEscapedPropName(key);
  if (!ctx.options.isProd) {
    return `${finalKey}: { ${concatStrings([
      `type: ${toRuntimeTypeString(type)}`,
      `required: ${required}`,
      skipCheck && "skipCheck: true",
      defaultString
    ])} }`;
  } else if (type.some(
    (el) => el === "Boolean" || (!hasStaticDefaults || defaultString) && el === "Function"
  )) {
    return `${finalKey}: { ${concatStrings([
      `type: ${toRuntimeTypeString(type)}`,
      defaultString
    ])} }`;
  } else {
    if (ctx.isCE) {
      if (defaultString) {
        return `${finalKey}: ${`{ ${defaultString}, type: ${toRuntimeTypeString(
          type
        )} }`}`;
      } else {
        return `${finalKey}: {type: ${toRuntimeTypeString(type)}}`;
      }
    }
    return `${finalKey}: ${defaultString ? `{ ${defaultString} }` : `{}`}`;
  }
}
function hasStaticWithDefaults(ctx) {
  return !!(ctx.propsRuntimeDefaults && ctx.propsRuntimeDefaults.type === "ObjectExpression" && ctx.propsRuntimeDefaults.properties.every(
    (node) => node.type !== "SpreadElement" && (!node.computed || node.key.type.endsWith("Literal"))
  ));
}
function genDestructuredDefaultValue(ctx, key, inferredType) {
  const destructured = ctx.propsDestructuredBindings[key];
  const defaultVal = destructured && destructured.default;
  if (defaultVal) {
    const value = ctx.getString(defaultVal);
    const unwrapped = unwrapTSNode(defaultVal);
    if (inferredType && inferredType.length && !inferredType.includes("null")) {
      const valueType = inferValueType(unwrapped);
      if (valueType && !inferredType.includes(valueType)) {
        ctx.error(
          `Default value of prop "${key}" does not match declared type.`,
          unwrapped
        );
      }
    }
    const needSkipFactory = !inferredType && (isFunctionType(unwrapped) || unwrapped.type === "Identifier");
    const needFactoryWrap = !needSkipFactory && !isLiteralNode(unwrapped) && !(inferredType == null ? void 0 : inferredType.includes("Function"));
    return {
      valueString: needFactoryWrap ? `() => (${value})` : value,
      needSkipFactory
    };
  }
}
function inferValueType(node) {
  switch (node.type) {
    case "StringLiteral":
      return "String";
    case "NumericLiteral":
      return "Number";
    case "BooleanLiteral":
      return "Boolean";
    case "ObjectExpression":
      return "Object";
    case "ArrayExpression":
      return "Array";
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      return "Function";
  }
}

function processPropsDestructure(ctx, declId) {
  if (ctx.options.propsDestructure === "error") {
    ctx.error(`Props destructure is explicitly prohibited via config.`, declId);
  } else if (ctx.options.propsDestructure === false) {
    return;
  }
  ctx.propsDestructureDecl = declId;
  const registerBinding = (key, local, defaultValue) => {
    ctx.propsDestructuredBindings[key] = { local, default: defaultValue };
    if (local !== key) {
      ctx.bindingMetadata[local] = "props-aliased";
      (ctx.bindingMetadata.__propsAliases || (ctx.bindingMetadata.__propsAliases = {}))[local] = key;
    }
  };
  for (const prop of declId.properties) {
    if (prop.type === "ObjectProperty") {
      const propKey = resolveObjectKey(prop.key, prop.computed);
      if (!propKey) {
        ctx.error(
          `${DEFINE_PROPS}() destructure cannot use computed key.`,
          prop.key
        );
      }
      if (prop.value.type === "AssignmentPattern") {
        const { left, right } = prop.value;
        if (left.type !== "Identifier") {
          ctx.error(
            `${DEFINE_PROPS}() destructure does not support nested patterns.`,
            left
          );
        }
        registerBinding(propKey, left.name, right);
      } else if (prop.value.type === "Identifier") {
        registerBinding(propKey, prop.value.name);
      } else {
        ctx.error(
          `${DEFINE_PROPS}() destructure does not support nested patterns.`,
          prop.value
        );
      }
    } else {
      ctx.propsDestructureRestId = prop.argument.name;
      ctx.bindingMetadata[ctx.propsDestructureRestId] = "setup-reactive-const";
    }
  }
}
function transformDestructuredProps(ctx, vueImportAliases) {
  if (ctx.options.propsDestructure === false) {
    return;
  }
  const rootScope = /* @__PURE__ */ Object.create(null);
  const scopeStack = [rootScope];
  let currentScope = rootScope;
  const excludedIds = /* @__PURE__ */ new WeakSet();
  const parentStack = [];
  const propsLocalToPublicMap = /* @__PURE__ */ Object.create(null);
  for (const key in ctx.propsDestructuredBindings) {
    const { local } = ctx.propsDestructuredBindings[key];
    rootScope[local] = true;
    propsLocalToPublicMap[local] = key;
  }
  function pushScope() {
    scopeStack.push(currentScope = Object.create(currentScope));
  }
  function popScope() {
    scopeStack.pop();
    currentScope = scopeStack[scopeStack.length - 1] || null;
  }
  function registerLocalBinding(id) {
    excludedIds.add(id);
    if (currentScope) {
      currentScope[id.name] = false;
    } else {
      ctx.error(
        "registerBinding called without active scope, something is wrong.",
        id
      );
    }
  }
  function walkScope(node, isRoot = false) {
    for (const stmt of node.body) {
      if (stmt.type === "VariableDeclaration") {
        walkVariableDeclaration(stmt, isRoot);
      } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
        if (stmt.declare || !stmt.id) continue;
        registerLocalBinding(stmt.id);
      } else if ((stmt.type === "ForOfStatement" || stmt.type === "ForInStatement") && stmt.left.type === "VariableDeclaration") {
        walkVariableDeclaration(stmt.left);
      } else if (stmt.type === "ExportNamedDeclaration" && stmt.declaration && stmt.declaration.type === "VariableDeclaration") {
        walkVariableDeclaration(stmt.declaration, isRoot);
      } else if (stmt.type === "LabeledStatement" && stmt.body.type === "VariableDeclaration") {
        walkVariableDeclaration(stmt.body, isRoot);
      }
    }
  }
  function walkVariableDeclaration(stmt, isRoot = false) {
    if (stmt.declare) {
      return;
    }
    for (const decl of stmt.declarations) {
      const isDefineProps = isRoot && decl.init && isCallOf(unwrapTSNode(decl.init), "defineProps");
      for (const id of extractIdentifiers$1(decl.id)) {
        if (isDefineProps) {
          excludedIds.add(id);
        } else {
          registerLocalBinding(id);
        }
      }
    }
  }
  function rewriteId(id, parent, parentStack2) {
    if (parent.type === "AssignmentExpression" && id === parent.left || parent.type === "UpdateExpression") {
      ctx.error(`Cannot assign to destructured props as they are readonly.`, id);
    }
    if (isStaticProperty(parent) && parent.shorthand) {
      if (!parent.inPattern || isInDestructureAssignment(parent, parentStack2)) {
        ctx.s.appendLeft(
          id.end + ctx.startOffset,
          `: ${genPropsAccessExp(propsLocalToPublicMap[id.name])}`
        );
      }
    } else {
      ctx.s.overwrite(
        id.start + ctx.startOffset,
        id.end + ctx.startOffset,
        genPropsAccessExp(propsLocalToPublicMap[id.name])
      );
    }
  }
  function checkUsage(node, method, alias = method) {
    if (isCallOf(node, alias)) {
      const arg = unwrapTSNode(node.arguments[0]);
      if (arg.type === "Identifier" && currentScope[arg.name]) {
        ctx.error(
          `"${arg.name}" is a destructured prop and should not be passed directly to ${method}(). Pass a getter () => ${arg.name} instead.`,
          arg
        );
      }
    }
  }
  const ast = ctx.scriptSetupAst;
  walkScope(ast, true);
  walk$2(ast, {
    enter(node, parent) {
      parent && parentStack.push(parent);
      if (parent && parent.type.startsWith("TS") && !TS_NODE_TYPES.includes(parent.type)) {
        return this.skip();
      }
      checkUsage(node, "watch", vueImportAliases.watch);
      checkUsage(node, "toRef", vueImportAliases.toRef);
      if (isFunctionType(node)) {
        pushScope();
        walkFunctionParams(node, registerLocalBinding);
        if (node.body.type === "BlockStatement") {
          walkScope(node.body);
        }
        return;
      }
      if (node.type === "CatchClause") {
        pushScope();
        if (node.param && node.param.type === "Identifier") {
          registerLocalBinding(node.param);
        }
        walkScope(node.body);
        return;
      }
      if (node.type === "BlockStatement" && !isFunctionType(parent)) {
        pushScope();
        walkScope(node);
        return;
      }
      if (node.type === "Identifier") {
        if (isReferencedIdentifier(node, parent, parentStack) && !excludedIds.has(node)) {
          if (currentScope[node.name]) {
            rewriteId(node, parent, parentStack);
          }
        }
      }
    },
    leave(node, parent) {
      parent && parentStack.pop();
      if (node.type === "BlockStatement" && !isFunctionType(parent) || isFunctionType(node) || node.type === "CatchClause") {
        popScope();
      }
    }
  });
}

const DEFINE_EMITS = "defineEmits";
function processDefineEmits(ctx, node, declId) {
  if (!isCallOf(node, DEFINE_EMITS)) {
    return false;
  }
  if (ctx.hasDefineEmitCall) {
    ctx.error(`duplicate ${DEFINE_EMITS}() call`, node);
  }
  ctx.hasDefineEmitCall = true;
  ctx.emitsRuntimeDecl = node.arguments[0];
  if (node.typeParameters) {
    if (ctx.emitsRuntimeDecl) {
      ctx.error(
        `${DEFINE_EMITS}() cannot accept both type and non-type arguments at the same time. Use one or the other.`,
        node
      );
    }
    ctx.emitsTypeDecl = node.typeParameters.params[0];
  }
  ctx.emitDecl = declId;
  return true;
}
function genRuntimeEmits(ctx) {
  let emitsDecl = "";
  if (ctx.emitsRuntimeDecl) {
    emitsDecl = ctx.getString(ctx.emitsRuntimeDecl).trim();
  } else if (ctx.emitsTypeDecl) {
    const typeDeclaredEmits = extractRuntimeEmits(ctx);
    emitsDecl = typeDeclaredEmits.size ? `[${Array.from(typeDeclaredEmits).map((k) => JSON.stringify(k)).join(", ")}]` : ``;
  }
  if (ctx.hasDefineModelCall) {
    let modelEmitsDecl = `[${Object.keys(ctx.modelDecls).map((n) => JSON.stringify(`update:${n}`)).join(", ")}]`;
    emitsDecl = emitsDecl ? `/*@__PURE__*/${ctx.helper(
      "mergeModels"
    )}(${emitsDecl}, ${modelEmitsDecl})` : modelEmitsDecl;
  }
  return emitsDecl;
}
function extractRuntimeEmits(ctx) {
  const emits = /* @__PURE__ */ new Set();
  const node = ctx.emitsTypeDecl;
  if (node.type === "TSFunctionType") {
    extractEventNames(ctx, node.parameters[0], emits);
    return emits;
  }
  const { props, calls } = resolveTypeElements(ctx, node);
  let hasProperty = false;
  for (const key in props) {
    emits.add(key);
    hasProperty = true;
  }
  if (calls) {
    if (hasProperty) {
      ctx.error(
        `defineEmits() type cannot mixed call signature and property syntax.`,
        node
      );
    }
    for (const call of calls) {
      extractEventNames(ctx, call.parameters[0], emits);
    }
  }
  return emits;
}
function extractEventNames(ctx, eventName, emits) {
  if (eventName.type === "Identifier" && eventName.typeAnnotation && eventName.typeAnnotation.type === "TSTypeAnnotation") {
    const types = resolveUnionType(ctx, eventName.typeAnnotation.typeAnnotation);
    for (const type of types) {
      if (type.type === "TSLiteralType") {
        if (type.literal.type !== "UnaryExpression" && type.literal.type !== "TemplateLiteral") {
          emits.add(String(type.literal.value));
        }
      }
    }
  }
}

const DEFINE_EXPOSE = "defineExpose";
function processDefineExpose(ctx, node) {
  if (isCallOf(node, DEFINE_EXPOSE)) {
    if (ctx.hasDefineExposeCall) {
      ctx.error(`duplicate ${DEFINE_EXPOSE}() call`, node);
    }
    ctx.hasDefineExposeCall = true;
    return true;
  }
  return false;
}

const DEFINE_SLOTS = "defineSlots";
function processDefineSlots(ctx, node, declId) {
  if (!isCallOf(node, DEFINE_SLOTS)) {
    return false;
  }
  if (ctx.hasDefineSlotsCall) {
    ctx.error(`duplicate ${DEFINE_SLOTS}() call`, node);
  }
  ctx.hasDefineSlotsCall = true;
  if (node.arguments.length > 0) {
    ctx.error(`${DEFINE_SLOTS}() cannot accept arguments`, node);
  }
  if (declId) {
    ctx.s.overwrite(
      ctx.startOffset + node.start,
      ctx.startOffset + node.end,
      `${ctx.helper("useSlots")}()`
    );
  }
  return true;
}

const DEFINE_OPTIONS = "defineOptions";
function processDefineOptions(ctx, node) {
  if (!isCallOf(node, DEFINE_OPTIONS)) {
    return false;
  }
  if (ctx.hasDefineOptionsCall) {
    ctx.error(`duplicate ${DEFINE_OPTIONS}() call`, node);
  }
  if (node.typeParameters) {
    ctx.error(`${DEFINE_OPTIONS}() cannot accept type arguments`, node);
  }
  if (!node.arguments[0]) return true;
  ctx.hasDefineOptionsCall = true;
  ctx.optionsRuntimeDecl = unwrapTSNode(node.arguments[0]);
  let propsOption = void 0;
  let emitsOption = void 0;
  let exposeOption = void 0;
  let slotsOption = void 0;
  if (ctx.optionsRuntimeDecl.type === "ObjectExpression") {
    for (const prop of ctx.optionsRuntimeDecl.properties) {
      if ((prop.type === "ObjectProperty" || prop.type === "ObjectMethod") && prop.key.type === "Identifier") {
        switch (prop.key.name) {
          case "props":
            propsOption = prop;
            break;
          case "emits":
            emitsOption = prop;
            break;
          case "expose":
            exposeOption = prop;
            break;
          case "slots":
            slotsOption = prop;
            break;
        }
      }
    }
  }
  if (propsOption) {
    ctx.error(
      `${DEFINE_OPTIONS}() cannot be used to declare props. Use ${DEFINE_PROPS}() instead.`,
      propsOption
    );
  }
  if (emitsOption) {
    ctx.error(
      `${DEFINE_OPTIONS}() cannot be used to declare emits. Use ${DEFINE_EMITS}() instead.`,
      emitsOption
    );
  }
  if (exposeOption) {
    ctx.error(
      `${DEFINE_OPTIONS}() cannot be used to declare expose. Use ${DEFINE_EXPOSE}() instead.`,
      exposeOption
    );
  }
  if (slotsOption) {
    ctx.error(
      `${DEFINE_OPTIONS}() cannot be used to declare slots. Use ${DEFINE_SLOTS}() instead.`,
      slotsOption
    );
  }
  return true;
}

function processAwait(ctx, node, needSemi, isStatement) {
  const argumentStart = node.argument.extra && node.argument.extra.parenthesized ? node.argument.extra.parenStart : node.argument.start;
  const startOffset = ctx.startOffset;
  const argumentStr = ctx.descriptor.source.slice(
    argumentStart + startOffset,
    node.argument.end + startOffset
  );
  const containsNestedAwait = /\bawait\b/.test(argumentStr);
  ctx.s.overwrite(
    node.start + startOffset,
    argumentStart + startOffset,
    `${needSemi ? `;` : ``}(
  ([__temp,__restore] = ${ctx.helper(
      `withAsyncContext`
    )}(${containsNestedAwait ? `async ` : ``}() => `
  );
  ctx.s.appendLeft(
    node.end + startOffset,
    `)),
  ${isStatement ? `` : `__temp = `}await __temp,
  __restore()${isStatement ? `` : `,
  __temp`}
)`
  );
}

var __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const MACROS = [
  DEFINE_PROPS,
  DEFINE_EMITS,
  DEFINE_EXPOSE,
  DEFINE_OPTIONS,
  DEFINE_SLOTS,
  DEFINE_MODEL,
  WITH_DEFAULTS
];
function compileScript(sfc, options) {
  var _a, _b, _c;
  if (!options.id) {
    warnOnce$1(
      `compileScript now requires passing the \`id\` option.
Upgrade your vite or vue-loader version for compatibility with the latest experimental proposals.`
    );
  }
  const ctx = new ScriptCompileContext(sfc, options);
  const { script, scriptSetup, source, filename } = sfc;
  const hoistStatic = options.hoistStatic !== false && !script;
  const scopeId = options.id ? options.id.replace(/^data-v-/, "") : "";
  const scriptLang = script && script.lang;
  const scriptSetupLang = scriptSetup && scriptSetup.lang;
  const vapor = sfc.vapor || options.vapor;
  const ssr = (_a = options.templateOptions) == null ? void 0 : _a.ssr;
  if (!scriptSetup) {
    if (!script) {
      throw new Error(`[@vue/compiler-sfc] SFC contains no <script> tags.`);
    }
    return processNormalScript(ctx, scopeId);
  }
  if (script && scriptLang !== scriptSetupLang) {
    throw new Error(
      `[@vue/compiler-sfc] <script> and <script setup> must have the same language type.`
    );
  }
  if (scriptSetupLang && !ctx.isJS && !ctx.isTS && !ctx.isUTS) {
    return scriptSetup;
  }
  const scriptBindings = /* @__PURE__ */ Object.create(null);
  const setupBindings = /* @__PURE__ */ Object.create(null);
  let defaultExport;
  let hasAwait = false;
  let hasInlinedSsrRenderFn = false;
  const startOffset = ctx.startOffset;
  const endOffset = ctx.endOffset;
  const scriptStartOffset = script && script.loc.start.offset;
  const scriptEndOffset = script && script.loc.end.offset;
  function hoistNode(node) {
    const start = node.start + startOffset;
    let end = node.end + startOffset;
    if (node.trailingComments && node.trailingComments.length > 0) {
      const lastCommentNode = node.trailingComments[node.trailingComments.length - 1];
      end = lastCommentNode.end + startOffset;
    }
    while (end <= source.length) {
      if (!/\s/.test(source.charAt(end))) {
        break;
      }
      end++;
    }
    ctx.s.move(start, end, 0);
  }
  function registerUserImport(source2, local, imported, isType, isFromSetup, needTemplateUsageCheck) {
    let isUsedInTemplate = needTemplateUsageCheck;
    if (needTemplateUsageCheck && (ctx.isTS || ctx.isUTS) && // fixed by uts
    sfc.template && !sfc.template.src && !sfc.template.lang) {
      isUsedInTemplate = isImportUsed(local, sfc);
    }
    ctx.userImports[local] = {
      isType,
      imported,
      local,
      source: source2,
      isFromSetup,
      isUsedInTemplate
    };
  }
  function checkInvalidScopeReference(node, method) {
    if (!node) return;
    walkIdentifiers(node, (id) => {
      const binding = setupBindings[id.name];
      if (binding && binding !== "literal-const") {
        ctx.error(
          `\`${method}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function. If your component options require initialization in the module scope, use a separate normal <script> to export the options instead.`,
          id
        );
      }
    });
  }
  const scriptAst = ctx.scriptAst;
  const scriptSetupAst = ctx.scriptSetupAst;
  if (scriptAst) {
    for (const node of scriptAst.body) {
      if (node.type === "ImportDeclaration") {
        for (const specifier of node.specifiers) {
          const imported = getImportedName(specifier);
          registerUserImport(
            node.source.value,
            specifier.local.name,
            imported,
            node.importKind === "type" || specifier.type === "ImportSpecifier" && specifier.importKind === "type",
            false,
            !options.inlineTemplate
          );
        }
      }
    }
  }
  for (const node of scriptSetupAst.body) {
    if (node.type === "ImportDeclaration") {
      hoistNode(node);
      let removed = 0;
      const removeSpecifier = (i) => {
        const removeLeft = i > removed;
        removed++;
        const current = node.specifiers[i];
        const next = node.specifiers[i + 1];
        ctx.s.remove(
          removeLeft ? node.specifiers[i - 1].end + startOffset : current.start + startOffset,
          next && !removeLeft ? next.start + startOffset : current.end + startOffset
        );
      };
      for (let i = 0; i < node.specifiers.length; i++) {
        const specifier = node.specifiers[i];
        const local = specifier.local.name;
        const imported = getImportedName(specifier);
        const source2 = node.source.value;
        const existing = ctx.userImports[local];
        if (source2 === "vue" && MACROS.includes(imported)) {
          if (local === imported) {
            warnOnce$1(
              `\`${imported}\` is a compiler macro and no longer needs to be imported.`
            );
          } else {
            ctx.error(
              `\`${imported}\` is a compiler macro and cannot be aliased to a different name.`,
              specifier
            );
          }
          removeSpecifier(i);
        } else if (existing) {
          if (existing.source === source2 && existing.imported === imported) {
            removeSpecifier(i);
          } else {
            ctx.error(
              `different imports aliased to same local name.`,
              specifier
            );
          }
        } else {
          registerUserImport(
            source2,
            local,
            imported,
            node.importKind === "type" || specifier.type === "ImportSpecifier" && specifier.importKind === "type",
            true,
            !options.inlineTemplate
          );
        }
      }
      if (node.specifiers.length && removed === node.specifiers.length) {
        ctx.s.remove(node.start + startOffset, node.end + startOffset);
      }
    }
  }
  const vueImportAliases = {};
  for (const key in ctx.userImports) {
    const { source: source2, imported, local } = ctx.userImports[key];
    if (source2 === "vue") vueImportAliases[imported] = local;
  }
  if (script && scriptAst) {
    for (const node of scriptAst.body) {
      if (node.type === "ExportDefaultDeclaration") {
        defaultExport = node;
        let optionProperties;
        if (defaultExport.declaration.type === "ObjectExpression") {
          optionProperties = defaultExport.declaration.properties;
        } else if (defaultExport.declaration.type === "CallExpression" && defaultExport.declaration.arguments[0] && defaultExport.declaration.arguments[0].type === "ObjectExpression") {
          optionProperties = defaultExport.declaration.arguments[0].properties;
        }
        if (optionProperties) {
          for (const p of optionProperties) {
            if (p.type === "ObjectProperty" && p.key.type === "Identifier" && p.key.name === "name") {
              ctx.hasDefaultExportName = true;
            }
            if ((p.type === "ObjectMethod" || p.type === "ObjectProperty") && p.key.type === "Identifier" && p.key.name === "render") {
              ctx.hasDefaultExportRender = true;
            }
          }
        }
        const start = node.start + scriptStartOffset;
        const end = node.declaration.start + scriptStartOffset;
        ctx.s.overwrite(start, end, `const ${normalScriptDefaultVar} = `);
      } else if (node.type === "ExportNamedDeclaration") {
        const defaultSpecifier = node.specifiers.find(
          (s) => s.exported.type === "Identifier" && s.exported.name === "default"
        );
        if (defaultSpecifier) {
          defaultExport = node;
          if (node.specifiers.length > 1) {
            ctx.s.remove(
              defaultSpecifier.start + scriptStartOffset,
              defaultSpecifier.end + scriptStartOffset
            );
          } else {
            ctx.s.remove(
              node.start + scriptStartOffset,
              node.end + scriptStartOffset
            );
          }
          if (node.source) {
            ctx.s.prepend(
              `import { ${defaultSpecifier.local.name} as ${normalScriptDefaultVar} } from '${node.source.value}'
`
            );
          } else {
            ctx.s.appendLeft(
              scriptEndOffset,
              `
const ${normalScriptDefaultVar} = ${defaultSpecifier.local.name}
`
            );
          }
        }
        if (node.declaration) {
          walkDeclaration(
            "script",
            node.declaration,
            scriptBindings,
            vueImportAliases,
            hoistStatic
          );
        }
      } else if ((node.type === "VariableDeclaration" || node.type === "FunctionDeclaration" || node.type === "ClassDeclaration" || node.type === "TSEnumDeclaration") && !node.declare) {
        walkDeclaration(
          "script",
          node,
          scriptBindings,
          vueImportAliases,
          hoistStatic
        );
      }
    }
    if (scriptStartOffset > startOffset) {
      if (!/\n$/.test(script.content.trim())) {
        ctx.s.appendLeft(scriptEndOffset, `
`);
      }
      ctx.s.move(scriptStartOffset, scriptEndOffset, 0);
    }
  }
  for (const node of scriptSetupAst.body) {
    if (node.type === "ExpressionStatement") {
      const expr = unwrapTSNode(node.expression);
      if (processDefineProps(ctx, expr) || processDefineEmits(ctx, expr) || processDefineOptions(ctx, expr) || processDefineSlots(ctx, expr)) {
        ctx.s.remove(node.start + startOffset, node.end + startOffset);
      } else if (processDefineExpose(ctx, expr)) {
        const callee = expr.callee;
        ctx.s.overwrite(
          callee.start + startOffset,
          callee.end + startOffset,
          "__expose"
        );
      } else {
        processDefineModel(ctx, expr);
      }
    }
    if (node.type === "VariableDeclaration" && !node.declare) {
      const total = node.declarations.length;
      let left = total;
      let lastNonRemoved;
      for (let i = 0; i < total; i++) {
        const decl = node.declarations[i];
        const init = decl.init && unwrapTSNode(decl.init);
        if (init) {
          if (processDefineOptions(ctx, init)) {
            ctx.error(
              `${DEFINE_OPTIONS}() has no returning value, it cannot be assigned.`,
              node
            );
          }
          const isDefineProps = processDefineProps(ctx, init, decl.id);
          if (ctx.propsDestructureRestId) {
            setupBindings[ctx.propsDestructureRestId] = "setup-reactive-const";
          }
          const isDefineEmits = !isDefineProps && processDefineEmits(ctx, init, decl.id);
          !isDefineEmits && (processDefineSlots(ctx, init, decl.id) || processDefineModel(ctx, init, decl.id));
          if (isDefineProps && !ctx.propsDestructureRestId && ctx.propsDestructureDecl) {
            if (left === 1) {
              ctx.s.remove(node.start + startOffset, node.end + startOffset);
            } else {
              let start = decl.start + startOffset;
              let end = decl.end + startOffset;
              if (i === total - 1) {
                start = node.declarations[lastNonRemoved].end + startOffset;
              } else {
                end = node.declarations[i + 1].start + startOffset;
              }
              ctx.s.remove(start, end);
              left--;
            }
          } else if (isDefineEmits) {
            ctx.s.overwrite(
              startOffset + init.start,
              startOffset + init.end,
              "__emit"
            );
          } else {
            lastNonRemoved = i;
          }
        }
      }
    }
    let isAllLiteral = false;
    if ((node.type === "VariableDeclaration" || node.type === "FunctionDeclaration" || node.type === "ClassDeclaration" || node.type === "TSEnumDeclaration") && !node.declare) {
      isAllLiteral = walkDeclaration(
        "scriptSetup",
        node,
        setupBindings,
        vueImportAliases,
        hoistStatic,
        !!ctx.propsDestructureDecl
      );
    }
    if (hoistStatic && isAllLiteral) {
      hoistNode(node);
    }
    if (node.type === "VariableDeclaration" && !node.declare || node.type.endsWith("Statement")) {
      const scope = [scriptSetupAst.body];
      walk$2(node, {
        enter(child, parent) {
          if (isFunctionType(child)) {
            this.skip();
          }
          if (child.type === "BlockStatement") {
            scope.push(child.body);
          }
          if (child.type === "AwaitExpression") {
            hasAwait = true;
            const currentScope = scope[scope.length - 1];
            const needsSemi = currentScope.some((n, i) => {
              return (scope.length === 1 || i > 0) && n.type === "ExpressionStatement" && n.start === child.start;
            });
            processAwait(
              ctx,
              child,
              needsSemi,
              parent.type === "ExpressionStatement"
            );
          }
        },
        exit(node2) {
          if (node2.type === "BlockStatement") scope.pop();
        }
      });
    }
    if (node.type === "ExportNamedDeclaration" && node.exportKind !== "type" || node.type === "ExportAllDeclaration" || node.type === "ExportDefaultDeclaration") {
      ctx.error(
        `<script setup> cannot contain ES module exports. If you are using a previous version of <script setup>, please consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.`,
        node
      );
    }
    if (ctx.isTS || ctx.isUTS) {
      if (node.type.startsWith("TS") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "VariableDeclaration" && node.declare) {
        if (node.type !== "TSEnumDeclaration") {
          hoistNode(node);
        }
      }
    }
  }
  if (ctx.propsDestructureDecl) {
    transformDestructuredProps(ctx, vueImportAliases);
  }
  checkInvalidScopeReference(ctx.propsRuntimeDecl, DEFINE_PROPS);
  checkInvalidScopeReference(ctx.propsRuntimeDefaults, DEFINE_PROPS);
  checkInvalidScopeReference(ctx.propsDestructureDecl, DEFINE_PROPS);
  checkInvalidScopeReference(ctx.emitsRuntimeDecl, DEFINE_EMITS);
  checkInvalidScopeReference(ctx.optionsRuntimeDecl, DEFINE_OPTIONS);
  for (const { runtimeOptionNodes } of Object.values(ctx.modelDecls)) {
    for (const node of runtimeOptionNodes) {
      checkInvalidScopeReference(node, DEFINE_MODEL);
    }
  }
  if (script) {
    if (startOffset < scriptStartOffset) {
      ctx.s.remove(0, startOffset);
      ctx.s.remove(endOffset, scriptStartOffset);
      ctx.s.remove(scriptEndOffset, source.length);
    } else {
      ctx.s.remove(0, scriptStartOffset);
      ctx.s.remove(scriptEndOffset, startOffset);
      ctx.s.remove(endOffset, source.length);
    }
  } else {
    ctx.s.remove(0, startOffset);
    ctx.s.remove(endOffset, source.length);
  }
  if (scriptAst) {
    Object.assign(ctx.bindingMetadata, analyzeScriptBindings(scriptAst.body));
  }
  for (const [key, { isType, imported, source: source2 }] of Object.entries(
    ctx.userImports
  )) {
    if (isType) continue;
    ctx.bindingMetadata[key] = imported === "*" || imported === "default" && source2.endsWith(".vue") || source2 === "vue" ? "setup-const" : "setup-maybe-ref";
  }
  for (const key in scriptBindings) {
    ctx.bindingMetadata[key] = scriptBindings[key];
  }
  for (const key in setupBindings) {
    ctx.bindingMetadata[key] = setupBindings[key];
  }
  if (sfc.cssVars.length && // no need to do this when targeting SSR
  !ssr) {
    ctx.helperImports.add(CSS_VARS_HELPER);
    ctx.helperImports.add("unref");
    ctx.s.prependLeft(
      startOffset,
      `
${genCssVarsCode(
        sfc.cssVars,
        ctx.bindingMetadata,
        scopeId,
        !!options.isProd
      )}
`
    );
  }
  let args = `__props`;
  if (ctx.propsTypeDecl) {
    args += `: any`;
  }
  if (ctx.propsDecl) {
    if (ctx.propsDestructureRestId) {
      ctx.s.overwrite(
        startOffset + ctx.propsCall.start,
        startOffset + ctx.propsCall.end,
        `${ctx.helper(`createPropsRestProxy`)}(__props, ${JSON.stringify(
          Object.keys(ctx.propsDestructuredBindings)
        )})`
      );
      ctx.s.overwrite(
        startOffset + ctx.propsDestructureDecl.start,
        startOffset + ctx.propsDestructureDecl.end,
        ctx.propsDestructureRestId
      );
    } else if (!ctx.propsDestructureDecl) {
      ctx.s.overwrite(
        startOffset + ctx.propsCall.start,
        startOffset + ctx.propsCall.end,
        "__props"
      );
    }
  }
  if (hasAwait) {
    const any = ctx.isTS || ctx.isUTS ? `: any` : ``;
    ctx.s.prependLeft(startOffset, `
let __temp${any}, __restore${any}
`);
  }
  const destructureElements = ctx.hasDefineExposeCall || !options.inlineTemplate ? [`expose: __expose`] : [];
  if (ctx.emitDecl) {
    destructureElements.push(`emit: __emit`);
  }
  if (destructureElements.length) {
    args += `, { ${destructureElements.join(", ")} }`;
  }
  let returned;
  if (!options.inlineTemplate || !sfc.template && ctx.hasDefaultExportRender) {
    const allBindings = __spreadValues$1(__spreadValues$1({}, scriptBindings), setupBindings);
    for (const key in ctx.userImports) {
      if (!ctx.userImports[key].isType && ctx.userImports[key].isUsedInTemplate) {
        allBindings[key] = true;
      }
    }
    returned = `{ `;
    for (const key in allBindings) {
      if (allBindings[key] === true && ctx.userImports[key].source !== "vue" && !ctx.userImports[key].source.endsWith(".vue")) {
        returned += `get ${key}() { return ${key} }, `;
      } else if (ctx.bindingMetadata[key] === "setup-let") {
        const setArg = key === "v" ? `_v` : `v`;
        returned += `get ${key}() { return ${key} }, set ${key}(${setArg}) { ${key} = ${setArg} }, `;
      } else {
        returned += `${key}, `;
      }
    }
    returned = returned.replace(/, $/, "") + ` }`;
  } else {
    if (sfc.template && !sfc.template.src) {
      if (ssr) {
        hasInlinedSsrRenderFn = true;
      }
      const { code, preamble, tips, errors, helpers } = compileTemplate(__spreadProps(__spreadValues$1({
        filename,
        ast: sfc.template.ast,
        source: sfc.template.content,
        inMap: sfc.template.map
      }, options.templateOptions), {
        id: scopeId,
        scoped: sfc.styles.some((s) => s.scoped),
        isProd: options.isProd,
        ssrCssVars: sfc.cssVars,
        vapor,
        compilerOptions: __spreadProps(__spreadValues$1({}, options.templateOptions && options.templateOptions.compilerOptions), {
          inline: true,
          isTS: ctx.isTS,
          bindingMetadata: ctx.bindingMetadata
        })
      }));
      if (tips.length) {
        tips.forEach(warnOnce$1);
      }
      const err = errors[0];
      if (typeof err === "string") {
        throw new Error(err);
      } else if (err) {
        if (err.loc) {
          err.message += `

` + sfc.filename + "\n" + generateCodeFrame(
            source,
            err.loc.start.offset,
            err.loc.end.offset
          ) + `
`;
        }
        throw err;
      }
      if (preamble) {
        ctx.s.prepend(preamble);
      }
      if (helpers && helpers.has(UNREF)) {
        ctx.helperImports.delete("unref");
      }
      returned = code;
    } else {
      returned = `() => {}`;
    }
  }
  if (!options.inlineTemplate && true) {
    ctx.s.appendRight(
      endOffset,
      `
const __returned__ = ${returned}
Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })
return __returned__
}

`
    );
  } else {
    ctx.s.appendRight(
      endOffset,
      // vapor mode generates its own return when inlined
      `
${vapor && !ssr ? `` : `return `}${returned}
}

`
    );
  }
  const genDefaultAs = options.genDefaultAs ? `const ${options.genDefaultAs} =` : `export default`;
  let runtimeOptions = ``;
  if (!ctx.hasDefaultExportName && filename && filename !== DEFAULT_FILENAME) {
    const match = filename.match(/([^/\\]+)\.\w+$/);
    if (match) {
      runtimeOptions += `
  __name: '${match[1]}',`;
    }
  }
  if (hasInlinedSsrRenderFn) {
    runtimeOptions += `
  __ssrInlineRender: true,`;
  }
  const propsDecl = genRuntimeProps(ctx);
  if (propsDecl) runtimeOptions += `
  props: ${propsDecl},`;
  const emitsDecl = genRuntimeEmits(ctx);
  if (emitsDecl) runtimeOptions += `
  emits: ${emitsDecl},`;
  let definedOptions = "";
  if (ctx.optionsRuntimeDecl) {
    definedOptions = scriptSetup.content.slice(ctx.optionsRuntimeDecl.start, ctx.optionsRuntimeDecl.end).trim();
  }
  const exposeCall = ctx.hasDefineExposeCall || options.inlineTemplate ? `` : `  __expose();
`;
  if (ctx.isTS || ctx.isUTS) {
    const def = (defaultExport ? `
  ...${normalScriptDefaultVar},` : ``) + (definedOptions ? `
  ...${definedOptions},` : "");
    ctx.s.prependLeft(
      startOffset,
      `
${genDefaultAs} /*@__PURE__*/${ctx.helper(
        vapor && !ssr ? `defineVaporComponent` : `defineComponent`
      )}({${def}${runtimeOptions}
  ${hasAwait ? `async ` : ``}setup(${args}) {
${exposeCall}`
    );
    ctx.s.appendRight(endOffset, `})`);
  } else {
    if (vapor) {
      runtimeOptions += `
  __vapor: true,`;
    }
    if (defaultExport || definedOptions) {
      ctx.s.prependLeft(
        startOffset,
        `
${genDefaultAs} /*@__PURE__*/Object.assign(${defaultExport ? `${normalScriptDefaultVar}, ` : ""}${definedOptions ? `${definedOptions}, ` : ""}{${runtimeOptions}
  ${hasAwait ? `async ` : ``}setup(${args}) {
${exposeCall}`
      );
      ctx.s.appendRight(endOffset, `})`);
    } else {
      ctx.s.prependLeft(
        startOffset,
        `
${genDefaultAs} {${runtimeOptions}
  ${hasAwait ? `async ` : ``}setup(${args}) {
${exposeCall}`
      );
      ctx.s.appendRight(endOffset, `}`);
    }
  }
  if (ctx.helperImports.size > 0) {
    const runtimeModuleName = (_c = (_b = options.templateOptions) == null ? void 0 : _b.compilerOptions) == null ? void 0 : _c.runtimeModuleName;
    const importSrc = runtimeModuleName ? JSON.stringify(runtimeModuleName) : `'vue'`;
    ctx.s.prepend(
      `import { ${[...ctx.helperImports].map((h) => `${h} as _${h}`).join(", ")} } from ${importSrc}
`
    );
  }
  return __spreadProps(__spreadValues$1({}, scriptSetup), {
    bindings: ctx.bindingMetadata,
    imports: ctx.userImports,
    content: ctx.s.toString(),
    map: options.sourceMap !== false ? ctx.s.generateMap({
      source: filename,
      hires: true,
      includeContent: true
    }) : void 0,
    scriptAst: scriptAst == null ? void 0 : scriptAst.body,
    scriptSetupAst: scriptSetupAst == null ? void 0 : scriptSetupAst.body,
    deps: ctx.deps ? [...ctx.deps] : void 0
  });
}
function registerBinding(bindings, node, type) {
  bindings[node.name] = type;
}
function walkDeclaration(from, node, bindings, userImportAliases, hoistStatic, isPropsDestructureEnabled = false) {
  let isAllLiteral = false;
  if (node.type === "VariableDeclaration") {
    const isConst = node.kind === "const";
    isAllLiteral = isConst && node.declarations.every(
      (decl) => decl.id.type === "Identifier" && isStaticNode(decl.init)
    );
    for (const { id, init: _init } of node.declarations) {
      const init = _init && unwrapTSNode(_init);
      const isConstMacroCall = isConst && isCallOf(
        init,
        (c) => c === DEFINE_PROPS || c === DEFINE_EMITS || c === WITH_DEFAULTS || c === DEFINE_SLOTS
      );
      if (id.type === "Identifier") {
        let bindingType;
        const userReactiveBinding = userImportAliases["reactive"];
        if ((hoistStatic || from === "script") && (isAllLiteral || isConst && isStaticNode(init))) {
          bindingType = "literal-const";
        } else if (isCallOf(init, userReactiveBinding)) {
          bindingType = isConst ? "setup-reactive-const" : "setup-let";
        } else if (
          // if a declaration is a const literal, we can mark it so that
          // the generated render fn code doesn't need to unref() it
          isConstMacroCall || isConst && canNeverBeRef(init, userReactiveBinding)
        ) {
          bindingType = isCallOf(init, DEFINE_PROPS) ? "setup-reactive-const" : "setup-const";
        } else if (isConst) {
          if (isCallOf(
            init,
            (m) => m === userImportAliases["ref"] || m === userImportAliases["computed"] || m === userImportAliases["shallowRef"] || m === userImportAliases["customRef"] || m === userImportAliases["toRef"] || m === userImportAliases["useTemplateRef"] || m === DEFINE_MODEL
          )) {
            bindingType = "setup-ref";
          } else {
            bindingType = "setup-maybe-ref";
          }
        } else {
          bindingType = "setup-let";
        }
        registerBinding(bindings, id, bindingType);
      } else {
        if (isCallOf(init, DEFINE_PROPS) && isPropsDestructureEnabled) {
          continue;
        }
        if (id.type === "ObjectPattern") {
          walkObjectPattern(id, bindings, isConst, isConstMacroCall);
        } else if (id.type === "ArrayPattern") {
          walkArrayPattern(id, bindings, isConst, isConstMacroCall);
        }
      }
    }
  } else if (node.type === "TSEnumDeclaration") {
    isAllLiteral = node.members.every(
      (member) => !member.initializer || isStaticNode(member.initializer)
    );
    bindings[node.id.name] = isAllLiteral ? "literal-const" : "setup-const";
  } else if (node.type === "FunctionDeclaration" || node.type === "ClassDeclaration") {
    bindings[node.id.name] = "setup-const";
  }
  return isAllLiteral;
}
function walkObjectPattern(node, bindings, isConst, isDefineCall = false) {
  for (const p of node.properties) {
    if (p.type === "ObjectProperty") {
      if (p.key.type === "Identifier" && p.key === p.value) {
        const type = isDefineCall ? "setup-const" : isConst ? "setup-maybe-ref" : "setup-let";
        registerBinding(bindings, p.key, type);
      } else {
        walkPattern(p.value, bindings, isConst, isDefineCall);
      }
    } else {
      const type = isConst ? "setup-const" : "setup-let";
      registerBinding(bindings, p.argument, type);
    }
  }
}
function walkArrayPattern(node, bindings, isConst, isDefineCall = false) {
  for (const e of node.elements) {
    e && walkPattern(e, bindings, isConst, isDefineCall);
  }
}
function walkPattern(node, bindings, isConst, isDefineCall = false) {
  if (node.type === "Identifier") {
    const type = isDefineCall ? "setup-const" : isConst ? "setup-maybe-ref" : "setup-let";
    registerBinding(bindings, node, type);
  } else if (node.type === "RestElement") {
    const type = isConst ? "setup-const" : "setup-let";
    registerBinding(bindings, node.argument, type);
  } else if (node.type === "ObjectPattern") {
    walkObjectPattern(node, bindings, isConst);
  } else if (node.type === "ArrayPattern") {
    walkArrayPattern(node, bindings, isConst);
  } else if (node.type === "AssignmentPattern") {
    if (node.left.type === "Identifier") {
      const type = isDefineCall ? "setup-const" : isConst ? "setup-maybe-ref" : "setup-let";
      registerBinding(bindings, node.left, type);
    } else {
      walkPattern(node.left, bindings, isConst);
    }
  }
}
function canNeverBeRef(node, userReactiveImport) {
  if (isCallOf(node, userReactiveImport)) {
    return true;
  }
  switch (node.type) {
    case "UnaryExpression":
    case "BinaryExpression":
    case "ArrayExpression":
    case "ObjectExpression":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
    case "UpdateExpression":
    case "ClassExpression":
    case "TaggedTemplateExpression":
      return true;
    case "SequenceExpression":
      return canNeverBeRef(
        node.expressions[node.expressions.length - 1],
        userReactiveImport
      );
    default:
      if (isLiteralNode(node)) {
        return true;
      }
      return false;
  }
}

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
const version = "3.5.14";
const parseCache = parseCache$1;
const errorMessages = __spreadValues(__spreadValues({}, errorMessages$1), DOMErrorMessages);
const walk = walk$2;
const shouldTransformRef = () => false;

var parse$4 = libExports.parse;
export { MagicString, parse$4 as babelParse, compileScript, compileStyle, compileStyleAsync, compileTemplate, errorMessages, extractIdentifiers$1 as extractIdentifiers, extractRuntimeEmits, extractRuntimeProps, generateCodeFrame, inferRuntimeType, invalidateTypeCache, isInDestructureAssignment, isStaticProperty, parse$2 as parse, parseCache, registerTS, resolveTypeElements, rewriteDefault, rewriteDefaultAST, shouldTransformRef, version, walk, walkIdentifiers };
