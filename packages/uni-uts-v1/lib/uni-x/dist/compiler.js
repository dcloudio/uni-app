'use strict';

require('fs');
var debug = require('debug');
var path = require('path');
var fs = require('fs-extra');
var sourceMapJs = require('source-map-js');

// 这些是uts插件类型的声明文件
const builtinDeclarationFiles = [
    '/uni-app-x/types/uni/',
    '/uni-app-x/types/uni-cloud/',
    '/UniPage.d.ts',
    '/IUniElement.d.ts', // RequestFullscreenOptions
];
function normalizePath(id) {
    return id.replace(/\\/g, '/');
}
function isUTSDeclarationFile(declaration, rootDir) {
    const sourceFile = declaration.getSourceFile();
    if (sourceFile.isDeclarationFile) {
        // 已经判断过
        if (sourceFile.__isUTSDeclarationFile === true) {
            return true;
        }
        if (sourceFile.__isUTSDeclarationFile === false) {
            return false;
        }
        const fileName = normalizePath(sourceFile.fileName);
        // 如果是项目内文件，则一定是
        if (fileName.startsWith(rootDir)) {
            sourceFile.__isUTSDeclarationFile = true;
            return true;
        }
        // 是类型文件
        if (builtinDeclarationFiles.some((builtinDeclarationFile) => fileName.includes(builtinDeclarationFile))) {
            sourceFile.__isUTSDeclarationFile = true;
            return true;
        }
        sourceFile.__isUTSDeclarationFile = false;
        return false;
    }
    return true;
}

var DiagnosticCategory;
(function (DiagnosticCategory) {
    DiagnosticCategory[DiagnosticCategory["Warning"] = 0] = "Warning";
    DiagnosticCategory[DiagnosticCategory["Error"] = 1] = "Error";
    DiagnosticCategory[DiagnosticCategory["Suggestion"] = 2] = "Suggestion";
    DiagnosticCategory[DiagnosticCategory["Message"] = 3] = "Message";
})(DiagnosticCategory || (DiagnosticCategory = {}));

// <auto-generated />
// generated from 'packages/shared/src/diagnosticMessages.json'
function diag$1(code, category, key, message, reportsUnnecessary, elidedInCompatabilityPyramid, reportsDeprecated) {
    return { code, category, key, message, reportsUnnecessary, elidedInCompatabilityPyramid, reportsDeprecated };
}
/** @internal */
const UTSDiagnostics = {
    Type_literal_property_must_have_a_type_annotation: diag$1(100000, DiagnosticCategory.Error, "Type_literal_property_must_have_a_type_annotation_100000", "Type literal property must have a type annotation."),
    Only_one_extends_heritage_clause_is_allowed_for_interface: diag$1(100001, DiagnosticCategory.Error, "Only_one_extends_heritage_clause_is_allowed_for_interface_100001", "Only one extends heritage clause is allowed for interface"),
    Variable_declaration_must_have_initializer: diag$1(100002, DiagnosticCategory.Error, "Variable_declaration_must_have_initializer_100002", "Variable declaration must have initializer."),
    Nested_type_literal_is_not_supported: diag$1(100003, DiagnosticCategory.Error, "Nested_type_literal_is_not_supported_100003", "Nested type literal is not supported."),
    Invalid_generic_type_which_can_not_be_constructed: diag$1(100004, DiagnosticCategory.Error, "Invalid_generic_type_which_can_not_be_constructed_100004", "Invalid generic type which can not be constructed."),
    script_setup_cannot_contain_ES_module_exports: diag$1(100005, DiagnosticCategory.Error, "script_setup_cannot_contain_ES_module_exports_100005", "`<script setup>` cannot contain ES module exports."),
    Type_aliases_cannot_appear_in_local_scope: diag$1(100006, DiagnosticCategory.Error, "Type_aliases_cannot_appear_in_local_scope_100006", "Type aliases cannot appear in local scope"),
    direct_declaration_of_Object_Literal_Type_is_not_supported: diag$1(110111101, DiagnosticCategory.Error, "direct_declaration_of_Object_Literal_Type_is_not_supported_110111101", "direct declaration of Object Literal Type is not supported."),
    Object_literals_only_support_object_types_defined_by_construction_type_and_do_not_support_interfaces: diag$1(110111163, DiagnosticCategory.Error, "Object_literals_only_support_object_types_defined_by_construction_type_and_do_not_support_interfaces_110111163", "Object literals only support object types defined by construction type, and do not support interfaces"),
    Conditional_statements_must_use_boolean_types: diag$1(110111120, DiagnosticCategory.Error, "Conditional_statements_must_use_boolean_types_110111120", "Conditional statements must use boolean types"),
};

// @see https://github.com/microsoft/TypeScript/blob/master/src/compiler/diagnosticMessages.json
// eslint-disable-next-line no-shadow
var DiagnosticCode;
(function (DiagnosticCode) {
    DiagnosticCode[DiagnosticCode["STARTING_COMPILATION_IN_WATCH_MODE"] = 6031] = "STARTING_COMPILATION_IN_WATCH_MODE";
    DiagnosticCode[DiagnosticCode["FILE_CHANGE_DETECTED"] = 6032] = "FILE_CHANGE_DETECTED";
    DiagnosticCode[DiagnosticCode["FOUND_1_ERROR_WATCHING_FOR_FILE_CHANGES"] = 6193] = "FOUND_1_ERROR_WATCHING_FOR_FILE_CHANGES";
    DiagnosticCode[DiagnosticCode["FOUND_N_ERRORS_WATCHING_FOR_FILE_CHANGES"] = 6194] = "FOUND_N_ERRORS_WATCHING_FOR_FILE_CHANGES";
})(DiagnosticCode || (DiagnosticCode = {}));
function createDeferred(timeout) {
    let promise;
    let resolve = () => { };
    if (timeout) {
        promise = Promise.race([
            new Promise((r) => setTimeout(r, timeout, true)),
            new Promise((r) => (resolve = r)),
        ]);
    }
    else {
        promise = new Promise((r) => (resolve = r));
    }
    return { promise, resolve };
}
/**
 * Typescript watch program helper to sync Typescript watch status with Rollup hooks.
 */
class WatchProgramHelper {
    constructor(ts) {
        this._startDeferred = null;
        this._finishDeferred = null;
        this._ts = ts;
    }
    watch(timeout) {
        // Race watcher start promise against a timeout in case Typescript and Rollup change detection is not in sync.
        this._startDeferred = createDeferred(timeout);
        this._finishDeferred = createDeferred();
    }
    handleStatus(diagnostic) {
        // Fullfil deferred promises by Typescript diagnostic message codes.
        if (diagnostic.category === this._ts.DiagnosticCategory.Message) {
            switch (diagnostic.code) {
                case DiagnosticCode.FILE_CHANGE_DETECTED:
                    this.resolveStart();
                    break;
                case DiagnosticCode.FOUND_1_ERROR_WATCHING_FOR_FILE_CHANGES:
                case DiagnosticCode.FOUND_N_ERRORS_WATCHING_FOR_FILE_CHANGES:
                    this.resolveFinish();
                    break;
            }
        }
    }
    resolveStart() {
        if (this._startDeferred) {
            this._startDeferred.resolve(false);
            this._startDeferred = null;
        }
    }
    resolveFinish() {
        if (this._finishDeferred) {
            this._finishDeferred.resolve(false);
            this._finishDeferred = null;
        }
    }
    async wait() {
        if (this._startDeferred) {
            const timeout = await this._startDeferred.promise;
            // If there is no file change detected by Typescript skip deferred promises.
            if (timeout) {
                this._startDeferred = null;
                this._finishDeferred = null;
            }
            await this._finishDeferred?.promise;
        }
    }
}

const debugCompile = debug('uts:tsc:compile');
const defaultCompilerOptions = {
    strict: true,
    noLib: true,
    emitUTS: true,
    isolatedModules: true,
    target: /* ts.ScriptTarget.ESNext */ 99,
    module: /* ts.ModuleKind.ESNext */ 99,
    moduleResolution: /* ts.ModuleResolutionKind.Bundler */ 100,
};
class UTSCompiler {
    constructor(options) {
        this._rootFiles = [];
        this._options = options;
    }
    debug(formatter, ...args) {
        return debugCompile(formatter, ...args);
    }
    getProgram() {
        return this._watcher?.getProgram()?.getProgram();
    }
    getTypeScript() {
        return this._options.typescript;
    }
    hasRootFile(fileName) {
        return this._rootFiles.includes(normalizePath(fileName));
    }
    async addRootFile(fileName, timeout = 2000) {
        return this.addRootFiles([fileName], timeout);
    }
    async addRootFiles(fileNames, timeout = 2000) {
        const normalizedFileNames = fileNames
            .map(normalizePath)
            .filter((fileName) => !this._rootFiles.includes(fileName));
        if (normalizedFileNames.length === 0) {
            if (fileNames.length) {
                debugCompile.enabled &&
                    debugCompile('addRootFile', fileNames, 'already exists');
            }
            return;
        }
        debugCompile.enabled &&
            debugCompile('addRootFiles.start', normalizedFileNames);
        const start = Date.now();
        this._rootFiles.push(...normalizedFileNames);
        await this._watcher.updateRootFileNames(this._rootFiles.slice());
        // 已经定制了 updateRootFileNames ，所以不需要 wait
        // 目前还需要保留 wait 实现，因为 invalidate 方法还需要调用 wait 机制，不然还要 hack TypeScript 的源码 onSourceFileChange 等方法
        // await this.wait(timeout, normalizedFileNames)
        debugCompile.enabled &&
            debugCompile('addRootFiles.end', normalizedFileNames, Date.now() - start);
    }
    getRootFiles() {
        return this._rootFiles;
    }
    async wait(timeout, fileNames) {
        const start = Date.now();
        this._helper.watch(timeout);
        await this._helper.wait();
        debugCompile.enabled && debugCompile('wait', Date.now() - start, fileNames);
    }
    async close() {
        this._watcher && this._watcher.close();
    }
    getDiagnostics() {
        const program = this._watcher?.getProgram();
        if (!program) {
            return [];
        }
        const standardDiagnostics = this._options.typescript.getPreEmitDiagnostics(program.getProgram());
        const customDiagnostics = [];
        const sourceFiles = program.getProgram().getSourceFiles();
        const utsDiagnosticCodes = new Set(Object.values(UTSDiagnostics).map((diag) => diag.code));
        sourceFiles.forEach((sourceFile) => {
            // @ts-expect-error 访问内部属性
            if (sourceFile.bindDiagnostics?.length) {
                // @ts-expect-error
                const utsBindDiagnostics = sourceFile.bindDiagnostics.filter((diag) => utsDiagnosticCodes.has(diag.code));
                customDiagnostics.push(...utsBindDiagnostics);
            }
            // @ts-expect-error 访问内部属性
            if (sourceFile.parseDiagnostics?.length) {
                // @ts-expect-error
                const utsParseDiagnostics = sourceFile.parseDiagnostics.filter((diag) => utsDiagnosticCodes.has(diag.code));
                customDiagnostics.push(...utsParseDiagnostics);
            }
        });
        return [...standardDiagnostics, ...customDiagnostics];
    }
    async init() {
        if (this._watcher) {
            return;
        }
        const start = Date.now();
        const { typescript: ts, compilerOptions, rootFiles, incremental, createTransformers, watchFile, reportFileName, reportDiagnostic, normalizeFileName, sourceMapCallback, } = this._options;
        if (debugCompile.enabled) {
            // @ts-expect-error
            ts.performance.enable(ts.sys);
        }
        const inputDir = normalizePath(this._options.inputDir);
        this._rootFiles = rootFiles.map(normalizePath);
        const options = {
            ...compilerOptions,
            ...defaultCompilerOptions,
            // 发行模式也启用，因为 uts 插件的原因，需要动态 addRootFile，增量 emit
            incremental: incremental,
            tsBuildInfoFile: incremental && this._options.cacheDir
                ? path.resolve(this._options.cacheDir, '.tsbuildInfo')
                : '',
        };
        if (!options.paths) {
            options.paths = {};
        }
        options.paths['@/*'] = [inputDir + '/*'];
        if (debugCompile.enabled) {
            // paths 可能很多（包含了android或ios的系统库映射）
            if (Object.keys(options.paths).length > 200) {
                const { paths, ...rest } = options;
                debugCompile('Compiler options:', rest);
            }
            else {
                debugCompile('Compiler options:', options);
            }
        }
        let isFirst = true;
        const utsFiles = new Map();
        const getCanonicalFileName = ts.sys.useCaseSensitiveFileNames
            ? identity
            : toFileNameLowerCase;
        const system = {
            ...ts.sys,
            watchFile(path, callback, pollingInterval, options) {
                if (watchFile) {
                    return watchFile(path, callback, pollingInterval, options);
                }
                return ts.sys.watchFile(path, callback, pollingInterval, options);
            },
            fileExists(filePath) {
                return !!parseUTSFile(filePath, ts);
            },
            readFile(filePath, encoding) {
                return ts.sys.readFile(parseUTSFile(filePath, ts), encoding);
            },
        };
        debugCompile.enabled && debugCompile('rootFiles', this._rootFiles);
        let curProgram;
        const { parser, before, after, afterDeclarations } = createTransformers({
            getProgram() {
                return curProgram;
            },
            shouldTransform: isUTSFile,
            normalizeFileName,
        }, {
            rootDir: normalizePath(options.rootDir || ''),
        });
        // 为 typescript.js 服务
        if (!globalThis.__utsParser__) {
            globalThis.__utsParser__ = parser;
        }
        globalThis.__utsCustomParser__ = parser;
        const { watcher, helper } = createWatcher();
        this._watcher = watcher;
        this._helper = helper;
        debugCompile.enabled && debugCompile('init', Date.now() - start);
        return;
        function createWatcher() {
            let start = 0;
            const watchProgramHelper = new WatchProgramHelper(ts);
            const watchOptions = {
                // 不监听任何目录
                excludeDirectories: ['/**/*/'],
            };
            debugCompile.enabled && debugCompile('watchOptions', watchOptions);
            const host = ts.createWatchCompilerHost(rootFiles, options, system, ts.createEmitAndSemanticDiagnosticsBuilderProgram, reportDiagnostic, reportWatchStatusChanged, undefined, watchOptions);
            function reportWatchStatusChanged(diagnostic) {
                debugCompile.enabled &&
                    debugCompile('reportWatchStatusChanged', diagnostic, Date.now() - start, 'ms');
                if (diagnostic.category === ts.DiagnosticCategory.Message) {
                    // Starting compilation in watch mode...
                    if (diagnostic.code ===
                        DiagnosticCode.STARTING_COMPILATION_IN_WATCH_MODE ||
                        diagnostic.code === DiagnosticCode.FILE_CHANGE_DETECTED) {
                        start = Date.now();
                    }
                    else if (diagnostic.code ===
                        DiagnosticCode.FOUND_1_ERROR_WATCHING_FOR_FILE_CHANGES ||
                        diagnostic.code ===
                            DiagnosticCode.FOUND_N_ERRORS_WATCHING_FOR_FILE_CHANGES) {
                        debugCompile.enabled &&
                            debugCompile('Compilation completed in', Date.now() - start, 'ms');
                        debugPerformance(ts, curProgram);
                    }
                }
                // console.log(ts.formatDiagnostic(diagnostic, formatHost))
                watchProgramHelper.handleStatus(diagnostic);
            }
            const origCreateProgram = host.createProgram;
            host.createProgram = (rootNames, options, host, oldProgram) => {
                initHost(host);
                const builderProgram = origCreateProgram(rootNames, options, host, oldProgram);
                initProgram(host, builderProgram.getProgram());
                debugProgram(builderProgram.getProgram());
                return builderProgram;
            };
            const watcher = ts.createWatchProgram(host);
            return {
                watcher,
                helper: watchProgramHelper,
            };
        }
        function isUTSFile(filePath) {
            if (utsFiles.has(filePath)) {
                return true;
            }
            return filePath.startsWith(inputDir);
        }
        function parseUTSFile(filePath, ts) {
            // utsFiles 的 key 存储的是格式化后的，不然可能存在大小写不一样，但实际是同一个文件的情况
            const normalizeFilePath = getCanonicalFileName(filePath);
            const utsFile = utsFiles.get(normalizeFilePath);
            if (utsFile) {
                return utsFile;
            }
            let fileName = filePath.split('?', 2)[0];
            const endsWithTs = fileName.endsWith('.ts');
            if (!endsWithTs) {
                // test.uvue
                const utsFileName = fileName + '.ts';
                if (ts.sys.fileExists(utsFileName)) {
                    utsFiles.set(normalizeFilePath, utsFileName);
                    return fileName;
                }
            }
            // utils.uts.ts
            if (ts.sys.fileExists(fileName)) {
                utsFiles.set(normalizeFilePath, fileName);
                return fileName;
            }
            if (endsWithTs) {
                const fileNameWithoutExtname = fileName.slice(0, -3);
                // utils.ts -> utils.uvue.ts
                // utils.ts -> utils.uts.ts
                // utils.ts -> utils.vue.ts
                const extnames = ['.uvue.ts', '.uts.ts', '.vue.ts'];
                for (const ext of extnames) {
                    const utsFileName = fileNameWithoutExtname + ext;
                    if (ts.sys.fileExists(utsFileName)) {
                        utsFiles.set(normalizeFilePath, utsFileName);
                        return utsFileName;
                    }
                }
            }
        }
        function initHost(host) {
            const resolveModuleNameLiterals = host.resolveModuleNameLiterals;
            host.resolveModuleNameLiterals = (moduleLiterals, containingFile, redirectedReference, options, containingSourceFile, reusedNames) => {
                const result = resolveModuleNameLiterals(moduleLiterals, containingFile, redirectedReference, options, containingSourceFile, reusedNames);
                result.forEach(({ resolvedModule }) => {
                    if (resolvedModule) {
                        const realFileName = utsFiles.get(getCanonicalFileName(resolvedModule.resolvedFileName));
                        if (realFileName) {
                            resolvedModule.resolvedFileName = realFileName;
                        }
                    }
                });
                return result;
            };
            return host;
        }
        function initProgram(host, program) {
            curProgram = program;
            const emit = program.emit.bind(program);
            program.emit = (targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) => {
                if (!customTransformers) {
                    customTransformers = {};
                }
                (customTransformers.before || (customTransformers.before = [])).push(...before);
                (customTransformers.after || (customTransformers.after = [])).push(...after);
                (customTransformers.afterDeclarations ||
                    (customTransformers.afterDeclarations = [])).push(...afterDeclarations);
                const emitResult = emit(targetSourceFile, (fileName, text, writeByteOrderMark, onError, sourceFiles, data) => {
                    // @ts-expect-error
                    writeFile = writeFile || host?.writeFile || program.writeFile;
                    if (sourceMapCallback && fileName.endsWith('.map')) {
                        if (sourceMapCallback(fileName, text, (fileName, text) => writeFile(fileName, text, writeByteOrderMark, onError, sourceFiles, data))) {
                            return;
                        }
                    }
                    return writeFile(fileName, text, writeByteOrderMark, onError, sourceFiles, data);
                }, cancellationToken, emitOnlyDtsFiles, customTransformers);
                return emitResult;
            };
            return program;
        }
        function debugProgram(program) {
            if (debugCompile.enabled) {
                const sourceFiles = program.getSourceFiles();
                const libs = [];
                const users = [];
                const others = [];
                sourceFiles.forEach((s) => {
                    const { type, fileName } = reportFileName(s.fileName);
                    if (type === 'system') {
                        libs.push(fileName);
                    }
                    else if (type === 'user') {
                        users.push(fileName);
                    }
                    else {
                        others.push(fileName);
                    }
                });
                if (isFirst) {
                    isFirst = false;
                    debugCompile('libs:', libs.length);
                    libs.sort().forEach((lib) => debugCompile('  ', lib));
                    debugCompile('users:', users.length);
                    users.sort().forEach((user) => debugCompile('  ', user));
                    debugCompile('others:', others.length);
                    others.sort().forEach((other) => debugCompile('  ', other));
                }
                debugCompile('sourceFiles', {
                    total: sourceFiles.length,
                    libs: libs.length,
                    users: users,
                    others: others.length,
                });
            }
        }
    }
}
function debugPerformance(ts, program) {
    if (debugCompile.enabled) {
        const measureNames = {
            Files: program.getSourceFiles().length,
            Identifiers: program.getIdentifierCount(),
            Symbols: program.getSymbolCount(),
            Types: program.getTypeCount(),
            Instantiations: program.getInstantiationCount(),
            'Memory used': Math.round((ts.sys.getMemoryUsage ? ts.sys.getMemoryUsage() : -1) / 1000 / 1000) + 'M',
            cache: program.getRelationCacheSizes(),
        };
        // @ts-expect-error
        ts.performance.forEachMeasure((measureName, duration) => {
            measureNames[measureName] = duration;
        });
        debugCompile.enabled && debugCompile(`performance:`, measureNames);
        // @ts-expect-error
        ts.performance.disable();
        // @ts-expect-error
        ts.performance.enable(ts.sys);
    }
}
function identity(x) {
    return x;
}
function toLowerCase(x) {
    return x.toLowerCase();
}
const fileNameLowerCaseRegExp = /[^\u0130\u0131\u00DFa-z0-9\\/:\-_. ]+/g;
function toFileNameLowerCase(x) {
    return fileNameLowerCaseRegExp.test(x)
        ? x.replace(fileNameLowerCaseRegExp, toLowerCase)
        : x;
}

class AutoImportTypeVisitor {
    addAutoImport(autoImport) {
        // TODO 还是有部分极端情况会生成重复名称，比如两个相同名称的类型从不同文件中导入，需要继续优化。
        if (!this.autoImports.some((imp) => imp.fileName === autoImport.fileName &&
            imp.name === autoImport.name &&
            imp.localName === autoImport.localName)) {
            this.autoImports.push(autoImport);
        }
    }
    constructor(currentNode, currentSourceFile, checker, context, ts, autoImports) {
        this.currentNode = currentNode;
        this.currentSourceFile = currentSourceFile;
        this.checker = checker;
        this.context = context;
        this.ts = ts;
        this.autoImports = autoImports;
    }
    static updateSourceFile(autoImports, sourceFile, factory, ts) {
        if (autoImports.length === 0) {
            return sourceFile;
        }
        const importDeclarations = [];
        for (let i = 0; i < autoImports.length; i++) {
            const autoImport = autoImports[i];
            const importDeclaration = factory.createImportDeclaration(undefined, factory.createImportClause(false, undefined, factory.createNamedImports([
                factory.createImportSpecifier(false, factory.createIdentifier(autoImport.localName), factory.createIdentifier(autoImport.name)),
            ])), factory.createStringLiteral(autoImport.fileName));
            importDeclarations.push(importDeclaration);
        }
        const importInserIndex = sourceFile.statements.findIndex((stmt) => !ts.isImportDeclaration(stmt)) ?? sourceFile.statements.length;
        const newStatements = [
            ...sourceFile.statements.slice(0, importInserIndex),
            ...importDeclarations,
            ...sourceFile.statements.slice(importInserIndex),
        ];
        return factory.updateSourceFile(sourceFile, newStatements, sourceFile.isDeclarationFile, sourceFile.referencedFiles, sourceFile.typeReferenceDirectives, sourceFile.hasNoDefaultLib, sourceFile.libReferenceDirectives);
    }
    visitTypeNode(typeNode) {
        const updatedTypeNode = this.ts.visitEachChild(typeNode, (typeNode) => {
            return this.visitTypeNode(typeNode);
        }, this.context);
        if (this.ts.isImportTypeNode(updatedTypeNode)) {
            const qualifier = updatedTypeNode.qualifier;
            if (qualifier) {
                const qualifierSymbol = 
                // @ts-expect-error internal API
                qualifier.symbol;
                const qualifierDecl = qualifierSymbol.declarations &&
                    qualifierSymbol.declarations[0];
                if (qualifierDecl) {
                    const importFileName = qualifierDecl.getSourceFile().fileName;
                    // @ts-expect-error internal API
                    const importTypeName = qualifier.escapedText;
                    // @ts-expect-error internal API
                    const localTypeName = ts.getUniqueName(importTypeName, this.currentSourceFile);
                    if (importTypeName && localTypeName) {
                        this.addAutoImport({
                            fileName: importFileName,
                            name: importTypeName,
                            localName: localTypeName,
                        });
                        return this.context.factory.createTypeReferenceNode(localTypeName, updatedTypeNode.typeArguments);
                    }
                }
            }
        }
        else if (this.ts.isIdentifier(updatedTypeNode)) {
            // @ts-expect-error internal API
            const symbol = updatedTypeNode.symbol;
            // @ts-expect-error internal API
            const isAccessible = this.checker.isSymbolAccessible(symbol, this.currentNode, this.ts.SymbolFlags.Type, true);
            if (isAccessible.accessibility ===
                // @ts-expect-error internal API
                this.ts.SymbolAccessibility.CannotBeNamed) {
                throw new Error(`Type '${updatedTypeNode.getText()}' is not accessible in the current context.`);
            }
        }
        return updatedTypeNode;
    }
}

debug('uts:transformer:importAndExportDeclaration');

function removeExtname(fileName) {
    if (fileName.endsWith('.uts.ts')) {
        return fileName.replace(/\.uts\.ts$/, '');
    }
    return fileName.replace(/\.\w+$/, '');
}
function wrapTransformer(ts, ls, transformer, type) {
    return (context) => {
        const transform = transformer(context);
        return (node) => {
            const isSourceFile = ts.isSourceFile(node);
            if (!context.fileName) {
                if (isSourceFile) {
                    context.fileName = node.fileName;
                }
            }
            if (ls.shouldTransform(context.fileName)) {
                if (isSourceFile && !node.isUTSFile) {
                    node.isUTSFile = true;
                    if (ls.isVueFile?.(context.fileName)) {
                        node.isVueFile = true;
                    }
                }
                if (isSourceFile && type === 'parser') {
                    if (node.statements.length) {
                        if (!node.statements[0].parent) {
                            // parser 阶段如果没有关联父节点
                            // @ts-expect-error 内部方法
                            ts.setParentRecursive(node, true);
                        }
                    }
                }
                return transform(node);
            }
            return node;
        };
    };
}
function setupParserNode(originalNode, newNode) {
    if (newNode && newNode !== originalNode && !Array.isArray(newNode)) {
        newNode.__parsedByUtsParser = true;
        newNode.parent = originalNode.parent;
    }
    return newNode;
}
let parserTs;
function createParserTsOnce(ts) {
    if (parserTs) {
        return parserTs;
    }
    parserTs = {
        ...ts,
    };
    const { visitNode, visitEachChild } = ts;
    parserTs.visitNode = (node, visitor) => {
        const realVisitor = (node) => {
            const originalNode = node;
            const newNode = visitor(node);
            return setupParserNode(originalNode, newNode);
        };
        return visitNode(node, realVisitor);
    };
    parserTs.visitEachChild = (node, visitor, context) => {
        const realVisitor = (node) => {
            const originalNode = node;
            const newNode = visitor(node);
            return setupParserNode(originalNode, newNode);
        };
        return visitEachChild(node, realVisitor, context);
    };
    return parserTs;
}
function initParser(ts, ls, parser, parserTransformers, transformOptions) {
    // if (options.InterfaceDeclaration) {
    //   ;(parser.InterfaceDeclaration || (parser.InterfaceDeclaration = [])).push(
    //     wrapTransformer(ts, ls, options.InterfaceDeclaration),
    //   )
    // }
    if (parserTransformers.TypeAliasDeclaration) {
        (parser.TypeAliasDeclaration || (parser.TypeAliasDeclaration = [])).push(
        // TODO allowDtsFiles配置项优化
        wrapTransformer(ts, ls, (context) => {
            const transformer = parserTransformers.TypeAliasDeclaration(context);
            return (node) => {
                const originalNode = node;
                const newNode = transformer(node);
                return setupParserNode(originalNode, newNode);
            };
        }, 'parser'));
    }
    if (parserTransformers.SourceFile) {
        (parser.SourceFile || (parser.SourceFile = [])).push(wrapTransformer(ts, ls, parserTransformers.SourceFile, 'parser'));
    }
}
function parseTransformer(ts, transformers, options) {
    initTs(ts);
    return (ls) => {
        const parser = {};
        const before = [];
        const after = [];
        const afterDeclarations = [];
        transformers.forEach((creator) => {
            let transformer = creator(ts, ls, options);
            if (typeof transformer === 'function') {
                before.push(wrapTransformer(ts, ls, transformer, 'before'));
            }
            else {
                if (transformer.parser) {
                    // TODO 优化此处逻辑
                    const transformer = creator(createParserTsOnce(ts), ls, options);
                    transformer.parser &&
                        initParser(ts, ls, parser, transformer.parser);
                }
                if (transformer.before) {
                    before.push(wrapTransformer(ts, ls, transformer.before, 'before'));
                }
                if (transformer.after) {
                    after.push(wrapTransformer(ts, ls, transformer.after, 'after'));
                }
                if (transformer.afterDeclarations) {
                    afterDeclarations.push(wrapTransformer(ts, ls, transformer.afterDeclarations, 'afterDeclarations'));
                }
            }
        });
        return {
            parser,
            before,
            after,
            afterDeclarations,
        };
    };
}
function initTs(ts, options) {
    if (!ts.ObjectFlags.UTSType) {
        const { Class, Interface, Reference, Anonymous, ArrayLiteral } = ts.ObjectFlags;
        // @ts-expect-error
        ts.ObjectFlags.UTSType =
            Class | Interface | Reference | Anonymous | ArrayLiteral;
    }
    if (!ts.TypeFlags.UTSType) {
        const { Any, String, Number, Boolean, Enum, StringLiteral, NumberLiteral, BooleanLiteral, EnumLiteral, Void, Null, Object, Union, TemplateLiteral, } = ts.TypeFlags;
        // @ts-expect-error
        ts.TypeFlags.UTSType =
            Any |
                String |
                Number |
                Boolean |
                Enum |
                StringLiteral |
                NumberLiteral |
                BooleanLiteral |
                EnumLiteral |
                Void |
                Null |
                Object |
                Union |
                TemplateLiteral;
        // @ts-expect-error
        ts.TypeFlags.UTSStringLike = String | StringLiteral | TemplateLiteral;
        // @ts-expect-error
        ts.TypeFlags.UTSNumberLike = Number | NumberLiteral;
    }
}

function getUniqueName(ts, name, sourceFile) {
    // @ts-expect-error 内部方法
    let uniqueName = ts.getUniqueName(name, sourceFile);
    if (!sourceFile.__uniqueNames) {
        sourceFile.__uniqueNames = [];
    }
    // 如果 uniqueName 已经存在，则添加后缀，需要考虑后缀冲突
    let suffix = 1;
    while (sourceFile.__uniqueNames.includes(uniqueName)) {
        uniqueName = `${name}_${suffix}`;
        suffix++;
    }
    sourceFile.__uniqueNames.push(uniqueName);
    return uniqueName;
}
function isValidType(ts, checker, type) {
    // 类型参数，直接返回 true
    if (type.flags & ts.TypeFlags.TypeParameter) {
        return true;
    }
    if (type.isUnion()) {
        if (type.types.length > 2) {
            return false;
        }
        // boolean
        if (type === checker.getBooleanType()) {
            return true;
        }
        const nullType = checker.getNullType();
        const firstType = type.types[0];
        const secondType = type.types[1];
        return ((firstType === nullType && isValidType(ts, checker, secondType)) ||
            (secondType === nullType && isValidType(ts, checker, firstType)));
    }
    if (type.flags & ts.TypeFlags.Object) {
        return !!(type.objectFlags & ts.ObjectFlags.UTSType);
    }
    return !!(type.flags & ts.TypeFlags.UTSType);
}
function resolveUpdatedNodeContextualType(ts, checker, node) {
    const originalNode = ts.getOriginalNode(node);
    return ts.isExpression(originalNode)
        ? checker.getContextualType(originalNode)
        : undefined;
}
function resolveExpressionType(checker, node) {
    return checker.getContextualType(node) ?? checker.getTypeAtLocation(node);
}
function resolveNonNullableType(checker, type) {
    return type ? checker.getNonNullableType(type) : type;
}
function isAnonymousObjectConstraintType(ts, type) {
    return (type.flags & ts.TypeFlags.Object &&
        type.objectFlags & ts.ObjectFlags.Anonymous &&
        !type.aliasSymbol &&
        type.getCallSignatures().length === 0);
}
/**
 * 是否是 type 定义的常规类型
 * 内部会提取非空类型做识别
 * @param ts
 * @param checker
 * @param type
 * @returns
 */
function resolveAnonymousLiteralType(ts, checker, type, declareType) {
    if (type) {
        type = resolveNonNullableType(checker, type);
        if (type.isUnion() && declareType) {
            // 是否可以匹配到指定的 type 类型
            for (const t of type.types) {
                if (isUTSObjectType(t, ts) &&
                    checker.isTypeAssignableTo(declareType, t)) {
                    return t;
                }
            }
        }
        else if (isUTSObjectType(type, ts)) {
            return type;
        }
    }
}
function isUTSObjectType(type, ts) {
    if (type.symbol &&
        type.aliasSymbol &&
        type.aliasSymbol.flags & ts.SymbolFlags.TypeAlias &&
        type.aliasSymbol.declarations?.length === 1) {
        const decl = type.aliasSymbol.declarations[0];
        if (ts.isTypeAliasDeclaration(decl) && ts.isTypeLiteralNode(decl.type)) {
            // decl 中仅定义了PropertySignature，CallSignature
            if (decl.type.members.every((m) => ts.isPropertySignature(m) || ts.isCallSignatureDeclaration(m))) {
                return true;
            }
        }
    }
    return false;
}
function resolveMethodDeclarationContextualType(ts, checker, node) {
    const parent = ts.getOriginalNode(node).parent;
    if (parent &&
        ts.isObjectLiteralExpression(parent) &&
        ts.isIdentifier(node.name)) {
        const parentType = checker.getContextualType(parent);
        if (parentType) {
            const symbol = parentType.getProperty(node.name.text);
            if (symbol) {
                return checker.getTypeOfSymbol(symbol);
            }
        }
    }
}
function isErrorType(type, ts, checker) {
    // The only 'any' types that have alias symbols are those manufactured by getTypeFromTypeAliasReference for
    // a reference to an unresolved symbol. We want those to behave like the errorType.
    return (type === checker.getErrorType?.() ||
        !!(type.flags & ts.TypeFlags.Any && type.aliasSymbol));
}
function isUTSNumberType(type, ts, checker) {
    return (type.flags & ts.TypeFlags.UTSNumberLike ||
        type === (checker.getUTSNumberType || checker.getNumberType)?.());
}
function getObjectFlags(type, ts) {
    return type.flags & ts.TypeFlags.Object ? type.objectFlags : 0;
}
function isReferenceType(type, ts) {
    return (getObjectFlags(type, ts) & ts.ObjectFlags.Reference) !== 0;
}
function isMethodCall(node, ts) {
    // 如果父节点是 CallExpression 且 expression 是当前节点，则是方法调用
    return (node.parent &&
        ts.isCallExpression(node.parent) &&
        node.parent.expression === node);
}
function displayArguments(ts, nodes) {
    return nodes
        .map((node) => (ts.isIdentifier(node.name) ? node.name.text : node.name))
        .join(', ');
}
function getContainerNode(ts, node) {
    node = ts.getOriginalNode(node);
    while (true) {
        node = node.parent;
        if (!node) {
            return undefined;
        }
        node = ts.getOriginalNode(node);
        switch (node.kind) {
            case ts.SyntaxKind.SourceFile:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.MethodSignature:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.EnumDeclaration:
            case ts.SyntaxKind.ModuleDeclaration:
                return node;
        }
    }
}
function containsImportTypeNode(node, ts) {
    if (ts.isImportTypeNode(node)) {
        return true;
    }
    return (ts.forEachChild(node, (child) => containsImportTypeNode(child, ts)) || false);
}
function typeToTypeNode(type, node, ts, checker) {
    const containerNode = getContainerNode(ts, node);
    let typeNode = checker.typeToTypeNode(type, containerNode, ts.NodeBuilderFlags.None);
    // 可能 使用了 containerNode 后反而获取不到类型，尝试直接获取
    if (!typeNode && containerNode) {
        typeNode = checker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.None);
    }
    if (typeNode) {
        // 通过 containerNode 可能获取到 import('type.uts').A 类型
        // import 目前由autoImport实现了，暂不处理
        if (containsImportTypeNode(typeNode, ts)) {
            return checker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.None);
        }
        // 目前不能排除 undefined，ArkTS 可选链的类型还需要保留 undefined 类型
        // if (ts.isUnionTypeNode(typeNode)) {
        //   // 排除 undefined 类型
        //   ;(typeNode as any).types = typeNode.types.filter((t) => {
        //     if (t.kind === ts.SyntaxKind.UndefinedKeyword) {
        //       return false
        //     }
        //     return true
        //   })
        // }
        return typeNode;
    }
    return undefined;
}

const debugAutoImport = debug('uts:transformer:autoImport');
function parseAutoImportSourceFileName(ts, symbol, sourceFile) {
    if (!symbol.declarations) {
        return;
    }
    for (const declaration of symbol.declarations) {
        // local
        const declarationSourceFile = declaration.getSourceFile();
        // TODO uts插件？
        if (declarationSourceFile.isDeclarationFile) {
            return;
        }
        if (declarationSourceFile === sourceFile ||
            declarationSourceFile.fileName === sourceFile.fileName) {
            return;
        }
        if (ts.isModuleDeclaration(declaration)) {
            return;
        }
        return removeExtname(normalizePath(declarationSourceFile.fileName));
    }
}
function getFileNameFromSymbol(symbol) {
    const { declarations } = symbol;
    if (!declarations || declarations.length !== 1) {
        return;
    }
    const declaration = declarations[0].getSourceFile();
    return removeExtname(normalizePath(declaration.fileName));
}
function initSourceFileImports(ts, checker, sourceFile) {
    const imports = new Map();
    sourceFile.statements.forEach((statement) => {
        if (!ts.isImportDeclaration(statement)) {
            return;
        }
        const importClause = statement.importClause;
        if (!importClause) {
            return;
        }
        const { name, namedBindings } = importClause;
        if (namedBindings) {
            // import { a as b } from 'xxx'
            if (ts.isNamedImports(namedBindings)) {
                namedBindings.elements.forEach((element) => {
                    const symbol = checker.getSymbolAtLocation(element.name);
                    if (symbol) {
                        const aliasedSymbol = checker.getAliasedSymbol(symbol);
                        const fileName = getFileNameFromSymbol(aliasedSymbol);
                        if (!fileName) {
                            return;
                        }
                        if (!imports.has(fileName)) {
                            imports.set(fileName, {});
                        }
                        imports.get(fileName)[element.name.text] =
                            element.propertyName?.text ?? element.name.text;
                    }
                });
            }
        }
    });
    sourceFile.__imports = imports;
}
function autoImport(ts, ls, checker, type, sourceFile, autoImports) {
    let { aliasSymbol: symbol } = resolveNonNullableType(checker, type);
    if (!symbol) {
        return;
    }
    const sourceFileName = parseAutoImportSourceFileName(ts, symbol, sourceFile);
    if (!sourceFileName) {
        return;
    }
    const { factory } = ts;
    const name = symbol.getName();
    // 判断是否已经导入
    if (!sourceFile.__imports) {
        initSourceFileImports(ts, checker, sourceFile);
    }
    const imports = sourceFile.__imports;
    if (imports.has(sourceFileName)) {
        const namedImports = imports.get(sourceFileName);
        if (namedImports[name]) {
            return factory.createTypeReferenceNode(namedImports[name]);
        }
    }
    const alias = getUniqueName(ts, name, sourceFile);
    let source = sourceFileName;
    const rootDir = sourceFile.__rootDir;
    if (rootDir && sourceFileName.startsWith(rootDir)) {
        const hostSourceFileName = removeExtname(normalizePath(sourceFile.fileName));
        if (hostSourceFileName.startsWith(rootDir)) {
            source = ls.normalizeFileName(path.relative(path.dirname(hostSourceFileName), sourceFileName));
            source = source.startsWith('.') ? source : './' + source;
        }
    }
    const importDeclaration = factory.createImportDeclaration(undefined, factory.createImportClause(false, undefined, factory.createNamedImports([
        factory.createImportSpecifier(false, alias !== name ? factory.createIdentifier(name) : undefined, factory.createIdentifier(alias)),
    ])), factory.createStringLiteral(source), undefined);
    if (debugAutoImport.enabled) {
        debugAutoImport(`import { ${name} as ${alias} } from '${source}'`, 'at', sourceFile.__relativeFileName);
    }
    autoImports.set(symbol, importDeclaration);
    if (!imports.has(sourceFileName)) {
        imports.set(sourceFileName, {});
    }
    imports.get(sourceFileName)[name] = alias;
    if (alias !== name) {
        return factory.createTypeReferenceNode(alias);
    }
}

function isNumberLiteralUnion(type) {
    return type.types.every((t) => t.isNumberLiteral());
}
function isNullable(ts, type) {
    return type.flags & (ts.TypeFlags.Null | ts.TypeFlags.Undefined);
}
function isNullableType(ts, type) {
    return (type.flags === ts.TypeFlags.Null || type.flags === ts.TypeFlags.Undefined);
}
function hasNullableType(type, checker) {
    return checker.getNonNullableType(type) !== type;
}
function createTypeNode(ts, checker, type, supportUnionType = false) {
    // 如果是字符串字面量，返回字符串类型
    if (type.isStringLiteral()) {
        return createStringTypeNode(ts);
    }
    // 如果是数字字面量，返回数字类型
    if (type.isNumberLiteral()) {
        return createNumberTypeNode(ts);
    }
    // 如果是布尔字面量，返回布尔类型
    if (type.flags & ts.TypeFlags.BooleanLiteral) {
        return createBooleanTypeNode(ts);
    }
    if (type.isUnion()) {
        const nonNullableType = checker.getNonNullableType(type);
        if (nonNullableType.isUnion()) {
            if (supportUnionType) {
                return checker.typeToTypeNode(type, undefined, undefined);
            }
            const types = nonNullableType.types;
            if (types.length) {
                let firstType = types[0];
                for (let i = 1; i < types.length; i++) {
                    if (types[i].flags !== firstType.flags) {
                        // 复杂的联合类型
                        if (types.length !== type.types.length) {
                            return ts.factory.createUnionTypeNode([
                                ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),
                                createNullTypeNode(ts),
                            ]);
                        }
                        else {
                            return ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
                        }
                    }
                }
                if (types.length !== type.types.length) {
                    const typeNode = createTypeNode(ts, checker, firstType, supportUnionType);
                    if (typeNode) {
                        return ts.factory.createUnionTypeNode([
                            typeNode,
                            createNullTypeNode(ts),
                        ]);
                    }
                }
                else {
                    return createTypeNode(ts, checker, firstType, supportUnionType);
                }
            }
        }
        else {
            const typeNode = createTypeNode(ts, checker, nonNullableType, supportUnionType);
            if (typeNode) {
                return ts.factory.createUnionTypeNode([
                    typeNode,
                    createNullTypeNode(ts),
                ]);
            }
        }
    }
}
let nullTypeNode;
let stringTypeNode;
let numberTypeNode;
let booleanTypeNode;
let anyTypeNode;
function createAnyTypeNode(ts) {
    if (!anyTypeNode) {
        anyTypeNode = ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
    }
    return anyTypeNode;
}
function createNullableTypeNode(typeNode, ts) {
    return ts.factory.createUnionTypeNode([typeNode, createNullTypeNode(ts)]);
}
function createNullTypeNode(ts) {
    if (!nullTypeNode) {
        nullTypeNode = ts.factory.createLiteralTypeNode(ts.factory.createNull());
    }
    return nullTypeNode;
}
function createStringTypeNode(ts) {
    if (!stringTypeNode) {
        stringTypeNode = ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
    }
    return stringTypeNode;
}
function createNumberTypeNode(ts) {
    if (!numberTypeNode) {
        numberTypeNode = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
    }
    return numberTypeNode;
}
function createBooleanTypeNode(ts) {
    if (!booleanTypeNode) {
        booleanTypeNode = ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);
    }
    return booleanTypeNode;
}

// function isRelatedToPrimitive(
//   ts: typeof tsTypes,
//   checker: tsTypes.TypeChecker,
//   source: tsTypes.Type,
//   target: tsTypes.Type,
// ) {
//   if (
//     target === checker.getUTSStringType?.() ||
//     target.flags & ts.TypeFlags.UTSStringLike
//   ) {
//     if (source.flags & ts.TypeFlags.UTSStringLike) {
//       return true
//     }
//     return isPrimitiveUnion(ts, source) && isStringLiteralUnion(source)
//   } else if (isUTSNumberType(target, ts, checker)) {
//     if (source.flags & ts.TypeFlags.UTSNumberLike) {
//       return true
//     }
//     return isPrimitiveUnion(ts, source) && isNumberLiteralUnion(source)
//   }
//   return false
// }
function isRelatedTo(ts, checker, source, target) {
    if (isNullableType(ts, source)) {
        if (isNullable(ts, target)) {
            return true;
        }
    }
    // 不能启用该对比，否则会影响ts的字面量类型推断逻辑
    // 例如重载函数：test(a:'a1'):string ;test(a:'a2'):number
    // 如果启用下边的逻辑，会导致test('a2')的类型不能推断为number
    //
    // if (
    //   isRelatedToPrimitive(ts, checker, source, target) ||
    //   isRelatedToPrimitive(ts, checker, target, source)
    // ) {
    //   // return true
    // }
    if (checker && checker.getGlobalType && !checker.getUTSJSONObjectType) {
        const globalUTSJSONObjectType = checker.getGlobalType("UTSJSONObject" /* IDENTIFIER.UTSJSONObject */, 
        /*arity*/ 0, true);
        checker.getUTSJSONObjectType = () => globalUTSJSONObjectType;
        const globalStringType = checker.getGlobalType('String', 
        /*arity*/ 0, 
        /*reportErrors*/ true);
        checker.getUTSStringType = () => globalStringType;
        const globalNumberType = checker.getGlobalType('Number', 
        /*arity*/ 0, 
        /*reportErrors*/ true);
        checker.getUTSNumberType = () => globalNumberType;
    }
    const jsonObjectType = checker.getUTSJSONObjectType?.();
    if (jsonObjectType) {
        const newTarget = checker.getNonNullableType(target);
        if ((isAnonymousObjectConstraintType(ts, source) &&
            newTarget === jsonObjectType) ||
            (isAnonymousObjectConstraintType(ts, target) && source === jsonObjectType)) {
            return true;
        }
    }
}

function isTypeRelatedTo(ts, typeChecker, source, target) {
    return isRelatedTo(ts, typeChecker, source, target);
}

const hacker$1 = {
    isRelatedTo,
    isTypeRelatedTo,
    useTypeAndInterfaceAsValue: true,
};

const debugArguments = debug('uts:transformer:arguments');
const transformArguments = (ts, ls, options) => {
    const shouldTransform = options.transformArguments?.shouldTransform ?? (() => true);
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const autoImports = new Map();
            let sourceFile;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                if (ts.isMethodDeclaration(updatedNode)) {
                    const type = resolveNonNullableType(checker, resolveMethodDeclarationContextualType(ts, checker, updatedNode));
                    if (type) {
                        if (!shouldTransform(updatedNode, type, checker)) {
                            return updatedNode;
                        }
                        const signatures = type.getCallSignatures();
                        if (signatures && signatures.length) {
                            const newParams = resolveParameters(ts, factory, signatures, updatedNode.parameters);
                            if (newParams) {
                                if (debugArguments.enabled) {
                                    const originalNode = ts.getOriginalNode(updatedNode);
                                    debugArguments(`method:`, `${originalNode.name.getText()}(${displayArguments(ts, newParams)}) at ${sourceFile.__relativeFileName}`);
                                }
                                return factory.updateMethodDeclaration(updatedNode, updatedNode.modifiers, updatedNode.asteriskToken, updatedNode.name, updatedNode.questionToken, updatedNode.typeParameters, newParams, updatedNode.type, updatedNode.body);
                            }
                        }
                    }
                }
                else if (ts.isArrowFunction(updatedNode)) {
                    const type = resolveNonNullableType(checker, resolveExpressionType(checker, updatedNode));
                    // 如果类型是联合类型，则不进行转换
                    if (type.isUnion()) {
                        return updatedNode;
                    }
                    if (!shouldTransform(updatedNode, type, checker)) {
                        return updatedNode;
                    }
                    const signatures = type.getCallSignatures();
                    if (signatures && signatures.length) {
                        const newParams = resolveParameters(ts, factory, signatures, updatedNode.parameters);
                        if (newParams) {
                            if (debugArguments.enabled) {
                                debugArguments(`arrow function:`, `(${displayArguments(ts, newParams)}) at ${sourceFile.__relativeFileName}`);
                            }
                            return factory.updateArrowFunction(updatedNode, updatedNode.modifiers, updatedNode.typeParameters, newParams, updatedNode.type, updatedNode.equalsGreaterThanToken, updatedNode.body);
                        }
                    }
                }
                else if (ts.isFunctionExpression(updatedNode)) {
                    const type = resolveNonNullableType(checker, resolveExpressionType(checker, updatedNode));
                    // 如果类型是联合类型，则不进行转换
                    if (type.isUnion()) {
                        return updatedNode;
                    }
                    if (!shouldTransform(updatedNode, type, checker)) {
                        return updatedNode;
                    }
                    const signatures = type.getCallSignatures();
                    if (signatures && signatures.length) {
                        const newParams = resolveParameters(ts, factory, signatures, updatedNode.parameters);
                        if (newParams) {
                            if (debugArguments.enabled) {
                                debugArguments(`function expression:`, `(${displayArguments(ts, newParams)}) at ${sourceFile.__relativeFileName}`);
                            }
                            return factory.updateFunctionExpression(updatedNode, updatedNode.modifiers, updatedNode.asteriskToken, updatedNode.name, updatedNode.typeParameters, newParams, updatedNode.type, updatedNode.body);
                        }
                    }
                }
                else if ((options.targetLanguage === 'Kotlin' ||
                    options.targetLanguage === 'Swift') &&
                    ts.isCallExpression(updatedNode) &&
                    updatedNode.arguments.length === 0) {
                    // 目前仅处理无参，需要 void 有参的情况
                    // function test(arg: void) {
                    //   console.log(arg)
                    // }
                    // test() => test(void 0)
                    //
                    const type = resolveNonNullableType(checker, resolveExpressionType(checker, updatedNode.expression));
                    const signatures = type.getCallSignatures();
                    if (signatures && signatures.length === 1) {
                        const parameters = signatures[0].parameters;
                        if (parameters.length === 1) {
                            const type = checker.getTypeOfSymbol(parameters[0]);
                            if (isVoidType(type, ts)) {
                                return factory.updateCallExpression(updatedNode, updatedNode.expression, updatedNode.typeArguments, factory.createNodeArray([
                                    factory.createVoidExpression(factory.createNumericLiteral(0)),
                                ]));
                            }
                        }
                    }
                }
                return updatedNode;
            };
            return (node) => {
                sourceFile = node;
                const updatedNode = ts.visitNode(node, visitor);
                if (autoImports.size === 0) {
                    return updatedNode;
                }
                return factory.updateSourceFile(updatedNode, [...autoImports.values(), ...updatedNode.statements], updatedNode.isDeclarationFile, updatedNode.referencedFiles, updatedNode.typeReferenceDirectives, updatedNode.hasNoDefaultLib, updatedNode.libReferenceDirectives);
            };
        },
    };
};
function isVoidType(type, ts) {
    return ((type.flags & ts.TypeFlags.Void) !== 0 ||
        (type.isUnion() && type.types.some((t) => isVoidType(t, ts))));
}
function resolveParameters(ts, factory, signatures, parameters) {
    let closestSignature;
    const len = parameters.length;
    for (const signature of signatures) {
        if (signature.parameters.length === len) {
            return;
        }
        if (signature.parameters.length > len) {
            if (!closestSignature ||
                signature.parameters.length < closestSignature.parameters.length) {
                closestSignature = signature;
            }
        }
    }
    if (!closestSignature) {
        return;
    }
    const requiredParameter = [];
    for (const p of closestSignature.parameters) {
        if (!p.valueDeclaration) {
            return;
        }
        if (!ts.isParameter(p.valueDeclaration)) {
            return;
        }
        // 可选值或者剩余参数
        if (p.valueDeclaration.questionToken || p.valueDeclaration.dotDotDotToken) {
            break;
        }
        requiredParameter.push(p);
    }
    const additionalParamsCount = requiredParameter.length - len;
    if (additionalParamsCount <= 0) {
        return;
    }
    const newParameters = [];
    for (let i = 0; i < additionalParamsCount; i++) {
        newParameters.push(factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier(`_${closestSignature.parameters[i + len].name}`), undefined, undefined, undefined));
    }
    return factory.createNodeArray([...parameters, ...newParameters]);
}

function createDiagnosticFromMessage(ts, message, range, file, code, isHyperlink, suggestion) {
    let hyperlink = ` https://doc.dcloud.net.cn/uni-app-x/uts/uts_diff_ts.html#UTS${code}`;
    return {
        file: file,
        start: range.pos,
        length: range.end - range.pos,
        messageText: message +
            (isHyperlink ? hyperlink : '') +
            (suggestion ? `\n建议: ${suggestion}` : ''),
        category: ts.DiagnosticCategory.Error,
        code: code,
    };
}

function checkConditionalNode(ts, node, context, ls) {
    const program = ls.getProgram();
    if (!program) {
        return;
    }
    const checker = program.getTypeChecker();
    let conditionExpression = null;
    switch (node.kind) {
        case ts.SyntaxKind.IfStatement:
            conditionExpression = node.expression;
            break;
        case ts.SyntaxKind.WhileStatement:
            conditionExpression = node.expression;
            break;
        case ts.SyntaxKind.ConditionalExpression:
            conditionExpression = node.condition;
            break;
    }
    if (conditionExpression) {
        validateConditionType(ts, conditionExpression, checker, context);
    }
}
/**
 * 验证条件表达式的类型
 * @param ts - TypeScript 实例
 * @param expression - 条件表达式
 * @param typeChecker - 类型检查器
 * @param context - 转换上下文
 */
function validateConditionType(ts, expression, typeChecker, context) {
    try {
        const kind = expression.kind;
        const kinds = [ts.SyntaxKind.PrefixUnaryExpression];
        if (!kinds.includes(kind)) {
            return;
        }
        if (kind === ts.SyntaxKind.PrefixUnaryExpression) {
            const unaryExpression = expression;
            const operand = unaryExpression.operand;
            const operatorType = typeChecker.getTypeAtLocation(operand);
            const isExclamationToken = unaryExpression.operator === ts.SyntaxKind.ExclamationToken;
            if (isExclamationToken && !isBooleanType(ts, operatorType, typeChecker)) {
                const sourceFile = expression.getSourceFile();
                const { code, message } = UTSDiagnostics.Conditional_statements_must_use_boolean_types;
                context.addSemanticDiagnostic(createDiagnosticFromMessage(ts, `${message}`, {
                    pos: expression.getStart(),
                    end: expression.getEnd(),
                }, sourceFile, code, true, getSuggestion(operand.getText(), typeChecker.typeToString(operatorType))));
                return;
            }
        }
    }
    catch (error) {
        // 如果类型检查失败，记录错误但继续执行
        console.warn(`类型检查失败: ${error}`);
    }
}
/**
 * 检查类型是否为布尔类型
 * @param ts - TypeScript 实例
 * @param type - 类型对象
 * @returns 是否为布尔类型
 */
function isBooleanType(ts, type, typeChecker) {
    // mark 因为内部很多.d.ts类型定义有问题，会导致编译失败，所以先固定只判断字符串和数字类型
    const typeStr = typeChecker.typeToString(type).toLocaleLowerCase();
    if (typeStr !== 'string' && typeStr !== 'number' && typeStr !== 'object') {
        return true;
    }
    // 检查是否为布尔类型
    if (type.flags & ts.TypeFlags.Boolean) {
        return true;
    }
    // 检查是否为 true 或 false 字面量类型
    if (type.flags & ts.TypeFlags.BooleanLiteral) {
        return true;
    }
    if (typeChecker.typeToString(type) === 'Boolean') {
        return true;
    }
    // 检查联合类型（如 true | false）
    if (type.flags & ts.TypeFlags.Union) {
        const unionType = type;
        return unionType.types.every((t) => isBooleanType(ts, t, typeChecker));
    }
    return false;
}
/**
 * 获取修复建议
 * @param expression - 表达式文本
 * @param type - 类型字符串
 * @returns 修复建议
 */
function getSuggestion(expression, type) {
    // 检查是否是否定表达式（如 !str）
    const isNegation = expression.startsWith('!');
    const baseExpression = isNegation ? expression.substring(1) : expression;
    switch (type) {
        case 'number':
            if (isNegation) {
                return `${baseExpression} == 0 或 ${baseExpression} <= 0`;
            }
            return `${expression} != 0 或 ${expression} > 0`;
        case 'string':
        case '""': // 空字符串字面量类型
            if (isNegation) {
                return `${baseExpression} == '' 或 ${baseExpression}.length == 0`;
            }
            return `${expression} != '' 或 ${expression}.length > 0`;
        case 'null':
            if (isNegation) {
                return `${baseExpression} == null`;
            }
            return `${expression} != null`;
        // case 'any':
        //   return `typeof ${baseExpression} == 'boolean'`
        default:
            if (type.includes('null')) {
                if (isNegation) {
                    return `${baseExpression} == null`;
                }
                return `${expression} != null`;
            }
            if (type.includes('object')) {
                if (isNegation) {
                    return `${baseExpression} == null`;
                }
                return `${expression} != null`;
            }
            if (type.includes('array') || type.includes('[]')) {
                if (isNegation) {
                    return `${baseExpression}.length == 0`;
                }
                return `${expression}.length > 0`;
            }
            return ``;
    }
}

function checkInterfaceDeclaration(ts, updatedNode, context, ls, hxPluginDir) {
    if (!ts.isTypeReferenceNode(updatedNode)) {
        return;
    }
    const typeName = updatedNode.typeName;
    if (!ts.isIdentifier(typeName)) {
        return;
    }
    const parent = updatedNode.parent;
    if (!parent ||
        !ts.isVariableDeclaration(parent) ||
        parent.type !== updatedNode) {
        return;
    }
    const program = ls.getProgram();
    if (!program) {
        return;
    }
    const checker = program.getTypeChecker();
    if (!checker) {
        return;
    }
    const symbol = checker.getSymbolAtLocation(typeName);
    if (!symbol || !(symbol.flags & ts.SymbolFlags.Interface)) {
        return;
    }
    if (parent.initializer && ts.isObjectLiteralExpression(parent.initializer)) {
        if (symbol.declarations?.length) {
            const desc = symbol.declarations[0];
            if (hxPluginDir &&
                desc.getSourceFile().fileName.endsWith('.d.ts') &&
                isUTSDeclarationFile(desc, hxPluginDir)) {
                return;
            }
        }
        const range = {
            pos: parent.initializer.getStart(),
            end: parent.initializer.getEnd(),
        };
        const { message, code } = UTSDiagnostics.Object_literals_only_support_object_types_defined_by_construction_type_and_do_not_support_interfaces;
        context.addSemanticDiagnostic(createDiagnosticFromMessage(ts, message, range, updatedNode.getSourceFile(), code, true, ''));
    }
}

function isInSlotsTypeContext(ts, node) {
    let current = node.parent;
    let depth = 0;
    const maxDepth = 5;
    while (current && depth < maxDepth) {
        if (ts.isTypeReferenceNode(current)) {
            const typeName = current.typeName;
            if (ts.isIdentifier(typeName) && typeName.text === 'SlotsType') {
                return true;
            }
        }
        current = current.parent;
        depth++;
    }
    return false;
}
function checkObjectLiteral(ts, updatedNode, context) {
    if (ts.isTypeLiteralNode(updatedNode)) {
        const parent = updatedNode.parent;
        if (parent &&
            (ts.isTypeAliasDeclaration(parent) ||
                ts.isInterfaceDeclaration(parent) ||
                ts.isTypeLiteralNode(parent) ||
                // ts.isAsExpression(parent) ||
                ts.isTypeAssertionExpression(parent))) {
            return;
        }
        if (isInSlotsTypeContext(ts, updatedNode)) {
            return;
        }
        const range = {
            pos: updatedNode.getStart(),
            end: updatedNode.getEnd(),
        };
        context.addSemanticDiagnostic(createDiagnosticFromMessage(ts, UTSDiagnostics
            .direct_declaration_of_Object_Literal_Type_is_not_supported.message, range, updatedNode.getSourceFile(), UTSDiagnostics
            .direct_declaration_of_Object_Literal_Type_is_not_supported.code, true, ''));
    }
    else if (ts.isVariableDeclaration(updatedNode) &&
        updatedNode.parent &&
        ts.isVariableDeclarationList(updatedNode.parent)) {
        const variableType = updatedNode.type;
        if (variableType && ts.isTypeLiteralNode(variableType)) {
            const range = {
                pos: updatedNode.pos + 1,
                end: updatedNode.end,
            };
            context.addSemanticDiagnostic(createDiagnosticFromMessage(ts, UTSDiagnostics
                .direct_declaration_of_Object_Literal_Type_is_not_supported.message, range, updatedNode.getSourceFile(), UTSDiagnostics
                .direct_declaration_of_Object_Literal_Type_is_not_supported.code, true, ''));
        }
    }
}

function checkTypeAliasDeclaration(ts, updatedNode, context) {
    if (ts.isTypeAliasDeclaration(updatedNode)) {
        const isTopLevelScope = ts.isBlockScopedContainerTopLevel(updatedNode.parent);
        if (!isTopLevelScope) {
            const typeNode = updatedNode.type;
            // 判断类型的kind是否为类型字面量，如：type MyType = {msg: string}
            if (typeNode.kind !== ts.SyntaxKind.TypeLiteral) {
                const range = {
                    pos: updatedNode.getStart(),
                    end: updatedNode.getEnd(),
                };
                // 类型别名不能出现在局部作用域中 / Type aliases cannot appear in local scope.
                const { message, code } = UTSDiagnostics.Type_aliases_cannot_appear_in_local_scope;
                context.addSemanticDiagnostic(createDiagnosticFromMessage(ts, message, range, updatedNode.getSourceFile(), code, true, ''));
            }
        }
    }
}

const debugChecker = debug('uts:transformer:checker');
/**
 * 检查器
 * @param ts
 * @returns
 */
const transformChecker = (ts, ls, options) => {
    return {
        before(context) {
            if (debugChecker.enabled) {
                debugChecker(options.hxPluginDir);
            }
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                checkObjectLiteral(ts, updatedNode, context);
                checkInterfaceDeclaration(ts, updatedNode, context, ls, options.hxPluginDir);
                checkTypeAliasDeclaration(ts, updatedNode, context);
                checkConditionalNode(ts, updatedNode, context, ls);
                return updatedNode;
            };
            return (sourceFile) => {
                return ts.visitNode(sourceFile, visitor);
            };
        },
    };
};

const transformContext = (ts, _, options) => {
    function initContext(context, node) {
        if (ts.isSourceFile(node)) {
            if (!node.__relativeFileName) {
                const compilerOptions = context.getCompilerOptions();
                if (compilerOptions.rootDir &&
                    path.isAbsolute(compilerOptions.rootDir)) {
                    const rootDir = normalizePath(compilerOptions.rootDir);
                    const fileName = normalizePath(node.fileName);
                    node.__rootDir = rootDir;
                    if (fileName.startsWith(rootDir)) {
                        node.__relativeFileName = normalizePath(path.relative(rootDir, fileName));
                    }
                    else if (fileName.includes('/@dcloudio/')) {
                        node.__relativeFileName =
                            '@dcloudio/' + fileName.split('/@dcloudio/')[1];
                    }
                }
                if (!node.__relativeFileName) {
                    node.__relativeFileName = path.basename(node.fileName);
                }
            }
            if (!context.printNode) {
                const printer = ts.createPrinter();
                context.printNode = (node, sourceFile) => {
                    return printer.printNode(ts.EmitHint.Unspecified, node, sourceFile);
                };
            }
            if (!context.addSyntacticDiagnostic) {
                context.addSyntacticDiagnostic = (diag) => {
                    // @ts-expect-error 内部属性
                    node.parseDiagnostics.push(diag);
                };
                context.addSemanticDiagnostic = (diag) => {
                    // @ts-expect-error 内部属性，借用bindDiagnostics来存储语义诊断
                    node.bindDiagnostics.push(diag);
                };
            }
            if (!context.error) {
                context.error = (diagnostic) => {
                    if (options.watch) {
                        // watch 模式下底层是setTimeout封装，且被try catch，不能直接抛出异常，需要使用addSyntacticDiagnostic
                        // 打个标记，让后续流程直接抛出
                        diagnostic.__throwError = true;
                        context.addSyntacticDiagnostic(diagnostic);
                        return;
                    }
                    const error = new Error(diagnostic.messageText.toString());
                    error.diagnostic = diagnostic;
                    // 指定了id后，不让后续的rollup重写
                    Object.defineProperty(error, 'id', {
                        get() {
                            return diagnostic.file.fileName;
                        },
                        set(_v) { },
                    });
                    throw error;
                };
            }
        }
        return node;
    }
    return {
        before(context) {
            return (node) => {
                return initContext(context, node);
            };
        },
        after(context) {
            return (node) => {
                return initContext(context, node);
            };
        },
        afterDeclarations(context) {
            return (node) => {
                return initContext(context, node);
            };
        },
    };
};

const debugGenerics = debug('uts:transformer:generics');
/**
 * 补充泛型参数默认值
 * @param ts
 * @returns
 */
const transformGenericsParameterDefaults = (ts, ls, options) => {
    const shouldTransform = options.transformGenericsParameterDefaults?.shouldTransform ??
        (() => true);
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const autoImports = new Map();
            let sourceFile;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                if (ts.isTypeReferenceNode(updatedNode)) {
                    const type = checker.getTypeAtLocation(updatedNode);
                    const symbol = type.aliasSymbol;
                    if (symbol &&
                        symbol.flags & ts.SymbolFlags.TypeAlias &&
                        !type.aliasTypeArguments) {
                        // type A<T> = {}
                        // type B = A<number>
                        // const b:B = {a:1}
                        // 此时 B 不能补充泛型默认值
                        return updatedNode;
                    }
                    // type alias
                    if (type.resolvedTypeArguments ||
                        type.mapper ||
                        type.aliasTypeArguments) {
                        if (!shouldTransform(updatedNode, type, checker, context)) {
                            return updatedNode;
                        }
                        const result = parseTypeArguments(updatedNode, type.resolvedTypeArguments ||
                            parseMapperTarget(type.mapper) ||
                            type.aliasTypeArguments, ts, checker);
                        if (result) {
                            result.newTypes.forEach((tp) => autoImport(ts, ls, checker, tp, sourceFile, autoImports));
                            if (debugGenerics.enabled) {
                                const originalNode = ts.getOriginalNode(updatedNode);
                                debugGenerics(originalNode.getText(), `${checker.typeToString(type)} at ${originalNode.getSourceFile().__relativeFileName}`);
                            }
                            return factory.updateTypeReferenceNode(updatedNode, updatedNode.typeName, result.newTypeArguments);
                        }
                    }
                }
                else if (ts.isExpressionWithTypeArguments(updatedNode)) {
                    const type = checker.getTypeFromTypeNode(updatedNode);
                    if (isReferenceType(type, ts) &&
                        type.resolvedTypeArguments?.length) {
                        if (!shouldTransform(updatedNode, type, checker, context)) {
                            return updatedNode;
                        }
                        const result = parseTypeArguments(updatedNode, type.resolvedTypeArguments, ts, checker);
                        if (result) {
                            result.newTypes.forEach((tp) => autoImport(ts, ls, checker, tp, sourceFile, autoImports));
                            if (debugGenerics.enabled) {
                                const originalNode = ts.getOriginalNode(updatedNode);
                                debugGenerics(originalNode.getText(), `${checker.typeToString(type)} at ${originalNode.getSourceFile().__relativeFileName}`);
                            }
                            return factory.updateExpressionWithTypeArguments(updatedNode, updatedNode.expression, result.newTypeArguments);
                        }
                    }
                }
                else if (ts.isNewExpression(updatedNode)) {
                    // new C<string>()
                    const type = checker.getTypeAtLocation(updatedNode);
                    const resolvedTypeArguments = type
                        .resolvedTypeArguments;
                    if (Array.isArray(resolvedTypeArguments) &&
                        resolvedTypeArguments.length) {
                        if (!shouldTransform(updatedNode, type, checker, context)) {
                            return updatedNode;
                        }
                        const result = parseTypeArguments(updatedNode, resolvedTypeArguments, ts, checker);
                        if (result) {
                            result.newTypes.forEach((tp) => autoImport(ts, ls, checker, tp, sourceFile, autoImports));
                            if (debugGenerics.enabled) {
                                const originalNode = ts.getOriginalNode(updatedNode);
                                debugGenerics(originalNode.getText(), `${checker.typeToString(type)} at ${originalNode.getSourceFile().__relativeFileName}`);
                            }
                            return factory.updateNewExpression(updatedNode, updatedNode.expression, result.newTypeArguments, updatedNode.arguments);
                        }
                    }
                }
                else if (ts.isCallExpression(updatedNode)) ;
                return updatedNode;
            };
            return (node) => {
                sourceFile = node;
                const updatedNode = ts.visitNode(node, visitor);
                if (autoImports.size === 0) {
                    return updatedNode;
                }
                return factory.updateSourceFile(updatedNode, [...autoImports.values(), ...updatedNode.statements], updatedNode.isDeclarationFile, updatedNode.referencedFiles, updatedNode.typeReferenceDirectives, updatedNode.hasNoDefaultLib, updatedNode.libReferenceDirectives);
            };
        },
    };
};
function parseTypeArguments(updatedNode, resolvedTypeArguments, ts, checker) {
    const len = updatedNode.typeArguments?.length ?? 0;
    if (resolvedTypeArguments.length === len) {
        return;
    }
    // 更新缺少的类型参数
    const typeArguments = updatedNode.typeArguments ?? [];
    const newTypes = resolvedTypeArguments.slice(typeArguments.length);
    const newTypeArguments = ts.factory.createNodeArray([
        ...typeArguments,
        ...newTypes.map((tp) => typeToTypeNode(tp, updatedNode, ts, checker)),
    ]);
    return {
        newTypeArguments,
        newTypes,
    };
}
function parseMapperTarget(mapper) {
    if (!mapper) {
        return;
    }
    if (mapper.kind === /* TypeMapKind.Simple */ 0) {
        return [mapper.target];
    }
    else if (mapper.kind === /* TypeMapKind.Array */ 1) {
        return mapper.targets;
    }
    else if (mapper.kind === /* TypeMapKind.Deferred */ 2) {
        return mapper.targets.map((fn) => fn());
    }
}

const debugIn = debug('uts:transformer:in');
/**
 * 将 in 类型操作符转换为 resolveInOperator 方法调用
 * @param ts
 * @returns
 */
const transformIn = (ts, ls, options) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                if (ts.isBinaryExpression(updatedNode)) {
                    if (updatedNode.operatorToken.kind === ts.SyntaxKind.InKeyword) {
                        if (debugIn.enabled) {
                            const originalNode = ts.getOriginalNode(updatedNode);
                            debugIn('transformIn', originalNode.getText(), `at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        const typeArguments = [];
                        if (options.targetLanguage === 'ArkTS') {
                            // 推断泛型类型
                            const leftType = checker.getTypeAtLocation(updatedNode.left);
                            if (leftType.isStringLiteral() || leftType.isNumberLiteral()) {
                                const rightType = checker.getNonNullableType(checker.getTypeAtLocation(updatedNode.right));
                                if (rightType.isUnion()) {
                                    const narrowedType = checker.narrowTypeByInKeyword(rightType, leftType, true);
                                    if (narrowedType !== rightType) {
                                        const narrowedTypeNode = typeToTypeNode(narrowedType, updatedNode, ts, checker);
                                        if (narrowedTypeNode) {
                                            typeArguments.push(narrowedTypeNode);
                                        }
                                    }
                                }
                            }
                        }
                        return factory.createCallExpression(factory.createIdentifier("resolveInOperator" /* IDENTIFIER.RESOLVE_IN_OPERATOR */), typeArguments, [updatedNode.right, updatedNode.left]);
                    }
                }
                return updatedNode;
            };
            return (sourceFile) => {
                return ts.visitNode(sourceFile, visitor);
            };
        },
    };
};

const debugKeyof = debug('uts:transformer:keyof');
/**
 * 将 keyof 类型操作符转换为联合类型
 * @param ts
 * @returns
 */
const transformKeyof = (ts, ls, options) => {
    const shouldTransform = options.transformKeyof?.shouldTransform ?? (() => true);
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                if (ts.isTypeOperatorNode(updatedNode) &&
                    updatedNode.operator === ts.SyntaxKind.KeyOfKeyword) {
                    const type = checker.getTypeAtLocation(updatedNode);
                    if (!shouldTransform(updatedNode, type, checker, context)) {
                        return updatedNode;
                    }
                    if (type.isUnion()) {
                        const types = type.types
                            .map((t) => {
                            if (t.isStringLiteral()) {
                                return t.value;
                            }
                            else if (t.isNumberLiteral()) {
                                return t.value;
                            }
                        })
                            .filter((name) => typeof name !== 'undefined');
                        if (debugKeyof.enabled) {
                            const originalNode = ts.getOriginalNode(updatedNode);
                            debugKeyof(originalNode.getText(), `${checker.typeToString(type)} at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        return factory.createUnionTypeNode(types.map((name) => factory.createLiteralTypeNode(typeof name === 'string'
                            ? factory.createStringLiteral(name)
                            : factory.createNumericLiteral(name))));
                    }
                    else if (type.isStringLiteral()) {
                        if (debugKeyof.enabled) {
                            const originalNode = ts.getOriginalNode(updatedNode);
                            debugKeyof(originalNode.getText(), `${checker.typeToString(type)} at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        return factory.createLiteralTypeNode(factory.createStringLiteral(type.value));
                    }
                    else if (type.isNumberLiteral()) {
                        if (debugKeyof.enabled) {
                            const originalNode = ts.getOriginalNode(updatedNode);
                            debugKeyof(originalNode.getText(), `${checker.typeToString(type)} at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        return factory.createLiteralTypeNode(factory.createNumericLiteral(type.value));
                    }
                }
                return updatedNode;
            };
            return (sourceFile) => {
                return ts.visitNode(sourceFile, visitor);
            };
        },
    };
};

function isUTSObjectTypeUnion(type, ts, checker) {
    const unionType = checker.getNonNullableType(type);
    if (!unionType.isUnion()) {
        return false;
    }
    if (unionType.types.length <= 1) {
        return false;
    }
    return unionType.types.every((t) => isUTSObjectType(t, ts));
}
function parseDiscriminatedUnion(type, ts, checker) {
    const unionType = checker.getNonNullableType(type);
    if (!unionType.isUnion()) {
        return;
    }
    if (unionType.types.length <= 1) {
        return;
    }
    // 检查所有联合类型成员必须是对象类型且有别名引用
    if (!unionType.types.every((t) => t.flags & ts.TypeFlags.Object && t.aliasSymbol !== undefined)) {
        return;
    }
    // 获取第一个成员的所有属性
    const firstType = unionType.types[0];
    const properties = checker.getPropertiesOfType(firstType);
    // 查找判别属性
    for (const prop of properties) {
        let isDiscriminant = true;
        let discriminantType;
        // 检查每个联合类型成员
        for (const t of unionType.types) {
            const p = checker.getPropertyOfType(t, prop.escapedName);
            if (!p) {
                isDiscriminant = false;
                break;
            }
            const propType = checker.getTypeOfSymbol(p);
            if (isDiscriminatedUnionStringLiteral(propType, ts)) {
                discriminantType = 'string';
            }
            else if (isDiscriminatedUnionNumberLiteral(propType, ts)) {
                discriminantType = 'number';
            }
            else {
                isDiscriminant = false;
                break;
            }
        }
        if (isDiscriminant && discriminantType) {
            return {
                name: prop.name,
                type: discriminantType,
            };
        }
    }
    return undefined;
}
function isDiscriminatedUnionStringLiteral(type, ts) {
    if (type.flags & ts.TypeFlags.StringLiteral) {
        return true;
    }
    if (type.isUnion()) {
        return type.types.every((t) => isDiscriminatedUnionStringLiteral(t, ts));
    }
    return false;
}
function isDiscriminatedUnionNumberLiteral(type, ts) {
    if (type.flags & ts.TypeFlags.NumberLiteral) {
        return true;
    }
    if (type.isUnion()) {
        return type.types.every((t) => isDiscriminatedUnionNumberLiteral(t, ts));
    }
    return false;
}

const debugDiscriminatedUnion = debug('uts:transformer:narrowType:discriminatedUnion');
const transformDiscriminatedUnion = (ts, ls, options) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                if (ts.isTypeAliasDeclaration(updatedNode) &&
                    ts.isUnionTypeNode(updatedNode.type)) {
                    if (updatedNode.type.types.every((t) => ts.isTypeReferenceNode(t))) {
                        const type = checker.getTypeAtLocation(updatedNode.type);
                        // 如果是联合类型，并且是可区分的联合类型，调整为 interface 类型
                        if (type.isUnion()) {
                            const discriminant = parseDiscriminatedUnion(type, ts, checker);
                            if (discriminant) {
                                if (debugDiscriminatedUnion.enabled) {
                                    const originalNode = ts.getOriginalNode(updatedNode);
                                    debugDiscriminatedUnion(`type ${originalNode.name.getText()} = ${"UTSUnionTypeObject" /* IDENTIFIER.UTSUnionTypeObject */}`, ` at ${originalNode.getSourceFile().__relativeFileName}`);
                                }
                                return factory.updateTypeAliasDeclaration(updatedNode, updatedNode.modifiers, updatedNode.name, updatedNode.typeParameters, factory.createTypeReferenceNode(factory.createIdentifier("UTSUnionTypeObject" /* IDENTIFIER.UTSUnionTypeObject */), undefined));
                            }
                        }
                    }
                }
                else if (ts.isPropertyAccessExpression(node) &&
                    ts.isIdentifier(node.expression)) {
                    const type = checker.getTypeAtLocation(node.name);
                    if (type.isUnion()) {
                        // 1. 判断该 type 类型是纯字符串联合或纯数字联合
                        // 2. 判断 parent 类型是否是可辨识联合类型
                        // 3. 严格判断该属性是否是可辨识联合类型中的可辨识属性
                        // 3. 如果1、2、3都成立，则将属性访问变成 resolveUTSObjectProperty
                        const nonNullableType = checker.getNonNullableType(type);
                        if (nonNullableType.isUnion()) {
                            if (nonNullableType.types.every((t) => {
                                return t.isStringLiteral() || t.isNumberLiteral();
                            })) {
                                const parentType = checker.getTypeAtLocation(node.expression);
                                if (parentType.isUnion()) {
                                    const discriminant = parseDiscriminatedUnion(parentType, ts, checker);
                                    if (discriminant && discriminant.name === node.name.text) {
                                        const args = [
                                            node.expression,
                                            factory.createStringLiteral(node.name.text),
                                        ];
                                        if (options.targetLanguage === 'Swift') {
                                            args.push(factory.createPropertyAccessExpression(factory.createIdentifier('String'), factory.createIdentifier('self')));
                                        }
                                        const typeArguments = options.targetLanguage === 'Swift'
                                            ? undefined
                                            : [
                                                factory.createKeywordTypeNode(discriminant.type === 'string'
                                                    ? ts.SyntaxKind.StringKeyword
                                                    : ts.SyntaxKind.NumberKeyword),
                                            ];
                                        return factory.createCallExpression(factory.createIdentifier("resolveUTSObjectProperty" /* IDENTIFIER.RESOLVE_UTS_OBJECT_PROPERTY */), typeArguments, args);
                                    }
                                }
                            }
                        }
                    }
                }
                return updatedNode;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

const debugNarrowNonNullableType = debug('uts:transformer:narrowType:nonNullable');
function isNarrowableNode(node, ts) {
    const parent = node.parent;
    if (!parent) {
        return false;
    }
    if (ts.isExpression(node)) {
        if (ts.isNonNullExpression(parent)) {
            return false;
        }
        if (ts.isAsExpression(parent)) {
            return false;
        }
        // 如果是 a instanceof B 无需收窄
        if (ts.isBinaryExpression(parent) &&
            parent.operatorToken.kind === ts.SyntaxKind.InstanceOfKeyword &&
            (parent.left === node || parent.right === node)) {
            return false;
        }
        // 如果是 typeof a 无需收窄
        if (ts.isTypeOfExpression(parent) && parent.expression === node) {
            return false;
        }
        // 如果是 a.b.c c 无需收窄，因为 a.b.c 时就已经收窄了，正常情况下不会等到 c 的时候
        // 一个特殊情况，是跳过了 a.b.c 的收窄，比如 typeof a.b.c === 'string'
        // 上一步会跳过 a.b.c 的收窄，此时会走到 c 的收窄，但 c 收窄会被转换为 c as string 这个是不符合语法定义的
        // 收窄的话相当于 a.b.(c as string)，明显不符合语法定义
        if (ts.isPropertyAccessExpression(parent) && parent.name === node) {
            return false;
        }
        // 如果是 a?.b?.c c 无需收窄
        if (ts.isPropertyAccessChain(parent) && parent.name === node) {
            return false;
        }
        // 快速的跳过一些不可能需要收窄的节点
        if (ts.isFunctionDeclaration(node) ||
            ts.isArrowFunction(node) ||
            ts.isFunctionExpression(node) ||
            ts.isClassDeclaration(node) ||
            ts.isInterfaceDeclaration(node) ||
            ts.isTypeAliasDeclaration(node) ||
            ts.isTypeLiteralNode(node) ||
            ts.isTypeOfExpression(node)) {
            return false;
        }
        if (ts.isTypeAliasDeclaration(parent) ||
            ts.isInterfaceDeclaration(parent) ||
            ts.isPropertySignature(parent) ||
            ts.isMethodSignature(parent) ||
            ts.isFunctionDeclaration(parent) ||
            // typeof a === 'string'
            // 此时不需要收窄 a
            ts.isTypeOfExpression(parent)) {
            return false;
        }
        // function test(a:number)
        // 跳过参数名
        if (ts.isParameter(parent) && parent.name === node) {
            return false;
        }
        // const a:number = 1
        // 跳过变量名
        if (ts.isVariableDeclaration(parent) && parent.name === node) {
            return false;
        }
        // const a = { b: 1 }
        // 跳过属性名
        if (ts.isPropertyAssignment(parent) && parent.name === node) {
            return false;
        }
        // this.a = true
        // 跳过赋值语句左侧
        if (ts.isBinaryExpression(parent) &&
            parent.left === node &&
            parent.operatorToken.kind === ts.SyntaxKind.EqualsToken) {
            return false;
        }
        if (!(
        // 1. 基础引用
        (ts.isIdentifier(node) || // foo
            ts.isPropertyAccessExpression(node) || // foo.bar
            ts.isElementAccessExpression(node) || // foo['bar']
            // 2. 特殊语法
            ts.isNonNullExpression(node) || // foo!
            ts.isParenthesizedExpression(node) || // (foo)
            ts.isPropertyAccessChain(node) || // foo?.bar
            ts.isElementAccessChain(node) || // foo?.[bar]
            // 3. 函数调用
            // foo()
            ts.isCallExpression(node)))) {
            return false;
        }
        return isNarrowableReference(node, ts);
    }
    return false;
}
function isNarrowableReference(expr, ts) {
    return (isDottedName(expr, ts) ||
        ((ts.isPropertyAccessExpression(expr) ||
            ts.isNonNullExpression(expr) ||
            ts.isParenthesizedExpression(expr)) &&
            isNarrowableReference(expr.expression, ts)) ||
        (ts.isBinaryExpression(expr) &&
            expr.operatorToken.kind === ts.SyntaxKind.CommaToken &&
            isNarrowableReference(expr.right, ts)) ||
        (ts.isElementAccessExpression(expr) &&
            (ts.isStringLiteral(expr.argumentExpression) ||
                ts.isNumericLiteral(expr.argumentExpression)) &&
            isNarrowableReference(expr.expression, ts)) ||
        (isAssignmentExpression(expr, ts) && isNarrowableReference(expr.left, ts)));
}
function isDottedName(node, ts) {
    return (node.kind === ts.SyntaxKind.Identifier ||
        node.kind === ts.SyntaxKind.ThisKeyword ||
        node.kind === ts.SyntaxKind.SuperKeyword ||
        node.kind === ts.SyntaxKind.MetaProperty ||
        (node.kind === ts.SyntaxKind.PropertyAccessExpression &&
            isDottedName(node.expression, ts)) ||
        (node.kind === ts.SyntaxKind.ParenthesizedExpression &&
            isDottedName(node.expression, ts)));
}
function isAssignmentExpression(node, ts) {
    return (ts.isBinaryExpression(node) &&
        isAssignmentOperator(node.operatorToken.kind, ts) &&
        ts.isLeftHandSideExpression(node.left));
}
function isAssignmentOperator(token, ts) {
    return (token >= ts.SyntaxKind.FirstAssignment &&
        token <= ts.SyntaxKind.LastAssignment);
}
function parseNarrowedType(node, shouldTransformNonNullable, ts, checker) {
    let symbol = checker.getSymbolAtLocation(node);
    // Date!.toDateString()
    if (!symbol && ts.isNonNullExpression(node)) {
        symbol = checker.getSymbolAtLocation(node.expression);
    }
    if (symbol) {
        const declaredType = checker.getTypeOfSymbol(symbol);
        const currentType = checker.getTypeAtLocation(node);
        if (currentType === declaredType) {
            return;
        }
        const nonNullableDeclaredType = checker.getNonNullableType(declaredType);
        const nonNullableCurrentType = checker.getNonNullableType(currentType);
        const anyType = checker.getAnyType();
        // 如果简单的判断不收窄any，会导致 any | null 类型，不能收窄变成 any 类型，但是如果不判断，会导致很多UTSJSONObject类型访问属性后，全被 as any了
        if (anyType === nonNullableCurrentType) {
            return;
        }
        const shouldNarrowNonNullable = 
        // 类型相等，且声明的是可为空类型、当前类型是不可为空的非联合类型
        // 如果判断联合类型，会导致字符串联合，boolean等类型识别有问题
        // !nonNullableCurrentType.isUnion() &&
        nonNullableDeclaredType === nonNullableCurrentType &&
            nonNullableDeclaredType !== declaredType &&
            nonNullableCurrentType === currentType &&
            // 需要收窄
            shouldTransformNonNullable(node, checker);
        // 为了减少影响范围，目前仅对非空收窄做上下文判断
        if (ts.isExpression(node)) {
            const contextualType = checker.getContextualType(node);
            if (contextualType) {
                // 如果上下文类型是 unknown 类型，则不收窄
                if (contextualType.flags === ts.TypeFlags.Unknown) {
                    return;
                }
                const nonNullableContextualType = checker.getNonNullableType(contextualType);
                // 如果上下文类型是 any 或 unknown 类型，则不收窄
                if (anyType === nonNullableContextualType) {
                    return;
                }
                if (shouldNarrowNonNullable) {
                    // 如果上下文也是可为空类型，且上下文类型和声明类型相等，则不收窄
                    if (nonNullableContextualType === nonNullableDeclaredType &&
                        nonNullableContextualType !== contextualType) {
                        return;
                    }
                }
            }
        }
        if (shouldNarrowNonNullable ||
            (nonNullableDeclaredType !== nonNullableCurrentType &&
                isNarrowableType(declaredType, ts, checker))) {
            // 如果当前类型收窄后变成字面量类型了，则不需要收窄
            // 比如
            // const c: boolean = true;
            // if(typeof c === 'boolean' && c == true ){ console.log(c) }
            // 此时 c 其实被收窄成了 true，但不需要 as boolean
            if (nonNullableCurrentType.isLiteral() &&
                checker.getApparentType(nonNullableCurrentType) ===
                    checker.getApparentType(nonNullableDeclaredType)) {
                return;
            }
            if (shouldNarrowNonNullable && debugNarrowNonNullableType.enabled) {
                const originalNode = ts.getOriginalNode(node);
                debugNarrowNonNullableType(originalNode.getText(), `as ${checker.typeToString(nonNullableCurrentType)} at ${originalNode.getSourceFile().__relativeFileName}`);
            }
            return {
                narrowedType: nonNullableCurrentType,
                isNarrowNonNullable: shouldNarrowNonNullable,
            };
        }
    }
}
function parseNarrowedTypeNode(node, type, ts, checker) {
    const typeNode = createTypeNode(ts, checker, type);
    if (typeNode) {
        return typeNode;
    }
    if (isValidType(ts, checker, type)) {
        return typeToTypeNode(type, node, ts, checker);
    }
}
function isNarrowableType(type, ts, checker) {
    if (isErrorType(type, ts, checker)) {
        return false;
    }
    type = checker.getNonNullableType(type);
    // any 类型可以收窄
    if (type === checker.getAnyType()) {
        return true;
    }
    // 非空的联合类型可以收窄
    if (type.isUnion() && isComplexUnionType(type, ts)) {
        return true;
    }
    return false;
}
function isComplexUnionType(type, ts) {
    const types = type.types.filter((t) => {
        if (isNullableType(ts, t)) {
            return false;
        }
        if (t.symbol && t.symbol.escapedName === "UTSObjectMarker" /* IDENTIFIER.UTS_OBJECT_MARKER */) {
            return false;
        }
        return true;
    });
    const len = types.length;
    if (len <= 1) {
        return false;
    }
    const firstType = types[0];
    if (firstType.isLiteral() ||
        // boolean 类型 true | false
        firstType.flags === ts.TypeFlags.BooleanLiteral) {
        const typeFlag = firstType.flags;
        for (let i = 1; i < len; i++) {
            if (types[i].flags !== typeFlag) {
                return true;
            }
        }
        // 全部相同的字面量类型不需要收窄
        return false;
    }
    return true;
}

const debugNarrowType = debug('uts:transformer:narrowType');
const transformNarrowType = (ts, ls, options) => {
    const shouldTransformNonNullable = options.transformNarrowType?.shouldTransformNonNullable ?? (() => false);
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const autoImports = new Map();
            let sourceFile;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                if (isNarrowableNode(node, ts)) {
                    const result = parseNarrowedType(node, shouldTransformNonNullable, ts, checker);
                    if (result) {
                        const { narrowedType, isNarrowNonNullable } = result;
                        if (isNarrowNonNullable && options.targetLanguage === 'Swift') {
                            // 为了兼容旧代码，之前的代码可能会导致类型推断可为空，新版本如果收窄非空，可能导致之前开发者的解包代码报错，所以需要二次校验一下是否有解包代码
                            if (!shouldNarrowNonNullableInSwift(node, context, ts, checker)) {
                                return updatedNode;
                            }
                        }
                        if (isNarrowNonNullable &&
                            ts.isExpression(updatedNode) &&
                            options.targetLanguage !== 'Swift') {
                            // 在 swift 中，如果类型不可为空，是不能强制解包的，所以用下边的as语句更合适一点。
                            return factory.createNonNullExpression(updatedNode);
                        }
                        // TODO: 如果类型推断可为空，as为具体类型，但swift中，as 会返回一个临时的不可变值，导致后续不能修改
                        // 比如 (children as string[]).push('1') 会报错 Cannot use mutating member on immutable value of type '[String]'
                        const typeNode = parseNarrowedTypeNode(node, narrowedType, ts, checker);
                        if (typeNode) {
                            autoImport(ts, ls, checker, narrowedType, sourceFile, autoImports);
                            if (debugNarrowType.enabled) {
                                const originalNode = ts.getOriginalNode(node);
                                debugNarrowType(originalNode.getText(), `as ${checker.typeToString(narrowedType)} at ${originalNode.getSourceFile().__relativeFileName}`);
                            }
                            return factory.createAsExpression(updatedNode, typeNode);
                        }
                    }
                }
                return updatedNode;
            };
            return (node) => {
                sourceFile = node;
                const updatedNode = ts.visitNode(node, visitor);
                if (autoImports.size === 0) {
                    return updatedNode;
                }
                return factory.updateSourceFile(updatedNode, [...autoImports.values(), ...updatedNode.statements], updatedNode.isDeclarationFile, updatedNode.referencedFiles, updatedNode.typeReferenceDirectives, updatedNode.hasNoDefaultLib, updatedNode.libReferenceDirectives);
            };
        },
    };
};
function shouldNarrowNonNullableInSwift(node, context, ts, checker) {
    // 目前仅检查赋值新变量引发的类型解包兼容问题
    // const a = b != null ? b : null
    // test(a!) // 开发者主动解包了，不能把上边的b强转非空了
    let parent = node.parent;
    // 第一步：检查是否在三元表达式中
    if (parent && ts.isConditionalExpression(parent)) {
        // 第二步：检查是否在变量声明中
        parent = parent.parent;
        let symbol;
        let parentStatement;
        while (parent) {
            if (ts.isVariableDeclaration(parent) && ts.isIdentifier(parent.name)) {
                // 第三步：获取 symbol
                symbol = checker.getSymbolAtLocation(parent.name);
                if (symbol) {
                    // 第四步：获取父级语句
                    parent = parent.parent;
                    while (parent) {
                        if (ts.isVariableStatement(parent)) {
                            parentStatement = parent.parent;
                            break;
                        }
                        parent = parent.parent;
                    }
                }
                break;
            }
            parent = parent.parent;
        }
        if (symbol && parentStatement) {
            // 遍历 parentStatement 的后续节点，检查是否有解包
            let foundNonNullExpression = false;
            const visitor = (node) => {
                if (!foundNonNullExpression &&
                    ts.isNonNullExpression(node) &&
                    ts.isIdentifier(node.expression)) {
                    if (checker.getSymbolAtLocation(node.expression) === symbol) {
                        foundNonNullExpression = true;
                        return node;
                    }
                }
                return ts.visitEachChild(node, visitor, context);
            };
            ts.visitEachChild(parentStatement, visitor, context);
            // 如果找到了非空表达式，则返回 false
            if (foundNonNullExpression) {
                return false;
            }
        }
    }
    return true;
}

const debugParameterUnionType = debug('uts:transformer:narrowType:parameterUnionType');
/**
 * 识别函数声明、类方法中的参数类型是否是合成的联合类型，如果是，则调整参数类型
 * @param ts
 * @param ls
 * @returns
 */
const transformParameterUnionType = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                if (ts.isFunctionDeclaration(node)) {
                    const params = parseWithType('modifier', node.parameters, ts, checker);
                    if (params) {
                        if (debugParameterUnionType.enabled) {
                            const originalNode = ts.getOriginalNode(node);
                            debugParameterUnionType(`function ${originalNode.name?.getText()}()`, `at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        return factory.updateFunctionDeclaration(node, node.modifiers, node.asteriskToken, node.name, node.typeParameters, params, node.type, node.body);
                    }
                }
                else if (ts.isMethodDeclaration(node)) {
                    const params = parseWithType('modifier', node.parameters, ts, checker);
                    if (params) {
                        if (debugParameterUnionType.enabled) {
                            const originalNode = ts.getOriginalNode(node);
                            debugParameterUnionType(`method ${originalNode.name?.getText()}()`, `at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        return factory.updateMethodDeclaration(node, node.modifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, params, node.type, node.body);
                    }
                }
                else if (ts.isConstructorDeclaration(node)) {
                    const params = parseWithType('modifier', node.parameters, ts, checker);
                    if (params) {
                        if (debugParameterUnionType.enabled) {
                            const originalNode = ts.getOriginalNode(node);
                            debugParameterUnionType(`constructor ${originalNode.name?.getText()}()`, `at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        return factory.updateConstructorDeclaration(node, node.modifiers, params, node.body);
                    }
                }
                else if (ts.isMethodSignature(node)) {
                    const params = parseWithType('type', node.parameters, ts, checker);
                    if (params) {
                        if (debugParameterUnionType.enabled) {
                            const originalNode = ts.getOriginalNode(node);
                            debugParameterUnionType(`method signature ${originalNode.name?.getText()}()`, `at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        return factory.updateMethodSignature(node, node.modifiers, node.name, node.questionToken, node.typeParameters, params, node.type);
                    }
                }
                else if (ts.isFunctionTypeNode(node)) {
                    const params = parseWithType('type', node.parameters, ts, checker);
                    if (params) {
                        if (debugParameterUnionType.enabled) {
                            const originalNode = ts.getOriginalNode(node);
                            debugParameterUnionType(`function type ${originalNode.name?.getText()}()`, `at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        return factory.updateFunctionTypeNode(node, node.typeParameters, params, node.type);
                    }
                }
                else if (ts.isArrowFunction(node)) {
                    const params = parseWithType('type', node.parameters, ts, checker);
                    if (params) {
                        if (debugParameterUnionType.enabled) {
                            const originalNode = ts.getOriginalNode(node);
                            debugParameterUnionType(`arrow function ${originalNode.name?.getText()}()`, `at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        return factory.updateArrowFunction(node, node.modifiers, node.typeParameters, params, node.type, node.equalsGreaterThanToken, node.body);
                    }
                }
                else if (ts.isFunctionExpression(node)) {
                    const params = parseWithType('type', node.parameters, ts, checker);
                    if (params) {
                        if (debugParameterUnionType.enabled) {
                            const originalNode = ts.getOriginalNode(node);
                            debugParameterUnionType(`function expression ${originalNode.name?.getText()}()`, `at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        return factory.updateFunctionExpression(node, node.modifiers, node.asteriskToken, node.name, node.typeParameters, params, node.type, node.body);
                    }
                }
                return updatedNode;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};
function createUnionTypeNode(types, ts, checker, node) {
    const typeNodes = [];
    for (const type of types) {
        const typeNode = typeToTypeNode(type, node, ts, checker);
        if (typeNode) {
            // 如果类型是字面量类型，则不需要
            if (ts.isTypeLiteralNode(typeNode)) {
                return;
            }
            typeNodes.push(typeNode);
        }
        else {
            return;
        }
    }
    return ts.factory.createUnionTypeNode(typeNodes);
}
function parseWithType(
// 添加类型的方式，可以是修饰符，也可以是类型
addType, params, ts, checker) {
    const { factory } = ts;
    const typeNodes = new Map();
    params.forEach((param, index) => {
        if (param.type) {
            const type = checker.getTypeAtLocation(param.type);
            if (type.isUnion() && isComplexUnionType(type, ts)) {
                // 检查是否存在类型引用
                let hasTypeReference = false;
                const checkTypeReference = (node) => {
                    if (ts.isTypeReferenceNode(node)) {
                        hasTypeReference = true;
                    }
                    else {
                        ts.forEachChild(node, checkTypeReference);
                    }
                };
                checkTypeReference(param.type);
                if (hasTypeReference) {
                    // 如果联合类型是可判别联合类型，则不需要处理
                    if (parseDiscriminatedUnion(type, ts, checker)) {
                        if (addType === 'modifier') {
                            typeNodes.set(index, {
                                addModifier: true,
                            });
                        }
                        else {
                            const utsUnionTypeObject = factory.createTypeReferenceNode("UTSUnionTypeObject" /* IDENTIFIER.UTSUnionTypeObject */, 
                            /*typeArguments*/ []);
                            typeNodes.set(index, {
                                addModifier: false,
                                type: hasNullableType(type, checker)
                                    ? createNullableTypeNode(utsUnionTypeObject, ts)
                                    : utsUnionTypeObject,
                            });
                        }
                        return;
                    }
                    const typeNode = createUnionTypeNode(type.types, ts, checker, param);
                    if (typeNode) {
                        if (addType === 'modifier') {
                            // 如果是普通的 type 联合类型，则需要增补装饰器标记是 UTSUnionTypeObject 类型
                            typeNodes.set(index, {
                                type: typeNode,
                                addModifier: isUTSObjectTypeUnion(type, ts, checker),
                            });
                        }
                        else {
                            if (isUTSObjectTypeUnion(type, ts, checker)) {
                                const utsUnionTypeObject = factory.createTypeReferenceNode("UTSUnionTypeObject" /* IDENTIFIER.UTSUnionTypeObject */, 
                                /*typeArguments*/ []);
                                typeNodes.set(index, {
                                    addModifier: false,
                                    type: hasNullableType(type, checker)
                                        ? createNullableTypeNode(utsUnionTypeObject, ts)
                                        : utsUnionTypeObject,
                                });
                            }
                        }
                    }
                }
            }
        }
    });
    if (typeNodes.size > 0) {
        const newParams = [];
        params.forEach((param, index) => {
            if (typeNodes.has(index)) {
                const { type, addModifier } = typeNodes.get(index);
                const modifiers = [];
                if (addModifier) {
                    modifiers.push(factory.createDecorator(factory.createIdentifier("UTSUnionTypeObject" /* IDENTIFIER.UTSUnionTypeObject */)));
                }
                newParams.push(factory.updateParameterDeclaration(param, modifiers.length > 0
                    ? [...(param.modifiers ?? []), ...modifiers]
                    : param.modifiers, param.dotDotDotToken, param.name, param.questionToken, type ?? param.type, param.initializer));
            }
            else {
                newParams.push(param);
            }
        });
        return factory.createNodeArray(newParams);
    }
}

const debugUTSObjectUnionType = debug('uts:transformer:UTSObjectUnionType');
const transformUTSObjectUnionType = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                if (ts.isUnionTypeNode(updatedNode)) {
                    // 函数参数的联合类型不处理
                    if (updatedNode.parent && ts.isParameter(updatedNode.parent)) {
                        return updatedNode;
                    }
                    const type = checker.getTypeAtLocation(updatedNode);
                    if (type.isUnion() && isUTSObjectTypeUnion(type, ts, checker)) {
                        const hasNullish = updatedNode.types.some((t) => ts.isLiteralTypeNode(t) &&
                            t.literal.kind === ts.SyntaxKind.NullKeyword);
                        if (debugUTSObjectUnionType.enabled) {
                            const originalNode = ts.getOriginalNode(updatedNode);
                            debugUTSObjectUnionType(originalNode.getText(), `at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        if (hasNullish) {
                            return factory.createUnionTypeNode([
                                factory.createTypeReferenceNode("UTSUnionTypeObject" /* IDENTIFIER.UTSUnionTypeObject */),
                                factory.createLiteralTypeNode(factory.createNull()),
                            ]);
                        }
                        return factory.createTypeReferenceNode("UTSUnionTypeObject" /* IDENTIFIER.UTSUnionTypeObject */);
                    }
                }
                return updatedNode;
            };
            return (sourceFile) => {
                return ts.visitNode(sourceFile, visitor);
            };
        },
    };
};

/**
 * 在 parse 阶段将 null 的相等运算符转换为 == 或 !=
 * 主要是为了兼容类型系统，确保 null 和 undefined 的比较
 * @param ts
 * @returns
 */
const transformNullEquals = (ts) => {
    return {
        parser: {
            SourceFile(_) {
                const visitor = (node) => {
                    node.forEachChild(visitor);
                    const parent = node.parent;
                    if (parent) {
                        if (ts.isBinaryExpression(node)) {
                            if (node.left.kind === ts.SyntaxKind.NullKeyword ||
                                node.right.kind === ts.SyntaxKind.NullKeyword) {
                                if (node.operatorToken.kind ===
                                    ts.SyntaxKind.EqualsEqualsEqualsToken) {
                                    // a === null => a == null
                                    // null === a => null == a
                                    // @ts-expect-error
                                    node.operatorToken.kind = ts.SyntaxKind.EqualsEqualsToken;
                                }
                                else if (node.operatorToken.kind ===
                                    ts.SyntaxKind.ExclamationEqualsEqualsToken) {
                                    // a !== null => a != null
                                    // null !== a => null != a
                                    // @ts-expect-error
                                    node.operatorToken.kind = ts.SyntaxKind.ExclamationEqualsToken;
                                }
                            }
                        }
                    }
                };
                return (node) => {
                    node.forEachChild(visitor);
                    return node;
                };
            },
        },
    };
};

function isObjectChild(ts, node) {
    return (ts.isObjectLiteralExpression(node) ||
        ts.isArrayLiteralExpression(node) ||
        ts.isAsExpression(node) ||
        ts.isPropertyAssignment(node));
}
function findObjectAncestor(ts, node) {
    let current = node;
    let parent;
    while (
    // @ts-expect-error use private property
    (parent = current.parent || current.original?.parent) &&
        isObjectChild(ts, parent)) {
        current = parent;
    }
    return ts.isPropertyAssignment(current)
        ? undefined
        : current;
}
function isApparentUTSJSONObjectType(type) {
    return (type.symbol?.name === "UTSJSONObject" /* IDENTIFIER.UTSJSONObject */ ||
        (type.isUnionOrIntersection() &&
            type.types.some((t) => isApparentUTSJSONObjectType(t))));
}
const debugObjectLiteral = debug('uts:transformer:objectLiteral');
const transformObjectLiteral = (ts, ls, options) => {
    const shouldTransformAsExpression = options?.transformObjectLiteral?.shouldTransformAsExpression ?? (() => true);
    const isArkTS = options.targetLanguage === 'ArkTS';
    const isPureSwift = options.isPureSwift ?? false;
    return {
        parser: {
            SourceFile(context) {
                const { factory } = context;
                let sourceFile;
                function createAs(node) {
                    if (debugObjectLiteral.enabled) {
                        const { line, character } = ts.getLineAndCharacterOfPosition(sourceFile, node.getEnd());
                        debugObjectLiteral('createAs:', `at ${sourceFile.fileName}:${line + 1}:${character}`);
                    }
                    return factory.createAsExpression(node, factory.createTypeReferenceNode(factory.createIdentifier("UTSJSONObject" /* IDENTIFIER.UTSJSONObject */), undefined));
                }
                function createAsArray(node) {
                    if (debugObjectLiteral.enabled) {
                        const { line, character } = ts.getLineAndCharacterOfPosition(sourceFile, node.getEnd());
                        debugObjectLiteral('createAsArray:', `at ${sourceFile.fileName}:${line + 1}:${character}`);
                    }
                    return factory.createAsExpression(node, factory.createArrayTypeNode(factory.createTypeReferenceNode(factory.createIdentifier("UTSJSONObject" /* IDENTIFIER.UTSJSONObject */), undefined)));
                }
                const visitor = (node) => {
                    node.forEachChild(visitor);
                    const parent = node.parent;
                    if (parent) {
                        if (ts.isObjectLiteralExpression(node)) {
                            if (ts.isExportAssignment(parent)) {
                                // export default {} => export default  {} as UTSJSONObject
                                // @ts-expect-error
                                parent.expression = createAs(node);
                            }
                            else if (ts.isVariableDeclaration(parent) && !parent.type) {
                                // const a = {} => const a = {} as UTSJSONObject
                                // @ts-expect-error
                                parent.initializer = createAs(node);
                            }
                            else if (ts.isPropertyDeclaration(parent) && !parent.type) {
                                // class A { a = {} } => class A { a = {} as UTSJSONObject }
                                // @ts-expect-error
                                parent.initializer = createAs(node);
                            }
                            else if (isPropertyAccessExpression(ts, parent)) {
                                // {}.toMap() => ({} as UTSJSONObject).toMap()
                                // @ts-expect-error
                                parent.expression = ts.isParenthesizedExpression(parent)
                                    ? createAs(node)
                                    : factory.createParenthesizedExpression(createAs(node));
                            }
                        }
                        else if (ts.isArrayLiteralExpression(node)) {
                            // 遍历 elements 是否都是对象字面量
                            const isPureObjectLiteralArray = node.elements.length &&
                                node.elements.every((element) => ts.isObjectLiteralExpression(element));
                            if (isPureObjectLiteralArray) {
                                if (ts.isExportAssignment(parent)) {
                                    // export default [{}, {}] => export default [{}, {}] as UTSJSONObject[]
                                    // @ts-expect-error
                                    parent.expression = createAsArray(node);
                                }
                                else if (ts.isVariableDeclaration(parent) && !parent.type) {
                                    // const a = [{}, {}] => const a = [{}, {}] as UTSJSONObject[]
                                    // @ts-expect-error
                                    parent.initializer = createAsArray(node);
                                }
                                else if (ts.isPropertyDeclaration(parent) && !parent.type) {
                                    // class A { a = [{}, {}] } => class A { a = [{}, {}] as UTSJSONObject[] }
                                    // @ts-expect-error
                                    parent.initializer = createAsArray(node);
                                }
                                else if (isPropertyAccessExpression(ts, parent)) {
                                    // [{}, {}].forEach((item) => item.toMap()) => ([{}, {}] as UTSJSONObject[]).forEach((item) => item.toMap())
                                    // @ts-expect-error
                                    parent.expression = ts.isParenthesizedExpression(parent)
                                        ? createAsArray(node)
                                        : factory.createParenthesizedExpression(createAsArray(node));
                                }
                            }
                        }
                    }
                };
                return (node) => {
                    sourceFile = node;
                    node.forEachChild(visitor);
                    return node;
                };
            },
        },
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const autoImports = new Map();
            let sourceFile;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                if (ts.isObjectLiteralExpression(updatedNode)) {
                    const parent = ts.getOriginalNode(updatedNode).parent;
                    let isParentDeclWithType = false;
                    if (parent) {
                        // const a = {} as A
                        if (ts.isAsExpression(parent)) {
                            return prepareObjectLiteral(updatedNode);
                        }
                        // const a: A = {}
                        if (ts.isVariableDeclaration(parent) && parent.type) {
                            isParentDeclWithType = true;
                            if (!isArkTS) {
                                return prepareObjectLiteral(updatedNode);
                            }
                        }
                    }
                    if (!shouldTransformAsExpression(updatedNode)) {
                        return updatedNode;
                    }
                    function prepareObjectLiteral(node) {
                        if (!isPureSwift) {
                            return node;
                        }
                        const contextualType = checker.getContextualType(node);
                        if (!contextualType) {
                            return node;
                        }
                        return completeObjectLiteral(node, contextualType);
                    }
                    function completeObjectLiteral(node, type) {
                        const symbol = type.aliasSymbol || type.symbol;
                        if (!symbol) {
                            return node;
                        }
                        if ((symbol.flags & ts.SymbolFlags.TypeAlias) === 0) {
                            return node;
                        }
                        const members = symbol.members;
                        if (!members || members.size === 0) {
                            return node;
                        }
                        const propertyAssignments = [];
                        let propertyChanged = false;
                        members.forEach((memberSymbol, memberName) => {
                            const declaredMember = node.properties.find((p) => {
                                return (ts.isPropertyAssignment(p) &&
                                    ts.isIdentifier(p.name) &&
                                    p.name.text === memberName);
                            });
                            if (declaredMember) {
                                propertyAssignments.push(declaredMember);
                            }
                            else {
                                propertyChanged = true;
                                propertyAssignments.push(factory.createPropertyAssignment(factory.createIdentifier(memberName.toString()), factory.createNull()));
                            }
                        });
                        if (!propertyChanged) {
                            return node;
                        }
                        return factory.updateObjectLiteralExpression(node, propertyAssignments);
                    }
                    const expressionType = resolveExpressionType(checker, updatedNode);
                    const type = resolveAnonymousLiteralType(ts, checker, expressionType, checker.getTypeAtLocation(updatedNode));
                    if (type && !isParentDeclWithType) {
                        if (!shouldTransformAsExpression(updatedNode, type)) {
                            return updatedNode;
                        }
                        return factory.createAsExpression(isPureSwift
                            ? completeObjectLiteral(updatedNode, type)
                            : updatedNode, autoImport(ts, ls, checker, type, sourceFile, autoImports) ||
                            factory.createTypeReferenceNode(type.aliasSymbol.name));
                    }
                    else if (isArkTS) {
                        // 缩小转化为UTSJSONObject的范围
                        const objectAncestor = findObjectAncestor(ts, updatedNode);
                        let shouldAsUTSJSONObject = false;
                        if (isApparentUTSJSONObjectType(expressionType)) {
                            shouldAsUTSJSONObject = true;
                        }
                        else if (objectAncestor) {
                            let realObjectAncestor = objectAncestor;
                            if (ts.isAsExpression(realObjectAncestor)) {
                                realObjectAncestor = realObjectAncestor.expression;
                            }
                            const objectAncestorType = resolveExpressionType(checker, realObjectAncestor);
                            shouldAsUTSJSONObject =
                                // @ts-expect-error 内部属性
                                objectAncestorType.intrinsicName !== 'error' &&
                                    // @ts-expect-error 内部属性
                                    expressionType.intrinsicName !== 'error' &&
                                    checker.isTypeAssignableTo(expressionType, checker.getUTSJSONObjectType());
                        }
                        if (shouldAsUTSJSONObject) {
                            return factory.createAsExpression(updatedNode, factory.createTypeReferenceNode(factory.createIdentifier("UTSJSONObject" /* IDENTIFIER.UTSJSONObject */), undefined));
                        }
                    }
                }
                return updatedNode;
            };
            return (node) => {
                sourceFile = node;
                const updatedNode = ts.visitNode(node, visitor);
                if (autoImports.size === 0) {
                    return updatedNode;
                }
                return factory.updateSourceFile(updatedNode, [...autoImports.values(), ...updatedNode.statements], updatedNode.isDeclarationFile, updatedNode.referencedFiles, updatedNode.typeReferenceDirectives, updatedNode.hasNoDefaultLib, updatedNode.libReferenceDirectives);
            };
        },
    };
};
function isPropertyAccessExpression(ts, node) {
    if (ts.isParenthesizedExpression(node) && node.parent) {
        return isPropertyAccessExpression(ts, node.parent);
    }
    return ts.isPropertyAccessExpression(node);
}

const debugReturnType = debug('uts:transformer:returnType');
const transformReturnType = (ts, ls, options) => {
    const shouldTransform = options?.transformReturnType?.shouldTransform ?? (() => true);
    const supportUnionType = options.targetLanguage === 'ArkTS' ||
        options.targetLanguage === 'JavaScript';
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const autoImports = new Map();
            let sourceFile;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                if (ts.isFunctionDeclaration(updatedNode)) {
                    if (!updatedNode.type) {
                        const signature = checker.getSignatureFromDeclaration(updatedNode);
                        if (signature) {
                            const returnType = checker.getReturnTypeOfSignature(signature);
                            const returnTypeNode = parseReturnType(supportUnionType, ts, checker, returnType, false, updatedNode);
                            if (returnTypeNode) {
                                if (debugReturnType.enabled) {
                                    const originalNode = ts.getOriginalNode(updatedNode);
                                    debugReturnType(`function:`, `${originalNode.name?.getText()}():${displayTypeNode(ts, checker, returnTypeNode, returnType)} at ${sourceFile.__relativeFileName}`);
                                }
                                autoImport(ts, ls, checker, returnType, sourceFile, autoImports);
                                return factory.updateFunctionDeclaration(updatedNode, updatedNode.modifiers, updatedNode.asteriskToken, updatedNode.name, updatedNode.typeParameters, updatedNode.parameters, returnTypeNode, updatedNode.body);
                            }
                        }
                    }
                }
                else if (ts.isMethodDeclaration(updatedNode)) {
                    if (!updatedNode.type) {
                        // 如果节点声明的（非上下文推导）返回值类型是void，不处理
                        const nodeSignature = checker
                            .getTypeAtLocation(updatedNode)
                            .getCallSignatures()[0];
                        if (nodeSignature &&
                            nodeSignature.getReturnType().flags & ts.TypeFlags.Void) {
                            return updatedNode;
                        }
                        const type = resolveMethodDeclarationContextualType(ts, checker, updatedNode);
                        if (type &&
                            !shouldTransform(ts.getOriginalNode(updatedNode), type, checker)) {
                            return updatedNode;
                        }
                        const signatures = resolveNonNullableType(checker, type)?.getCallSignatures();
                        const signature = signatures && signatures.length
                            ? signatures[0]
                            : checker.getSignatureFromDeclaration(updatedNode);
                        if (signature) {
                            const returnType = checker.getReturnTypeOfSignature(signature);
                            const returnTypeNode = parseReturnType(supportUnionType, ts, checker, returnType, !!(signatures && signatures.length), updatedNode);
                            if (returnTypeNode) {
                                if (debugReturnType.enabled) {
                                    const originalNode = ts.getOriginalNode(updatedNode);
                                    debugReturnType(`method:`, `${originalNode.name?.getText()}():${displayTypeNode(ts, checker, returnTypeNode, returnType)} at ${sourceFile.__relativeFileName}`);
                                }
                                autoImport(ts, ls, checker, returnType, sourceFile, autoImports);
                                return factory.updateMethodDeclaration(updatedNode, updatedNode.modifiers, updatedNode.asteriskToken, updatedNode.name, updatedNode.questionToken, updatedNode.typeParameters, updatedNode.parameters, returnTypeNode, updatedNode.body);
                            }
                        }
                    }
                }
                else if (ts.isArrowFunction(updatedNode)) {
                    if (!updatedNode.type) {
                        const type = checker.getTypeAtLocation(updatedNode);
                        // 如果节点声明的（非上下文推导）返回值类型是void，不处理
                        const nodeSignature = type.getCallSignatures()[0];
                        if (nodeSignature &&
                            nodeSignature.getReturnType().flags & ts.TypeFlags.Void) {
                            return updatedNode;
                        }
                        const contextualType = resolveUpdatedNodeContextualType(ts, checker, updatedNode);
                        if (contextualType &&
                            !shouldTransform(ts.getOriginalNode(updatedNode), contextualType, checker)) {
                            return updatedNode;
                        }
                        let actualType = type;
                        if (contextualType) {
                            const nonNullableContextualType = checker.getNonNullableType(contextualType);
                            if (nonNullableContextualType.getCallSignatures().length &&
                                !nonNullableContextualType.isUnion()) {
                                actualType = contextualType;
                            }
                        }
                        const signatures = resolveNonNullableType(checker, actualType)?.getCallSignatures();
                        if (signatures && signatures.length) {
                            const returnType = signatures[0].getReturnType();
                            let isContextualType = !!contextualType;
                            const declareSignatures = checker
                                .getTypeAtLocation(ts.getOriginalNode(updatedNode))
                                .getCallSignatures();
                            if (declareSignatures.length) {
                                if (declareSignatures[0].getReturnType() ===
                                    signatures[0].getReturnType()) {
                                    isContextualType = false;
                                }
                            }
                            const returnTypeNode = parseReturnType(supportUnionType, ts, checker, returnType, isContextualType, updatedNode);
                            if (returnTypeNode) {
                                if (debugReturnType.enabled) {
                                    const originalNode = ts.getOriginalNode(updatedNode);
                                    debugReturnType(`arrow function:`, `():${displayTypeNode(ts, checker, returnTypeNode, returnType)} at ${originalNode.getSourceFile().__relativeFileName}`);
                                }
                                autoImport(ts, ls, checker, returnType, sourceFile, autoImports);
                                return factory.updateArrowFunction(updatedNode, updatedNode.modifiers, updatedNode.typeParameters, updatedNode.parameters, returnTypeNode, updatedNode.equalsGreaterThanToken, updatedNode.body);
                            }
                        }
                    }
                }
                else if (ts.isFunctionExpression(updatedNode)) {
                    if (!updatedNode.type) {
                        const type = checker.getTypeAtLocation(updatedNode);
                        // 如果节点声明的（非上下文推导）返回值类型是void，不处理
                        const nodeSignature = type.getCallSignatures()[0];
                        if (nodeSignature &&
                            nodeSignature.getReturnType().flags & ts.TypeFlags.Void) {
                            return updatedNode;
                        }
                        const contextualType = resolveUpdatedNodeContextualType(ts, checker, updatedNode);
                        if (contextualType &&
                            !shouldTransform(ts.getOriginalNode(updatedNode), contextualType, checker)) {
                            return updatedNode;
                        }
                        let actualType = type;
                        if (contextualType) {
                            const nonNullableContextualType = checker.getNonNullableType(contextualType);
                            if (nonNullableContextualType.getCallSignatures().length &&
                                !nonNullableContextualType.isUnion()) {
                                actualType = contextualType;
                            }
                        }
                        const signatures = resolveNonNullableType(checker, actualType)?.getCallSignatures();
                        if (signatures && signatures.length) {
                            const returnType = signatures[0].getReturnType();
                            let isContextualType = !!contextualType;
                            const declareSignatures = checker
                                .getTypeAtLocation(ts.getOriginalNode(updatedNode))
                                .getCallSignatures();
                            if (declareSignatures.length) {
                                if (declareSignatures[0].getReturnType() ===
                                    signatures[0].getReturnType()) {
                                    isContextualType = false;
                                }
                            }
                            const returnTypeNode = parseReturnType(supportUnionType, ts, checker, returnType, isContextualType, updatedNode);
                            if (returnTypeNode) {
                                if (debugReturnType.enabled) {
                                    debugReturnType(`function expression:`, `():${displayTypeNode(ts, checker, returnTypeNode, returnType)} at ${sourceFile.__relativeFileName}`);
                                }
                                autoImport(ts, ls, checker, returnType, sourceFile, autoImports);
                                return factory.updateFunctionExpression(updatedNode, updatedNode.modifiers, updatedNode.asteriskToken, updatedNode.name, updatedNode.typeParameters, updatedNode.parameters, returnTypeNode, updatedNode.body);
                            }
                        }
                    }
                }
                return updatedNode;
            };
            return (node) => {
                sourceFile = node;
                const updatedNode = ts.visitNode(node, visitor);
                if (autoImports.size === 0) {
                    return updatedNode;
                }
                return factory.updateSourceFile(updatedNode, [...autoImports.values(), ...updatedNode.statements], updatedNode.isDeclarationFile, updatedNode.referencedFiles, updatedNode.typeReferenceDirectives, updatedNode.hasNoDefaultLib, updatedNode.libReferenceDirectives);
            };
        },
    };
};
function displayTypeNode(ts, checker, node, type) {
    if (ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName)) {
        return node.typeName.text;
    }
    return checker.typeToString(type);
}
function parseReturnType(supportUnionType, ts, checker, returnType, isContextualType, node) {
    if (isErrorType(returnType, ts, checker)) {
        return;
    }
    const typeNode = createTypeNode(ts, checker, returnType, supportUnionType);
    if (typeNode) {
        return typeNode;
    }
    // 上下文推导出来的类型，不处理UTSJSONObject
    const checkJSONObject = !isContextualType;
    if (returnType.isUnion()) {
        if (isAnonymousObjectConstraintType(ts, resolveNonNullableType(checker, returnType))) {
            if (!checkJSONObject) {
                return;
            }
            return ts.factory.createUnionTypeNode([
                ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("UTSJSONObject" /* IDENTIFIER.UTSJSONObject */)),
                ts.factory.createLiteralTypeNode(ts.factory.createNull()),
            ]);
        }
    }
    if (!(returnType.flags & ts.TypeFlags.Void)) {
        return isAnonymousObjectConstraintType(ts, returnType)
            ? checkJSONObject
                ? ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("UTSJSONObject" /* IDENTIFIER.UTSJSONObject */))
                : undefined
            : isValidType(ts, checker, returnType)
                ? typeToTypeNode(returnType, node, ts, checker)
                : undefined;
    }
}

const debugUTSJSONObject = debug('uts:transformer:UTSJSONObject');
const transformUTSJSONObject = (ts, ls) => {
    // let globalUTSJSONObjectProperties: string[] = []
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            // if (checker.getUTSJSONObjectType) {
            //   globalUTSJSONObjectProperties = checker
            //     .getUTSJSONObjectType()
            //     .getProperties()
            //     .map((p) => p.getName())
            // }
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                // 如果访问UTSJSONObject类型的属性，则转换为索引访问
                if (ts.isPropertyAccessExpression(updatedNode) &&
                    !isMethodCall(updatedNode, ts)) {
                    const type = checker.getTypeAtLocation(updatedNode.expression);
                    if (isUTSJSONObject(type, checker)) {
                        const propertyName = updatedNode.name.text;
                        if (updatedNode.questionDotToken) {
                            if (debugUTSJSONObject.enabled) {
                                const originalNode = ts.getOriginalNode(updatedNode);
                                debugUTSJSONObject(originalNode.getText(), `at ${originalNode.getSourceFile().__relativeFileName}`);
                            }
                            return factory.createElementAccessChain(updatedNode.expression, updatedNode.questionDotToken, factory.createStringLiteral(propertyName));
                        }
                        if (debugUTSJSONObject.enabled) {
                            const originalNode = ts.getOriginalNode(updatedNode);
                            debugUTSJSONObject(originalNode.getText(), `at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        return factory.createElementAccessExpression(updatedNode.expression, factory.createStringLiteral(propertyName));
                    }
                }
                return updatedNode;
            };
            return (sourceFile) => {
                return ts.visitNode(sourceFile, visitor);
            };
        },
    };
};
function isUTSJSONObject(type, checker) {
    const utsJSONObjectType = checker.getUTSJSONObjectType?.();
    if (utsJSONObjectType) {
        return (type === utsJSONObjectType ||
            checker.getNonNullableType(type) === utsJSONObjectType);
    }
    return false;
}

const transformUTSNumber = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                if (ts.isBinaryExpression(updatedNode) &&
                    updatedNode.operatorToken.kind === ts.SyntaxKind.EqualsToken) {
                    // 赋值语句，如果左侧是Number，右侧是数值或纯数值运算，则将右侧转换为Number()
                    // a = 1 => a = Number(1)
                    const leftType = resolveExpressionType(checker, updatedNode.left);
                    if (isUTSNumberType(leftType, ts, checker) &&
                        isPureNumber(updatedNode.right, ts)) {
                        return factory.createBinaryExpression(updatedNode.left, updatedNode.operatorToken, factory.createCallExpression(factory.createIdentifier('Number'), [], [updatedNode.right]));
                    }
                }
                else if (ts.isCallExpression(updatedNode) &&
                    updatedNode.arguments.length) {
                    // 函数调用，如果参数是Number，则将参数转换为Number构造器
                    // test(1, 2, 3) => test(Number(1), Number(2), Number(3))
                    const newArguments = parseNumberArguments(updatedNode.arguments, ts, checker);
                    if (newArguments) {
                        return factory.updateCallExpression(updatedNode, updatedNode.expression, updatedNode.typeArguments, newArguments);
                    }
                }
                else if (ts.isNewExpression(updatedNode) &&
                    updatedNode.arguments?.length) {
                    // 构造函数调用，如果参数是Number，则将参数转换为Number构造器
                    // new Test(1, 2, 3) => new Test(Number(1), Number(2), Number(3))
                    const newArguments = parseNumberArguments(updatedNode.arguments, ts, checker);
                    if (newArguments) {
                        return factory.updateNewExpression(updatedNode, updatedNode.expression, updatedNode.typeArguments, newArguments);
                    }
                }
                else if (ts.isObjectLiteralExpression(updatedNode)) {
                    // 对象字面量，如果属性是Number，则将属性转换为Number构造器
                    // {n:2} => {n:Number(2)}
                    let hasNumber = false;
                    const properties = updatedNode.properties.map((property) => {
                        if (ts.isPropertyAssignment(property) && property.initializer) {
                            const newInitializers = parseNumberArguments([property.initializer], ts, checker);
                            if (newInitializers) {
                                hasNumber = true;
                                return factory.updatePropertyAssignment(property, property.name, newInitializers[0]);
                            }
                        }
                        return property;
                    });
                    if (hasNumber) {
                        return factory.updateObjectLiteralExpression(updatedNode, properties);
                    }
                }
                return updatedNode;
            };
            return (sourceFile) => {
                return ts.visitNode(sourceFile, visitor);
            };
        },
    };
};
function parseNumberArguments(argumentExprs, ts, checker) {
    const newArguments = [];
    let hasNumber = false;
    argumentExprs.forEach((argument) => {
        const argumentType = resolveExpressionType(checker, argument);
        if (isUTSNumberType(argumentType, ts, checker) &&
            isPureNumber(argument, ts)) {
            hasNumber = true;
            newArguments.push(ts.factory.createCallExpression(ts.factory.createIdentifier('Number'), [], [argument]));
        }
        else {
            newArguments.push(argument);
        }
    });
    if (hasNumber) {
        return newArguments;
    }
}
function isPureNumber(expr, ts) {
    if (ts.isNumericLiteral(expr)) {
        return true;
    }
    if (ts.isParenthesizedExpression(expr)) {
        return isPureNumber(expr.expression, ts);
    }
    if (ts.isPrefixUnaryExpression(expr)) {
        switch (expr.operator) {
            case ts.SyntaxKind.MinusToken:
            case ts.SyntaxKind.PlusToken:
            case ts.SyntaxKind.TildeToken:
                return isPureNumber(expr.operand, ts);
            default:
                return false;
        }
    }
    if (ts.isBinaryExpression(expr)) {
        switch (expr.operatorToken.kind) {
            case ts.SyntaxKind.PlusToken:
            case ts.SyntaxKind.MinusToken:
            case ts.SyntaxKind.AsteriskToken:
            case ts.SyntaxKind.SlashToken:
            case ts.SyntaxKind.PercentToken:
            case ts.SyntaxKind.LessThanLessThanToken:
            case ts.SyntaxKind.GreaterThanGreaterThanToken:
            case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
            case ts.SyntaxKind.CaretToken:
            case ts.SyntaxKind.AmpersandToken:
            case ts.SyntaxKind.BarToken:
            case ts.SyntaxKind.AsteriskAsteriskToken:
                return isPureNumber(expr.left, ts) && isPureNumber(expr.right, ts);
            default:
                return false;
        }
    }
    return false;
}

const transformUTSObject = (ts, ls) => {
    return {
        parser: {
            SourceFile(context) {
                const { factory } = context;
                const visitor = (node) => {
                    const updatedNode = ts.visitEachChild(node, visitor, context);
                    // 如果是TypeAliasDeclaration且是TypeLiteral，则补充一个[UTSObjectMarker]?: true;
                    if (ts.isTypeAliasDeclaration(updatedNode) &&
                        ts.isTypeLiteralNode(updatedNode.type)) {
                        // @ts-expect-error
                        updatedNode.type.members.push(factory.createPropertySignature(undefined, factory.createComputedPropertyName(factory.createIdentifier("UTSObjectMarker" /* IDENTIFIER.UTS_OBJECT_MARKER */)), factory.createToken(ts.SyntaxKind.QuestionToken), factory.createLiteralTypeNode(factory.createTrue())));
                    }
                    return updatedNode;
                };
                return (node) => {
                    node.forEachChild(visitor);
                    return node;
                };
            },
        },
        before(context) {
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                // 如果是 [UTSObjectMarker]?: true，则移除该属性
                if (ts.isPropertySignature(updatedNode) &&
                    ts.isComputedPropertyName(updatedNode.name) &&
                    ts.isIdentifier(updatedNode.name.expression)) {
                    if (updatedNode.name.expression.text === "UTSObjectMarker" /* IDENTIFIER.UTS_OBJECT_MARKER */) {
                        return;
                    }
                }
                return updatedNode;
            };
            return (sourceFile) => {
                return ts.visitNode(sourceFile, visitor);
            };
        },
    };
};

const debugArktsNoAnyUnknown = debug('uts:transformer:arkts-no-any-unknown');
const transformArktsNoAnyUnknown = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                // 目前仅处理 Promise 的 catch 回调
                // p.catch((e)=>{}) => p.catch((e:any)=>{})
                if (ts.isCallExpression(updatedNode)) {
                    const { expression, typeArguments, arguments: args } = updatedNode;
                    if (ts.isPropertyAccessExpression(expression) &&
                        ts.isIdentifier(expression.name)) {
                        const type = checker.getTypeAtLocation(expression.expression);
                        if (type.symbol?.name === 'Promise') {
                            if (args.length === 1 && expression.name.text === 'catch') {
                                const callback = prasePromiseCatchCallback(args[0], ts);
                                if (callback) {
                                    return factory.updateCallExpression(updatedNode, expression, typeArguments, [callback]);
                                }
                            }
                            else if (args.length === 2 && expression.name.text === 'then') {
                                const callback = prasePromiseCatchCallback(args[1], ts);
                                if (callback) {
                                    return factory.updateCallExpression(updatedNode, expression, typeArguments, [args[0], callback]);
                                }
                            }
                        }
                    }
                }
                return updatedNode;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};
function prasePromiseCatchCallback(callback, ts) {
    if (ts.isArrowFunction(callback)) {
        const { parameters } = callback;
        if (parameters.length === 1) {
            const parameter = parameters[0];
            if (!parameter.type) {
                if (debugArktsNoAnyUnknown.enabled) {
                    const originalNode = ts.getOriginalNode(parameter);
                    debugArktsNoAnyUnknown(originalNode.getText(), `at ${originalNode.getSourceFile().__relativeFileName}`);
                }
                const { factory } = ts;
                return factory.updateArrowFunction(callback, callback.modifiers, callback.typeParameters, [
                    factory.updateParameterDeclaration(parameter, parameter.modifiers, parameter.dotDotDotToken, parameter.name, parameter.questionToken, factory.createTypeReferenceNode(factory.createIdentifier("ESObject" /* IDENTIFIER.ARKTS_ES_OBJECT */), undefined), parameter.initializer),
                ], callback.type, callback.equalsGreaterThanToken, callback.body);
            }
        }
    }
    else if (ts.isFunctionExpression(callback)) {
        const { parameters } = callback;
        if (parameters.length === 1) {
            const parameter = parameters[0];
            if (!parameter.type) {
                if (debugArktsNoAnyUnknown.enabled) {
                    const originalNode = ts.getOriginalNode(parameter);
                    debugArktsNoAnyUnknown(originalNode.getText(), `at ${originalNode.getSourceFile().__relativeFileName}`);
                }
                return ts.factory.updateFunctionExpression(callback, callback.modifiers, callback.asteriskToken, callback.name, callback.typeParameters, [
                    ts.factory.updateParameterDeclaration(parameter, parameter.modifiers, parameter.dotDotDotToken, parameter.name, parameter.questionToken, createAnyTypeNode(ts), parameter.initializer),
                ], callback.type, callback.body);
            }
        }
    }
}

const debugRuntimeHelper = debug('uts:transformer:runtimeHelper');
const transformRuntimeHelper = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                // 目前暂不支持 const JSON1 = JSON 这种二次赋值形式
                // JSON.xxx,console.xxx => UTS.JSON.xxx,UTS.console.xxx
                if (ts.isPropertyAccessExpression(updatedNode)) {
                    const { expression, name } = updatedNode;
                    if (ts.isIdentifier(expression)) {
                        if (expression.text === "JSON" /* IDENTIFIER.JSON */ ||
                            expression.text === "console" /* IDENTIFIER.CONSOLE */) {
                            if (debugRuntimeHelper.enabled) {
                                const originalNode = ts.getOriginalNode(updatedNode);
                                debugRuntimeHelper(originalNode.getText(), `at ${originalNode.getSourceFile().__relativeFileName}`);
                            }
                            return factory.updatePropertyAccessExpression(updatedNode, factory.createPropertyAccessExpression(factory.createIdentifier("UTS" /* IDENTIFIER.UTS */), expression), name);
                        }
                    }
                }
                if (ts.isCallExpression(node)) {
                    const newCallExpr = parseArkTSRuntimeCallExpression(node, ts, checker);
                    if (newCallExpr) {
                        return newCallExpr;
                    }
                }
                return updatedNode;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};
function parseArkTSRuntimeCallExpression(node, ts, checker) {
    if (ts.isPropertyAccessExpression(node.expression)) {
        const methodName = parseArkTSRuntimeMethodName(node.expression, ts, checker);
        if (methodName) {
            const factory = ts.factory;
            return factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("UTS" /* IDENTIFIER.UTS */), factory.createIdentifier(methodName)), undefined, [node.expression.expression, ...node.arguments]);
        }
    }
}
function parseArkTSRuntimeMethodName(expr, ts, checker) {
    if (!ts.isIdentifier(expr.name)) {
        return;
    }
    const callerType = checker.getTypeAtLocation(expr.expression);
    let callerName = '';
    if (callerType.isUnion()) {
        // 目前只有 map/weakMap 的 get 方法可能存在联合类型调用的情况
        // 如果每个子type都是Map or WeakMap,则callerName为Map
        if (callerType.types.every((type) => {
            if (type.symbol) {
                if (type.symbol.name === 'Map') {
                    return true;
                }
                else if (type.symbol.name === 'WeakMap') {
                    return true;
                }
            }
            return false;
        })) {
            callerName = 'Map';
        }
    }
    else if (
    // Array<T>
    checker.isArrayType(callerType)) {
        callerName = 'Array';
    }
    else if (callerType.flags & ts.TypeFlags.StringLike) {
        callerName = 'String';
    }
    else if (callerType.symbol) {
        const symbolName = callerType.symbol.name;
        if (symbolName === 'Map') {
            callerName = 'Map';
        }
        else if (symbolName === 'WeakMap') {
            callerName = 'WeakMap';
        }
    }
    if (!callerName) {
        return;
    }
    return ARKTS_RUNTIME_CALL_EXPRESSION_MAP[`${callerName}_${expr.name.text}`];
}
const ARKTS_RUNTIME_CALL_EXPRESSION_MAP = {
    Array_find: 'arrayFind',
    Array_pop: 'arrayPop',
    Array_shift: 'arrayShift',
    Array_copyWithin: 'arrayCopyWithin',
    Array_fill: 'arrayFill',
    Map_get: 'mapGet',
    WeakMap_get: 'weakMapGet',
    String_codePointAt: 'stringCodePointAt',
};

const transformCatchClause = (ts, ls) => {
    return {
        parser: {
            SourceFile(context) {
                const { factory } = context;
                const visitor = (node) => {
                    node.forEachChild(visitor);
                    if (ts.isCatchClause(node)) {
                        if (node.variableDeclaration) {
                            if (!node.variableDeclaration.type) {
                                // catch(e){} => catch(e: any){}
                                // @ts-expect-error
                                node.variableDeclaration.type = factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
                            }
                        }
                        else {
                            // catch{} => catch(e: any){}
                            // @ts-expect-error
                            node.variableDeclaration = factory.createVariableDeclaration(factory.createIdentifier('e'), undefined, factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
                        }
                    }
                };
                return (node) => {
                    node.forEachChild(visitor);
                    return node;
                };
            },
        },
    };
};

const debugInlineAndReified = debug('uts:transformer:decorators:inlineAndReified');
// TODO 是否需要根据 as T 来判断是否需要添加 inline/reified 装饰器，以及
// 生成 const genericTypeT = class extends TypeToken<T>() {}.type 语句
// 目前 as T 的判断是在 rust 层实现的
const transformInlineAndReified = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const createKeywordVisitor = (keywordVisitorContext) => {
                const keywords = keywordVisitorContext.keywords;
                const keywordVisitor = (node) => {
                    if (ts.isCallExpression(node) && node.typeArguments) {
                        // 判断函数调用泛型是否匹配函数声明泛型
                        const typeArguments = node.typeArguments;
                        const typeParameterNames = keywordVisitorContext.typeParameterNames;
                        const isMatch = typeArguments.some((typeArgument) => {
                            if (ts.isTypeReferenceNode(typeArgument) &&
                                ts.isIdentifier(typeArgument.typeName)) {
                                const typeName = typeArgument.typeName.text;
                                return typeParameterNames.includes(typeName);
                            }
                        });
                        if (isMatch) {
                            const signature = checker.getResolvedSignature(node);
                            if (signature) {
                                const declaration = signature.declaration;
                                if (declaration) {
                                    // 识别 @tsdoc 中的关键词
                                    // d.ts 中通过doc定义的关键词
                                    const tags = ts.getJSDocTags(declaration);
                                    tags.forEach((tag) => {
                                        const tagName = tag.tagName.text;
                                        if (keywords.has(tagName)) {
                                            keywordVisitorContext.found = true;
                                            keywords.set(tagName, true);
                                        }
                                    });
                                    // 识别 @UTSAndroid.keyword 中的关键词
                                    // 源码中定义的装饰器
                                    if (ts.isFunctionDeclaration(declaration) ||
                                        ts.isMethodDeclaration(declaration)) {
                                        declaration.modifiers?.forEach((modifier) => {
                                            const keyword = parseUTSAndroidKeyword(ts, modifier);
                                            if (keyword && keywords.has(keyword)) {
                                                keywordVisitorContext.found = true;
                                                keywords.set(keyword, true);
                                            }
                                        });
                                    }
                                }
                            }
                        }
                    }
                    return ts.visitEachChild(node, keywordVisitor, context);
                };
                return keywordVisitor;
            };
            function parseInlineAndReifiedDecorators(updatedNode) {
                const typeParameterNames = parseTypeParameterNames(updatedNode.typeParameters);
                const modifierKeywords = parseUTSAndroidKeywords(ts, updatedNode.modifiers);
                if (modifierKeywords.includes('reified')) {
                    return [];
                }
                const keywordVisitorContext = {
                    found: false,
                    keywords: new Map([['reified', false]]),
                    typeParameterNames,
                };
                const keywordVisitor = createKeywordVisitor(keywordVisitorContext);
                ts.visitEachChild(updatedNode, keywordVisitor, context);
                if (keywordVisitorContext.found) {
                    const decorators = [];
                    for (const [keyword, found,] of keywordVisitorContext.keywords.entries()) {
                        if (found) {
                            if (keyword === 'reified' &&
                                !modifierKeywords.includes('inline')) {
                                // 如果装饰器是 reified，还需要添加 @UTSAndroid.keyword('inline')
                                decorators.push(factory.createDecorator(factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier('UTSAndroid'), factory.createIdentifier('keyword')), undefined, [factory.createStringLiteral('inline')])));
                            }
                            decorators.push(factory.createDecorator(factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier('UTSAndroid'), factory.createIdentifier('keyword')), undefined, [factory.createStringLiteral(keyword)])));
                        }
                    }
                    return decorators;
                }
            }
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                // 如果 keywords 中的 keyword 为 true，则添加装饰器@UTSAndroid.keyword('inline')
                if (ts.isFunctionDeclaration(updatedNode) &&
                    updatedNode.typeParameters) {
                    const decorators = parseInlineAndReifiedDecorators(updatedNode);
                    if (decorators) {
                        if (debugInlineAndReified.enabled) {
                            const originalNode = ts.getOriginalNode(updatedNode);
                            debugInlineAndReified(originalNode.name?.getText() || originalNode.getText(), `at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        return factory.updateFunctionDeclaration(updatedNode, factory.createNodeArray([
                            ...decorators,
                            ...(updatedNode.modifiers || []),
                        ]), updatedNode.asteriskToken, updatedNode.name, updatedNode.typeParameters, updatedNode.parameters, updatedNode.type, updatedNode.body);
                    }
                }
                else if (ts.isMethodDeclaration(updatedNode) &&
                    updatedNode.typeParameters) {
                    const decorators = parseInlineAndReifiedDecorators(updatedNode);
                    if (decorators) {
                        if (debugInlineAndReified.enabled) {
                            const originalNode = ts.getOriginalNode(updatedNode);
                            debugInlineAndReified(originalNode.name.getText(), `at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        return factory.updateMethodDeclaration(updatedNode, factory.createNodeArray([
                            ...decorators,
                            ...(updatedNode.modifiers || []),
                        ]), updatedNode.asteriskToken, updatedNode.name, updatedNode.questionToken, updatedNode.typeParameters, updatedNode.parameters, updatedNode.type, updatedNode.body);
                    }
                }
                return updatedNode;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};
function parseTypeParameterNames(typeParameters) {
    return typeParameters.map((typeParameter) => typeParameter.name.text);
}
function parseUTSAndroidKeywords(ts, modifiers) {
    const keywords = [];
    modifiers?.forEach((modifier) => {
        const keyword = parseUTSAndroidKeyword(ts, modifier);
        if (keyword) {
            keywords.push(keyword);
        }
    });
    return keywords;
}
function parseUTSAndroidKeyword(ts, modifier) {
    if (ts.isDecorator(modifier) &&
        ts.isCallExpression(modifier.expression) &&
        ts.isPropertyAccessExpression(modifier.expression.expression) &&
        ts.isIdentifier(modifier.expression.expression.name) &&
        ts.isIdentifier(modifier.expression.expression.expression) &&
        modifier.expression.expression.expression.text === 'UTSAndroid' &&
        modifier.expression.expression.name.text === 'keyword' &&
        ts.isStringLiteral(modifier.expression.arguments[0])) {
        return modifier.expression.arguments[0].text;
    }
}

/**
 * 转换器：移除空的导入声明
 * 例如：import {} from 'module' => // 空导入 (因为Android下这样编译会报错)
 * 这种转换主要用于处理那些没有实际导入内容的导入声明。
 */
const transformRemoveEmptyImports = (ts) => {
    return {
        before(context) {
            const { factory } = context;
            const visitor = (node) => {
                if (ts.isImportDeclaration(node)) {
                    const importClause = node.importClause;
                    if (importClause &&
                        importClause.namedBindings &&
                        ts.isNamedImports(importClause.namedBindings) &&
                        importClause.namedBindings.elements.length === 0) {
                        return factory.createEmptyStatement();
                    }
                }
                // 继续遍历子节点
                return ts.visitEachChild(node, visitor, context);
            };
            return (sourceFile) => {
                return ts.visitNode(sourceFile, visitor);
            };
        },
    };
};

const debugInterfaceOverride = debug('uts:transformer:interface:override');
/**
 * 此转换器会遍历类声明，检查其实现的接口，
 * 然后为实现接口方法的成员函数添加 override 修饰符。
 *
 * @param ts TypeScript 对象
 * @param ls 语言服务对象
 * @returns 转换器工厂
 */
const transformInterfaceOverride = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const visitor = (node) => {
                if (ts.isClassDeclaration(node) || ts.isClassExpression(node)) {
                    const implementHeritageClauses = node.heritageClauses?.filter((heritageClause) => {
                        return heritageClause.token === ts.SyntaxKind.ImplementsKeyword;
                    });
                    // 获取类实现的所有接口
                    const implementedInterfaces = implementHeritageClauses?.flatMap((clause) => clause.types.map((t) => checker.getTypeAtLocation(t)));
                    if (implementedInterfaces?.length) {
                        const visitorClassMethod = (member) => {
                            // 参数属性 ParameterProperty，也需要处理
                            if (ts.isConstructorDeclaration(member)) {
                                let hasUpdated = false;
                                const updatedParameters = [];
                                for (const param of member.parameters) {
                                    let updatedParam = param;
                                    if (ts.isParameterPropertyDeclaration(param, member)) {
                                        const modifiers = parseModifiers(param, implementedInterfaces, ts, checker);
                                        if (modifiers) {
                                            if (debugInterfaceOverride.enabled) {
                                                const originalNode = ts.getOriginalNode(param);
                                                debugInterfaceOverride(originalNode.getText(), `at ${originalNode.getSourceFile().__relativeFileName}`);
                                            }
                                            updatedParam = factory.updateParameterDeclaration(param, modifiers, param.dotDotDotToken, param.name, param.questionToken, param.type, param.initializer);
                                            hasUpdated = true;
                                        }
                                    }
                                    updatedParameters.push(updatedParam);
                                }
                                if (hasUpdated) {
                                    return factory.updateConstructorDeclaration(member, member.modifiers, updatedParameters, member.body);
                                }
                            }
                            else if (
                            // 如果成员是属性，且没有 override static 修饰符
                            ts.isPropertyDeclaration(member) &&
                                !hasModifier(member, [
                                    ts.SyntaxKind.OverrideKeyword,
                                    ts.SyntaxKind.StaticKeyword,
                                ])) {
                                const modifiers = parseModifiers(member, implementedInterfaces, ts, checker);
                                if (modifiers) {
                                    if (debugInterfaceOverride.enabled) {
                                        const originalNode = ts.getOriginalNode(member);
                                        debugInterfaceOverride(originalNode.getText(), `at ${originalNode.getSourceFile().__relativeFileName}`);
                                    }
                                    return factory.updatePropertyDeclaration(member, modifiers, member.name, member.questionToken, member.type, member.initializer);
                                }
                            }
                            else if (
                            // 如果成员是方法，且没有 override static 修饰符
                            ts.isMethodDeclaration(member) &&
                                !hasModifier(member, [
                                    ts.SyntaxKind.OverrideKeyword,
                                    ts.SyntaxKind.StaticKeyword,
                                ])) {
                                const modifiers = parseModifiers(member, implementedInterfaces, ts, checker);
                                if (modifiers) {
                                    if (debugInterfaceOverride.enabled) {
                                        const originalNode = ts.getOriginalNode(member);
                                        debugInterfaceOverride(originalNode.getText(), `at ${originalNode.getSourceFile().__relativeFileName}`);
                                    }
                                    return factory.updateMethodDeclaration(member, modifiers, member.asteriskToken, member.name, member.questionToken, member.typeParameters, member.parameters, member.type, member.body);
                                }
                            }
                            return member;
                        };
                        return ts.visitEachChild(node, visitorClassMethod, context);
                    }
                }
                return ts.visitEachChild(node, visitor, context);
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};
function parseModifiers(member, implementedInterfaces, ts, checker) {
    const memberSymbol = checker.getSymbolAtLocation(member.name);
    if (memberSymbol) {
        // 检查方法是否来自接口
        const isFromInterface = implementedInterfaces.some((interfaceType) => interfaceType
            .getProperties()
            .some((prop) => prop.name === memberSymbol.name));
        if (isFromInterface) {
            // 添加 override 修饰符
            const modifiers = member.modifiers
                ? [
                    ...member.modifiers.filter((m) => isPrecedeOverrideModifier(m, ts)),
                    ts.factory.createModifier(ts.SyntaxKind.OverrideKeyword),
                    ...member.modifiers.filter((m) => !isPrecedeOverrideModifier(m, ts)),
                ]
                : [ts.factory.createModifier(ts.SyntaxKind.OverrideKeyword)];
            return modifiers;
        }
    }
}
function hasModifier(member, modifierKinds) {
    return member.modifiers?.some((m) => modifierKinds.includes(m.kind));
}
function isPrecedeOverrideModifier(m, ts) {
    return (m.kind === ts.SyntaxKind.Decorator ||
        m.kind === ts.SyntaxKind.PublicKeyword ||
        m.kind === ts.SyntaxKind.ProtectedKeyword ||
        m.kind === ts.SyntaxKind.PrivateKeyword ||
        m.kind === ts.SyntaxKind.AbstractKeyword);
}

const debugNumberToString = debug('uts:transformer:number:toString');
const transformNumberToString = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                // 0.00001.toString() => 0.00001.toString(10)
                // (0.00001).toString() => (0.00001).toString(10)
                // (0.00001+1).toString() => (0.00001+1).toString(10)
                if (ts.isCallExpression(updatedNode) &&
                    updatedNode.arguments.length === 0 &&
                    ts.isPropertyAccessExpression(updatedNode.expression) &&
                    updatedNode.expression.name.text === 'toString') {
                    const type = checker.getTypeAtLocation(updatedNode.expression.expression);
                    if (type.flags & ts.TypeFlags.NumberLiteral ||
                        type.flags & ts.TypeFlags.Number) {
                        return factory.updateCallExpression(updatedNode, updatedNode.expression, updatedNode.typeArguments, [factory.createNumericLiteral('10')]);
                    }
                    return updatedNode;
                }
                // 如果是字符串拼接浮点数值字面量，则将浮点数值字面量转换为toString(10)方法
                else if (ts.isBinaryExpression(updatedNode) &&
                    updatedNode.operatorToken.kind === ts.SyntaxKind.PlusToken &&
                    ts.isNumericLiteral(updatedNode.right) &&
                    // 注意不能用text，text返回的数据是处理的，比如 1.0 会返回 1
                    updatedNode.right.getText().includes('.')) {
                    // 判断整个表达式是否是字符串类型
                    const type = checker.getTypeAtLocation(updatedNode);
                    if (type.flags & ts.TypeFlags.String) {
                        if (debugNumberToString.enabled) {
                            const originalNode = ts.getOriginalNode(updatedNode);
                            debugNumberToString(originalNode.right.getText(), `at ${originalNode.getSourceFile().__relativeFileName}`);
                        }
                        return factory.updateBinaryExpression(updatedNode, updatedNode.left, updatedNode.operatorToken, factory.createCallExpression(factory.createPropertyAccessExpression(updatedNode.right, 'toString'), undefined, [factory.createNumericLiteral('10')]));
                    }
                }
                else if (ts.isTemplateSpan(updatedNode) &&
                    ts.isNumericLiteral(updatedNode.expression) &&
                    updatedNode.expression.getText().includes('.')) {
                    if (debugNumberToString.enabled) {
                        const originalNode = ts.getOriginalNode(updatedNode);
                        debugNumberToString(originalNode.expression.getText(), `at ${originalNode.getSourceFile().__relativeFileName}`);
                    }
                    return factory.updateTemplateSpan(updatedNode, factory.createCallExpression(factory.createPropertyAccessExpression(updatedNode.expression, 'toString'), undefined, [factory.createNumericLiteral('10')]), updatedNode.literal);
                }
                return updatedNode;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

const debugRestParameters = debug('uts:transforms:rest_parameters');
const DO_NOT_TRANSFORM_SPREAD = 'do_not_transform_spread';
const transformRestParameters = (ts, ls, options) => {
    const shouldTransform = options.transformRestParameters?.shouldTransform ?? (() => true);
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                if (ts.isMethodDeclaration(updatedNode) &&
                    updatedNode.parameters.length &&
                    updatedNode.body) {
                    const type = resolveNonNullableType(checker, resolveMethodDeclarationContextualType(ts, checker, updatedNode));
                    if (type) {
                        const signatures = type.getCallSignatures();
                        if (signatures && signatures.length === 1) {
                            if (!shouldTransform(updatedNode, signatures[0], checker, context)) {
                                return updatedNode;
                            }
                            const spreadArgs = resolveSpreadArgs(signatures[0], updatedNode, ts);
                            if (spreadArgs) {
                                if (debugRestParameters.enabled) {
                                    const originalNode = ts.getOriginalNode(updatedNode);
                                    debugRestParameters(`method:`, `${originalNode.name.getText()}(${displayArguments(ts, spreadArgs.parameters)}) at ${originalNode.getSourceFile().__relativeFileName}`);
                                }
                                return factory.updateMethodDeclaration(updatedNode, updatedNode.modifiers, updatedNode.asteriskToken, updatedNode.name, updatedNode.questionToken, updatedNode.typeParameters, spreadArgs.parameters, updatedNode.type, factory.createBlock([
                                    ...spreadArgs.statements,
                                    ...updatedNode.body.statements,
                                ]));
                            }
                        }
                    }
                }
                else if (ts.isArrowFunction(updatedNode) &&
                    updatedNode.parameters.length) {
                    const type = resolveNonNullableType(checker, checker.getContextualType(updatedNode));
                    if (type) {
                        const inferredType = checker.getTypeAtLocation(updatedNode);
                        if (type !== inferredType) {
                            const signatures = type.getCallSignatures();
                            if (signatures && signatures.length) {
                                if (!shouldTransform(updatedNode, signatures[0], checker, context)) {
                                    return updatedNode;
                                }
                                const spreadArgs = resolveSpreadArgs(signatures[0], updatedNode, ts);
                                if (spreadArgs) {
                                    if (debugRestParameters.enabled) {
                                        const originalNode = ts.getOriginalNode(updatedNode);
                                        debugRestParameters(`arrow function:`, `(${displayArguments(ts, spreadArgs.parameters)}) at ${originalNode.getSourceFile().__relativeFileName}`);
                                    }
                                    const newBody = ts.isExpression(updatedNode.body)
                                        ? factory.createBlock([
                                            ...spreadArgs.statements,
                                            factory.createReturnStatement(updatedNode.body),
                                        ])
                                        : factory.createBlock([
                                            ...spreadArgs.statements,
                                            ...updatedNode.body.statements,
                                        ]);
                                    return createNewExpressionWrapper(signatures[0], updatedNode, factory.updateArrowFunction(updatedNode, updatedNode.modifiers, updatedNode.typeParameters, spreadArgs.parameters, updatedNode.type, updatedNode.equalsGreaterThanToken, newBody), ts);
                                }
                            }
                        }
                    }
                }
                else if (ts.isFunctionExpression(updatedNode) &&
                    updatedNode.parameters.length) {
                    const type = resolveNonNullableType(checker, checker.getContextualType(updatedNode));
                    if (type) {
                        const inferredType = checker.getTypeAtLocation(updatedNode);
                        if (type !== inferredType) {
                            const signatures = type.getCallSignatures();
                            if (signatures && signatures.length) {
                                if (!shouldTransform(updatedNode, signatures[0], checker, context)) {
                                    return updatedNode;
                                }
                                const spreadArgs = resolveSpreadArgs(signatures[0], updatedNode, ts);
                                if (spreadArgs) {
                                    if (debugRestParameters.enabled) {
                                        const originalNode = ts.getOriginalNode(updatedNode);
                                        debugRestParameters(`function expression:`, `(${displayArguments(ts, spreadArgs.parameters)}) at ${originalNode.getSourceFile().__relativeFileName}`);
                                    }
                                    return createNewExpressionWrapper(signatures[0], updatedNode, factory.updateFunctionExpression(updatedNode, updatedNode.modifiers, updatedNode.asteriskToken, updatedNode.name, updatedNode.typeParameters, spreadArgs.parameters, updatedNode.type, factory.createBlock([
                                        ...spreadArgs.statements,
                                        ...updatedNode.body.statements,
                                    ])), ts);
                                }
                            }
                        }
                    }
                }
                return updatedNode;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};
function findRestParameterIndex(signature, ts) {
    if (signature.parameters.length) {
        const lastParameter = signature.parameters[signature.parameters.length - 1];
        if (lastParameter.valueDeclaration &&
            ts.isParameter(lastParameter.valueDeclaration) &&
            lastParameter.valueDeclaration.dotDotDotToken) {
            return signature.parameters.length - 1;
        }
    }
    return -1;
}
function resolveSpreadArgs(signature, updatedNode, ts) {
    const restParameterIndex = findRestParameterIndex(signature, ts);
    // 如果存在剩余参数，并且剩余参数在方法参数列表中
    if (restParameterIndex !== -1 &&
        restParameterIndex < updatedNode.parameters.length) {
        const restParameters = updatedNode.parameters.slice(restParameterIndex);
        const names = resolveSpreadArgsNames(restParameters, ts);
        if (names.length) {
            return {
                parameters: ts.factory.createNodeArray([
                    ...updatedNode.parameters.slice(0, restParameterIndex),
                    createSpreadArgsParameterDeclaration(ts.factory),
                ]),
                statements: createSpreadArgsVariableStatements(names, ts.factory),
            };
        }
    }
}
function createSpreadArgsParameterDeclaration(factory) {
    return factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier(DO_NOT_TRANSFORM_SPREAD), undefined, undefined, undefined);
}
function resolveSpreadArgsNames(parameters, ts) {
    if (parameters.find((p) => !ts.isIdentifier(p.name))) {
        return [];
    }
    return parameters.map((parameter) => ({
        name: parameter.name.getText(),
        isRestParameter: !!parameter.dotDotDotToken,
    }));
}
function createSpreadArgsVariableStatements(names, factory) {
    return factory.createNodeArray(names.map(({ name, isRestParameter }, index) => createSpreadArgsVariableStatement(name, index, isRestParameter, factory)));
}
function createSpreadArgsVariableStatement(name, index, isRestParameter, factory) {
    return factory.createVariableStatement(undefined, factory.createNodeArray([
        createSpreadArgsVariableDeclaration(name, index, isRestParameter, factory),
    ]));
}
function createSpreadArgsVariableDeclaration(name, index, isRestParameter, factory) {
    return factory.createVariableDeclaration(factory.createIdentifier(name), undefined, undefined, isRestParameter
        ? factory.createNewExpression(factory.createIdentifier('Array'), undefined, [
            factory.createSpreadElement(factory.createIdentifier(DO_NOT_TRANSFORM_SPREAD)),
        ])
        : factory.createElementAccessExpression(factory.createIdentifier(DO_NOT_TRANSFORM_SPREAD), factory.createNumericLiteral(index.toString())));
}
function createNewExpressionWrapper(signature, updateNode, newNode, ts) {
    // const a = (...args) => { ... }
    // const a = new Callback((...args) =>{ ... })
    // test.callback = (...args) => { ... }
    // test.callback = new Callback((...args) =>{ ... })
    // 如果 updateNode 的父节点是 VariableDeclaration 或 BinaryExpression
    const parent = ts.getOriginalNode(updateNode).parent;
    if (parent &&
        (ts.isVariableDeclaration(parent) ||
            (ts.isBinaryExpression(parent) &&
                parent.operatorToken.kind === ts.SyntaxKind.EqualsToken))) {
        if (signature.declaration && signature.declaration.parent) {
            const parent = signature.declaration.parent;
            if (ts.isTypeAliasDeclaration(parent)) {
                const name = parent.name.getText();
                const factory = ts.factory;
                return factory.createNewExpression(factory.createIdentifier(name), undefined, [newNode]);
            }
        }
    }
    return newNode;
}

/**
 * 为传递了泛型参数的函数调用添加缺失的参数。
 *
 * swift相关特性
 * - 参数可以带名称也可以不带，以开发者写法为准，如果开发者有任意参数命名，则自动补充的参数都要命名
 * - nil会覆盖参数默认值
 * - 调用函数时如果传了泛型参数，则所有参数都不可省略，即使有默认值
 */
const transformAddMissingParameters = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const { factory } = context;
            return (sourceFile) => {
                function visitNode(node) {
                    const updatedNode = ts.visitEachChild(node, visitNode, context);
                    const typeChecker = program.getTypeChecker();
                    if (ts.isCallExpression(updatedNode) &&
                        updatedNode.typeArguments &&
                        updatedNode.typeArguments.length > 0) {
                        const signature = typeChecker.getResolvedSignature(updatedNode);
                        if (!signature) {
                            return updatedNode;
                        }
                        const passedArguments = updatedNode.arguments;
                        const resolvedArguments = signature.getParameters();
                        /**
                         * 注意：uts允许给参数命名，https://doc.dcloud.net.cn/uni-app-x/plugin/uts-for-ios.html#_5-1-4-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0
                         * 命名参数、匿名参数不可混用。
                         * uts使用赋值语句作为参数命名方式
                         */
                        if (passedArguments.length < resolvedArguments.length) {
                            const useNamedParameter = passedArguments.length > 0 &&
                                ts.isBinaryExpression(passedArguments[0]) &&
                                passedArguments[0].operatorToken.kind ===
                                    ts.SyntaxKind.EqualsToken;
                            const addedParameters = [];
                            for (let i = 0; i < resolvedArguments.length; i++) {
                                const param = resolvedArguments[i];
                                const paramDecl = param.declarations?.[0];
                                if (paramDecl && ts.isParameter(paramDecl)) {
                                    if (paramDecl.dotDotDotToken) {
                                        return updatedNode; // 不支持剩余参数
                                    }
                                    if (!ts.isIdentifier(paramDecl.name)) {
                                        return updatedNode; // 不支持非标识符的参数名
                                    }
                                    const skipParam = useNamedParameter
                                        ? passedArguments.some((p) => ts.isBinaryExpression(p) &&
                                            p.left.getText() === paramDecl.name.getText())
                                        : i < passedArguments.length;
                                    if (skipParam) {
                                        continue; // 已经传入了该参数
                                    }
                                    if (paramDecl.initializer) {
                                        if (!ts.isLiteralExpression(paramDecl.initializer)) {
                                            return updatedNode; // 不支持复杂类型默认值
                                        }
                                        addedParameters.push(useNamedParameter
                                            ? factory.createBinaryExpression(factory.cloneNode(paramDecl.name), ts.SyntaxKind.EqualsToken, factory.cloneNode(paramDecl.initializer))
                                            : factory.cloneNode(paramDecl.initializer));
                                    }
                                    else {
                                        addedParameters.push(useNamedParameter
                                            ? factory.createBinaryExpression(factory.createIdentifier(param.name), ts.SyntaxKind.EqualsToken, factory.createNull())
                                            : factory.createNull());
                                    }
                                }
                            }
                            return factory.updateCallExpression(updatedNode, updatedNode.expression, updatedNode.typeArguments, [...passedArguments, ...addedParameters]);
                        }
                    }
                    return updatedNode;
                }
                return visitNode(sourceFile);
            };
        },
    };
};

/**
 * 为传递了泛型参数的函数调用添加返回类型。
 */
const transformAddReturnType = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            return (sourceFile) => {
                const autoImports = [];
                const visitor = (node) => {
                    const updatedNode = ts.visitEachChild(node, visitor, context);
                    if (ts.isCallExpression(updatedNode) &&
                        updatedNode.typeArguments &&
                        updatedNode.typeArguments.length > 0) {
                        const parent = updatedNode.parent || ts.getOriginalNode(updatedNode)?.parent;
                        if (parent && !ts.isAsExpression(parent)) {
                            const type = checker.getTypeAtLocation(updatedNode);
                            if (type) {
                                let typeNode = checker.typeToTypeNode(type, ts.getOriginalNode(updatedNode), ts.NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope);
                                // TODO 与transformUTSObjectUnionType合并
                                if (type.isUnion() && isUTSObjectTypeUnion(type, ts, checker)) {
                                    const hasNullish = typeNode.types.some((t) => ts.isLiteralTypeNode(t) &&
                                        t.literal.kind === ts.SyntaxKind.NullKeyword);
                                    if (hasNullish) {
                                        typeNode = factory.createUnionTypeNode([
                                            factory.createTypeReferenceNode("UTSUnionTypeObject" /* IDENTIFIER.UTSUnionTypeObject */),
                                            factory.createLiteralTypeNode(factory.createNull()),
                                        ]);
                                    }
                                    typeNode = factory.createTypeReferenceNode("UTSUnionTypeObject" /* IDENTIFIER.UTSUnionTypeObject */);
                                    return factory.createAsExpression(updatedNode, typeNode);
                                }
                                if (typeNode) {
                                    const tempAutoImports = [...autoImports];
                                    const autoImportTypeVisitor = new AutoImportTypeVisitor(updatedNode, sourceFile, checker, context, ts, autoImports);
                                    try {
                                        const updatedTypeNode = autoImportTypeVisitor.visitTypeNode(typeNode);
                                        if (updatedTypeNode) {
                                            const result = factory.createAsExpression(updatedNode, updatedTypeNode);
                                            return result;
                                        }
                                    }
                                    catch (error) {
                                        // 如果访问类型节点失败，恢复 autoImports
                                        autoImports.splice(0, autoImports.length, ...tempAutoImports);
                                        return updatedNode;
                                    }
                                }
                            }
                        }
                    }
                    return updatedNode;
                };
                const updatedSourceFile = ts.visitNode(sourceFile, visitor);
                return AutoImportTypeVisitor.updateSourceFile(autoImports, updatedSourceFile, factory, ts);
            };
        },
    };
};

const debugExistentialType = debug('uts:transformer:existentialType');
const transformExistentialType = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                if (ts.isTypeReferenceNode(updatedNode) &&
                    updatedNode.typeArguments &&
                    // 目前仅支持单个泛型参数，暂不考虑多个
                    updatedNode.typeArguments.length === 1 &&
                    // 泛型参数必须为unknown
                    updatedNode.typeArguments[0].kind === ts.SyntaxKind.UnknownKeyword) {
                    let ignore = false;
                    if (ts.isIdentifier(updatedNode.typeName)) {
                        const name = updatedNode.typeName.text;
                        // 内置的类型，不进行转换
                        if (name === 'Array' ||
                            name === 'Set' ||
                            name === 'Map' ||
                            name === 'Ref') {
                            ignore = true;
                        }
                    }
                    if (!ignore) {
                        const type = checker.getTypeFromTypeNode(updatedNode);
                        // 检查类型是否是interface
                        if (type.symbol?.flags & ts.SymbolFlags.Interface) {
                            if (debugExistentialType.enabled) {
                                const originalNode = ts.getOriginalNode(updatedNode);
                                debugExistentialType(originalNode.getText(), ` at ${originalNode.getSourceFile().__relativeFileName}`);
                            }
                            return factory.createTypeReferenceNode("SwiftExistentialType" /* IDENTIFIER.SWIFT_EXISTENTIAL_TYPE */, [
                                updatedNode.typeArguments[0],
                                factory.createTypeReferenceNode(updatedNode.typeName),
                            ]);
                        }
                    }
                }
                return updatedNode;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

const debugNumberNarrowing = debug('uts:transformer:numberNarrowing');
/**
 * 如果一个字面量赋值给了联合类型中的number，则需要将该字面量 as number，不然swift会把它推导为其他基础类型，比如Int之类
 * let a: number | string = 1 => let a: number | string = 1 as number => let a: Any = 1 as NSNumber
 * function test(a: number | string); test(1) => test(1 as number) => test(1 as NSNumber)
 * @param ts
 * @param ls
 * @returns
 */
const transformNumberNarrowing = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                if (ts.isNumericLiteral(updatedNode) &&
                    updatedNode.parent &&
                    !ts.isAsExpression(updatedNode.parent)) {
                    const type = checker.getContextualType(updatedNode);
                    if (type) {
                        const nonNullableType = checker.getNonNullableType(type);
                        if (nonNullableType.isUnion() &&
                            !isNumberLiteralUnion(nonNullableType)) {
                            const types = nonNullableType.types;
                            if (types.length > 1 &&
                                types.some((t) => isUTSNumberType(t, ts, checker))) {
                                if (debugNumberNarrowing.enabled) {
                                    const originalNode = ts.getOriginalNode(updatedNode);
                                    debugNumberNarrowing(`${originalNode.getText()} as number`, ` at ${originalNode.getSourceFile().__relativeFileName}`);
                                }
                                return factory.createAsExpression(updatedNode, createNumberTypeNode(ts));
                            }
                        }
                    }
                }
                return updatedNode;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

const transformOverride = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            return (sourceFile) => {
                function visitNode(node) {
                    if (!ts.isClassDeclaration(node) ||
                        !node.heritageClauses?.some((hc) => hc.token === ts.SyntaxKind.ExtendsKeyword)) {
                        return ts.visitEachChild(node, visitNode, context);
                    }
                    const classType = checker.getTypeAtLocation(node);
                    const baseTypes = checker.getBaseTypes(classType);
                    if (baseTypes.length === 0) {
                        return ts.visitEachChild(node, visitNode, context);
                    }
                    const superType = baseTypes[0];
                    const superTypeSymbol = superType.getSymbol();
                    if (!superTypeSymbol) {
                        return ts.visitEachChild(node, visitNode, context);
                    }
                    const superCtorType = checker.getTypeOfSymbol(superTypeSymbol);
                    const superCtorSignatures = superCtorType.getConstructSignatures();
                    if (superCtorSignatures.length === 0) {
                        return ts.visitEachChild(node, visitNode, context);
                    }
                    const updatedMembers = node.members.map((member) => {
                        if (!ts.isConstructorDeclaration(member)) {
                            return member;
                        }
                        const ctorSignature = checker.getSignatureFromDeclaration(member);
                        if (!ctorSignature) {
                            return member;
                        }
                        for (const superCtorSignature of superCtorSignatures) {
                            if (signaturesMatch(ctorSignature, superCtorSignature, checker)) {
                                const hasOverride = member.modifiers?.some((modifier) => {
                                    if (ts.isDecorator(modifier)) {
                                        const expr = modifier.expression;
                                        if (ts.isCallExpression(expr) &&
                                            ts.isPropertyAccessExpression(expr.expression) &&
                                            ts.isIdentifier(expr.expression.expression) &&
                                            expr.expression.expression.text === "UTSiOS" /* IDENTIFIER.UTS_IOS */ &&
                                            expr.expression.name.text === 'keyword' &&
                                            expr.arguments.length === 1 &&
                                            ts.isStringLiteral(expr.arguments[0]) &&
                                            expr.arguments[0].text === 'override') {
                                            return true;
                                        }
                                    }
                                    return false;
                                });
                                if (!hasOverride) {
                                    const overrideDecorator = factory.createDecorator(factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("UTSiOS" /* IDENTIFIER.UTS_IOS */), 'keyword'), undefined, [factory.createStringLiteral('override')]));
                                    const modifiers = ts.getModifiers(member) || [];
                                    return factory.updateConstructorDeclaration(member, [overrideDecorator, ...modifiers], member.parameters, member.body);
                                }
                                break;
                            }
                        }
                        return member;
                    });
                    return factory.updateClassDeclaration(node, ts.getModifiers(node), node.name, node.typeParameters, node.heritageClauses, updatedMembers);
                }
                return visitNode(sourceFile);
            };
        },
    };
};
function signaturesMatch(sig1, sig2, checker) {
    const params1 = sig1.getParameters();
    const params2 = sig2.getParameters();
    if (params1.length !== params2.length) {
        return false;
    }
    for (let i = 0; i < params1.length; i++) {
        const param1 = params1[i];
        const param2 = params2[i];
        const type1 = checker.getTypeOfSymbolAtLocation(param1, param1.valueDeclaration);
        const type2 = checker.getTypeOfSymbolAtLocation(param2, param2.valueDeclaration);
        // 直接比较类型的字符串表示形式
        if (checker.typeToString(type1) !== checker.typeToString(type2)) {
            return false;
        }
    }
    return true;
}

/**
 * 为override属性增加类型
 */
const transformOverrideProperty = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            // const { factory } = context
            const checker = program.getTypeChecker();
            return (sourceFile) => {
                const autoImports = [];
                function visitNode(node) {
                    const updatedNode = ts.visitEachChild(node, visitNode, context);
                    if (ts.isPropertyDeclaration(updatedNode) &&
                        updatedNode.modifiers?.some((modifier) => modifier.kind === ts.SyntaxKind.OverrideKeyword) &&
                        updatedNode.type === undefined) {
                        const parent = updatedNode.parent;
                        const propertyName = updatedNode.name;
                        if (ts.isClassDeclaration(parent) &&
                            ts.isIdentifier(propertyName)) {
                            const propertyNameStr = propertyName.text;
                            const parentType = checker.getTypeAtLocation(parent);
                            const baseTypes = checker.getBaseTypes(parentType);
                            // @ts-expect-error internal api
                            const currentPropertyType = checker.getTypeOfPropertyOfType(parentType, propertyNameStr);
                            let tempBaseType = baseTypes[0];
                            let inferredType = currentPropertyType;
                            while (tempBaseType) {
                                // @ts-expect-error internal api
                                const basePropertyType = checker.getTypeOfPropertyOfType(tempBaseType, propertyNameStr);
                                if (!basePropertyType) {
                                    // 基类没有该属性，停止递归
                                    break;
                                }
                                if (!(checker.isTypeAssignableTo(currentPropertyType, basePropertyType) &&
                                    checker.isTypeAssignableTo(basePropertyType, currentPropertyType))) {
                                    inferredType = basePropertyType;
                                }
                                tempBaseType = checker.getBaseTypes(tempBaseType)[0];
                            }
                            const typeNode = checker.typeToTypeNode(inferredType, updatedNode, ts.NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope);
                            if (typeNode) {
                                const tempAutoImports = [...autoImports];
                                const autoImportTypeVisitor = new AutoImportTypeVisitor(updatedNode, sourceFile, checker, context, ts, autoImports);
                                try {
                                    const updatedTypeNode = autoImportTypeVisitor.visitTypeNode(typeNode);
                                    if (updatedTypeNode) {
                                        return ts.factory.updatePropertyDeclaration(updatedNode, updatedNode.modifiers, updatedNode.name, updatedNode.questionToken, updatedTypeNode, updatedNode.initializer);
                                    }
                                }
                                catch (error) {
                                    // 如果访问类型节点失败，恢复 autoImports
                                    autoImports.splice(0, autoImports.length, ...tempAutoImports);
                                }
                            }
                        }
                    }
                    return updatedNode;
                }
                const updatedSourceFile = visitNode(sourceFile);
                return AutoImportTypeVisitor.updateSourceFile(autoImports, updatedSourceFile, context.factory, ts);
            };
        },
    };
};

/**
 * 移除不可为空的值后的解包操作符和可选链操作符
 *
 * 用于处理如下swift报错
 *
 * func testOptionalChain() {
 *   let a: String? = "abc"
 *   print(a?.last)
 *   if(a != nil) {
 *       print(a?.last)
 *   }
 *   if let b = a {
 *       print(b.last)
 *       // print(b!.last) // Cannot force unwrap value of non-optional type 'String'
 *       // print(b?.last) // Cannot use optional chaining on non-optional value of type 'String'
 *       print(b ?? "")
 *   }
 * }
 */
const transformRemoveUnnecessaryOperator = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            return (sourceFile) => {
                const visitor = (node) => {
                    const updatedNode = ts.visitEachChild(node, visitor, context);
                    function realHasNullableType(node) {
                        const symbol = checker.getSymbolAtLocation(node);
                        if (!symbol) {
                            return true;
                        }
                        const type = checker.getTypeOfSymbol(symbol);
                        return (
                        // TODO any不应包含null，开发者写的any|null含null，开发者写的any不含null。此处发现any类型跳过处理
                        hasNullableType(type, checker) || type === checker.getAnyType());
                    }
                    if (ts.isNonNullExpression(updatedNode)) {
                        if (realHasNullableType(updatedNode.expression)) {
                            return updatedNode;
                        }
                        return updatedNode.expression;
                    }
                    else if (ts.isPropertyAccessChain(updatedNode)) {
                        if (realHasNullableType(updatedNode.expression)) {
                            return updatedNode;
                        }
                        return factory.updatePropertyAccessChain(updatedNode, updatedNode.expression, undefined, updatedNode.name);
                    }
                    else if (ts.isElementAccessChain(updatedNode)) {
                        if (realHasNullableType(updatedNode.expression)) {
                            return updatedNode;
                        }
                        return factory.updateElementAccessChain(updatedNode, updatedNode.expression, undefined, updatedNode.argumentExpression);
                    }
                    else if (ts.isCallChain(updatedNode)) {
                        if (realHasNullableType(updatedNode.expression)) {
                            return updatedNode;
                        }
                        return factory.updateCallChain(updatedNode, updatedNode.expression, undefined, updatedNode.typeArguments, updatedNode.arguments);
                    }
                    return updatedNode;
                };
                return ts.visitNode(sourceFile, visitor);
            };
        },
    };
};

function componentPublicInstancePropertyAccessFallback(ts, typeChecker, node, left, leftType, right) {
    if (!ts.isPropertyAccessExpression(node) ||
        !ts.isExpression(left) ||
        !ts.isIdentifier(right)) {
        return;
    }
    const leftTypeAliasSymbolName = leftType.aliasSymbol?.escapedName.toString();
    if (leftTypeAliasSymbolName !== 'ComponentPublicInstance' &&
        leftTypeAliasSymbolName !== 'CreateComponentPublicInstance') {
        return;
    }
    const propertyName = right.escapedText.toString();
    const globalPropertiesMap = globalThis?.__utsUniXGlobalProperties__;
    if (globalPropertiesMap && globalPropertiesMap.has(propertyName)) {
        const { initializerNode } = globalPropertiesMap.get(propertyName);
        const type = typeChecker.getTypeAtLocation(initializerNode);
        if (type.isNumberLiteral()) {
            return typeChecker.getNumberType();
        }
        else if (type.isStringLiteral()) {
            return typeChecker.getStringType();
        }
        else if (type.flags & ts.TypeFlags.BooleanLiteral) {
            return typeChecker.getBooleanType();
        }
        return type;
    }
}

function filterReferencedByPaths(referencedFilePath, keys) {
    // 为了优化性能，uvue.ts 变化时，不触发 main.uts.ts 的 check （一般是修改页面）
    if (keys && referencedFilePath.endsWith('.uvue.ts')) {
        for (const [key] of keys?.entries()) {
            if (key.endsWith('main.uts.ts')) {
                keys.delete(key);
                return;
            }
        }
    }
}

const hacker = {
    componentPublicInstancePropertyAccessFallback,
    filterReferencedByPaths,
};

globalThis.__utsUniXGlobalProperties__ =
    globalThis.__utsUniXGlobalProperties__ || new Map();
/**
 * .config.
 */
const transformComponentExtraProperty = (ts) => {
    return {
        parser: {
            SourceFile(context) {
                return (sourceFile) => {
                    const sourceFileName = sourceFile.fileName;
                    const globalPropertiesMap = globalThis
                        ?.__utsUniXGlobalProperties__;
                    if (globalPropertiesMap) {
                        for (const [key, value] of globalPropertiesMap) {
                            if (value.file === sourceFileName) {
                                globalPropertiesMap.delete(key);
                            }
                        }
                    }
                    function visitNode(node) {
                        if (ts.isBinaryExpression(node)) {
                            const { left, operatorToken, right } = node;
                            if (operatorToken.kind === ts.SyntaxKind.EqualsToken) {
                                if (ts.isPropertyAccessExpression(left)) {
                                    const { expression: globalPropertiesExpression, name: globalPropertyName, } = left;
                                    if (ts.isPropertyAccessExpression(globalPropertiesExpression)) {
                                        const { expression: appConfigExpression, name: globalPropertiesIdentifier, } = globalPropertiesExpression;
                                        if (globalPropertiesIdentifier.escapedText.toString() ===
                                            'globalProperties' &&
                                            ts.isPropertyAccessExpression(appConfigExpression)) {
                                            const { name: configIdentifier } = appConfigExpression;
                                            if (configIdentifier.escapedText.toString() === 'config') {
                                                globalPropertiesMap.set(globalPropertyName.escapedText.toString(), {
                                                    file: sourceFileName,
                                                    initializerNode: right,
                                                });
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return ts.visitEachChild(node, visitNode, context);
                    }
                    return visitNode(sourceFile);
                };
            },
        },
    };
};

function diag(code, category, key, message) {
    return {
        code,
        category,
        key,
        message,
    };
}
// createWorker('workers/request/index.uts') => createWorker(RequestTask)
const transformCreateWorker = (ts, _ls, options) => {
    const { extname, resolveWorkers } = options.transformCreateWorker || {
        resolveWorkers: () => ({}),
    };
    const WorkerDiagnostics = {
        Worker_Path_Expected_a_string_literal: diag(0, ts.DiagnosticCategory.Error, 'Worker_Path_Expected_a_string_literal_0', 'uni.createWorker(workerPath) 的 workerPath 参数必须是字符串字面量'),
        Worker_Path_Not_Found: diag(0, ts.DiagnosticCategory.Error, 'Worker_Path_Not_Found_0', 'Worker[{0}]路径不存在或未正确实现'),
        Worker_Not_Supported_on_App_IOS_Uvue: diag(0, ts.DiagnosticCategory.Error, 'Worker_Not_Supported_on_App_IOS_Uvue_0', 'app-ios平台，目前仅 uts 插件中支持使用 uni.createWorker 创建 worker'),
    };
    return {
        before(context) {
            const { factory } = context;
            const autoImports = new Map();
            const workers = resolveWorkers();
            const visitor = (node) => {
                if (ts.isCallExpression(node) &&
                    node.arguments.length >= 1 &&
                    ts.isPropertyAccessExpression(node.expression) &&
                    node.expression.name.escapedText === 'createWorker' &&
                    ts.isIdentifier(node.expression.expression) &&
                    node.expression.expression.escapedText === 'uni') {
                    if (options.targetLanguage === 'JavaScript' &&
                        options.platform === 'app-ios') {
                        context.error(ts.createDiagnosticForNode(node, WorkerDiagnostics.Worker_Not_Supported_on_App_IOS_Uvue));
                    }
                    const firstArg = node.arguments[0];
                    let workerPath = '';
                    if (ts.isStringLiteral(firstArg)) {
                        workerPath = firstArg.text;
                    }
                    else if (ts.isNoSubstitutionTemplateLiteral(firstArg)) {
                        workerPath = firstArg.text;
                    }
                    else {
                        context.error(ts.createDiagnosticForNode(firstArg, WorkerDiagnostics.Worker_Path_Expected_a_string_literal));
                    }
                    if (workerPath) {
                        if (workerPath.startsWith('/')) {
                            workerPath = workerPath.slice(1);
                        }
                        if (workers[workerPath]) {
                            // 目前仅 Kotlin 和 Swift，需要重写参数以及导入 worker
                            if (options.targetLanguage === 'Kotlin' ||
                                options.targetLanguage === 'Swift') {
                                const workerIdent = factory.createIdentifier(workers[workerPath]);
                                if (!autoImports.has(workerPath)) {
                                    const importDeclaration = factory.createImportDeclaration(undefined, factory.createImportClause(false, undefined, factory.createNamedImports([
                                        factory.createImportSpecifier(false, undefined, workerIdent),
                                    ])), factory.createStringLiteral(`@/${workerPath}`), undefined);
                                    autoImports.set(workerPath, importDeclaration);
                                }
                                // 增加 workerIdent 的导入
                                const newArguments = [
                                    factory.createArrowFunction(undefined, undefined, [], factory.createTypeReferenceNode(factory.createIdentifier("WorkerTaskImpl" /* IDENTIFIER.WORKER_TASK_IMPL */), undefined), factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken), factory.createNewExpression(workerIdent, undefined, [])),
                                ];
                                for (let i = 1; i < node.arguments.length; i++) {
                                    newArguments.push(node.arguments[i]);
                                }
                                return factory.updateCallExpression(node, node.expression, node.typeArguments, newArguments);
                            }
                            else if (extname) {
                                // 调整 workerPath 参数文件名后缀
                                const newArguments = [
                                    factory.createStringLiteral(workerPath.replace('.uts', extname)),
                                ];
                                for (let i = 1; i < node.arguments.length; i++) {
                                    newArguments.push(node.arguments[i]);
                                }
                                return factory.updateCallExpression(node, node.expression, node.typeArguments, newArguments);
                            }
                        }
                        else {
                            context.error(ts.createDiagnosticForNode(firstArg, WorkerDiagnostics.Worker_Path_Not_Found, workerPath));
                        }
                    }
                }
                return ts.visitEachChild(node, visitor, context);
            };
            return (node) => {
                const updatedNode = ts.visitNode(node, visitor);
                if (autoImports.size === 0) {
                    return updatedNode;
                }
                return factory.updateSourceFile(updatedNode, [...autoImports.values(), ...updatedNode.statements], updatedNode.isDeclarationFile, updatedNode.referencedFiles, updatedNode.typeReferenceDirectives, updatedNode.hasNoDefaultLib, updatedNode.libReferenceDirectives);
            };
        },
    };
};

let globalUniAppType = null;
let globalUniAppProperties = [];
const transformUniApp = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            if (globalUniAppType === null && checker.getGlobalType) {
                globalUniAppType = checker.getGlobalType('UniApp', 
                /*arity*/ 0, false);
                if (globalUniAppType) {
                    globalUniAppProperties = globalUniAppType
                        .getProperties()
                        .map((p) => p.getName());
                }
            }
            const visitor = (node) => {
                if (globalUniAppType && globalUniAppProperties.length) {
                    // 如果是 CallExpression，则检查是否 UniApp 的 API，比如 app.test() 确认 app 是 UniApp 类型
                    // 判断 test 是否是 globalUniAppType 的方法
                    if (ts.isCallExpression(node) &&
                        ts.isPropertyAccessExpression(node.expression) &&
                        ts.isIdentifier(node.expression.name)) {
                        const type = resolveExpressionType(checker, node.expression.expression);
                        if (type &&
                            type.isIntersection() &&
                            type.types.some((t) => t.symbol?.name === 'UniApp')) {
                            if (!globalUniAppProperties.includes(node.expression.name.text)) {
                                console.error(`error: '${node.expression.name.text}' 不是 UniApp 对象的方法，请检查是否拼写错误，如果想调用在 App.uvue 文件中定义的 methods 方法，请使用 .vm?.xxx 的方式调用，详情参考：https://doc.dcloud.net.cn/uni-app-x/api/get-app.html#appmethods`);
                                const sourceFile = node.getSourceFile();
                                if (sourceFile.__relativeFileName) {
                                    const lineAndCharacter = ts.getLineAndCharacterOfPosition(sourceFile, node.pos);
                                    const fileName = sourceFile.__relativeFileName
                                        .split('?')[0]
                                        .replace(/\.(vue|uvue|uts).ts$/g, '.$1');
                                    console.error('at ' + fileName + ':' + lineAndCharacter.line);
                                }
                                // const lineAndCharacter = ts.getLineAndCharacterOfPosition(
                                //   sourceFile,
                                //   node.pos,
                                // )
                                // const start = ts.getPositionOfLineAndCharacter(
                                //   sourceFile,
                                //   lineAndCharacter.line - 2,
                                //   0,
                                //   // @ts-expect-error
                                //   /* allowEdits */ true,
                                // )
                                // const end = ts.getPositionOfLineAndCharacter(
                                //   sourceFile,
                                //   lineAndCharacter.line + 2,
                                //   1000,
                                //   // @ts-expect-error
                                //   /* allowEdits */ true,
                                // )
                                // const text = sourceFile.getText().slice(start, end)
                                // console.error(text)
                            }
                        }
                    }
                    return ts.visitEachChild(node, visitor, context);
                }
                return node;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

const debugUniElement = debug('uts:transformer:uniElement');
/**
 * uniElement.addEventListener('click', () => {})
 * => (uniElement as UniElementImpl).addEventListener('click', () => {})
 *
 * uniElement?.addEventListener('click', () => {})
 * => (uniElement as UniElementImpl | null)?.addEventListener('click', () => {})
 *
 * (uniElement as UniElement).addEventListener('click', () => {})
 * => ((uniElement as UniElement) as UniElementImpl).addEventListener('click', () => {})
 *
 * @param ts
 * @param ls
 * @returns
 */
const transformUniElement = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                if (ts.isCallExpression(updatedNode) &&
                    ts.isPropertyAccessExpression(updatedNode.expression)) {
                    const propertyAccessExpression = updatedNode.expression;
                    if (propertyAccessExpression.name.text === 'addEventListener') {
                        const type = checker.getTypeAtLocation(propertyAccessExpression.expression);
                        const nonNullableType = checker.getNonNullableType(type);
                        // 是否是 UniElement 或 UniElement 的子类型
                        if (nonNullableType !== getUniElementImplType(checker) &&
                            checker.isTypeStrictSubtypeOf(nonNullableType, getUniElementType(checker))) {
                            if (debugUniElement.enabled) {
                                const originalNode = ts.getOriginalNode(propertyAccessExpression.expression);
                                debugUniElement(`${propertyAccessExpression.expression.getText()} as UniElementImpl`, ` at ${originalNode.getSourceFile().__relativeFileName}`);
                            }
                            const uniElementImplType = factory.createTypeReferenceNode("UniElementImpl" /* IDENTIFIER.UNI_ELEMENT_IMPL */, 
                            /*typeArguments*/ []);
                            return factory.updateCallExpression(updatedNode, factory.updatePropertyAccessExpression(propertyAccessExpression, factory.createAsExpression(propertyAccessExpression.expression, nonNullableType === type
                                ? uniElementImplType
                                : createNullableTypeNode(uniElementImplType, ts)), propertyAccessExpression.name), updatedNode.typeArguments, updatedNode.arguments);
                        }
                    }
                }
                return updatedNode;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};
let uniElementType;
function getUniElementType(checker) {
    if (!uniElementType) {
        uniElementType = checker.getGlobalType("UniElement" /* IDENTIFIER.UNI_ELEMENT */, 
        /*arity*/ 0, true);
    }
    return uniElementType;
}
let uniElementImplType;
function getUniElementImplType(checker) {
    if (!uniElementImplType) {
        uniElementImplType = checker.getGlobalType("UniElementImpl" /* IDENTIFIER.UNI_ELEMENT_IMPL */, 
        /*arity*/ 0, true);
    }
    return uniElementImplType;
}

const debugVModel = debug('uts:transformer:vModel');
/**
 * 为 vue 的 v-model 补充 类型信息
 * createVNode(
 *  _component_test,
 *  utsMapOf({
 *    modelValue: _ctx.a.msg,
 *    'onUpdate:modelValue': ($event) => {
 *      _ctx.a.msg = $event
 *    },
 *  }),
 *  null,
 * )
 * =>
 * createVNode(
 *  _component_test,
 *  utsMapOf({
 *    modelValue: _ctx.a.msg,
 *    'onUpdate:modelValue': ($event: string) => {
 *      _ctx.a.msg = $event
 *
 *    title: _ctx.a.msg,
 *    'onUpdate:title': ($event: string) => {
 *      _ctx.a.msg = $event
 *    },
 *  }),
 */
const transformVModel = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const { factory } = context;
            const visitor = (node) => {
                const updatedNode = ts.visitEachChild(node, visitor, context);
                // 先判断是否是 ($event) => {} 的写法
                if (ts.isArrowFunction(updatedNode) &&
                    updatedNode.parameters.length === 1 &&
                    ts.isBlock(updatedNode.body) &&
                    updatedNode.body.statements.length === 1) {
                    const eventParameter = updatedNode.parameters[0];
                    if (!eventParameter.type &&
                        ts.isIdentifier(eventParameter.name) &&
                        eventParameter.name.text === '$event') {
                        // 向上判断是否是 { 'onUpdate:modelValue': ($event) => {} } 的写法
                        const parent = updatedNode.parent;
                        if (ts.isPropertyAssignment(parent)) {
                            const name = parent.name;
                            if (ts.isStringLiteral(name) &&
                                name.text.startsWith('onUpdate:')) {
                                // 应该不用再判断其他条件了，基本可以断定是v-model的表达式
                                const statement = updatedNode.body.statements[0];
                                if (ts.isExpressionStatement(statement) &&
                                    ts.isBinaryExpression(statement.expression) &&
                                    statement.expression.operatorToken.kind ===
                                        ts.SyntaxKind.EqualsToken) {
                                    const type = checker.getTypeAtLocation(statement.expression.left);
                                    const typeNode = typeToTypeNode(type, eventParameter, ts, checker);
                                    if (typeNode) {
                                        if (debugVModel.enabled) {
                                            const originalNode = ts.getOriginalNode(eventParameter);
                                            debugVModel(`$event as ${checker.typeToString(type)}`, ` at ${originalNode.getSourceFile().__relativeFileName}`);
                                        }
                                        return factory.updateArrowFunction(updatedNode, updatedNode.modifiers, updatedNode.typeParameters, [
                                            factory.updateParameterDeclaration(eventParameter, eventParameter.modifiers, eventParameter.dotDotDotToken, eventParameter.name, eventParameter.questionToken, typeNode, eventParameter.initializer),
                                        ], updatedNode.type, updatedNode.equalsGreaterThanToken, updatedNode.body);
                                    }
                                }
                            }
                        }
                    }
                }
                return updatedNode;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

exports.TargetLanguage = void 0;
(function (TargetLanguage) {
    TargetLanguage["Kotlin"] = "Kotlin";
    TargetLanguage["Swift"] = "Swift";
    TargetLanguage["ArkTS"] = "ArkTS";
    TargetLanguage["JavaScript"] = "JavaScript";
})(exports.TargetLanguage || (exports.TargetLanguage = {}));
function initTargetHacker(_targetLanguage) {
    return {
        ...hacker$1,
        ...hacker,
    };
}
function initTargetTransformers(targetLanguage, options = {}) {
    const transformers = [transformContext];
    if (targetLanguage === exports.TargetLanguage.Kotlin ||
        targetLanguage === exports.TargetLanguage.Swift) {
        transformers.push(transformChecker);
    }
    if (targetLanguage === exports.TargetLanguage.Kotlin ||
        targetLanguage === exports.TargetLanguage.Swift) {
        transformers.push(transformUTSObject, transformKeyof, transformNullEquals);
        if (options.enableGenericsParameterDefaults) {
            transformers.push(transformGenericsParameterDefaults);
        }
        if (options.enableNarrowType) {
            transformers.push(transformNarrowType);
            transformers.push(transformParameterUnionType);
            transformers.push(transformDiscriminatedUnion);
            transformers.push(transformUTSObjectUnionType);
        }
        // ArkTS 不需要处理
        transformers.push(transformArguments);
    }
    if (targetLanguage === exports.TargetLanguage.Kotlin ||
        targetLanguage === exports.TargetLanguage.Swift ||
        targetLanguage === exports.TargetLanguage.ArkTS) {
        transformers.push(transformUTSJSONObject);
    }
    if (targetLanguage === exports.TargetLanguage.Kotlin) {
        transformers.push(transformUniApp, transformVModel, transformInterfaceOverride, transformCatchClause, transformInlineAndReified, transformRemoveEmptyImports, transformNumberToString, transformRestParameters);
        if (options.enableUTSNumber) {
            transformers.push(transformUTSNumber);
        }
    }
    if (targetLanguage === exports.TargetLanguage.Swift) {
        options.isPureSwift && transformers.push(transformAddReturnType);
        options.isPureSwift && transformers.push(transformAddMissingParameters);
        transformers.push(transformNumberNarrowing);
        transformers.push(transformUniElement);
        transformers.push(transformExistentialType);
        options.isPureSwift && transformers.push(transformRemoveUnnecessaryOperator);
        options.isPureSwift && transformers.push(transformOverrideProperty);
        options.isPureSwift && transformers.push(transformOverride);
    }
    if (targetLanguage === exports.TargetLanguage.ArkTS) {
        // transformers.push(transformOptionalChain)
        transformers.push(transformArktsNoAnyUnknown);
        transformers.push(transformRuntimeHelper);
    }
    transformers.push(transformComponentExtraProperty, 
    // 需要放到 transformObjectLiteral 之前
    transformObjectLiteral, transformReturnType, transformIn, transformCreateWorker);
    return transformers;
}

const COLLECTION_CALLBACK_METHODS = [
    'map',
    'filter',
    'forEach',
    'every',
    'some',
    'find',
    'findIndex',
    'reduce',
    'reduceRight',
];
function isCollectionCallbackFunction(node, ts, checker) {
    if (!ts.isArrowFunction(node) && !ts.isFunctionExpression(node)) {
        return false;
    }
    const callExpr = node.parent;
    if (!ts.isCallExpression(callExpr)) {
        return false;
    }
    const propAccess = callExpr.expression;
    if (!ts.isPropertyAccessExpression(propAccess)) {
        return false;
    }
    // 检查方法名
    const methodName = propAccess.name.getText();
    if (!COLLECTION_CALLBACK_METHODS.includes(methodName)) {
        return false;
    }
    // 获取调用者的类型
    let callerType = checker.getNonNullableType(checker.getTypeAtLocation(propAccess.expression));
    // 可能已经被 transform 转换为 AsExpression，此时类型是 any，需要继续查找一下
    if (callerType.flags === ts.TypeFlags.Any) {
        let expr = propAccess.expression;
        if (ts.isParenthesizedExpression(expr)) {
            expr = expr.expression;
        }
        if (ts.isAsExpression(expr)) {
            callerType = checker.getNonNullableType(checker.getTypeAtLocation(expr.expression));
        }
    }
    if (
    // Array<T>
    checker.isArrayType(callerType) ||
        // iOS 会使用字典类型 [string:boolean]，需要特殊处理，不能补充参数
        checker.isTupleType(callerType)) {
        return true;
    }
    // 简易判断
    if (callerType.isUnion()) {
        return callerType.types.some((type) => isCollectionType(type));
    }
    if (callerType.isIntersection()) {
        return callerType.types.some((type) => isCollectionType(type));
    }
    // 简易判断
    if (isCollectionType(callerType)) {
        return true;
    }
    return false;
}
function isCollectionType(type) {
    return (type.symbol && ['Set', 'Map'].includes(type.symbol.escapedName));
}

class UniXCompiler {
    constructor(options) {
        this._options = options;
    }
    debug(formatter, ...args) {
        return this._utsCompiler.debug(formatter, ...args);
    }
    getProgram() {
        return this._utsCompiler.getProgram();
    }
    getTypeScript() {
        return this._utsCompiler.getTypeScript();
    }
    close() {
        return this._utsCompiler.close();
    }
    wait(timeout) {
        return this._utsCompiler.wait(timeout);
    }
    getRootFiles() {
        return this._utsCompiler.getRootFiles();
    }
    hasRootFile(fileName) {
        return this._utsCompiler.hasRootFile(fileName);
    }
    addRootFile(fileName, timeout = 2000) {
        return this._utsCompiler.addRootFile(fileName, timeout);
    }
    addRootFiles(fileNames, timeout = 2000) {
        return this._utsCompiler.addRootFiles(fileNames, timeout);
    }
    getDiagnostics() {
        return this._utsCompiler.getDiagnostics();
    }
    async invalidate(files) { }
    init() {
        if (this._utsCompiler) {
            return Promise.resolve();
        }
        const options = this._options;
        const { mode, targetLanguage, hxLanguageServiceDir } = options;
        // 构造ts实例
        const ts = options.tsFactory(initTargetHacker());
        const inputDir = normalizePath(options.inputDir);
        const outputDir = normalizePath(options.outputDir);
        const hxLanguageServiceDtsDir = hxLanguageServiceDir
            ? path.resolve(hxLanguageServiceDir, 'builtin-dts')
            : '';
        let utsLibDir = options.utsLibDir;
        const utsTypesDir = normalizePath(path.resolve(utsLibDir, 'uts/types/uts'));
        const uniXTypesDir = normalizePath(path.resolve(utsLibDir, 'uts/types/uni-x'));
        const platform = getPlatform(targetLanguage);
        if (!platform) {
            console.error(`${targetLanguage} is unsupported`);
            process.exit(0);
        }
        const platformPathsFileName = normalizePath(path.resolve(uniXTypesDir, platform, 'paths.json'));
        const rootFiles = [path.resolve(uniXTypesDir, `${platform}.d.ts`)];
        const uniExtApiDeclarationFileName = path.resolve(inputDir, '../uni-ext-api.d.ts');
        if (fs.existsSync(uniExtApiDeclarationFileName)) {
            rootFiles.push(uniExtApiDeclarationFileName);
        }
        // @uts/common.d.ts
        let utsCommonDir = '';
        // @uni-x/app-android.d.ts
        // @uni-x/app-ios.d.ts
        let uniXAppPlatformDir = '';
        // @dcloudio/uni-app-x/index.d.ts
        let uniAppXTypesDir = '';
        let utsPlatformLibDir = '';
        if (platform === 'app-harmony') {
            utsPlatformLibDir = path.resolve(uniXTypesDir, platform);
        }
        function fallback() {
            utsCommonDir = normalizePath(path.resolve(utsTypesDir, 'common'));
            uniXAppPlatformDir = normalizePath(path.resolve(uniXTypesDir, platform));
            uniAppXTypesDir = normalizePath(path.resolve(require.resolve('@dcloudio/uni-app-x/package.json', {
                paths: [utsLibDir],
            }), '../types'));
        }
        if (hxLanguageServiceDir && hxLanguageServiceDtsDir) {
            if (fs.existsSync(hxLanguageServiceDtsDir)) {
                utsCommonDir = normalizePath(path.resolve(hxLanguageServiceDtsDir, 'uts-types/common'));
                uniXAppPlatformDir = normalizePath(path.resolve(hxLanguageServiceDtsDir, `uts-types/${platform}`));
                uniAppXTypesDir = normalizePath(path.resolve(hxLanguageServiceDtsDir, 'uniappx/node_modules/@dcloudio/uni-app-x/types'));
            }
            else {
                fallback();
            }
            if (platform === 'app-android' || platform === 'app-ios') {
                utsPlatformLibDir = normalizePath(path.resolve(hxLanguageServiceDir, `../uts-development-${platform.replace('app-', '')}/uts-types/${platform}`));
                if (!fs.existsSync(utsPlatformLibDir)) {
                    utsPlatformLibDir = '';
                }
            }
        }
        else {
            fallback();
        }
        const platformPaths = {};
        if (utsPlatformLibDir && fs.existsSync(platformPathsFileName)) {
            const paths = require(platformPathsFileName);
            Object.keys(paths).forEach((name) => {
                const newPaths = [];
                paths[name].forEach((value) => {
                    newPaths.push(path.resolve(utsPlatformLibDir, value));
                });
                platformPaths[name] = newPaths;
            });
        }
        if (options.rootFiles && options.rootFiles.length) {
            rootFiles.push(...options.rootFiles);
        }
        const vueRuntimeDts = [
            path.resolve(uniXTypesDir, '@vue/runtime-core/dist/runtime-core.d.ts'),
        ];
        const compilerOptions = {
            rootDir: inputDir,
            baseUrl: inputDir,
            outDir: outputDir,
            noImplicitAny: false,
            noImplicitThis: true,
            useDefineForClassFields: false,
            sourceMap: 'sourceMap' in options
                ? options.sourceMap
                : process.env.NODE_ENV === 'development',
            inlineSources: 'inlineSources' in options
                ? options.inlineSources
                : process.env.NODE_ENV === 'development',
            noEmitOnError: false,
            skipLibCheck: true,
            resolveJsonModule: false,
            typeRoots: [],
            paths: {
                // '@dcloudio/uni-runtime': [
                //   path.resolve(
                //     utsKotlinTypesPath,
                //     '@dcloudio/uni-runtime/dist/uni-runtime.d.ts'
                //   ),
                // ],
                '@uts/common.d.ts': [path.resolve(utsCommonDir, 'common.d.ts')],
                [`@uni-x/${platform}.d.ts`]: [
                    path.resolve(uniXAppPlatformDir, 'index.d.ts'),
                ],
                '@dcloudio/uni-app-x/index.d.ts': [
                    path.resolve(uniAppXTypesDir, 'index.d.ts'),
                ],
                '@vue/shared': [
                    path.resolve(uniXTypesDir, '@vue/shared/dist/shared.d.ts'),
                ],
                '@vue/reactivity': [
                    path.resolve(uniXTypesDir, '@vue/reactivity/dist/reactivity.d.ts'),
                ],
                '@vue/runtime-core': vueRuntimeDts,
                vue: vueRuntimeDts,
                ...platformPaths,
                ...options.paths,
            },
        };
        const utsCompilerOptions = {
            mode,
            typescript: ts,
            inputDir: inputDir,
            cacheDir: options.cacheDir,
            rootFiles,
            incremental: options.incremental,
            compilerOptions,
            reportFileName,
            reportDiagnostic(diagnostic) {
                // NOOP
            },
            createTransformers,
            watchFile: options.watchFile,
            normalizeFileName: options.normalizeFileName,
            sourceMapCallback: (fileName, text, writeFile) => {
                const relativeFileName = normalizePath(path.relative(outputDir, fileName));
                if (fileName.endsWith('.uvue.map') || fileName.endsWith('.vue.map')) {
                    const sourceMapFilename = path.resolve(inputDir, relativeFileName.replace('.map', '.ts.map'));
                    if (fs.existsSync(sourceMapFilename)) {
                        // 合并sourcemap
                        const sourceMap = fs.readFileSync(sourceMapFilename, 'utf8');
                        text = merge(sourceMap, text);
                    }
                }
                writeFile?.(fileName, normalizeSourceMap(targetLanguage, text));
                return true;
            },
        };
        this._utsCompiler = new UTSCompiler(utsCompilerOptions);
        return this._utsCompiler.init();
        function createTransformers(languageService, { rootDir }) {
            return parseTransformer(ts, initTargetTransformers(targetLanguage, options.transformOptions), {
                // uniXCompiler只有 watch 模式
                watch: true,
                platform,
                targetLanguage,
                hxPluginDir: options.hxPluginDir,
                isPureSwift: options.transformOptions?.isPureSwift ?? false,
                setParentRecursive: false,
                transformCreateWorker: {
                    extname: options.transformOptions?.workers?.extname,
                    resolveWorkers: options.transformOptions?.workers?.resolve ?? (() => ({})),
                },
                transformObjectLiteral: {
                    shouldTransformAsExpression(node, type) {
                        node = ts.getOriginalNode(node); // 必须获取原始节点，不然可能找不到parent
                        const callExpr = node.parent;
                        if (callExpr && ts.isCallExpression(callExpr)) {
                            if (isExtApiCallExpr(ts, callExpr)) {
                                return false;
                            }
                        }
                        if (type) {
                            if (!isUTSDeclarationType(type, rootDir)) {
                                return false;
                            }
                        }
                        return true;
                    },
                },
                transformArguments: {
                    shouldTransform(node, _type, checker) {
                        node = ts.getOriginalNode(node); // 必须获取原始节点，不然可能找不到parent
                        // Array,Set,Map的 方法回调，不处理参数长度，因为底层已经重载了
                        if (isCollectionCallbackFunction(node, ts, checker)) {
                            return false;
                        }
                        const objectLit = ts.isMethodDeclaration(node)
                            ? node.parent
                            : node.parent.parent;
                        if (objectLit && ts.isObjectLiteralExpression(objectLit)) {
                            let callExpr = objectLit.parent;
                            if (callExpr) {
                                if (ts.isAsExpression(callExpr)) {
                                    // uni.request({success(){}} as RequestOptions)
                                    callExpr = callExpr.parent;
                                }
                                if (ts.isCallExpression(callExpr)) {
                                    // defineComponent({setup(){}})
                                    if (ts.isIdentifier(callExpr.expression)) {
                                        const callExprName = callExpr.expression.getText();
                                        if (DEFINE_METHODS.includes(callExprName)) {
                                            return false;
                                        }
                                    }
                                    // uni.request({success(){}})
                                    else if (isExtApiCallExpr(ts, callExpr)) {
                                        return false;
                                    }
                                }
                            }
                        }
                        return shouldTransformCallback(ts, checker, node);
                    },
                },
                transformReturnType: {
                    shouldTransform(node, _type, checker) {
                        node = ts.getOriginalNode(node); // 必须获取原始节点，不然可能找不到parent
                        // { provide(){ return {} } }
                        if (ts.isMethodDeclaration(node) && ts.isIdentifier(node.name)) {
                            const name = node.name.getText();
                            if (name === 'provide') {
                                return false;
                            }
                        }
                        return shouldTransformCallback(ts, checker, node);
                    },
                },
                transformGenericsParameterDefaults: {
                    shouldTransform(node, type, checker, _context) {
                        if (ts.isCallExpression(node) || ts.isNewExpression(node)) {
                            if (!isUTSDeclarationNode(node.expression, checker, rootDir)) {
                                return false;
                            }
                        }
                        if (type) {
                            if (!isUTSDeclarationType(type, rootDir)) {
                                return false;
                            }
                        }
                        return true;
                    },
                },
                transformRestParameters: {
                    shouldTransform(_node, signature, _checker, _context) {
                        const declaration = signature.declaration;
                        if (declaration) {
                            return isUTSDeclarationFile(declaration, rootDir);
                        }
                        return true;
                    },
                },
                transformNarrowType: {
                    shouldTransformNonNullable(node, _checker) {
                        if (targetLanguage === exports.TargetLanguage.Kotlin) {
                            if (ts.isIdentifier(node)) {
                                return false;
                            }
                            return isNarrowableNonNullableNode(node, ts);
                        }
                        if (targetLanguage === exports.TargetLanguage.Swift) {
                            return isNarrowableNonNullableNode(node, ts);
                        }
                        return false;
                    },
                },
            })(languageService);
        }
        function reportFileName(fileName) {
            let type = 'other';
            fileName = normalizePath(fileName);
            if (fileName.startsWith(utsTypesDir)) {
                type = 'system';
                fileName = 'uts:' + path.relative(utsTypesDir, fileName);
            }
            else if (fileName.startsWith(uniXTypesDir)) {
                type = 'system';
                fileName = 'uni-x:' + path.relative(uniXTypesDir, fileName);
            }
            else if (fileName.startsWith(uniAppXTypesDir)) {
                type = 'system';
                fileName = 'uni-x:' + path.relative(uniAppXTypesDir, fileName);
            }
            else if (fileName.startsWith(utsCommonDir)) {
                // @uts/common
                type = 'system';
                fileName =
                    'uts:' + path.join('common', path.relative(utsCommonDir, fileName));
            }
            else if (fileName.startsWith(uniXAppPlatformDir)) {
                type = 'system';
                fileName =
                    'uni-x:' +
                        path.join(platform, path.relative(uniXAppPlatformDir, fileName));
            }
            else if (utsPlatformLibDir && fileName.startsWith(utsPlatformLibDir)) {
                type = 'system';
                fileName = platform + ':' + path.relative(utsPlatformLibDir, fileName);
            }
            else if (fileName.startsWith(inputDir)) {
                type = 'user';
                fileName = path.relative(inputDir, fileName);
            }
            return {
                type,
                fileName: fileName,
            };
        }
    }
}
const EXT_API_NAMESPACES = ['uni', 'uniCloud'];
function isExtApiCallExpr(ts, callExpr) {
    if (ts.isPropertyAccessExpression(callExpr.expression) &&
        ts.isIdentifier(callExpr.expression.expression)) {
        const callExprName = callExpr.expression.expression.getText();
        if (EXT_API_NAMESPACES.includes(callExprName)) {
            return true;
        }
    }
    return false;
}
const DEFINE_METHODS = [
    'defineApp',
    'defineComponent',
    'defineVaporComponent',
    'defineAsyncComponent',
    'defineVaporComponent',
    'defineMixin',
];
function merge(oldMapStr, newMapStr) {
    if (!oldMapStr)
        return newMapStr;
    if (!newMapStr)
        return oldMapStr;
    const oldMap = JSON.parse(oldMapStr);
    const newMap = JSON.parse(newMapStr);
    const oldMapConsumer = new sourceMapJs.SourceMapConsumer(oldMap);
    const newMapConsumer = new sourceMapJs.SourceMapConsumer(newMap);
    const mergedMapGenerator = new sourceMapJs.SourceMapGenerator(oldMap);
    // iterate on new map and overwrite original position of new map with one of old map
    newMapConsumer.eachMapping(function (m) {
        // pass when `originalLine` is null.
        // It occurs in case that the node does not have origin in original code.
        if (m.originalLine == null)
            return;
        const origPosInOldMap = oldMapConsumer.originalPositionFor({
            line: m.originalLine,
            column: m.originalColumn,
        });
        if (origPosInOldMap.source == null)
            return;
        mergedMapGenerator.addMapping({
            original: {
                line: origPosInOldMap.line,
                column: origPosInOldMap.column,
            },
            generated: {
                line: m.generatedLine,
                column: m.generatedColumn,
            },
            source: origPosInOldMap.source,
            name: origPosInOldMap.name,
        });
    });
    const maps = [oldMap, newMap];
    maps.forEach(function (map, index) {
        map.sources.forEach(function (sourceFile) {
            const sourceContent = (index === 0 ? oldMapConsumer : newMapConsumer).sourceContentFor(sourceFile);
            if (sourceContent != null) {
                mergedMapGenerator.setSourceContent(sourceFile, sourceContent);
            }
        });
    });
    return mergedMapGenerator.toString();
}
function getPlatform(targetLanguage) {
    return targetLanguage === exports.TargetLanguage.Kotlin
        ? 'app-android'
        : targetLanguage === exports.TargetLanguage.Swift
            ? 'app-ios'
            : targetLanguage === exports.TargetLanguage.ArkTS
                ? 'app-harmony'
                : '';
}
function normalizeSourceMap(targetLanguage, text) {
    const sourceMap = JSON.parse(text);
    sourceMap.sources = sourceMap.sources.map((source) => {
        const parts = source.split('/.tsc/' + getPlatform(targetLanguage) + '/');
        source = parts[1] || parts[0];
        source = source.split('?')[0];
        return source.replace('.uts.ts', '.uts');
    });
    return JSON.stringify(sourceMap);
}
function shouldTransformCallback(ts, _checker, node) {
    const parent = node.parent;
    if (parent) {
        if (ts.isCallExpression(parent)) {
            if (ts.isIdentifier(parent.expression)) {
                const name = parent.expression.getText();
                if (
                // vue
                name === 'watch' ||
                    name === 'watchEffect' ||
                    name === 'watchPostEffect' ||
                    name === 'watchSyncEffect') {
                    return false;
                }
            }
            else if (ts.isPropertyAccessExpression(parent.expression)) {
                const name = parent.expression.name.getText();
                // Promise.resolve().then(() => {},()=>{}).catch(()=>{})
                // Kotlin 端 then(resolve,reject),reject不能自动补参数，因为必须指定类型
                if (name === 'then' || name === 'catch') {
                    return false;
                }
            }
        }
    }
    return true;
}
function getDeclarationForNode(node, checker) {
    const symbol = checker.getSymbolAtLocation(node);
    if (symbol) {
        const declarations = symbol.declarations;
        if (declarations && declarations.length > 0) {
            return declarations[0];
        }
    }
}
function isUTSDeclarationNode(node, checker, rootDir) {
    const declaration = getDeclarationForNode(node, checker);
    if (declaration) {
        return isUTSDeclarationFile(declaration, rootDir);
    }
    return true;
}
function isUTSDeclarationType(type, rootDir) {
    if (type.aliasSymbol || type.symbol) {
        const declarations = (type.aliasSymbol || type.symbol).declarations;
        if (declarations &&
            declarations.length > 0 &&
            !isUTSDeclarationFile(declarations[0], rootDir)) {
            return false;
        }
    }
    return true;
}
function isNarrowableNonNullableNode(node, ts) {
    if (ts.isNonNullExpression(node)) {
        return false;
    }
    if (ts.isAsExpression(node)) {
        return false;
    }
    const parent = node.parent;
    if (!parent) {
        return false;
    }
    if (ts.isNonNullExpression(parent)) {
        return false;
    }
    // this.a?.()
    if (ts.isCallExpression(parent) && parent.questionDotToken) {
        return false;
    }
    // this.a ?? '1'
    if (ts.isBinaryExpression(parent) &&
        parent.operatorToken.kind === ts.SyntaxKind.QuestionQuestionToken) {
        return false;
    }
    // this.a == "a"
    if (ts.isBinaryExpression(parent)) {
        const operator = parent.operatorToken.kind;
        if (operator === ts.SyntaxKind.EqualsEqualsToken ||
            operator === ts.SyntaxKind.EqualsEqualsEqualsToken ||
            operator === ts.SyntaxKind.ExclamationEqualsToken ||
            operator === ts.SyntaxKind.ExclamationEqualsEqualsToken) {
            return false;
        }
    }
    if (ts.isPropertyAccessExpression(parent)) {
        // this.a?.b
        // 如果是可选链，则不需要收窄
        if (parent.questionDotToken) {
            return false;
        }
        // this.a!.b
        // 如果是NonNullableExpression，则不需要收窄
        if (ts.isNonNullExpression(parent.expression)) {
            return false;
        }
    }
    return true;
}

exports.UniXCompiler = UniXCompiler;
exports.initTargetHacker = initTargetHacker;
exports.initTargetTransformers = initTargetTransformers;
