'use strict';

var fs = require('fs');
var path = require('path');
var debug = require('debug');
var module$1 = require('module');
var pluginutils = require('@rollup/pluginutils');
var safe = require('colors/safe');
var events = require('events');
var findCacheDir = require('find-cache-dir');
var _ = require('lodash');
var semver = require('semver');
var sourceMapJs = require('source-map-js');
var codeFrame = require('@babel/code-frame');
var fs$1 = require('fs-extra');
var graphlib = require('graphlib');
var objHash = require('object-hash');
var url = require('url');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs);
var path__namespace = /*#__PURE__*/_interopNamespaceDefault(path);
var ___namespace = /*#__PURE__*/_interopNamespaceDefault(_);
var fs__namespace$1 = /*#__PURE__*/_interopNamespaceDefault(fs$1);

function createUTSHelper(context) {
    return context.factory.createIdentifier("UTS" /* IDENTIFIER.UTS */);
}

// 这些是uts插件类型的声明文件
function normalizePath(id) {
    return id.replace(/\\/g, '/');
}

const fsExistsMap = new Map();
function fsExistsSync(p) {
    const normalizedPath = normalizePath(p);
    if (fsExistsMap.has(normalizedPath)) {
        return fsExistsMap.get(normalizedPath);
    }
    if (fs__namespace.existsSync(normalizedPath)) {
        fsExistsMap.set(normalizedPath, true);
        return true;
    }
    fsExistsMap.set(normalizedPath, false);
    return false;
}

var DiagnosticCategory;
(function (DiagnosticCategory) {
    DiagnosticCategory[DiagnosticCategory["Warning"] = 0] = "Warning";
    DiagnosticCategory[DiagnosticCategory["Error"] = 1] = "Error";
    DiagnosticCategory[DiagnosticCategory["Suggestion"] = 2] = "Suggestion";
    DiagnosticCategory[DiagnosticCategory["Message"] = 3] = "Message";
})(DiagnosticCategory || (DiagnosticCategory = {}));

// <auto-generated />
// generated from 'packages/shared/src/diagnosticMessages.json'
function diag$1(code, category, key, message, reportsUnnecessary, elidedInCompatabilityPyramid, reportsDeprecated) {
    return { code, category, key, message, reportsUnnecessary, elidedInCompatabilityPyramid, reportsDeprecated };
}
/** @internal */
const UTSDiagnostics = {
    Type_literal_property_must_have_a_type_annotation: diag$1(100000, DiagnosticCategory.Error, "Type_literal_property_must_have_a_type_annotation_100000", "Type literal property must have a type annotation."),
    Only_one_extends_heritage_clause_is_allowed_for_interface: diag$1(100001, DiagnosticCategory.Error, "Only_one_extends_heritage_clause_is_allowed_for_interface_100001", "Only one extends heritage clause is allowed for interface"),
    Variable_declaration_must_have_initializer: diag$1(100002, DiagnosticCategory.Error, "Variable_declaration_must_have_initializer_100002", "Variable declaration must have initializer."),
    Nested_type_literal_is_not_supported: diag$1(100003, DiagnosticCategory.Error, "Nested_type_literal_is_not_supported_100003", "Nested type literal is not supported."),
    Invalid_generic_type_which_can_not_be_constructed: diag$1(100004, DiagnosticCategory.Error, "Invalid_generic_type_which_can_not_be_constructed_100004", "Invalid generic type which can not be constructed."),
    script_setup_cannot_contain_ES_module_exports: diag$1(100005, DiagnosticCategory.Error, "script_setup_cannot_contain_ES_module_exports_100005", "`<script setup>` cannot contain ES module exports."),
    Type_aliases_cannot_appear_in_local_scope: diag$1(100006, DiagnosticCategory.Error, "Type_aliases_cannot_appear_in_local_scope_100006", "Type aliases cannot appear in local scope"),
    direct_declaration_of_Object_Literal_Type_is_not_supported: diag$1(110111101, DiagnosticCategory.Error, "direct_declaration_of_Object_Literal_Type_is_not_supported_110111101", "direct declaration of Object Literal Type is not supported."),
    Object_literals_only_support_object_types_defined_by_construction_type_and_do_not_support_interfaces: diag$1(110111163, DiagnosticCategory.Error, "Object_literals_only_support_object_types_defined_by_construction_type_and_do_not_support_interfaces_110111163", "Object literals only support object types defined by construction type, and do not support interfaces"),
    Conditional_statements_must_use_boolean_types: diag$1(110111120, DiagnosticCategory.Error, "Conditional_statements_must_use_boolean_types_110111120", "Conditional statements must use boolean types"),
};

const uniModulesPath$2 = normalizePath(path__namespace.resolve((process.env.UNI_INPUT_DIR || ''), 'uni_modules'));

const defineMethodList = [
    "defineComponent" /* IDENTIFIER.DEFINE_COMPONENT */,
    "defineVaporComponent" /* IDENTIFIER.DEFINE_VAPOR_COMPONENT */,
    "defineApp" /* IDENTIFIER.DEFINE_APP */,
    "defineAsyncComponent" /* IDENTIFIER.DEFINE_ASYNC_COMPONENT */,
    "defineMixin" /* IDENTIFIER.DEFINE_MIXIN */,
];
function isDefineMethod(name) {
    return defineMethodList.some((defineMethod) => {
        return name === defineMethod || name === '_' + defineMethod;
    });
}
function createTsUtils(ts, typeChecker, // parse阶段不传
context) {
    function isImportedSymbol(symbol) {
        /**
         * import x from 'xx'
         * import { x } from 'xx'
         */
        return !!(symbol.declarations &&
            symbol.declarations.some((declaration) => {
                return (ts.isImportSpecifier(declaration) ||
                    (ts.isImportClause(declaration) && declaration.name));
            }));
    }
    function getOriginalType(type) {
        // @ts-ignore
        return type?.constraintType?.origin?.type || type;
    }
    function isObjectLiteralType(type) {
        if (!type) {
            return false;
        }
        // TODO 优化此处判断逻辑
        if (type.symbol?.escapedName === '__object') {
            return true;
        }
        // @ts-ignore
        const flags = type?.objectFlags;
        if (flags &&
            (flags & ts.ObjectFlags.ObjectLiteral ||
                flags & ts.ObjectFlags.FreshLiteral)) {
            return true;
        }
        const symbol = type.getSymbol();
        if (symbol && symbol.flags & ts.SymbolFlags.ObjectLiteral) {
            return true;
        }
        return false;
    }
    function isPossibleNullType(type) {
        if (!type) {
            return false;
        }
        const nullType = typeChecker.getNullType();
        // @ts-ignore
        return typeChecker.isTypeAssignableTo(nullType, type);
    }
    function isPossiblePromiseNullType(type) {
        if (!type) {
            return false;
        }
        // @ts-ignore
        return isPossibleNullType(typeChecker.getPromisedTypeOfPromise(type));
    }
    function isPossibleUTSJSONObjectType(type, ignoreUnresolved = false) {
        /**
         * 以下三种情况都认为是可能的UTSJSONObject类型，进行转化
         * - 未知类型
         * - UTSJSONObject类型
         * - 联合类型，其中包含UTSJSONObject类型
         */
        if (!type) {
            return !ignoreUnresolved;
        }
        // const orginalType = getOriginalType(type)
        // return orginalType.symbol?.escapedName === IDENTIFIER.UTSJSONObject
        return ((type.isUnion() &&
            type.types.some((type) => getOriginalType(type).symbol?.escapedName ===
                "UTSJSONObject" /* IDENTIFIER.UTSJSONObject */)) ||
            getOriginalType(type).symbol?.escapedName === "UTSJSONObject" /* IDENTIFIER.UTSJSONObject */);
    }
    function isUnionWithNullType(typeNode) {
        return !!(typeNode &&
            ts.isUnionTypeNode(typeNode) &&
            typeNode.types.some((type) => ts.isLiteralTypeNode(type) &&
                type.literal.kind === ts.SyntaxKind.NullKeyword));
    }
    /**
     * 获取对象字面量方法名节点
     */
    function getMethodNameNodeOfObjectLiteral(node) {
        if (ts.isMethodDeclaration(node)) {
            return node.name;
        }
        const parent = node.parent;
        if (!ts.isPropertyAssignment(parent)) {
            return;
        }
        const propertyName = parent.name;
        return ts.isIdentifier(propertyName) ? propertyName : undefined;
    }
    function createTypeNodeWithNullType(typeNode, withQuestionToken) {
        const factory = context.factory;
        const unionWithNullType = isUnionWithNullType(typeNode);
        let realMemberType = typeNode;
        if (withQuestionToken && !unionWithNullType) {
            // 尝试为memberType添加null类型
            if (ts.isUnionTypeNode(typeNode)) {
                realMemberType = factory.createUnionTypeNode([
                    ...typeNode.types,
                    factory.createLiteralTypeNode(factory.createNull()),
                ]);
            }
            else {
                realMemberType = factory.createUnionTypeNode([
                    typeNode,
                    factory.createLiteralTypeNode(factory.createNull()),
                ]);
            }
        }
        return realMemberType;
    }
    function isVueOrNativeParameter(node) {
        if (!node.parent) {
            return false;
        }
        if (ts.isPropertyAssignment(node.parent) &&
            node.parent.parent &&
            ts.isObjectLiteralExpression(node.parent.parent)) {
            return isVueOrNativeParameter(node.parent.parent);
        }
        if (!ts.isCallExpression(node.parent)) {
            return false;
        }
        else if (node.parent.expression.pos === -1) {
            // uts编译器生成的节点如果期望转为UTSJSONObject，会在parse阶段生成AsExpression节点
            return true;
        }
        const exprType = typeChecker.getTypeAtLocation(node.parent.expression);
        if (!exprType) {
            return false;
        }
        const callDecl = exprType.getCallSignatures()?.[0]?.declaration;
        if (!callDecl) {
            return false;
        }
        const fileName = callDecl.getSourceFile().fileName;
        const rawFileName = fileName.replace(/\\/g, '/').split('/').pop();
        return (fileName.endsWith('runtime-core.d.ts') ||
            (rawFileName && /lib\.es(\d+|next)\..*d.ts/.test(rawFileName)));
    }
    /**
     * 父级节点不是AsExpression时方可调用此方法，用于规避parse阶段生成的AsExpression节点
     * 基于如下两个原因，这里不使用isTypeAssignableTo判断UTSJSONObject类型是否能赋值给contextualType类型
     * - uts规范下开发者不能写复杂类型
     * - parse阶段hack了UTSJSONObject类型和Object类型的关系，导致如果一个类型的所有属性都是可选时，isTypeAssignableTo(UTSJONObject, contextualType)会返回true
     */
    function shouldTransfromToUTSJSONObject(node, contextualType) {
        if (!contextualType || contextualType === typeChecker.getAnyType()) {
            return true;
        }
        if (contextualType.isUnion()) {
            return contextualType.types.some((type) => {
                return shouldTransfromToUTSJSONObject(node, type);
            });
        }
        if (contextualType.isIntersection()) {
            return contextualType.types.every((type) => {
                return typeChecker.isTypeAssignableTo(typeChecker.getGlobalType("UTSJSONObject" /* IDENTIFIER.UTSJSONObject */, 
                /*arity*/ 0, true), contextualType);
            });
        }
        const symbol = contextualType.getSymbol() || contextualType.aliasSymbol;
        if (!symbol && !contextualType.isClassOrInterface()) {
            // 各种基础类型，number、string、boolean、null、undefined、void、never等
            return false;
        }
        /**
         * 难点：编译为js时是无法准确判断一个对象字面量是不是需要编译为UTSJSONObject的。目前的方案算是贪婪模式，可能是UTSJSONObject的都编译为UTSJSONObject。特殊情况提前排除
         */
        return (!symbol ||
            symbol?.escapedName === '__object' ||
            symbol?.escapedName === 'UTSJSONObject' ||
            typeChecker.isTypeAssignableTo(typeChecker.getGlobalType("UTSJSONObject" /* IDENTIFIER.UTSJSONObject */, 
            /*arity*/ 0, true), contextualType));
    }
    function isDefineComponentCall(callExpression) {
        if (!callExpression || !ts.isCallExpression(callExpression)) {
            return false;
        }
        const defineComponentFunctionName = callExpression.expression;
        if (!defineComponentFunctionName ||
            !ts.isIdentifier(defineComponentFunctionName) ||
            !isDefineMethod(defineComponentFunctionName.escapedText.toString())) {
            return false;
        }
        return true;
    }
    function isComponentOptions(node) {
        const callExpression = node?.parent;
        return callExpression && isDefineComponentCall(callExpression);
    }
    function isComponentOptionsProperty(node) {
        const callExpression = node?.parent?.parent?.parent;
        return callExpression && isDefineComponentCall(callExpression);
    }
    function isComponentProp(node) {
        const grandParent = node.parent?.parent;
        const greatGrandParent = grandParent?.parent;
        return (grandParent &&
            greatGrandParent &&
            ts.isObjectLiteralExpression(grandParent) &&
            ts.isPropertyAssignment(greatGrandParent) &&
            ts.isIdentifier(greatGrandParent.name) &&
            greatGrandParent.name.escapedText.toString() === 'props' &&
            isComponentOptionsProperty(grandParent));
    }
    /**
     * 判断是否为组件data或provide，此方法不能完美判断如下情况，后续再找更佳方案
     *
     * data() {
     *   const a = {a: 1}
     *   return a
     * }
     */
    function isComponentDataOrProvide(node) {
        const returnExpression = node.parent;
        if (!returnExpression || !ts.isReturnStatement(returnExpression)) {
            return false;
        }
        const containingFunction = returnExpression?.parent?.parent;
        if (!containingFunction || !ts.isMethodDeclaration(containingFunction)) {
            return false;
        }
        const functionName = containingFunction.name;
        if (!functionName ||
            !ts.isIdentifier(functionName) ||
            (functionName.escapedText.toString() !== 'data' &&
                functionName.escapedText.toString() !== 'provide')) {
            return false;
        }
        const callExpression = containingFunction?.parent?.parent;
        return isDefineComponentCall(callExpression);
    }
    function isCreateAppReturnValue(node) {
        if (process.env.UNI_INPUT_DIR &&
            normalizePath(path.resolve(process.env.UNI_INPUT_DIR, 'main.uts')) ===
                normalizePath(node.getSourceFile().fileName) &&
            node.parent &&
            ts.isReturnStatement(node.parent)) {
            const containingFunction = node?.parent?.parent?.parent;
            if (containingFunction &&
                ts.isFunctionDeclaration(containingFunction) &&
                containingFunction.name &&
                ts.isIdentifier(containingFunction.name) &&
                containingFunction.name.escapedText.toString() === 'createApp') {
                return true;
            }
        }
    }
    // 简单判断一下是否为setup返回值，继续向上查找浪费性能
    function isSetupReturnValue(node) {
        const parent = node.parent;
        return (parent &&
            ts.isVariableDeclaration(parent) &&
            parent.name &&
            ts.isIdentifier(parent.name) &&
            parent.name.escapedText.toString() === '___returned__');
    }
    return {
        ts,
        typeChecker,
        context,
        isImportedSymbol,
        isPossibleUTSJSONObjectType,
        isPossibleNullType,
        isPossiblePromiseNullType,
        createTypeNodeWithNullType,
        isUnionWithNullType,
        isObjectLiteralType,
        getMethodNameNodeOfObjectLiteral,
        shouldTransfromToUTSJSONObject,
        isVueOrNativeParameter,
        isComponentDataOrProvide,
        isComponentOptions,
        isComponentOptionsProperty,
        isComponentProp,
        isCreateAppReturnValue,
        isSetupReturnValue,
    };
}
const CONTEXTUAL_TYPE_NODE_KINDS = [
    260 /* VariableDeclaration */, 169 /* Parameter */,
    172 /* PropertyDeclaration */, 171 /* PropertySignature */,
    208 /* BindingElement */, 219 /* ArrowFunction */, 253 /* ReturnStatement */,
    229 /* YieldExpression */, 223 /* AwaitExpression */,
    213 /* CallExpression */, 214 /* NewExpression */, 170 /* Decorator */,
    216 /* TypeAssertionExpression */, 234 /* AsExpression */,
    226 /* BinaryExpression */, 303 /* PropertyAssignment */,
    304 /* ShorthandPropertyAssignment */, 305 /* SpreadAssignment */,
    209 /* ArrayLiteralExpression */, 227 /* ConditionalExpression */,
    239 /* TemplateSpan */, 217 /* ParenthesizedExpression */,
    235 /* NonNullExpression */, 238 /* SatisfiesExpression */,
    277 /* ExportAssignment */, 294 /* JsxExpression */, 291 /* JsxAttribute */,
    293 /* JsxSpreadAttribute */, 286 /* JsxOpeningElement */,
    285 /* JsxSelfClosingElement */,
];

function isSymbolTransformable(tsUtils, symbol) {
    const { ts } = tsUtils;
    const declarations = symbol?.declarations;
    if (declarations?.length !== 1) {
        return false;
    }
    const declaration = declarations[0];
    if (ts.isClassDeclaration(declaration)) {
        const isUTSType = declaration.heritageClauses?.some((heritageClause) => {
            return (heritageClause.token === ts.SyntaxKind.ExtendsKeyword &&
                heritageClause.types.some((type) => {
                    return (isTempUTSTypeNode(tsUtils, type.expression) ||
                        isUTSTypeNode(tsUtils, type.expression));
                }));
        });
        return isUTSType;
    }
    return false;
}
function isNodeTransformable(tsUtils, node) {
    const typeChecker = tsUtils.typeChecker;
    const type = typeChecker.getContextualType(node);
    return !!(type && isTypeTransformable(tsUtils, type));
}
function isTypeTransformable(tsUtils, type) {
    return type.symbol && isSymbolTransformable(tsUtils, type.symbol);
}
function createTempUTSTypeNode(tsUtils) {
    const context = tsUtils.context;
    const factory = context.factory;
    const ts = tsUtils.ts;
    // (glbalThis as any).UTSType
    return factory.createPropertyAccessExpression(factory.createParenthesizedExpression(factory.createAsExpression(factory.createIdentifier("globalThis" /* IDENTIFIER.GLOBAL_THIS */), factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword))), factory.createIdentifier("UTSType" /* IDENTIFIER.UTS_TYPE */));
}
function isTempUTSTypeNode(tsUtils, node) {
    const ts = tsUtils.ts;
    if (!ts.isPropertyAccessExpression(node)) {
        return false;
    }
    const { expression, name } = node;
    return (ts.isIdentifier(name) &&
        name.escapedText === "UTSType" /* IDENTIFIER.UTS_TYPE */ &&
        ts.isParenthesizedExpression(expression) &&
        ts.isAsExpression(expression.expression) &&
        ts.isIdentifier(expression.expression.expression) &&
        expression.expression.expression.escapedText === "globalThis" /* IDENTIFIER.GLOBAL_THIS */);
}
function isUTSTypeClass(tsUtils, node) {
    const ts = tsUtils.ts;
    if (!ts.isClassDeclaration(node)) {
        return false;
    }
    const { heritageClauses } = node;
    const parentClass = heritageClauses?.[0]?.types?.[0]?.expression;
    if (parentClass && isTempUTSTypeNode(tsUtils, parentClass)) {
        return true;
    }
    return false;
}
function isUTSTypeNode(tsUtils, node) {
    const ts = tsUtils.ts;
    if (!ts.isPropertyAccessExpression(node)) {
        return false;
    }
    const { expression, name } = node;
    return (ts.isIdentifier(name) &&
        name.escapedText === "UTS" /* IDENTIFIER.UTS */ &&
        ts.isIdentifier(expression) &&
        expression.escapedText === "UTSType" /* IDENTIFIER.UTS_TYPE */);
}
function createRuntimeTypeNode(tsUtils, type) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const factory = context.factory;
    const typeChecker = tsUtils.typeChecker;
    const unknown = factory.createStringLiteral('Unknown');
    if (tsUtils.isUnionWithNullType(type) && type.types.length === 2) {
        // xxx | null 直接按照 xxx 类型处理，并同时添加optional: true标记
        type = type.types.find((item) => item.kind !== ts.SyntaxKind.NullKeyword);
    }
    // 注意此方法未支持所有typeNode类型，仅支持如下情况
    if (ts.isTypeReferenceNode(type)) {
        const { typeName, typeArguments } = type;
        if (!ts.isIdentifier(typeName)) {
            return unknown;
        }
        const symbol = typeChecker.getSymbolAtLocation(typeName);
        const declaration = symbol?.declarations?.[0];
        if (!declaration || !isUTSTypeClass(tsUtils, declaration)) {
            return unknown;
        }
        if (!typeArguments) {
            return factory.createIdentifier(typeName.escapedText.toString());
        }
        return factory.createCallExpression(factory.createPropertyAccessExpression(createTempUTSTypeNode(tsUtils), factory.createIdentifier('withGenerics')), undefined, [
            factory.createIdentifier(typeName.escapedText.toString()),
            factory.createArrayLiteralExpression([
                ...typeArguments.map((typeArgument) => createRuntimeTypeNode(tsUtils, typeArgument)),
            ], false),
        ]);
    }
    else if (ts.isArrayTypeNode(type)) {
        return factory.createCallExpression(factory.createPropertyAccessExpression(createTempUTSTypeNode(tsUtils), factory.createIdentifier('withGenerics')), undefined, [
            factory.createIdentifier('Array'),
            factory.createArrayLiteralExpression([createRuntimeTypeNode(tsUtils, type.elementType)], false),
        ]);
    }
    else if (ts.isTypeLiteralNode(type)) {
        context.addSemanticDiagnostic(ts.createDiagnosticForNode(type, UTSDiagnostics.Nested_type_literal_is_not_supported));
    }
    else if (type.kind === ts.SyntaxKind.NumberKeyword) {
        return factory.createIdentifier('Number');
    }
    else if (type.kind === ts.SyntaxKind.StringKeyword) {
        return factory.createIdentifier('String');
    }
    else if (type.kind === ts.SyntaxKind.BooleanKeyword) {
        return factory.createIdentifier('Boolean');
    }
    else if (type.kind === ts.SyntaxKind.AnyKeyword) {
        return factory.createStringLiteral('Any');
    }
    return unknown;
}
/**
 * class A {
 *   a: number
 *   protected b(){
 *   }
 *   constructor(a: number) {
 *     this.a = a
 *   }
 * }
 *
 * // 错误 Property 'b' is missing in type '{ a: number; }' but required in type 'A'.
 * const a: A = {
 *   a: 1,
 * }
 *
 * // 正确
 * const a = {
 *   a: 1
 * } as A
 */
function createStaticGetUTSMetadataNode(tsUtils, typeParameters, metadata) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const factory = context.factory;
    return factory.createMethodDeclaration([factory.createToken(ts.SyntaxKind.StaticKeyword)], undefined, factory.createIdentifier('get' + "$UTSMetadata$" /* IDENTIFIER.UTS_METADATA */), undefined, undefined, typeParameters
        ? [
            ...typeParameters.map((typeParameter) => {
                return factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier(typeParameter.name.escapedText.toString()), factory.createToken(ts.SyntaxKind.QuestionToken), factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword), undefined);
            }),
        ]
        : [], undefined, factory.createBlock([
        factory.createReturnStatement(factory.createAsExpression(metadata, factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword))),
    ], true));
}
// class和interface使用此方法，不记录字段名，仅记录类型与继承关系，此方法在parse阶段调用
function createBasicUTSMetadataNode(tsUtils, name, kind, interfaceNameList) {
    const context = tsUtils.context;
    const factory = context.factory;
    const utsMetadataNodeMembers = [
        factory.createPropertyAssignment(factory.createIdentifier('kind'), factory.createNumericLiteral(kind)),
        factory.createPropertyAssignment(factory.createIdentifier('interfaces'), factory.createArrayLiteralExpression(interfaceNameList, false)),
    ];
    if (process.env.NODE_ENV === 'development') {
        utsMetadataNodeMembers.push(factory.createPropertyAssignment(factory.createIdentifier('name'), factory.createStringLiteral(name)));
    }
    return [
        createStaticGetUTSMetadataNode(tsUtils, undefined, factory.createObjectLiteralExpression(utsMetadataNodeMembers, true)),
    ];
}
// type字面量声明使用此方法，此方法在transform阶段执行
function createTypeUTSMetadataNode(tsUtils, name, kind, members, typeParameters) {
    const context = tsUtils.context;
    const factory = context.factory;
    // { kind: 0, interfaces: [] }
    const utsMetadataNodeMembers = [
        factory.createPropertyAssignment(factory.createIdentifier('kind'), factory.createNumericLiteral(kind)),
        /**
         * get fields() {
         *   return {
         *     a: {
         *       type: Number,
         *       optional: false,
         *       jsonField: 'a_b',
         *     },
         *   }
         * }
         */
        factory.createGetAccessorDeclaration(undefined, factory.createIdentifier('fields'), [], undefined, factory.createBlock([
            factory.createReturnStatement(factory.createObjectLiteralExpression([
                ...members.map((member) => {
                    let jsonField = '';
                    // ts.getJSDocTags 无法获取member的jsDoc，暂未排查原因，先通过下面的方式绕过
                    // @ts-ignore
                    const jsDoc = (member.jsDoc || []);
                    jsDoc.forEach((jsDocItem) => {
                        const tags = jsDocItem.tags || [];
                        tags.forEach((item) => {
                            if (item.tagName.escapedText === "JSON_FIELD" /* IDENTIFIER.JSON_FIELD */ &&
                                typeof item.comment === 'string') {
                                const commentLength = item.comment.length;
                                if ((item.comment[0] === "'" &&
                                    item.comment[commentLength - 1] === "'") ||
                                    (item.comment[0] === '"' &&
                                        item.comment[commentLength - 1] === '"')) {
                                    jsonField = item.comment.slice(1, -1);
                                }
                                else {
                                    jsonField = item.comment;
                                }
                            }
                        });
                    });
                    const fieldInfoObjectElements = [
                        factory.createPropertyAssignment(factory.createIdentifier('type'), createRuntimeTypeNode(tsUtils, member.type)),
                        factory.createPropertyAssignment(factory.createIdentifier('optional'), member.questionToken ||
                            tsUtils.isUnionWithNullType(member.type)
                            ? factory.createTrue()
                            : factory.createFalse()),
                    ];
                    if (jsonField) {
                        fieldInfoObjectElements.push(factory.createPropertyAssignment(factory.createIdentifier('jsonField'), factory.createStringLiteral(jsonField)));
                    }
                    return factory.createPropertyAssignment(factory.createIdentifier(member.name.escapedText.toString()), factory.createObjectLiteralExpression(fieldInfoObjectElements));
                }),
            ], true)),
        ], true)),
    ];
    if (process.env.NODE_ENV === 'development') {
        utsMetadataNodeMembers.push(factory.createPropertyAssignment(factory.createIdentifier('name'), factory.createStringLiteral(name)));
    }
    return [
        createStaticGetUTSMetadataNode(tsUtils, typeParameters, factory.createObjectLiteralExpression(utsMetadataNodeMembers, true)),
    ];
}

function addUTSMetadataNodeForClassIfNeeded(tsUtils, node) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const typeChecker = tsUtils.typeChecker;
    // 仅为impements添加utsMetadataNode
    const factory = context.factory;
    const heritageClauses = node.heritageClauses;
    if (!heritageClauses) {
        return node;
    }
    const implementsHeritageClauses = heritageClauses.filter((item) => {
        return item.token === ts.SyntaxKind.ImplementsKeyword;
    });
    if (implementsHeritageClauses.length !== 1) {
        return node;
    }
    const types = implementsHeritageClauses[0].types;
    const interfaceNameList = [];
    for (let i = 0; i < types.length; i++) {
        const type = types[i];
        if (!type.expression || !ts.isIdentifier(type.expression)) {
            continue;
        }
        const symbol = typeChecker.getSymbolAtLocation(type.expression);
        const declarations = symbol?.declarations || [];
        if (declarations.length !== 1) {
            continue;
        }
        const declaration = declarations[0];
        if (!ts.isClassDeclaration(declaration)) {
            continue;
        }
        interfaceNameList.push(type.expression);
    }
    if (interfaceNameList.length === 0) {
        return node;
    }
    const className = node.name ? node.name.escapedText.toString() : '';
    return factory.updateClassDeclaration(node, node.modifiers, node.name, node.typeParameters, node.heritageClauses, [
        ...createBasicUTSMetadataNode(tsUtils, className, 0 /* UTS_CLASS_METADATA_KIND.CLASS */, interfaceNameList),
        ...node.members,
    ]);
}
const transformClassImplements = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const typeChecker = program.getTypeChecker();
            const tsUtils = createTsUtils(ts, typeChecker, context);
            const visitor = (node) => {
                if (ts.isClassDeclaration(node)) {
                    node = addUTSMetadataNodeForClassIfNeeded(tsUtils, node);
                }
                node = ts.visitEachChild(node, visitor, context);
                return node;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

globalThis.__utsUniXGlobalProperties__ =
    globalThis.__utsUniXGlobalProperties__ || new Map();
/**
 * .config.
 */
const transformComponentExtraProperty = (ts) => {
    return {
        parser: {
            SourceFile(context) {
                return (sourceFile) => {
                    const sourceFileName = sourceFile.fileName;
                    const globalPropertiesMap = globalThis
                        ?.__utsUniXGlobalProperties__;
                    if (globalPropertiesMap) {
                        for (const [key, value] of globalPropertiesMap) {
                            if (value.file === sourceFileName) {
                                globalPropertiesMap.delete(key);
                            }
                        }
                    }
                    function visitNode(node) {
                        const updatedNode = ts.visitEachChild(node, visitNode, context);
                        if (ts.isBinaryExpression(updatedNode)) {
                            const { left, operatorToken, right } = updatedNode;
                            if (operatorToken.kind === ts.SyntaxKind.EqualsToken) {
                                if (ts.isPropertyAccessExpression(left)) {
                                    const { expression: globalPropertiesExpression, name: globalPropertyName, } = left;
                                    if (ts.isPropertyAccessExpression(globalPropertiesExpression)) {
                                        const { expression: appConfigExpression, name: globalPropertiesIdentifier, } = globalPropertiesExpression;
                                        if (globalPropertiesIdentifier.escapedText.toString() ===
                                            'globalProperties' &&
                                            ts.isPropertyAccessExpression(appConfigExpression)) {
                                            const { name: configIdentifier } = appConfigExpression;
                                            if (configIdentifier.escapedText.toString() === 'config') {
                                                globalPropertiesMap.set(globalPropertyName.escapedText.toString(), {
                                                    file: sourceFileName,
                                                    initializerNode: right,
                                                });
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return updatedNode;
                    }
                    return visitNode(sourceFile);
                };
            },
        },
    };
};

/**
 * 1. 将 import xxx from 'xxx.uts' 转换为 import xxx from 'xxx'
 * @param ts
 * @returns
 */
const transformImportDeclaration = (ts, ls) => {
    return {
        parser: {
            SourceFile(context) {
                const factory = context.factory;
                function parseSpecifier(text) {
                    if (text.endsWith('.uts') || text.endsWith('.ts')) {
                        return text.replace(/.u?ts$/, '');
                    }
                }
                let commentDirectives = [];
                function visitor(node) {
                    const updatedNode = ts.visitEachChild(node, visitor, context);
                    if (ts.isImportDeclaration(updatedNode) ||
                        ts.isExportDeclaration(updatedNode)) {
                        let moduleSpecifier = updatedNode.moduleSpecifier;
                        if (moduleSpecifier && ts.isStringLiteral(moduleSpecifier)) {
                            const text = moduleSpecifier.text;
                            const uniModuleNameReg = /@\/uni_modules\/([a-zA-Z0-9_-]+)/;
                            const uniModuleName = text.match(uniModuleNameReg)?.[1];
                            if (uniModuleName) {
                                const encryptPath = path__namespace.resolve(uniModulesPath$2, uniModuleName, 'encrypt');
                                if (fsExistsSync(encryptPath)) {
                                    commentDirectives.push({
                                        range: {
                                            pos: Math.max(updatedNode.pos - 1, 0),
                                            end: updatedNode.pos,
                                        },
                                        type: 1,
                                    });
                                }
                            }
                        }
                    }
                    if (ts.isImportDeclaration(updatedNode) &&
                        updatedNode.moduleSpecifier &&
                        ts.isStringLiteral(updatedNode.moduleSpecifier)) {
                        const specifier = parseSpecifier(updatedNode.moduleSpecifier.text);
                        if (specifier) {
                            return factory.createImportDeclaration(updatedNode.modifiers, updatedNode.importClause, factory.createStringLiteral(specifier), updatedNode.assertClause);
                        }
                    }
                    if (ts.isExportDeclaration(updatedNode) &&
                        updatedNode.moduleSpecifier &&
                        ts.isStringLiteral(updatedNode.moduleSpecifier)) {
                        const specifier = parseSpecifier(updatedNode.moduleSpecifier.text);
                        if (specifier) {
                            return factory.createExportDeclaration(updatedNode.modifiers, false, // isTypeOnly
                            updatedNode.exportClause, factory.createStringLiteral(specifier), updatedNode.assertClause);
                        }
                        else if (updatedNode.isTypeOnly) {
                            return factory.createExportDeclaration(updatedNode.modifiers, false, // isTypeOnly
                            updatedNode.exportClause, updatedNode.moduleSpecifier, updatedNode.assertClause);
                        }
                    }
                    if (ts.isImportClause(updatedNode) && updatedNode.isTypeOnly) {
                        return factory.createImportClause(false, // isTypeOnly
                        updatedNode.name, updatedNode.namedBindings);
                    }
                    else if (ts.isImportSpecifier(updatedNode) &&
                        updatedNode.isTypeOnly) {
                        return factory.createImportSpecifier(false, // isTypeOnly
                        updatedNode.propertyName, updatedNode.name);
                    }
                    else if (ts.isExportSpecifier(updatedNode) &&
                        updatedNode.isTypeOnly) {
                        return factory.createExportSpecifier(false, // isTypeOnly
                        updatedNode.propertyName, updatedNode.name);
                    }
                    return updatedNode;
                }
                return (sourceFile) => {
                    sourceFile = ts.visitNode(sourceFile, visitor);
                    if (commentDirectives.length > 0) {
                        // @ts-ignore
                        sourceFile.commentDirectives =
                            // @ts-ignore
                            sourceFile.commentDirectives || [];
                        // @ts-ignore
                        sourceFile.commentDirectives.push(...commentDirectives);
                        commentDirectives.length = 0;
                    }
                    return sourceFile;
                };
            },
        },
    };
};

function generateImportSymbolFromSourceFile(tsUtils, sourceFile, symbol, alias) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const typeChecker = tsUtils.typeChecker;
    let exportSymbolName = '';
    const symbolDeclarations = symbol?.declarations || [];
    const declarationLength = symbolDeclarations.length;
    if (declarationLength !== 1) {
        return;
    }
    // @ts-expect-error
    const exports = sourceFile.symbol?.exports;
    for (const exportKey of exports.keys()) {
        const exportSymbolDeclarations = exports.get(exportKey).declarations || [];
        if (exportSymbolDeclarations.length !== 1) {
            continue;
        }
        const exportSymbolDeclaration = exportSymbolDeclarations[0];
        let symbolToCheck;
        let exportNodeToCheck;
        if (ts.isClassDeclaration(exportSymbolDeclaration)) {
            exportNodeToCheck = exportSymbolDeclaration.name;
        }
        else if (ts.isExportAssignment(exportSymbolDeclaration)) {
            exportNodeToCheck = exportSymbolDeclaration.expression;
        }
        else if (ts.isExportSpecifier(exportSymbolDeclaration)) {
            exportNodeToCheck = exportSymbolDeclaration.name;
        }
        symbolToCheck =
            exportNodeToCheck &&
                (typeChecker.getContextualType(exportNodeToCheck)
                    ?.symbol ||
                    typeChecker.getTypeAtLocation(exportNodeToCheck)?.symbol);
        if (symbolToCheck === symbol) {
            exportSymbolName = exportKey;
            break;
        }
    }
    if (!exportSymbolName) {
        return;
    }
    const factory = context.factory;
    const aliasIdentifier = factory.createIdentifier(alias);
    if (exportSymbolName === 'default') {
        return factory.createImportDeclaration(undefined, factory.createImportClause(false, aliasIdentifier, undefined), factory.createStringLiteral(sourceFile.fileName), undefined);
    }
    return factory.createImportDeclaration(undefined, factory.createImportClause(false, undefined, factory.createNamedImports([
        factory.createImportSpecifier(false, exportSymbolName !== alias
            ? factory.createIdentifier(exportSymbolName)
            : undefined, aliasIdentifier),
    ])), factory.createStringLiteral(sourceFile.fileName), undefined);
}
// function setSymbolReferenced(symbol: tsTypes.Symbol, referenced: boolean) {
//   // @ts-ignore
//   symbol.links
// }
function getObjectLiteralTypeNode(tsUtils, node, symbolAutoImportMap) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const typeChecker = tsUtils.typeChecker;
    const factory = context.factory;
    const originalNode = (ts.getOriginalNode(node) ||
        node);
    if ((originalNode.flags & ts.NodeFlags.Synthesized) ===
        ts.NodeFlags.Synthesized) {
        return;
    }
    /**
     * main.uts的createApp返回值及任意文件的setup函数的返回值不转化为UTSJSONObject
     */
    const tempParent = originalNode?.parent;
    if ((tempParent && ts.isAsExpression(tempParent)) ||
        tsUtils.isComponentDataOrProvide(originalNode) ||
        tsUtils.isComponentOptions(originalNode) ||
        tsUtils.isComponentOptionsProperty(originalNode) ||
        tsUtils.isComponentProp(originalNode) ||
        tsUtils.isCreateAppReturnValue(originalNode)) {
        return;
    }
    const containerNode = ts.getContainerNode(originalNode);
    if (containerNode &&
        ts.isMethodDeclaration(containerNode) &&
        containerNode.modifiers &&
        containerNode.modifiers.some((modifier) => modifier.kind === ts.SyntaxKind.StaticKeyword) &&
        ts.isIdentifier(containerNode.name) &&
        containerNode.name.escapedText === 'get' + "$UTSMetadata$" /* IDENTIFIER.UTS_METADATA */) {
        // 生成static get$UTSMetadata$()会在非常早的时机执行，其中的所有代码都不需要转化
        return;
    }
    /**
     * getContextualType内部逻辑非常复杂
     * 目前遇到的问题：页面data内包含对象字面量，onLoad内包含interface，如果先在before阶段转化interface则会导致上层所有节点被修改丢失symbol。导致getContextualType内部报错。
     * 暂时将ObjectLiteral添加as或者转为UTSJSONObject的逻辑移至最早的before内执行
     *
     * 后续可能的解决方案：所有的transformer内仅做标记不进行before阶段转化，最后添加一个读取标记用于生成最终语法树的transformer。
     *
     * TODO 调研更优的解决方案
     * 更新：此问题疑似由介入tsc parse阶段设置parent的操作引发，parse阶段setParent无法去除。
     * 为此问题做了一次调整：parse阶段仅使用create不使用update，避免originalNode混乱，仍然无法消除此问题
     * 目前的解决方案是：contextualType获取两次，一次originalNode的一次node的
     */
    let contextualType;
    try {
        contextualType = typeChecker.getContextualType(originalNode);
    }
    catch (error) {
        try {
            contextualType = typeChecker.getContextualType(node);
        }
        catch (e) { }
    }
    if (tsUtils.shouldTransfromToUTSJSONObject(node, contextualType)) {
        return factory.createTypeReferenceNode("UTSJSONObject" /* IDENTIFIER.UTSJSONObject */, undefined);
    }
    /**
     * 为未声明类型的ObjectLiteral添加as
     */
    const symbol = contextualType.symbol;
    const className = symbol?.escapedName;
    if (!className || !isTypeTransformable(tsUtils, contextualType)) {
        return;
    }
    /**
     * 判断contextualType在当前作用域的可访问性
     * - type声明在同一个文件的可访问位置，无需自动引入即可直接使用
     * - type声明由其他文件导出，需要自动引入
     * - 其他情况不予转化并给出告警？
     */
    // @ts-expect-error 内部方法
    const symbolAccessibilityResult = typeChecker.isSymbolAccessible(symbol, originalNode, ts.SymbolFlags.Class, true);
    if (symbolAccessibilityResult.accessibility !==
        // @ts-expect-error 内部属性
        ts.SymbolAccessibility.Accessible) {
        /*
         * symbol不可通过当前作用域访问，也无法自动引入
         * symbol在同一文件内非全局（注意此场景即使可以访问到也会进入此分支）
         */
        // @ts-expect-error 内部方法
        typeChecker.markSymbolAsNotTypeOnly(symbol);
        return factory.createTypeReferenceNode(typeChecker.symbolToEntityName(symbol, ts.SymbolFlags.Class, node, undefined), undefined);
    }
    // @ts-expect-error 内部方法
    const accessibleSymbolChain = typeChecker.getAccessibleSymbolChain(symbol, originalNode, symbol.flags, false);
    let typeName;
    if (accessibleSymbolChain && accessibleSymbolChain.length > 0) {
        // symbol可通过当前作用域访问，无需自动引入
        typeName = typeChecker.symbolToEntityName(symbol, ts.SymbolFlags.Class, originalNode, undefined);
    }
    else {
        // symbol不可通过当前作用域访问，但是需要自动引入
        const symbolDeclarations = symbol.declarations;
        if (!symbolDeclarations || symbolDeclarations.length !== 1) {
            return;
        }
        const symbolDeclaration = symbolDeclarations[0];
        const symbolDeclarationSourceFile = symbolDeclaration.getSourceFile();
        const sourceFile = originalNode.getSourceFile();
        if (symbolDeclarationSourceFile === sourceFile) {
            // 正常情况下不应进入此条件判断
            return;
        }
        let typeNameStr;
        let importDeclaration;
        if (symbolAutoImportMap.has(symbol)) {
            const cache = symbolAutoImportMap.get(symbol);
            typeNameStr = cache.alias;
            importDeclaration = cache.importDeclaration;
        }
        else {
            const originalTypeNameStr = symbol.escapedName;
            // @ts-ignore
            typeNameStr = ts.getUniqueName(originalTypeNameStr, sourceFile);
            importDeclaration = generateImportSymbolFromSourceFile(tsUtils, symbolDeclarationSourceFile, symbol, typeNameStr);
            if (!importDeclaration) {
                return;
            }
            symbolAutoImportMap.set(symbol, {
                symbol,
                alias: typeNameStr,
                importDeclaration,
            });
        }
        typeName = factory.createIdentifier(typeNameStr);
    }
    // @ts-expect-error 内部方法
    typeChecker.markSymbolAsNotTypeOnly(symbol);
    return factory.createTypeReferenceNode(typeName, undefined);
}
function isAccessedUTSJSONObject(tsUtils, node) {
    const { ts } = tsUtils;
    const parent = node.parent;
    // TODO ((((ObjectLiteralExpression)))).toMap()
    return ((parent &&
        ts.isPropertyAccessExpression(parent) &&
        parent.expression === node) ||
        (ts.isParenthesizedExpression(parent) &&
            parent.parent &&
            ts.isPropertyAccessExpression(parent.parent) &&
            parent.parent.expression === parent));
}
function isUnTypedUTSJSONObjectDeclaration(tsUtils, node) {
    const { ts } = tsUtils;
    const parent = node.parent;
    return parent && ts.isVariableDeclaration(parent) && !parent.type;
}
const transformObjectLiteral = (ts, ls) => {
    return {
        parser: {
            SourceFile(context) {
                const factory = context.factory;
                const tsUtils = createTsUtils(ts, undefined, context);
                const visitor = (node) => {
                    const updatedNode = ts.visitEachChild(node, visitor, context);
                    const parent = updatedNode.parent;
                    // 特殊处理变量声明，转为UTSJSONObject
                    if (parent && ts.isObjectLiteralExpression(updatedNode)) {
                        if (tsUtils.isSetupReturnValue(updatedNode)) {
                            return updatedNode;
                        }
                        if (
                        // 未声明类型的变量
                        isUnTypedUTSJSONObjectDeclaration(tsUtils, updatedNode) ||
                            isAccessedUTSJSONObject(tsUtils, updatedNode) ||
                            ts.isExportAssignment(parent) ||
                            // 无需推断类型的对象字面量
                            !CONTEXTUAL_TYPE_NODE_KINDS.includes(parent.kind)) {
                            return factory.createAsExpression(updatedNode, factory.createTypeReferenceNode(factory.createIdentifier("UTSJSONObject" /* IDENTIFIER.UTSJSONObject */), undefined));
                        }
                    }
                    return updatedNode;
                };
                return (node) => {
                    return ts.visitNode(node, visitor);
                };
            },
        },
        before(context) {
            const { factory } = context;
            const program = ls.getProgram();
            const typeChecker = program.getTypeChecker();
            const tsUtils = createTsUtils(ts, typeChecker, context);
            const symbolAutoImportMap = new Map();
            const visitor = (node) => {
                if (ts.isObjectLiteralExpression(node)) {
                    if (tsUtils.isSetupReturnValue(node)) {
                        return node;
                    }
                    const typeNode = getObjectLiteralTypeNode(tsUtils, node, symbolAutoImportMap);
                    if (typeNode) {
                        return factory.createAsExpression(ts.visitEachChild(node, visitor, context), typeNode);
                    }
                }
                return ts.visitEachChild(node, visitor, context);
            };
            return (node) => {
                const sourceFile = ts.visitNode(node, visitor);
                const importDeclarationList = [];
                for (const cache of symbolAutoImportMap.values()) {
                    importDeclarationList.push(cache.importDeclaration);
                    // @ts-expect-error 内部属性
                    node.locals.set(cache.alias, cache.symbol);
                }
                const updatedStatements = Array.from(sourceFile.statements);
                let insertIndex = 0;
                for (let i = 0; i < updatedStatements.length; i++) {
                    const statement = updatedStatements[i];
                    if (ts.isImportDeclaration(statement)) {
                        insertIndex = i + 1;
                    }
                    else {
                        break;
                    }
                }
                updatedStatements.splice(insertIndex, 0, ...importDeclarationList);
                return factory.updateSourceFile(sourceFile, updatedStatements, sourceFile.isDeclarationFile, sourceFile.referencedFiles, sourceFile.typeReferenceDirectives, sourceFile.hasNoDefaultLib, sourceFile.libReferenceDirectives);
            };
        },
    };
};

/**
 * uts-compiler内部会自动引入vue文件，由于内部hack会导致引入的文件后缀为.u?vue.ts
 * 将 import xxx from 'xxx.u?vue.ts' 转换为 import xxx from 'xxx.u?vue'
 */
const transformRemoveVueTsExtention = (ts) => {
    return {
        before(context) {
            return (node) => {
                node.statements.forEach((node) => {
                    if (ts.isImportDeclaration(node) || ts.isExportDeclaration(node)) {
                        if (node.moduleSpecifier &&
                            ts.isStringLiteral(node.moduleSpecifier)) {
                            const text = node.moduleSpecifier.text;
                            if (text.endsWith('.uvue.ts') || text.endsWith('.vue.ts')) {
                                node.moduleSpecifier.text = text.replace(/.u?ts$/, '');
                            }
                        }
                    }
                });
                return node;
            };
        },
    };
};

// function createInterfaceClassDeclaration(
//   tsUtils: TsUtils,
//   modifiers: tsTypes.ModifierLike[] | undefined = [],
//   name: tsTypes.Identifier,
//   typeParameters: tsTypes.TypeParameterDeclaration[] | undefined,
//   heritageClauses: tsTypes.HeritageClause[] | undefined,
//   members: (tsTypes.PropertySignature | tsTypes.MethodSignature)[],
// ) {
//   const { ts } = tsUtils
//   const context = tsUtils.context!
//   const factory = context.factory
//   function addAbstract(
//     modifiers: tsTypes.ModifierLike[],
//   ): tsTypes.ModifierLike[] {
//     return [
//       ...(modifiers || []),
//       factory.createToken(ts.SyntaxKind.AbstractKeyword),
//     ]
//   }
//   const extendsIdentifierList: tsTypes.Identifier[] = []
//   if (
//     heritageClauses &&
//     (heritageClauses.length > 1 ||
//       (heritageClauses.length === 1 &&
//         heritageClauses.some(
//           (item) => item.token !== ts.SyntaxKind.ExtendsKeyword,
//         )))
//   ) {
//     context.addSyntacticDiagnostic(
//       ts.createDiagnosticForNode(
//         heritageClauses[0].parent,
//         UTSDiagnostics.Only_one_extends_heritage_clause_is_allowed_for_interface,
//       ),
//     )
//     return
//   }
//   // 不保留interface的继承链
//   // const heritageClausesTypes =
//   //   heritageClauses && heritageClauses.length > 0
//   //     ? [...heritageClauses[0].types]
//   //     : []
//   // for (let i = 0; i < heritageClausesTypes.length; i++) {
//   //   const type = heritageClausesTypes[i]
//   //   if (ts.isIdentifier(type.expression)) {
//   //     extendsIdentifierList.push(type.expression)
//   //   }
//   // }
//   const classMembers = members.map((member) => {
//     const {
//       modifiers = [] as tsTypes.ModifierLike[],
//       name: memberName,
//       questionToken,
//     } = member
//     let memberType: tsTypes.TypeNode | undefined
//     if (ts.isPropertySignature(member)) {
//       memberType = member.type
//     } else if (ts.isMethodSignature(member)) {
//       const { type: returnType, typeParameters, parameters } = member
//       memberType = factory.createFunctionTypeNode(
//         typeParameters,
//         parameters,
//         returnType!,
//       )
//     }
//     const realMemberType =
//       memberType &&
//       tsUtils.createTypeNodeWithNullType(memberType, !!questionToken)
//     return factory.createPropertyDeclaration(
//       addAbstract([...modifiers]),
//       memberName,
//       questionToken,
//       realMemberType,
//       /*initializer*/ undefined,
//     )
//   })
//   const utsMetadataNodes = createBasicUTSMetadataNode(
//     tsUtils,
//     UTS_CLASS_METADATA_KIND.INTERFACE,
//     extendsIdentifierList,
//   )
//   return factory.createClassDeclaration(
//     addAbstract(modifiers),
//     name,
//     typeParameters?.length ? typeParameters : undefined,
//     undefined,
//     [...utsMetadataNodes, ...classMembers],
//   )
// }
function createTypeClassDeclaration(tsUtils, modifiers, name, typeParameters, members) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const factory = context.factory;
    const optionsTypeMembers = [];
    const classMembers = !members
        ? []
        : members.map((member) => {
            const { modifiers, name: memberName, questionToken, 
            // @ts-ignore
            jsDoc, } = member;
            let memberType;
            if (ts.isPropertySignature(member)) {
                memberType = member.type;
            }
            else if (ts.isMethodSignature(member)) {
                const { type: returnType, typeParameters, parameters } = member;
                memberType = factory.createFunctionTypeNode(typeParameters, parameters, returnType);
            }
            const realMemberType = memberType &&
                tsUtils.createTypeNodeWithNullType(memberType, !!questionToken);
            optionsTypeMembers.push(factory.createPropertySignature(
            /*modifiers*/ undefined, memberName, questionToken, realMemberType));
            const propertyDeclaration = factory.createPropertyDeclaration(modifiers, memberName, questionToken, realMemberType, 
            /*initializer*/ undefined);
            // @ts-ignore
            propertyDeclaration.jsDoc = jsDoc;
            return propertyDeclaration;
        });
    const optionsType = factory.createTypeLiteralNode(optionsTypeMembers);
    const generatedMembers = [];
    // [key: string] : any
    const indexSignature = factory.createIndexSignature(undefined, [
        factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier('key'), undefined, factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword), undefined),
    ], factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
    const constructorNode = factory.createConstructorDeclaration(undefined, [
        factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier('options'), undefined, optionsType, undefined),
    ], factory.createBlock([
        factory.createExpressionStatement(factory.createCallExpression(factory.createSuper(), undefined, [])),
        ...(members || []).map((item) => {
            const nameStr = item.name.escapedText.toString();
            return factory.createExpressionStatement(factory.createBinaryExpression(factory.createPropertyAccessExpression(factory.createThis(), factory.createIdentifier(nameStr)), factory.createToken(ts.SyntaxKind.EqualsToken), factory.createPropertyAccessExpression(factory.createIdentifier('options'), factory.createIdentifier(nameStr))));
        }),
    ], true));
    generatedMembers.push(indexSignature, ...classMembers, constructorNode);
    const classDeclaration = factory.createClassDeclaration(modifiers, name, typeParameters?.length ? typeParameters : undefined, [
        factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
            factory.createExpressionWithTypeArguments(createTempUTSTypeNode(tsUtils), undefined),
        ]),
    ], generatedMembers);
    return classDeclaration;
}
function transformTypeClass(tsUtils, node) {
    const ts = tsUtils.ts;
    const context = tsUtils.context;
    const factory = context.factory;
    const { modifiers, name, typeParameters, heritageClauses, members } = node;
    const properties = members.filter((item) => ts.isPropertyDeclaration(item));
    /**
     * static get$UTSMetadata() {}
     */
    const typeName = name ? name.escapedText.toString() : '';
    // 此方法内由于要处理泛型类型使用了typeChecker，因此只能在before阶段调用
    const utsMetadataNode = createTypeUTSMetadataNode(tsUtils, typeName, 2 /* UTS_CLASS_METADATA_KIND.TYPE */, properties, typeParameters ? [...typeParameters] : []);
    const indexSignature = members.find((item) => ts.isIndexSignatureDeclaration(item));
    const originalConstructorNode = members.find((item) => ts.isConstructorDeclaration(item));
    const { parameters } = originalConstructorNode;
    const constructorParameters = [
        ...parameters,
        factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier('metadata'), undefined, factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword), factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier(name.escapedText), factory.createIdentifier('get' + "$UTSMetadata$" /* IDENTIFIER.UTS_METADATA */)), undefined, [])),
        factory.createParameterDeclaration(
        /*modifiers*/ undefined, 
        /*dotDotDotToken*/ undefined, factory.createIdentifier('isJSONParse'), 
        /*questionToken*/ undefined, factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword), 
        /*initializer*/ factory.createFalse()),
    ];
    const tempPropsName = '__props__';
    const constructorNode = factory.createConstructorDeclaration(
    /*modifiers*/ undefined, constructorParameters, factory.createBlock([
        // super()
        factory.createExpressionStatement(factory.createCallExpression(factory.createSuper(), undefined, [])),
        /**
         * const props = (globalThis as any).UTSType.initProps(options, metadata, isJSONParse) 不可在parse阶段使用改为下面的用法
         * this.__props__ = (globalThis as any).UTSType.initProps(options, metadata, isJSONParse)
         * delete this.__props__
         */
        // this.__props__ = (globalThis as any).UTSType.initProps(options, metadata, isJSONParse)
        factory.createExpressionStatement(factory.createBinaryExpression(factory.createPropertyAccessExpression(factory.createThis(), factory.createIdentifier(tempPropsName)), factory.createToken(ts.SyntaxKind.EqualsToken), factory.createCallExpression(factory.createPropertyAccessExpression(createTempUTSTypeNode(tsUtils), factory.createIdentifier('initProps')), undefined, [
            factory.createIdentifier('options'),
            factory.createIdentifier('metadata'),
            factory.createIdentifier('isJSONParse'),
        ]))),
        // this.a = this.__props__.a
        ...properties.map((member) => {
            const { name: memberName } = member;
            const memberNameText = memberName
                .escapedText;
            return factory.createExpressionStatement(factory.createBinaryExpression(factory.createPropertyAccessExpression(factory.createThis(), factory.createIdentifier(memberNameText)), factory.createToken(ts.SyntaxKind.EqualsToken), factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(factory.createThis(), factory.createIdentifier(tempPropsName)), factory.createIdentifier(memberNameText))));
        }),
        // delete this.__props__
        factory.createExpressionStatement(factory.createDeleteExpression(factory.createPropertyAccessExpression(factory.createThis(), factory.createIdentifier(tempPropsName)))),
    ], 
    /*multiLine*/ true));
    return factory.updateClassDeclaration(node, modifiers, name, typeParameters, heritageClauses, [indexSignature, ...properties, ...utsMetadataNode, constructorNode]);
}
/**
 * 处理继承关系。如果class实现自interface，对应的实例应能通过instanceof判断为interface实例
 * class extends -> class(abstract + not abstract) 不保存interfaces信息
 * class implements -> interface + abstract class 保存interfaces信息，在此处处理
 * interface extends -> interface + class(abstract + not abstract) 保存interfaces信息，在transformTypeAndInterface内处理
 * interface implements -> ×
 *
 * instanceof -> UTS.isInstanceOf
 *
 * 额外注意的点
 * - class声明可以嵌套
 * - 不再支持interface重复声明自动合并，需要抛出错误
 */
const transformTypeAndInterface = (ts, ls) => {
    return {
        parser: {
            TypeAliasDeclaration(context) {
                return function (node) {
                    const factory = context.factory;
                    const { modifiers = [], name, typeParameters = [], type } = node;
                    if (ts.isTypeLiteralNode(type)) {
                        return factory.createTypeAliasDeclaration(modifiers, name, typeParameters, factory.createTypeLiteralNode(factory.createNodeArray([
                            factory.createIndexSignature(undefined, [
                                factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier('key'), undefined, factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword), undefined),
                            ], factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)),
                            ...type.members,
                        ])));
                    }
                    return node;
                };
            },
            SourceFile(context) {
                const tsUtils = createTsUtils(ts, undefined, context);
                // let hasTypeDeclaration = false
                const visitor = (node) => {
                    if (ts.isTypeAliasDeclaration(node) &&
                        ts.isTypeLiteralNode(node.type)) {
                        const { modifiers = [], name, typeParameters = [], type } = node;
                        const members = type.members;
                        const classDeclaration = createTypeClassDeclaration(tsUtils, [...modifiers], name, [...typeParameters], [
                            ...members.filter((item) => ts.isPropertySignature(item) || ts.isMethodSignature(item)),
                        ]);
                        if (classDeclaration) {
                            // hasTypeDeclaration = true
                            node = classDeclaration;
                        }
                    }
                    else if (ts.isInterfaceDeclaration(node)) ;
                    node = ts.visitEachChild(node, visitor, context);
                    return node;
                };
                return (node) => {
                    return ts.visitNode(node, visitor);
                };
            },
        },
        before(context) {
            const program = ls.getProgram();
            const typeChecker = program.getTypeChecker();
            const tsUtils = createTsUtils(ts, typeChecker, context);
            const factory = context.factory;
            const visitor = (node) => {
                if (ts.isPropertyAccessExpression(node) &&
                    isTempUTSTypeNode(tsUtils, node)) {
                    // 替换所有临时UTSTypeNode
                    /**
                     * parse阶段不能访问createUTSHelper（即使在context上挂上相关方法也不行），用globalThis占位，在此处替换
                     */
                    node = factory.createPropertyAccessExpression(createUTSHelper(context), factory.createIdentifier("UTSType" /* IDENTIFIER.UTS_TYPE */));
                }
                else if (ts.isClassDeclaration(node)) {
                    // 转化type声明的class的metadata
                    const { heritageClauses } = node;
                    const parentClass = heritageClauses?.[0]?.types?.[0]?.expression;
                    if (parentClass && isTempUTSTypeNode(tsUtils, parentClass)) {
                        node = transformTypeClass(tsUtils, node);
                    }
                }
                node = ts.visitEachChild(node, visitor, context);
                return node;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};
/**
 * TODO
 * - 将子作用域内的type声明提升到最外层，以便转化对象字面量时能引用到
 * - interface、type生成的class继承自uts内置类
 */

/**
 * 收集uni和uniCloud的扩展api，后续考虑通过参数控制是否启用收集
 */
const transformUniExtApi = (ts) => {
    return {
        parser: {
            SourceFile(context) {
                return (sourceFile) => {
                    const visitor = (node) => {
                        const updatedNode = ts.visitEachChild(node, visitor, context);
                        if (ts.isCallExpression(updatedNode) &&
                            ts.isPropertyAccessExpression(updatedNode.expression)) {
                            const obj = updatedNode.expression.expression;
                            const prop = updatedNode.expression.name;
                            if (ts.isIdentifier(obj) && ts.isIdentifier(prop)) {
                                const objName = obj.text;
                                if (objName === 'uni' || objName === 'uniCloud') {
                                    if (!sourceFile.__utsMeta) {
                                        sourceFile.__utsMeta = {};
                                    }
                                    if (!sourceFile.__utsMeta.uniExtApis) {
                                        sourceFile.__utsMeta.uniExtApis = new Set();
                                    }
                                    sourceFile.__utsMeta.uniExtApis.add(objName + '.' + prop.text);
                                }
                            }
                        }
                        return updatedNode;
                    };
                    return ts.visitNode(sourceFile, visitor);
                };
            },
        },
    };
};

globalThis.__utsHacker__ = {
    ...globalThis.__utsHacker__,
};

debug('uts:transformer:importAndExportDeclaration');

function wrapTransformer(ts, ls, transformer, type) {
    return (context) => {
        const transform = transformer(context);
        return (node) => {
            const isSourceFile = ts.isSourceFile(node);
            if (!context.fileName) {
                if (isSourceFile) {
                    context.fileName = node.fileName;
                }
            }
            if (ls.shouldTransform(context.fileName)) {
                if (isSourceFile && !node.isUTSFile) {
                    node.isUTSFile = true;
                    if (ls.isVueFile?.(context.fileName)) {
                        node.isVueFile = true;
                    }
                }
                if (isSourceFile && type === 'parser') {
                    if (node.statements.length) {
                        if (!node.statements[0].parent) {
                            // parser 阶段如果没有关联父节点
                            // @ts-expect-error 内部方法
                            ts.setParentRecursive(node, true);
                        }
                    }
                }
                return transform(node);
            }
            return node;
        };
    };
}
function setupParserNode(originalNode, newNode) {
    if (newNode && newNode !== originalNode && !Array.isArray(newNode)) {
        newNode.__parsedByUtsParser = true;
        newNode.parent = originalNode.parent;
    }
    return newNode;
}
let parserTs;
function createParserTsOnce(ts) {
    if (parserTs) {
        return parserTs;
    }
    parserTs = {
        ...ts,
    };
    const { visitNode, visitEachChild } = ts;
    parserTs.visitNode = (node, visitor) => {
        const realVisitor = (node) => {
            const originalNode = node;
            const newNode = visitor(node);
            return setupParserNode(originalNode, newNode);
        };
        return visitNode(node, realVisitor);
    };
    parserTs.visitEachChild = (node, visitor, context) => {
        const realVisitor = (node) => {
            const originalNode = node;
            const newNode = visitor(node);
            return setupParserNode(originalNode, newNode);
        };
        return visitEachChild(node, realVisitor, context);
    };
    return parserTs;
}
function initParser(ts, ls, parser, parserTransformers, transformOptions) {
    // if (options.InterfaceDeclaration) {
    //   ;(parser.InterfaceDeclaration || (parser.InterfaceDeclaration = [])).push(
    //     wrapTransformer(ts, ls, options.InterfaceDeclaration),
    //   )
    // }
    if (parserTransformers.TypeAliasDeclaration) {
        (parser.TypeAliasDeclaration || (parser.TypeAliasDeclaration = [])).push(
        // TODO allowDtsFiles配置项优化
        wrapTransformer(ts, ls, (context) => {
            const transformer = parserTransformers.TypeAliasDeclaration(context);
            return (node) => {
                const originalNode = node;
                const newNode = transformer(node);
                return setupParserNode(originalNode, newNode);
            };
        }, 'parser'));
    }
    if (parserTransformers.SourceFile) {
        (parser.SourceFile || (parser.SourceFile = [])).push(wrapTransformer(ts, ls, parserTransformers.SourceFile, 'parser'));
    }
}
function parseTransformer(ts, transformers, options) {
    initTs(ts);
    return (ls) => {
        const parser = {};
        const before = [];
        const after = [];
        const afterDeclarations = [];
        transformers.forEach((creator) => {
            let transformer = creator(ts, ls, options);
            if (typeof transformer === 'function') {
                before.push(wrapTransformer(ts, ls, transformer, 'before'));
            }
            else {
                if (transformer.parser) {
                    // TODO 优化此处逻辑
                    const transformer = creator(createParserTsOnce(ts), ls, options);
                    transformer.parser &&
                        initParser(ts, ls, parser, transformer.parser);
                }
                if (transformer.before) {
                    before.push(wrapTransformer(ts, ls, transformer.before, 'before'));
                }
                if (transformer.after) {
                    after.push(wrapTransformer(ts, ls, transformer.after, 'after'));
                }
                if (transformer.afterDeclarations) {
                    afterDeclarations.push(wrapTransformer(ts, ls, transformer.afterDeclarations, 'afterDeclarations'));
                }
            }
        });
        return {
            parser,
            before,
            after,
            afterDeclarations,
        };
    };
}
function initTs(ts, options) {
    if (!ts.ObjectFlags.UTSType) {
        const { Class, Interface, Reference, Anonymous, ArrayLiteral } = ts.ObjectFlags;
        // @ts-expect-error
        ts.ObjectFlags.UTSType =
            Class | Interface | Reference | Anonymous | ArrayLiteral;
    }
    if (!ts.TypeFlags.UTSType) {
        const { Any, String, Number, Boolean, Enum, StringLiteral, NumberLiteral, BooleanLiteral, EnumLiteral, Void, Null, Object, Union, TemplateLiteral, } = ts.TypeFlags;
        // @ts-expect-error
        ts.TypeFlags.UTSType =
            Any |
                String |
                Number |
                Boolean |
                Enum |
                StringLiteral |
                NumberLiteral |
                BooleanLiteral |
                EnumLiteral |
                Void |
                Null |
                Object |
                Union |
                TemplateLiteral;
        // @ts-expect-error
        ts.TypeFlags.UTSStringLike = String | StringLiteral | TemplateLiteral;
        // @ts-expect-error
        ts.TypeFlags.UTSNumberLike = Number | NumberLiteral;
    }
}

function resolveExpressionType(checker, node) {
    return checker.getContextualType(node) ?? checker.getTypeAtLocation(node);
}
function getContainerNode(ts, node) {
    node = ts.getOriginalNode(node);
    while (true) {
        node = node.parent;
        if (!node) {
            return undefined;
        }
        node = ts.getOriginalNode(node);
        switch (node.kind) {
            case ts.SyntaxKind.SourceFile:
            case ts.SyntaxKind.MethodDeclaration:
            case ts.SyntaxKind.MethodSignature:
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.GetAccessor:
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.EnumDeclaration:
            case ts.SyntaxKind.ModuleDeclaration:
                return node;
        }
    }
}
function containsImportTypeNode(node, ts) {
    if (ts.isImportTypeNode(node)) {
        return true;
    }
    return (ts.forEachChild(node, (child) => containsImportTypeNode(child, ts)) || false);
}
function typeToTypeNode(type, node, ts, checker) {
    const containerNode = getContainerNode(ts, node);
    let typeNode = checker.typeToTypeNode(type, containerNode, ts.NodeBuilderFlags.None);
    // 可能 使用了 containerNode 后反而获取不到类型，尝试直接获取
    if (!typeNode && containerNode) {
        typeNode = checker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.None);
    }
    if (typeNode) {
        // 通过 containerNode 可能获取到 import('type.uts').A 类型
        // import 目前由autoImport实现了，暂不处理
        if (containsImportTypeNode(typeNode, ts)) {
            return checker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.None);
        }
        // 目前不能排除 undefined，ArkTS 可选链的类型还需要保留 undefined 类型
        // if (ts.isUnionTypeNode(typeNode)) {
        //   // 排除 undefined 类型
        //   ;(typeNode as any).types = typeNode.types.filter((t) => {
        //     if (t.kind === ts.SyntaxKind.UndefinedKeyword) {
        //       return false
        //     }
        //     return true
        //   })
        // }
        return typeNode;
    }
    return undefined;
}

debug('uts:transformer:autoImport');

debug('uts:transformer:arguments');

debug('uts:transformer:checker');

const transformContext = (ts, _, options) => {
    function initContext(context, node) {
        if (ts.isSourceFile(node)) {
            if (!node.__relativeFileName) {
                const compilerOptions = context.getCompilerOptions();
                if (compilerOptions.rootDir &&
                    path.isAbsolute(compilerOptions.rootDir)) {
                    const rootDir = normalizePath(compilerOptions.rootDir);
                    const fileName = normalizePath(node.fileName);
                    node.__rootDir = rootDir;
                    if (fileName.startsWith(rootDir)) {
                        node.__relativeFileName = normalizePath(path.relative(rootDir, fileName));
                    }
                    else if (fileName.includes('/@dcloudio/')) {
                        node.__relativeFileName =
                            '@dcloudio/' + fileName.split('/@dcloudio/')[1];
                    }
                }
                if (!node.__relativeFileName) {
                    node.__relativeFileName = path.basename(node.fileName);
                }
            }
            if (!context.printNode) {
                const printer = ts.createPrinter();
                context.printNode = (node, sourceFile) => {
                    return printer.printNode(ts.EmitHint.Unspecified, node, sourceFile);
                };
            }
            if (!context.addSyntacticDiagnostic) {
                context.addSyntacticDiagnostic = (diag) => {
                    // @ts-expect-error 内部属性
                    node.parseDiagnostics.push(diag);
                };
                context.addSemanticDiagnostic = (diag) => {
                    // @ts-expect-error 内部属性，借用bindDiagnostics来存储语义诊断
                    node.bindDiagnostics.push(diag);
                };
            }
            if (!context.error) {
                context.error = (diagnostic) => {
                    if (options.watch) {
                        // watch 模式下底层是setTimeout封装，且被try catch，不能直接抛出异常，需要使用addSyntacticDiagnostic
                        // 打个标记，让后续流程直接抛出
                        diagnostic.__throwError = true;
                        context.addSyntacticDiagnostic(diagnostic);
                        return;
                    }
                    const error = new Error(diagnostic.messageText.toString());
                    error.diagnostic = diagnostic;
                    // 指定了id后，不让后续的rollup重写
                    Object.defineProperty(error, 'id', {
                        get() {
                            return diagnostic.file.fileName;
                        },
                        set(_v) { },
                    });
                    throw error;
                };
            }
        }
        return node;
    }
    return {
        before(context) {
            return (node) => {
                return initContext(context, node);
            };
        },
        after(context) {
            return (node) => {
                return initContext(context, node);
            };
        },
        afterDeclarations(context) {
            return (node) => {
                return initContext(context, node);
            };
        },
    };
};

debug('uts:transformer:generics');

debug('uts:transformer:in');

debug('uts:transformer:keyof');

debug('uts:transformer:narrowType:discriminatedUnion');

debug('uts:transformer:narrowType:nonNullable');

debug('uts:transformer:narrowType');

debug('uts:transformer:narrowType:parameterUnionType');

debug('uts:transformer:UTSObjectUnionType');

debug('uts:transformer:objectLiteral');

// TODO 排查Debug的类型错误
// copy from typescript transformES2020
function createOptionalChainTransformer(withType, ts, context, checker) {
    const { addEmitFlags, cast, chainBundle, Debug, EmitFlags, isCallChain, isExpression, isGeneratedIdentifier, isIdentifier, isNonNullChain, isOptionalChain, isParenthesizedExpression, isSimpleCopiableExpression, isSyntheticReference, isTaggedTemplateExpression, OuterExpressionKinds, setOriginalNode, setTextRange, skipParentheses, skipPartiallyEmittedExpressions, SyntaxKind, TransformFlags, visitEachChild, visitNode, visitNodes, } = ts;
    const { factory, hoistVariableDeclaration } = context;
    return chainBundle(context, transformSourceFile);
    function transformSourceFile(node) {
        if (node.isDeclarationFile) {
            return node;
        }
        return visitEachChild(node, visitor, context);
    }
    function visitor(node) {
        if ((node.transformFlags & TransformFlags.ContainsES2020) === 0) {
            return node;
        }
        switch (node.kind) {
            case SyntaxKind.CallExpression: {
                const updated = visitNonOptionalCallExpression(node, 
                /*captureThisArg*/ false);
                // @ts-expect-error type error
                Debug.assertNotNode(updated, isSyntheticReference);
                return updated;
            }
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.ElementAccessExpression:
                if (isOptionalChain(node)) {
                    const updated = visitOptionalExpression(node, 
                    /*captureThisArg*/ false, 
                    /*isDelete*/ false);
                    // @ts-expect-error type error
                    Debug.assertNotNode(updated, isSyntheticReference);
                    return updated;
                }
                return visitEachChild(node, visitor, context);
            case SyntaxKind.BinaryExpression:
                if (node.operatorToken.kind ===
                    SyntaxKind.QuestionQuestionToken) {
                    return transformNullishCoalescingExpression(node);
                }
                return visitEachChild(node, visitor, context);
            case SyntaxKind.DeleteExpression:
                return visitDeleteExpression(node);
            default:
                return visitEachChild(node, visitor, context);
        }
    }
    function flattenChain(chain) {
        // @ts-expect-error type error
        Debug.assertNotNode(chain, isNonNullChain);
        if (isNonNullChain(chain)) {
            throw new Error('Unexpected non-null chain');
        }
        const links = [chain];
        while (!chain.questionDotToken &&
            !isTaggedTemplateExpression(chain)) {
            chain = cast(skipPartiallyEmittedExpressions(chain.expression), isOptionalChain);
            // @ts-expect-error type error
            Debug.assertNotNode(chain, isNonNullChain);
            links.unshift(chain);
        }
        return { expression: chain.expression, chain: links };
    }
    function visitNonOptionalParenthesizedExpression(node, captureThisArg, isDelete) {
        const expression = visitNonOptionalExpression(node.expression, captureThisArg, isDelete);
        if (isSyntheticReference(expression)) {
            // `(a.b)` -> { expression `((_a = a).b)`, thisArg: `_a` }
            // `(a[b])` -> { expression `((_a = a)[b])`, thisArg: `_a` }
            return factory.createSyntheticReferenceExpression(factory.updateParenthesizedExpression(node, expression.expression), expression.thisArg);
        }
        return factory.updateParenthesizedExpression(node, expression);
    }
    function visitNonOptionalPropertyOrElementAccessExpression(node, captureThisArg, isDelete) {
        if (isOptionalChain(node)) {
            // If `node` is an optional chain, then it is the outermost chain of an optional expression.
            return visitOptionalExpression(node, captureThisArg, isDelete);
        }
        const type = checker.getTypeAtLocation(node.expression);
        let expression = visitNode(node.expression, visitor, isExpression);
        // @ts-expect-error type error
        Debug.assertNotNode(expression, isSyntheticReference);
        let thisArg;
        if (captureThisArg) {
            if (!isSimpleCopiableExpression(expression)) {
                thisArg = factory.createTempVariable(hoistVariableDeclaration, undefined, undefined, undefined, withType ? typeToTypeNode(type, node, ts, checker) : undefined);
                expression = factory.createAssignment(thisArg, expression);
            }
            else {
                thisArg = expression;
            }
        }
        expression =
            node.kind === SyntaxKind.PropertyAccessExpression
                ? factory.updatePropertyAccessExpression(node, expression, visitNode(node.name, visitor, isIdentifier))
                : factory.updateElementAccessExpression(node, expression, visitNode(node.argumentExpression, visitor, isExpression));
        return thisArg
            ? factory.createSyntheticReferenceExpression(expression, thisArg)
            : expression;
    }
    function visitNonOptionalCallExpression(node, captureThisArg) {
        if (isOptionalChain(node)) {
            // If `node` is an optional chain, then it is the outermost chain of an optional expression.
            return visitOptionalExpression(node, captureThisArg, /*isDelete*/ false);
        }
        if (isParenthesizedExpression(node.expression) &&
            isOptionalChain(skipParentheses(node.expression))) {
            // capture thisArg for calls of parenthesized optional chains like `(foo?.bar)()`
            const expression = visitNonOptionalParenthesizedExpression(node.expression, 
            /*captureThisArg*/ true, 
            /*isDelete*/ false);
            const args = visitNodes(node.arguments, visitor, isExpression);
            if (isSyntheticReference(expression)) {
                return setTextRange(factory.createFunctionCallCall(expression.expression, expression.thisArg, args), node);
            }
            return factory.updateCallExpression(node, expression, 
            /*typeArguments*/ undefined, args);
        }
        return visitEachChild(node, visitor, context);
    }
    function visitNonOptionalExpression(node, captureThisArg, isDelete) {
        switch (node.kind) {
            case SyntaxKind.ParenthesizedExpression:
                return visitNonOptionalParenthesizedExpression(node, captureThisArg, isDelete);
            case SyntaxKind.PropertyAccessExpression:
            case SyntaxKind.ElementAccessExpression:
                return visitNonOptionalPropertyOrElementAccessExpression(node, captureThisArg, isDelete);
            case SyntaxKind.CallExpression:
                return visitNonOptionalCallExpression(node, captureThisArg);
            default:
                return visitNode(node, visitor, isExpression);
        }
    }
    function visitOptionalExpression(node, captureThisArg, isDelete) {
        const { expression, chain } = flattenChain(node);
        const type = checker.getTypeAtLocation(expression);
        const left = visitNonOptionalExpression(skipPartiallyEmittedExpressions(expression), isCallChain(chain[0]), 
        /*isDelete*/ false);
        let leftThisArg = isSyntheticReference(left) ? left.thisArg : undefined;
        let capturedLeft = isSyntheticReference(left) ? left.expression : left;
        let leftExpression = factory.restoreOuterExpressions(expression, capturedLeft, OuterExpressionKinds.PartiallyEmittedExpressions);
        if (!isSimpleCopiableExpression(capturedLeft)) {
            capturedLeft = factory.createTempVariable(hoistVariableDeclaration, undefined, undefined, undefined, withType ? typeToTypeNode(type, node, ts, checker) : undefined);
            leftExpression = factory.createAssignment(capturedLeft, leftExpression);
        }
        let rightExpression = capturedLeft;
        let thisArg;
        for (let i = 0; i < chain.length; i++) {
            const segment = chain[i];
            switch (segment.kind) {
                case SyntaxKind.PropertyAccessExpression:
                case SyntaxKind.ElementAccessExpression:
                    if (i === chain.length - 1 && captureThisArg) {
                        if (!isSimpleCopiableExpression(rightExpression)) {
                            const type = checker.getTypeAtLocation(segment.expression);
                            thisArg = factory.createTempVariable(hoistVariableDeclaration, undefined, undefined, undefined, withType
                                ? typeToTypeNode(type, segment, ts, checker)
                                : undefined);
                            rightExpression = factory.createAssignment(thisArg, rightExpression);
                        }
                        else {
                            thisArg = rightExpression;
                        }
                    }
                    rightExpression =
                        segment.kind === SyntaxKind.PropertyAccessExpression
                            ? factory.createPropertyAccessExpression(rightExpression, visitNode(segment.name, visitor, isIdentifier))
                            : factory.createElementAccessExpression(rightExpression, visitNode(segment.argumentExpression, visitor, isExpression));
                    break;
                case SyntaxKind.CallExpression:
                    if (i === 0 && leftThisArg) {
                        if (!isGeneratedIdentifier(leftThisArg)) {
                            leftThisArg = factory.cloneNode(leftThisArg);
                            addEmitFlags(leftThisArg, EmitFlags.NoComments);
                        }
                        rightExpression = factory.createFunctionCallCall(rightExpression, leftThisArg.kind === SyntaxKind.SuperKeyword
                            ? factory.createThis()
                            : leftThisArg, visitNodes(segment.arguments, visitor, isExpression));
                    }
                    else {
                        rightExpression = factory.createCallExpression(rightExpression, 
                        /*typeArguments*/ undefined, visitNodes(segment.arguments, visitor, isExpression));
                    }
                    break;
            }
            setOriginalNode(rightExpression, segment);
        }
        const target = isDelete
            ? factory.createConditionalExpression(createNotNullCondition(leftExpression, capturedLeft, /*invert*/ true), 
            /*questionToken*/ undefined, factory.createTrue(), 
            /*colonToken*/ undefined, factory.createDeleteExpression(rightExpression))
            : factory.createConditionalExpression(createNotNullCondition(leftExpression, capturedLeft, /*invert*/ true), 
            /*questionToken*/ undefined, factory.createNull(), 
            /*colonToken*/ undefined, rightExpression);
        setTextRange(target, node);
        return thisArg
            ? factory.createSyntheticReferenceExpression(target, thisArg)
            : target;
    }
    function createNotNullCondition(left, right, invert) {
        // 使用 == 或 != 来简单判断
        // return factory.createBinaryExpression(
        //   left,
        //   factory.createToken(
        //     invert
        //       ? SyntaxKind.EqualsEqualsToken
        //       : SyntaxKind.ExclamationEqualsToken,
        //   ),
        //   factory.createNull(),
        // )
        return factory.createBinaryExpression(factory.createBinaryExpression(left, factory.createToken(invert
            ? SyntaxKind.EqualsEqualsEqualsToken
            : SyntaxKind.ExclamationEqualsEqualsToken), factory.createNull()), factory.createToken(invert ? SyntaxKind.BarBarToken : SyntaxKind.AmpersandAmpersandToken), factory.createBinaryExpression(right, factory.createToken(invert
            ? SyntaxKind.EqualsEqualsEqualsToken
            : SyntaxKind.ExclamationEqualsEqualsToken), factory.createVoidZero()));
    }
    function transformNullishCoalescingExpression(node) {
        let left = visitNode(node.left, visitor, isExpression);
        let right = left;
        if (!isSimpleCopiableExpression(left)) {
            right = factory.createTempVariable(hoistVariableDeclaration);
            left = factory.createAssignment(right, left);
        }
        return setTextRange(factory.createConditionalExpression(createNotNullCondition(left, right), 
        /*questionToken*/ undefined, right, 
        /*colonToken*/ undefined, visitNode(node.right, visitor, isExpression)), node);
    }
    function visitDeleteExpression(node) {
        return isOptionalChain(skipParentheses(node.expression))
            ? setOriginalNode(visitNonOptionalExpression(node.expression, 
            /*captureThisArg*/ false, 
            /*isDelete*/ true), node)
            : factory.updateDeleteExpression(node, visitNode(node.expression, visitor, isExpression));
    }
}
/**
 * 在 parse 阶段将可选链编译为返回null，而不是undefined
 * @param ts
 * @returns
 */
const transformOptionalChain = (ts, ls, options) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            const transform = createOptionalChainTransformer(options.targetLanguage === 'ArkTS', ts, context, checker);
            return (node) => transform(node);
        },
    };
};

debug('uts:transformer:returnType');

debug('uts:transformer:UTSJSONObject');

globalThis.__utsUniXGlobalProperties__ =
    globalThis.__utsUniXGlobalProperties__ || new Map();

function diag(code, category, key, message) {
    return {
        code,
        category,
        key,
        message,
    };
}
// createWorker('workers/request/index.uts') => createWorker(RequestTask)
const transformCreateWorker = (ts, _ls, options) => {
    const { extname, resolveWorkers } = options.transformCreateWorker || {
        resolveWorkers: () => ({}),
    };
    const WorkerDiagnostics = {
        Worker_Path_Expected_a_string_literal: diag(0, ts.DiagnosticCategory.Error, 'Worker_Path_Expected_a_string_literal_0', 'uni.createWorker(workerPath) 的 workerPath 参数必须是字符串字面量'),
        Worker_Path_Not_Found: diag(0, ts.DiagnosticCategory.Error, 'Worker_Path_Not_Found_0', 'Worker[{0}]路径不存在或未正确实现'),
        Worker_Not_Supported_on_App_IOS_Uvue: diag(0, ts.DiagnosticCategory.Error, 'Worker_Not_Supported_on_App_IOS_Uvue_0', 'app-ios平台，目前仅 uts 插件中支持使用 uni.createWorker 创建 worker'),
    };
    return {
        before(context) {
            const { factory } = context;
            const autoImports = new Map();
            const workers = resolveWorkers();
            const visitor = (node) => {
                if (ts.isCallExpression(node) &&
                    node.arguments.length >= 1 &&
                    ts.isPropertyAccessExpression(node.expression) &&
                    node.expression.name.escapedText === 'createWorker' &&
                    ts.isIdentifier(node.expression.expression) &&
                    node.expression.expression.escapedText === 'uni') {
                    if (options.targetLanguage === 'JavaScript' &&
                        options.platform === 'app-ios') {
                        context.error(ts.createDiagnosticForNode(node, WorkerDiagnostics.Worker_Not_Supported_on_App_IOS_Uvue));
                    }
                    const firstArg = node.arguments[0];
                    let workerPath = '';
                    if (ts.isStringLiteral(firstArg)) {
                        workerPath = firstArg.text;
                    }
                    else if (ts.isNoSubstitutionTemplateLiteral(firstArg)) {
                        workerPath = firstArg.text;
                    }
                    else {
                        context.error(ts.createDiagnosticForNode(firstArg, WorkerDiagnostics.Worker_Path_Expected_a_string_literal));
                    }
                    if (workerPath) {
                        if (workerPath.startsWith('/')) {
                            workerPath = workerPath.slice(1);
                        }
                        if (workers[workerPath]) {
                            // 目前仅 Kotlin 和 Swift，需要重写参数以及导入 worker
                            if (options.targetLanguage === 'Kotlin' ||
                                options.targetLanguage === 'Swift') {
                                const workerIdent = factory.createIdentifier(workers[workerPath]);
                                if (!autoImports.has(workerPath)) {
                                    const importDeclaration = factory.createImportDeclaration(undefined, factory.createImportClause(false, undefined, factory.createNamedImports([
                                        factory.createImportSpecifier(false, undefined, workerIdent),
                                    ])), factory.createStringLiteral(`@/${workerPath}`), undefined);
                                    autoImports.set(workerPath, importDeclaration);
                                }
                                // 增加 workerIdent 的导入
                                const newArguments = [
                                    factory.createArrowFunction(undefined, undefined, [], factory.createTypeReferenceNode(factory.createIdentifier("WorkerTaskImpl" /* IDENTIFIER.WORKER_TASK_IMPL */), undefined), factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken), factory.createNewExpression(workerIdent, undefined, [])),
                                ];
                                for (let i = 1; i < node.arguments.length; i++) {
                                    newArguments.push(node.arguments[i]);
                                }
                                return factory.updateCallExpression(node, node.expression, node.typeArguments, newArguments);
                            }
                            else if (extname) {
                                // 调整 workerPath 参数文件名后缀
                                const newArguments = [
                                    factory.createStringLiteral(workerPath.replace('.uts', extname)),
                                ];
                                for (let i = 1; i < node.arguments.length; i++) {
                                    newArguments.push(node.arguments[i]);
                                }
                                return factory.updateCallExpression(node, node.expression, node.typeArguments, newArguments);
                            }
                        }
                        else {
                            context.error(ts.createDiagnosticForNode(firstArg, WorkerDiagnostics.Worker_Path_Not_Found, workerPath));
                        }
                    }
                }
                return ts.visitEachChild(node, visitor, context);
            };
            return (node) => {
                const updatedNode = ts.visitNode(node, visitor);
                if (autoImports.size === 0) {
                    return updatedNode;
                }
                return factory.updateSourceFile(updatedNode, [...autoImports.values(), ...updatedNode.statements], updatedNode.isDeclarationFile, updatedNode.referencedFiles, updatedNode.typeReferenceDirectives, updatedNode.hasNoDefaultLib, updatedNode.libReferenceDirectives);
            };
        },
    };
};

function isDefineExposeStatement(ts, node) {
    return (ts.isExpressionStatement(node) &&
        ts.isCallExpression(node.expression) &&
        ts.isIdentifier(node.expression.expression) &&
        node.expression.expression.text === "defineExpose" /* IDENTIFIER.DEFINE_EXPOSE */);
}
// 仅类型校验时使用
function createDefineComponentForSetup(factory, setupStatements) {
    return factory.createExportAssignment(undefined, undefined, factory.createCallExpression(factory.createIdentifier("defineComponent" /* IDENTIFIER.DEFINE_COMPONENT */), undefined, [
        factory.createObjectLiteralExpression([
            factory.createMethodDeclaration(undefined, undefined, factory.createIdentifier('setup'), undefined, undefined, [
                factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier('props'), undefined, undefined, undefined),
                factory.createParameterDeclaration(undefined, undefined, factory.createObjectBindingPattern([
                    factory.createBindingElement(undefined, undefined, factory.createIdentifier('expose'), undefined),
                ]), undefined, undefined, undefined),
            ], undefined, factory.createBlock(setupStatements, true)),
        ], true),
    ]));
}
/**
 * 1. 将 export default {} 转换为 export default defineComponent({})
 * > 理论上该逻辑放在预处理环节实现也是可以的，编译器本身也要实现自动导入vue的相关方法，稍后评估吧
 * @param ts
 * @returns
 */
const transformVueDefineComponent = (ts) => {
    return {
        parser: {
            SourceFile(context) {
                const { factory } = context;
                let isAppUvue = false;
                let isVueTs = false;
                const visitor = (node) => {
                    // 仅 SourceFile 需要遍历子节点，其他不需要，减少遍历流程
                    if (ts.isSourceFile(node)) {
                        if (isVueTs && node.text.startsWith('// @uts-setup\n')) {
                            const statements = node.statements;
                            const importStatements = [];
                            const setupStatements = [];
                            const setupReturnStatements = [];
                            for (let i = 0; i < statements.length; i++) {
                                const statement = statements[i];
                                if (ts.isImportDeclaration(statement)) {
                                    importStatements.push(statement);
                                }
                                else if (ts.isExportAssignment(statement)) {
                                    if (ts.isObjectLiteralExpression(statement.expression) &&
                                        statement.expression.properties.length === 0) {
                                        continue;
                                    }
                                    const diagnostic = ts.createDiagnosticForNode(statement, UTSDiagnostics.script_setup_cannot_contain_ES_module_exports);
                                    context.addSyntacticDiagnostic(diagnostic);
                                }
                                else if (isDefineExposeStatement(ts, statement)) {
                                    setupReturnStatements.push(factory.createReturnStatement(statement.expression
                                        .arguments[0]));
                                }
                                else {
                                    setupStatements.push(statement);
                                }
                            }
                            // return factory.createSourceFile(
                            //   [
                            //     ...(importStatements as tsTypes.Statement[]),
                            //     createDefineComponentForSetup(factory, setupStatements),
                            //   ],
                            //   factory.createToken(ts.SyntaxKind.EndOfFileToken),
                            //   ts.NodeFlags.None,
                            // )
                            return factory.updateSourceFile(node, [
                                ...importStatements,
                                createDefineComponentForSetup(factory, [
                                    ...setupStatements,
                                    ...setupReturnStatements,
                                ]),
                            ]);
                        }
                        return ts.visitEachChild(node, visitor, context);
                    }
                    // 简单判断 export default {}，暂不支持其他方式
                    if (ts.isExportAssignment(node) &&
                        ts.isObjectLiteralExpression(node.expression)) {
                        return factory.updateExportAssignment(node, node.modifiers, factory.createCallExpression(factory.createIdentifier(isAppUvue
                            ? "defineApp" /* IDENTIFIER.DEFINE_APP */
                            : "defineComponent" /* IDENTIFIER.DEFINE_COMPONENT */), undefined, [node.expression]));
                    }
                    return node;
                };
                return (node) => {
                    if (!node.isVueFile || node.fileName.indexOf('setup=true') > -1) {
                        return node;
                    }
                    // 判断是否是App.vue  App.uvue?import&vue&type=script&lang.uts
                    const fileName = path__namespace
                        .basename(node.fileName)
                        .split('?')[0]
                        .toLowerCase();
                    if (fileName === 'app.uvue' || fileName === 'app.uvue.ts') {
                        isAppUvue = true;
                    }
                    if (/.u?vue.ts/.test(fileName)) {
                        isVueTs = true;
                    }
                    const sourceFile = ts.visitNode(node, visitor);
                    if (sourceFile !== node) {
                        /**
                         * 添加 import { defineComponent } from 'vue'
                         * App.uvue添加 import { defineApp } from 'vue'
                         */
                        return factory.updateSourceFile(sourceFile, [
                            factory.createImportDeclaration(undefined, factory.createImportClause(false, undefined, factory.createNamedImports([
                                factory.createImportSpecifier(false, undefined, factory.createIdentifier(isAppUvue
                                    ? "defineApp" /* IDENTIFIER.DEFINE_APP */
                                    : "defineComponent" /* IDENTIFIER.DEFINE_COMPONENT */)),
                            ])), factory.createStringLiteral("vue" /* IDENTIFIER.VUE */)),
                            ...sourceFile.statements,
                        ]);
                    }
                    return sourceFile;
                };
            },
        },
        before(context) {
            // 将App.uvue内的defineApp重置为defineComponent
            const { factory } = context;
            const visitor = (node) => {
                // 仅 SourceFile 需要遍历子节点，其他不需要，减少遍历流程
                if (ts.isSourceFile(node)) {
                    return ts.visitEachChild(node, visitor, context);
                }
                // 简单判断 export default {}，暂不支持其他方式
                if (ts.isExportAssignment(node) &&
                    ts.isCallExpression(node.expression)) {
                    return factory.updateExportAssignment(node, node.modifiers, factory.createCallExpression(factory.createIdentifier("defineComponent" /* IDENTIFIER.DEFINE_COMPONENT */), undefined, node.expression.arguments));
                }
                else if (ts.isImportDeclaration(node)) {
                    // 删除 import { defineComponent } from 'vue'
                    if (node.moduleSpecifier &&
                        ts.isStringLiteral(node.moduleSpecifier) &&
                        node.moduleSpecifier.text === "vue" /* IDENTIFIER.VUE */ &&
                        node.importClause &&
                        ts.isImportClause(node.importClause) &&
                        node.importClause.namedBindings &&
                        ts.isNamedImports(node.importClause.namedBindings) &&
                        node.importClause.namedBindings.elements.some((element) => element.name.text === "defineApp" /* IDENTIFIER.DEFINE_APP */)) {
                        return factory.updateImportDeclaration(node, node.modifiers, factory.updateImportClause(node.importClause, false, undefined, factory.createNamedImports(node.importClause.namedBindings.elements.filter((element) => element.name.text !== "defineApp" /* IDENTIFIER.DEFINE_APP */))), node.moduleSpecifier, node.assertClause);
                    }
                }
                return node;
            };
            return (node) => {
                if (!node.isVueFile) {
                    return node;
                }
                // 判断是否是App.vue  App.uvue?import&vue&type=script&lang.uts
                if (path__namespace.basename(node.fileName).split('?')[0].toLowerCase() ===
                    'app.uvue') {
                    node = ts.visitNode(node, visitor);
                }
                return node;
            };
        },
    };
};

let globalUniAppType = null;
let globalUniAppProperties = [];
const transformUniApp = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const checker = program.getTypeChecker();
            if (globalUniAppType === null && checker.getGlobalType) {
                globalUniAppType = checker.getGlobalType('UniApp', 
                /*arity*/ 0, false);
                if (globalUniAppType) {
                    globalUniAppProperties = globalUniAppType
                        .getProperties()
                        .map((p) => p.getName());
                }
            }
            const visitor = (node) => {
                if (globalUniAppType && globalUniAppProperties.length) {
                    // 如果是 CallExpression，则检查是否 UniApp 的 API，比如 app.test() 确认 app 是 UniApp 类型
                    // 判断 test 是否是 globalUniAppType 的方法
                    if (ts.isCallExpression(node) &&
                        ts.isPropertyAccessExpression(node.expression) &&
                        ts.isIdentifier(node.expression.name)) {
                        const type = resolveExpressionType(checker, node.expression.expression);
                        if (type &&
                            type.isIntersection() &&
                            type.types.some((t) => t.symbol?.name === 'UniApp')) {
                            if (!globalUniAppProperties.includes(node.expression.name.text)) {
                                console.error(`error: '${node.expression.name.text}' 不是 UniApp 对象的方法，请检查是否拼写错误，如果想调用在 App.uvue 文件中定义的 methods 方法，请使用 .vm?.xxx 的方式调用，详情参考：https://doc.dcloud.net.cn/uni-app-x/api/get-app.html#appmethods`);
                                const sourceFile = node.getSourceFile();
                                if (sourceFile.__relativeFileName) {
                                    const lineAndCharacter = ts.getLineAndCharacterOfPosition(sourceFile, node.pos);
                                    const fileName = sourceFile.__relativeFileName
                                        .split('?')[0]
                                        .replace(/\.(vue|uvue|uts).ts$/g, '.$1');
                                    console.error('at ' + fileName + ':' + lineAndCharacter.line);
                                }
                                // const lineAndCharacter = ts.getLineAndCharacterOfPosition(
                                //   sourceFile,
                                //   node.pos,
                                // )
                                // const start = ts.getPositionOfLineAndCharacter(
                                //   sourceFile,
                                //   lineAndCharacter.line - 2,
                                //   0,
                                //   // @ts-expect-error
                                //   /* allowEdits */ true,
                                // )
                                // const end = ts.getPositionOfLineAndCharacter(
                                //   sourceFile,
                                //   lineAndCharacter.line + 2,
                                //   1000,
                                //   // @ts-expect-error
                                //   /* allowEdits */ true,
                                // )
                                // const text = sourceFile.getText().slice(start, end)
                                // console.error(text)
                            }
                        }
                    }
                    return ts.visitEachChild(node, visitor, context);
                }
                return node;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

const COMPILE_TIME_METHODS = [
    "defineMixin" /* IDENTIFIER.DEFINE_MIXIN */,
    "definePlugin" /* IDENTIFIER.DEFINE_PLUGIN */,
];
const removeCompileTimeMethod = (ts) => {
    return {
        before(context) {
            // 移除编译时方法
            const visitor = (node) => {
                if (ts.isCallExpression(node) &&
                    ts.isIdentifier(node.expression) &&
                    node.arguments.length > 0) {
                    const methodName = node.expression.escapedText.toString();
                    if (COMPILE_TIME_METHODS.includes(methodName)) {
                        node = node.arguments[0];
                    }
                }
                return ts.visitEachChild(node, visitor, context);
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

const lifeCycleMap = new Map();
// App and Page
lifeCycleMap.set('onShow', false);
lifeCycleMap.set('onHide', false);
// App
lifeCycleMap.set('onAppShow', true); // true 表示有参数
lifeCycleMap.set('onLaunch', true);
lifeCycleMap.set('onError', true);
lifeCycleMap.set('onThemeChange', true);
lifeCycleMap.set('onKeyboardHeightChange', true);
lifeCycleMap.set('onPageNotFound', true);
lifeCycleMap.set('onUnhandledRejection', true);
lifeCycleMap.set('onLastPageBackPress', false);
lifeCycleMap.set('onExit', false);
// Page
lifeCycleMap.set('onLoad', true);
lifeCycleMap.set('onShow', true); // 页面onShow无参数、App onShow有参数，这里都按照有参数处理
lifeCycleMap.set('onReady', false);
lifeCycleMap.set('onUnload', false);
lifeCycleMap.set('onResize', true);
lifeCycleMap.set('onBackPress', true);
lifeCycleMap.set('onPageScroll', true);
lifeCycleMap.set('onTabItemTap', true);
lifeCycleMap.set('onReachBottom', false);
lifeCycleMap.set('onPullDownRefresh', false);
// Vue
lifeCycleMap.set('beforeCreate', false);
lifeCycleMap.set('created', false);
lifeCycleMap.set('beforeMount', false);
lifeCycleMap.set('mounted', false);
lifeCycleMap.set('beforeUpdate', false);
lifeCycleMap.set('updated', false);
lifeCycleMap.set('beforeUnmount', false);
lifeCycleMap.set('unmounted', false);
/**
 * defineComponent({
 *   onLoad(options) {},
 *   onShow: () => {},
 *   onLaunch: function (){},
 * })
 */
const transformLifeCycleOptions = (ts, ls) => {
    return {
        parser: {
            SourceFile(context) {
                const factory = context.factory;
                const tsUtils = createTsUtils(ts, undefined, context);
                const visitor = (node) => {
                    const updatedNode = ts.visitEachChild(node, visitor, context);
                    if (ts.isParameter(updatedNode) &&
                        !updatedNode.type &&
                        !updatedNode.dotDotDotToken) {
                        const methodNode = updatedNode.parent;
                        if (methodNode &&
                            (ts.isMethodDeclaration(methodNode) ||
                                ts.isArrowFunction(methodNode) ||
                                ts.isFunctionExpression(methodNode)) &&
                            methodNode.parameters.indexOf(updatedNode) === 0) {
                            const methodNameNode = tsUtils.getMethodNameNodeOfObjectLiteral(methodNode);
                            if (methodNameNode && ts.isIdentifier(methodNameNode)) {
                                const methodName = methodNameNode.escapedText.toString();
                                if (lifeCycleMap.get(methodName) === true) {
                                    const callExpressionNode = methodNameNode?.parent?.parent?.parent;
                                    if (callExpressionNode &&
                                        ts.isCallExpression(callExpressionNode)) {
                                        const callExpressionNameNode = callExpressionNode.expression;
                                        if (ts.isIdentifier(callExpressionNameNode) &&
                                            isDefineMethod(callExpressionNameNode.escapedText.toString())) {
                                            return factory.createParameterDeclaration(updatedNode.modifiers, updatedNode.dotDotDotToken, updatedNode.name, updatedNode.questionToken, factory.createTypeReferenceNode(factory.createIdentifier(methodName.replace(/^(\w)/, (str) => str.toUpperCase()) + 'Options'), undefined), updatedNode.initializer);
                                            // return factory.updateParameterDeclaration(
                                            //   node,
                                            //   node.modifiers,
                                            //   node.dotDotDotToken,
                                            //   node.name,
                                            //   node.questionToken,
                                            //   factory.createTypeReferenceNode(
                                            //     factory.createIdentifier(
                                            //       methodName.replace(/^(\w)/, (str) =>
                                            //         str.toUpperCase(),
                                            //       ) + 'Options',
                                            //     ),
                                            //     undefined,
                                            //   ),
                                            //   node.initializer,
                                            // )
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return updatedNode;
                };
                return (node) => {
                    if (!node.isVueFile) {
                        return node;
                    }
                    return ts.visitEachChild(node, visitor, context);
                };
            },
        },
    };
};

/**
 * module M {
 *     export module E {
 *         export type C = {
 *             a: number
 *         }
 *         export class D { }
 *     }
 * }
 * const a = {
 *     a: 1
 * } as M.E.C
 * new M.E.D()
 */
function transformQualifiedNameToPropertyAccessExpression(tsUtils, node) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const factory = context.factory;
    return factory.createPropertyAccessExpression(ts.isQualifiedName(node.left)
        ? transformQualifiedNameToPropertyAccessExpression(tsUtils, node.left)
        : node.left, node.right);
}
function createNewExpressionFromObjectLiteral(tsUtils, objectLiteral, className) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const factory = context.factory;
    const classExpression = ts.isQualifiedName(className)
        ? transformQualifiedNameToPropertyAccessExpression(tsUtils, className)
        : factory.createIdentifier(className.escapedText.toString());
    return factory.createNewExpression(classExpression, undefined, [
        objectLiteral,
    ]);
}
function transformAsExpression(tsUtils, node) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const typeChecker = tsUtils.typeChecker;
    const factory = context.factory;
    const { type, expression } = node;
    if (!ts.isObjectLiteralExpression(expression)) {
        return;
    }
    if (ts.isTypeReferenceNode(type) &&
        ts.isIdentifier(type.typeName) &&
        type.typeName.escapedText === 'UTSJSONObject') {
        return factory.createNewExpression(factory.createIdentifier('UTSJSONObject'), undefined, [expression]);
    }
    let symbol;
    try {
        symbol = typeChecker.getContextualType(expression)?.symbol;
    }
    catch (error) { }
    if (!symbol) {
        return;
    }
    if (symbol && symbol.escapedName === 'UTSJSONObject') {
        return factory.createNewExpression(factory.createIdentifier('UTSJSONObject'), undefined, [expression]);
    }
    if (type &&
        isNodeTransformable(tsUtils, expression) &&
        ts.isObjectLiteralExpression(expression)) {
        return createNewExpressionFromObjectLiteral(tsUtils, expression, type.typeName);
    }
}
const transformTypedObjectLiteral = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const typeChecker = program.getTypeChecker();
            const tsUtils = createTsUtils(ts, typeChecker, context);
            const factory = context.factory;
            const visitor = (node) => {
                if (ts.isAsExpression(node) && node.type) {
                    const transformed = transformAsExpression(tsUtils, node);
                    if (transformed) {
                        return factory.createNewExpression(transformed.expression, transformed.typeArguments, [ts.visitEachChild(node, visitor, context)]);
                    }
                }
                node = ts.visitEachChild(node, visitor, context);
                return node;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

function parseVariableDeclaration(tsUtils, node) {
    const context = tsUtils.context;
    const factory = context.factory;
    const typeChecker = tsUtils.typeChecker;
    // node.type 包含 null
    if (!node.initializer &&
        node.pos > 0 &&
        tsUtils.isPossibleNullType(typeChecker.getTypeAtLocation(node))) {
        return factory.updateVariableDeclaration(node, node.name, node.exclamationToken, node.type, factory.createNull());
    }
    return node;
}
function parseParameter(tsUtils, node) {
    const { modifiers, dotDotDotToken, name, questionToken, type, initializer } = node;
    if (node.pos < 0 || initializer || dotDotDotToken) {
        return node;
    }
    const context = tsUtils.context;
    const factory = context.factory;
    const typeChecker = tsUtils.typeChecker;
    const ts = tsUtils.ts;
    if (ts.isMethodDeclaration(node.parent) &&
        ts.isIdentifier(node.parent.name) &&
        node.parent.name.text === 'setup') {
        /**
         * vue内部会通过setup.length判断需不需要传context给setup函数。
         * (function(props, context){}).length === 2
         * (function(props = 1, context){}).length === 0
         */
        return node;
    }
    if (questionToken ||
        tsUtils.isPossibleNullType(typeChecker.getTypeAtLocation(node))) {
        return factory.updateParameterDeclaration(node, modifiers, dotDotDotToken, name, questionToken, type && tsUtils.createTypeNodeWithNullType(type, true), initializer || factory.createNull());
    }
    return node;
}
/**
 * 开发者自行指定返回值为为null或包含null时，将`return`转化为`return null`
 * 未指定返回类型时，将`return`转化为`return null`
 *
 * TODO: 返回值类型指定为`Promise<null>`时，需要将`return`转化为`return Promise.resolve(null)`
 */
function parseFunctionLikeDeclaration(tsUtils, node) {
    const ts = tsUtils.ts;
    const context = tsUtils.context;
    const factory = context.factory;
    const typeChecker = tsUtils.typeChecker;
    const { modifiers, type } = node;
    const isAsync = modifiers?.some((modifier) => modifier.kind === ts.SyntaxKind.AsyncKeyword);
    let returnNullType = false;
    let returnPromiseNullType = false;
    if (type) {
        const returnType = typeChecker
            .getSignatureFromDeclaration(node)
            ?.getReturnType();
        if (returnType) {
            returnNullType = tsUtils.isPossibleNullType(returnType);
            returnPromiseNullType = tsUtils.isPossiblePromiseNullType(returnType);
            if (!returnNullType && !returnPromiseNullType) {
                return node;
            }
        }
    }
    function findReturnStatement(node) {
        if (ts.isFunctionLike(node)) {
            return node;
        }
        else if (ts.isReturnStatement(node)) {
            if (!node.expression) {
                return factory.updateReturnStatement(node, isAsync || returnPromiseNullType
                    ? factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier('Promise'), factory.createIdentifier('resolve')), undefined, [factory.createNull()])
                    : factory.createNull());
            }
        }
        return ts.visitEachChild(node, findReturnStatement, context);
    }
    return ts.visitEachChild(node, findReturnStatement, context);
}
const transformUndefinedToNull = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const typeChecker = program.getTypeChecker();
            const tsUtils = createTsUtils(ts, typeChecker, context);
            const visitor = (node) => {
                if (ts.isVariableDeclaration(node) &&
                    !node.initializer &&
                    (!node.parent || !ts.isCatchClause(node.parent)) &&
                    ts.isIdentifier(node.name)) {
                    // 为未初始化的变量声明增加默认值，属性声明在transformTypeAndInterface内处理
                    node = parseVariableDeclaration(tsUtils, node);
                }
                else if (ts.isParameter(node)) {
                    // 为可选参数增加默认值
                    node = parseParameter(tsUtils, node);
                }
                else if (ts.isFunctionDeclaration(node) ||
                    ts.isMethodDeclaration(node) ||
                    ts.isArrowFunction(node) ||
                    ts.isFunctionExpression(node) ||
                    ts.isGetAccessorDeclaration(node)) {
                    // 为函数声明增加默认值
                    node = parseFunctionLikeDeclaration(tsUtils, node);
                }
                node = ts.visitEachChild(node, visitor, context);
                return node;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

// function isJsNativeType(symbol: tsTypes.Symbol): boolean {
//   if (!symbol) return false
//   const declarations = symbol.getDeclarations()
//   if (!declarations) return false
//   for (const declaration of declarations) {
//     if (
//       declaration.getSourceFile().isDeclarationFile &&
//       /lib\..*\.d\.ts/i.test(declaration.getSourceFile().fileName)
//     ) {
//       return true
//     }
//   }
//   return false
// }
function transformJSON(tsUtils) {
    const context = tsUtils.context;
    const factory = context.factory;
    createUTSHelper(context);
    return factory.createPropertyAccessExpression(factory.createIdentifier("UTS" /* IDENTIFIER.UTS */), factory.createIdentifier("JSON" /* IDENTIFIER.JSON */));
}
function transformInstanceof(tsUtils, node) {
    const context = tsUtils.context;
    const factory = context.factory;
    createUTSHelper(context);
    return factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("UTS" /* IDENTIFIER.UTS */), factory.createIdentifier('isInstanceOf')), undefined, [node.left, node.right]);
}
const JS_RUNTIME_CALL_EXPRESSION_MAP = {
    Array_pop: 'arrayPop',
    Array_shift: 'arrayShift',
    Array_find: 'arrayFind',
    Array_findLast: 'arrayFindLast',
    Array_at: 'arrayAt',
    Map_get: 'mapGet',
    WeakMap_get: 'weakMapGet',
    string_codePointAt: 'stringCodePointAt',
    string_at: 'stringAt',
};
const JS_RUNTIME_CALL_METHOD_LIST = Object.keys(JS_RUNTIME_CALL_EXPRESSION_MAP).map((item) => item.split('_')[1]);
const GENERIC_TYPE_AS_PARAMETER_METHOD_MAP = [
    'uni.request',
    'JSON.parse',
    'JSON.parseArray',
    'JSON.parseObject',
];
function genericTypeToRuntimeType(tsUtils, type) {
    const ts = tsUtils.ts;
    const context = tsUtils.context;
    const factory = context.factory;
    if (ts.isArrayTypeNode(type)) {
        const { elementType } = type;
        return factory.createCallExpression(factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(createUTSHelper(context), factory.createIdentifier("UTSType" /* IDENTIFIER.UTS_TYPE */)), factory.createIdentifier('withGenerics')), undefined, [
            factory.createIdentifier('Array'),
            factory.createArrayLiteralExpression([
                genericTypeToRuntimeType(tsUtils, elementType),
            ]),
            factory.createTrue(),
        ]);
    }
    if (ts.isTypeReferenceNode(type)) {
        const { typeName, typeArguments } = type;
        if (!ts.isIdentifier(typeName)) {
            const diag = ts.createDiagnosticForNode(typeName, UTSDiagnostics.Invalid_generic_type_which_can_not_be_constructed);
            context.addSemanticDiagnostic(diag);
            return factory.createIdentifier("UTSJSONObject" /* IDENTIFIER.UTSJSONObject */);
        }
        if (!typeArguments || typeArguments.length === 0) {
            return factory.createIdentifier(typeName.escapedText.toString());
        }
        return factory.createCallExpression(factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(createUTSHelper(context), factory.createIdentifier("UTSType" /* IDENTIFIER.UTS_TYPE */)), factory.createIdentifier('withGenerics')), undefined, [
            factory.createIdentifier(typeName.escapedText.toString()),
            factory.createArrayLiteralExpression(typeArguments.map((item) => genericTypeToRuntimeType(tsUtils, item))),
            factory.createTrue(),
        ]);
    }
    return createRuntimeTypeNode(tsUtils, type);
}
const nativeTypeNames = [
    'Array',
    'Map',
    'WeakMap',
    'string',
    'String',
    'number',
    'Number',
    'boolean',
    'Boolean',
    'UTSJSONObject',
];
function parseJsRuntimeCallExpression(tsUtils, node) {
    const context = tsUtils.context;
    const factory = context.factory;
    const typeChecker = tsUtils.typeChecker;
    const ts = tsUtils.ts;
    const { expression, arguments: args } = node;
    if (!ts.isPropertyAccessExpression(expression)) {
        return node;
    }
    const { expression: object, name: prop } = expression;
    if (ts.isIdentifier(object) && ts.isIdentifier(prop)) {
        if (GENERIC_TYPE_AS_PARAMETER_METHOD_MAP.includes(`${object.escapedText}.${prop.escapedText}`)) {
            const typeArgument = node.typeArguments?.[0];
            if (typeArgument &&
                ts.isTypeReferenceNode(typeArgument) &&
                typeArgument.pos > 0 &&
                ts.isIdentifier(typeArgument.typeName)) {
                const isNativeType = nativeTypeNames.includes(typeArgument.typeName.escapedText.toString());
                let symbol;
                if (!isNativeType) {
                    symbol = typeChecker.getSymbolAtLocation(typeArgument);
                    if (!symbol) {
                        const typeName = typeArgument.typeName.escapedText;
                        symbol = typeChecker
                            .getSymbolsInScope(node, ts.SymbolFlags.Type)
                            .find((item) => item.escapedName === typeName);
                    }
                }
                if (isNativeType ||
                    (symbol && isSymbolTransformable(tsUtils, symbol))) {
                    return factory.updateCallExpression(node, expression, undefined, [
                        ...args,
                        genericTypeToRuntimeType(tsUtils, typeArgument),
                    ]);
                }
            }
        }
    }
    if (!ts.isIdentifier(prop) ||
        !JS_RUNTIME_CALL_METHOD_LIST.includes(prop.escapedText.toString())) {
        return node;
    }
    if (object.pos < 0) {
        return node;
    }
    const objectType = typeChecker.getTypeAtLocation(object);
    // 注意需要处理Map<string, any> Array<number> WeakMap<Object, any>等场景
    let objectBaseTypeName = '';
    if (typeChecker.isArrayType(objectType)) {
        objectBaseTypeName = 'Array';
    }
    else if (
    // @ts-ignore
    typeChecker.isTypeAssignableTo(objectType, typeChecker.getStringType())) {
        objectBaseTypeName = 'string';
    }
    const symbolName = objectType.symbol?.escapedName.toString();
    if (symbolName === 'Map') {
        objectBaseTypeName = 'Map';
    }
    else if (symbolName === 'WeakMap') {
        objectBaseTypeName = 'WeakMap';
    }
    const propName = prop.escapedText;
    const helperName = JS_RUNTIME_CALL_EXPRESSION_MAP[`${objectBaseTypeName}_${propName}`];
    if (!helperName) {
        return node;
    }
    createUTSHelper(context);
    return factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("UTS" /* IDENTIFIER.UTS */), factory.createIdentifier(helperName)), undefined, [object, ...args]);
}
const transformUTSRuntime = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const typeChecker = program.getTypeChecker();
            const tsUtils = createTsUtils(ts, typeChecker, context);
            const visitor = (node) => {
                if (ts.isIdentifier(node)) {
                    if (node.escapedText === "JSON" /* IDENTIFIER.JSON */) {
                        // 替换JSON对象
                        return transformJSON(tsUtils);
                    }
                }
                else if (ts.isBinaryExpression(node)) {
                    if (node.operatorToken.kind === ts.SyntaxKind.InstanceOfKeyword) {
                        node = transformInstanceof(tsUtils, node);
                    }
                }
                else if (ts.isCallExpression(node)) {
                    if (ts.isPropertyAccessExpression(node.expression)) {
                        node = parseJsRuntimeCallExpression(tsUtils, node);
                    }
                }
                node = ts.visitEachChild(node, visitor, context);
                return node;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

const transformUTSValueIterable = (ts, ls) => {
    return {
        parser: {
            SourceFile: (context) => {
                const factory = context.factory;
                const visitor = (node) => {
                    let updatedNode = ts.visitEachChild(node, visitor, context);
                    if (ts.isMethodDeclaration(updatedNode) &&
                        ts.isIdentifier(updatedNode.name) &&
                        updatedNode.name.escapedText === 'valueIterator') {
                        return factory.createMethodDeclaration(updatedNode.modifiers, updatedNode.asteriskToken, factory.createComputedPropertyName(factory.createPropertyAccessExpression(factory.createIdentifier('Symbol'), factory.createIdentifier('iterator'))), updatedNode.questionToken, updatedNode.typeParameters, updatedNode.parameters, updatedNode.type, updatedNode.body);
                    }
                    else if (ts.isExpressionWithTypeArguments(node) &&
                        ts.isIdentifier(node.expression) &&
                        node.expression.escapedText === 'UTSValueIterable') {
                        return factory.createExpressionWithTypeArguments(factory.createIdentifier('Iterable'), node.typeArguments);
                    }
                    return updatedNode;
                };
                return (node) => {
                    return ts.visitEachChild(node, visitor, context);
                };
            },
        },
    };
};

function componentPublicInstancePropertyAccessFallback(ts, typeChecker, node, left, leftType, right) {
    if (!ts.isPropertyAccessExpression(node) ||
        !ts.isExpression(left) ||
        !ts.isIdentifier(right)) {
        return;
    }
    const leftTypeAliasSymbolName = leftType.aliasSymbol?.escapedName.toString();
    if (leftTypeAliasSymbolName !== 'ComponentPublicInstance' &&
        leftTypeAliasSymbolName !== 'CreateComponentPublicInstance') {
        return;
    }
    const propertyName = right.escapedText.toString();
    const globalPropertiesMap = globalThis?.__utsUniXGlobalProperties__;
    if (globalPropertiesMap && globalPropertiesMap.has(propertyName)) {
        const { initializerNode } = globalPropertiesMap.get(propertyName);
        const type = typeChecker.getTypeAtLocation(initializerNode);
        if (type.isNumberLiteral()) {
            return typeChecker.getNumberType();
        }
        else if (type.isStringLiteral()) {
            return typeChecker.getStringType();
        }
        else if (type.flags & ts.TypeFlags.BooleanLiteral) {
            return typeChecker.getBooleanType();
        }
        return type;
    }
}

function isRelatedTo(ts, typeChecker, source, target) {
    const tsUtils = createTsUtils(ts, typeChecker, undefined);
    const nullType = typeChecker.getNullType();
    const undefinedType = typeChecker.getUndefinedType();
    const voidType = typeChecker.getVoidType();
    // const anyType = typeChecker.getAnyType()
    const stringType = typeChecker.getStringType();
    function isPossibleSpecialStringType(type) {
        // TODO 副作用String可以赋值给string类型
        let baseTypes = type.getBaseTypes();
        return (baseTypes?.length === 1 &&
            baseTypes[0].getSymbol()?.getName() === 'String');
    }
    function isUndefinedType(type) {
        return type === undefinedType || type === voidType;
    }
    if ((tsUtils.isObjectLiteralType(source) &&
        tsUtils.isPossibleUTSJSONObjectType(target)) ||
        (tsUtils.isObjectLiteralType(target) &&
            tsUtils.isPossibleUTSJSONObjectType(source))) {
        /**
         * ObjectLiteral可以赋给UTSJSONObject
         */
        return true;
    }
    else if ((isUndefinedType(source) && target === nullType) ||
        (source === nullType && isUndefinedType(target))) {
        /**
         * undefined可以赋给null
         * 为处理函数返回值类型为undefined的情况
         * function test(): number | null {
         *   return
         * }
         * TODO: 寻找更优解决方案
         */
        return true;
    }
    // else if (
    //   ((source === nullType || isUndefinedType(source)) && target === anyType) ||
    //   ((target === nullType || isUndefinedType(target)) && source === anyType)
    // ) {
    //   // null | undefined 均不可赋给 any
    //   return false
    // }
    else if ((source === stringType && isPossibleSpecialStringType(target)) ||
        (isPossibleSpecialStringType(source) && target === stringType)) {
        return true;
    }
}

const uniModulesPath$1 = normalizePath(path__namespace.resolve((process.env.UNI_INPUT_DIR || ''), 'uni_modules'));
function isRequireIOSNativeUtsSdk(importer, importee) {
    if (!process.env.UNI_INPUT_DIR) {
        return false;
    }
    if (process.env.UNI_UTS_PLATFORM !== 'app-ios' &&
        process.env.UNI_UTS_PLATFORM !== 'app-harmony') {
        return false;
    }
    let importeeAbsolutePath = importee;
    if (importee.startsWith('@/')) {
        importeeAbsolutePath = path__namespace.resolve(process.env.UNI_INPUT_DIR, importee.slice(2));
    }
    else if (importee.startsWith('.')) {
        importeeAbsolutePath = path__namespace.resolve(path__namespace.dirname(importer), importee);
    }
    else if (path__namespace.isAbsolute(importee)) ;
    else {
        return false;
    }
    const uniModuleName = path__namespace
        .relative(uniModulesPath$1, importeeAbsolutePath)
        .replace(/\\/g, '/');
    if (uniModuleName.startsWith('.') || uniModuleName.indexOf('/') > -1) {
        return false;
    }
    if (process.env.UNI_UTS_PLATFORM === 'app-ios') {
        if (fsExistsSync(path__namespace.resolve(uniModulesPath$1, uniModuleName, 'utssdk')) &&
            !fsExistsSync(path__namespace.resolve(uniModulesPath$1, uniModuleName, 'utssdk/app-js'))) {
            return true;
        }
    }
    else if (process.env.UNI_UTS_PLATFORM === 'app-harmony') {
        // 鸿蒙平台和iOS平台不同，无论何时都优先使用app-harmony
        if (fsExistsSync(path__namespace.resolve(uniModulesPath$1, uniModuleName, 'utssdk')) &&
            fsExistsSync(path__namespace.resolve(uniModulesPath$1, uniModuleName, 'utssdk', 'app-harmony')) &&
            !fsExistsSync(path__namespace.resolve(uniModulesPath$1, uniModuleName, 'utssdk/app-js'))) {
            return true;
        }
    }
    return false;
}

function isTypeRelatedTo(ts, typeChecker, source, target) {
    return isRelatedTo(ts, typeChecker, source, target);
}

/**
 * 仅uts2js需要执行，目前主要用于提前处理vue相关类型文件内容，最终在rollup-plugin-uts内加载文件时执行
 */
function replaceVueTypes(fileName, content) {
    if (fileName.endsWith('runtime-core.d.ts')) {
        /**
         * 替换inject的定义为以下内容
         * type ObjectInjectOptions<I = Data> = {
         *   [K in keyof I]: {
         *     type: PropType<I[K]>;
         *     default: I[K];
         *   }
         * };
         * type InjectToObject<T> = T extends string[] ? {
         *   [K in T[number]]: unknown;
         * } : T extends ObjectInjectOptions<infer I> ? {
         *   [K in keyof I]: I[K];
         * } : never;
         */
        content = content.replace(/type ObjectInjectOptions = Record<([\s\S]+?)>;/, `type ObjectInjectOptions<I = Data> = {
    [K in keyof I]: {
      type: PropType<I[K]>;
      from?: string;
      default?: I[K] | (() => I[K]);
    }
  };`);
        content = content.replace(/type InjectToObject<T([\s\S]+?): never;/, `type InjectToObject<T> = T extends string[] ? {
    [K in T[number]]: unknown;
  } : T extends ObjectInjectOptions<infer I> ? {
    [K in keyof I]: I[K];
  } : never;`);
        // 由于null undefined不能赋值给any导致serverPrefetch报错，此处将serverPrefetch的Promise<any>替换为Promise<any | null>
        content = content.replace(/serverPrefetch\?\(\): void \| Promise<any>;/, `serverPrefetch?(): void | Promise<any | null>;`);
    }
    if (fileName.endsWith('app.d.ts')) {
        content = content.replace(/\s\sexport function defineApp<D extends OptionsData = OptionsData.*/, '');
    }
    return content;
}

const uniModulesRegExp = new RegExp('^' + uniModulesPath$2 + '/([a-zA-Z0-9_-]+)/index.d.ts$');
function getUniModulesName(fileName) {
    const matches = fileName.match(uniModulesRegExp);
    return matches ? matches[1] : '';
}
// TODO 本应修改tryResolveExtension来实现和这个列表一致的逻辑，遇到无法解决的Bug暂时回退为此方案resolve非vue后缀文件
// const COMMON_EXTENSIONS = [
//   '.uts',
//   '.mjs',
//   '.js',
//   '.ts',
//   '.jsx',
//   '.tsx',
//   '.json',
//   '.uvue',
//   '.vue',
// ]
const utsPlatForm = process.env.UNI_UTS_PLATFORM;
const isIOS = utsPlatForm === 'app-ios';
const isHarmony = utsPlatForm === 'app-harmony';
let POSSIBLE_UNI_MODULE_PLATFORM_ENTRY = [];
const appJsEntries = ['app-js/index.uts', 'app-js/index.ts', 'app-js/index.js'];
const appNativeEntries = [
    `${utsPlatForm}/index.uts`,
    `${utsPlatForm}/index.ts`,
    `${utsPlatForm}/index.js`,
];
if (isIOS || isHarmony) {
    POSSIBLE_UNI_MODULE_PLATFORM_ENTRY = appJsEntries;
}
else {
    POSSIBLE_UNI_MODULE_PLATFORM_ENTRY = appNativeEntries;
}
function tryFileLookup(fileName) {
    if (!process.env.UNI_INPUT_DIR) {
        return;
    }
    const uniModuleName = getUniModulesName(fileName);
    if (uniModuleName) {
        const uniModuleDir = path__namespace.resolve(uniModulesPath$2, uniModuleName, 'utssdk');
        if (isHarmony) {
            // app-harmony目录存在时不使用app-js
            const appHarmonyEntry = path__namespace.resolve(uniModuleDir, 'app-harmony/index.uts');
            if (fsExistsSync(appHarmonyEntry)) {
                return;
            }
        }
        // 处理uni_modules引用逻辑
        for (let i = 0; i < POSSIBLE_UNI_MODULE_PLATFORM_ENTRY.length; i++) {
            const entry = POSSIBLE_UNI_MODULE_PLATFORM_ENTRY[i];
            const entryPath = path__namespace.resolve(uniModuleDir, entry);
            if (fsExistsSync(entryPath)) {
                return normalizePath(entryPath);
            }
        }
        if (isIOS || isHarmony) {
            // app-ios不查找根目录入口
            return;
        }
        const commonEntry = path__namespace.resolve(uniModulesPath$2, uniModuleName, 'utssdk/index.uts');
        if (fsExistsSync(commonEntry)) {
            return normalizePath(commonEntry);
        }
    }
    else if (fileName.endsWith('.d.ts') && !fsExistsSync(fileName)) {
        // 处理不带后缀的uvue、vue文件引入逻辑，uts文件在插件内处理
        const fileNameWithoutExt = fileName.replace(/\.d\.ts$/, '');
        const possibleUvueFile = fileNameWithoutExt + '.uvue';
        if (fsExistsSync(possibleUvueFile)) {
            return possibleUvueFile + '.ts';
        }
        const possibleVueFile = fileNameWithoutExt + '.vue';
        if (fsExistsSync(possibleVueFile)) {
            return possibleVueFile + '.ts';
        }
    }
    else if (fileName.endsWith('.json') && fsExistsSync(fileName)) {
        // json文件不可通过修改readFile进行处理，因为ts本身还会读取tsconfig.json和package.json，另外tsconfig.json内也可以依赖其他json文件
        return fileName + '.ts';
    }
}

const hacker = {
    replaceVueTypes,
    isTypeRelatedTo,
    isRelatedTo,
    tryFileLookup,
    componentPublicInstancePropertyAccessFallback,
    isRequireIOSNativeUtsSdk,
    // tryExtensionAfter,
    // tryExtensionBefore,
    isUtsCompiler: true,
    hijackAnyNullUnionType: true,
    hijackTsLibResolve: true,
    hijackDestructuring: true,
    ignoreInstanceofLeftType: true,
    ignoreInstanceofRightType: true,
    useTypeAndInterfaceAsValue: true,
    ignoreAllDebugFail: true,
};

var transformers = [
    transformOptionalChain,
    transformContext,
    transformImportDeclaration,
    transformUniApp,
    transformUniExtApi,
    transformVueDefineComponent,
    transformUTSValueIterable,
    transformLifeCycleOptions,
    transformTypeAndInterface,
    transformObjectLiteral,
    transformComponentExtraProperty,
    transformClassImplements,
    transformTypedObjectLiteral,
    transformUTSRuntime,
    transformUndefinedToNull,
    transformRemoveVueTsExtention,
    removeCompileTimeMethod,
    transformCreateWorker,
];

const uniModulesPath = pluginutils.normalizePath(path__namespace.resolve((process.env.UNI_INPUT_DIR || ''), 'uni_modules'));
const uniModuleNameReg = new RegExp('^' + uniModulesPath + '/([a-zA-Z0-9_-]+)/');
const VUE_FILE_RE = /\.(u)?vue(.ts)?/;
let tsModule;
const utsFileNames = new Set();
function isUTSFile(fileName) {
    return (isVueFile(fileName) ||
        fileName.includes('.uts') ||
        utsFileNames.has(pluginutils.normalizePath(fileName)));
}
function isVueFile(fileName) {
    return VUE_FILE_RE.test(fileName);
}
function preprocessVueFile(content, modules) {
    // 获取script标签内的内容
    content = modules.uniCliShared.preUVueJs(modules.uniCliShared.preUVueHtml(content));
    const scriptNode = modules.vueCompilerDom
        .parse(content)
        .children.find((item) => item.tag === 'script');
    const emptyVueFile = 'export default {}';
    if (!scriptNode) {
        return emptyVueFile;
    }
    // TODO defineExpose
    if (scriptNode.props.some((prop) => prop.name === 'setup')) {
        // .vue.ts文件仅会在tsc内部处理时使用，使用了setup的文件导出空对象保证类型正确即可
        return ('// @uts-setup\n' +
            (scriptNode?.children[0]?.content || '') +
            '\n' +
            emptyVueFile);
    }
    else {
        return scriptNode?.children[0]?.content || emptyVueFile;
    }
}
function preprocessUtsFile(content, modules) {
    return modules.uniCliShared.preUVueJs(modules.uniCliShared.preUVueJs(content));
}
function preprocessJsonFile(content, modules) {
    const data = modules.uniCliShared.parseJson(content, true);
    return pluginutils.dataToEsm(data, {
        preferConst: true,
        compact: true,
    });
}
function setTypescriptModule(override, modules) {
    tsModule = override;
    // @ts-expect-error 判断是否已重写
    if (!tsModule.sys.__rewrited) {
        const { fileExists, readFile, realpath } = tsModule.sys;
        tsModule.sys.realpath = (path) => {
            const realFilePath = realpath ? realpath(path) : path;
            if (realFilePath.endsWith('.ts')) {
                if (utsFileNames.has(pluginutils.normalizePath(path))) {
                    return path.replace('.ts', '.uts');
                }
            }
            return realFilePath;
        };
        tsModule.sys.fileExists = (path) => {
            const normalizedPath = pluginutils.normalizePath(path);
            const matches = normalizedPath.match(uniModuleNameReg);
            const uniModuleName = matches ? matches[1] : '';
            if (uniModuleName &&
                fileExists(path__namespace.resolve(uniModulesPath, uniModuleName, 'encrypt'))) {
                return false;
            }
            if (normalizedPath.endsWith('.ts')) {
                if (fileExists(normalizedPath.replace('.ts', '.uts'))) {
                    utsFileNames.add(normalizedPath);
                    return true;
                }
            }
            if (normalizedPath.endsWith('.vue.ts') ||
                normalizedPath.endsWith('.uvue.ts')) {
                if (fileExists(normalizedPath.replace(/.ts$/, ''))) {
                    return true;
                }
            }
            if (normalizedPath.endsWith('.json.ts')) {
                if (fileExists(normalizedPath.replace(/.ts$/, ''))) {
                    return true;
                }
            }
            return fileExists(path);
        };
        tsModule.sys.readFile = (path, encoding) => {
            if (path.endsWith('.ts')) {
                if (utsFileNames.has(pluginutils.normalizePath(path))) {
                    const utsPath = path.replace('.ts', '.uts');
                    const content = readFile(utsPath, encoding);
                    if (content == null) {
                        return;
                    }
                    return preprocessUtsFile(content, modules);
                }
            }
            if (path.endsWith('.json.ts')) {
                const jsonPath = path.replace(/.ts$/, '');
                if (fileExists(jsonPath)) {
                    const content = readFile(jsonPath, encoding);
                    if (content == null) {
                        return;
                    }
                    return preprocessJsonFile(content, modules);
                }
            }
            if (path.endsWith('.vue.ts') || path.endsWith('.uvue.ts')) {
                const vuePath = path.replace(/.ts$/, '');
                if (fileExists(vuePath)) {
                    const content = readFile(vuePath, encoding);
                    if (content == null) {
                        return;
                    }
                    return preprocessVueFile(content, modules);
                }
            }
            let content = readFile(path, encoding);
            if (content == null) {
                return;
            }
            if (path.endsWith('runtime-dom/dist/runtime-dom.d.ts')) {
                // TODO 在tsc处理vue文件时，vue文件已经在头部引入jsx相关类型，简介引用了runtime-dom的类型，导致产生了runtimeDOMBailTypes: any; 在UnwrapRef类型推断时时会导致进入到错误的条件分支
                content = content.replace('runtimeDOMBailTypes: Node | Window;', '');
            }
            const replaceVueTypes = globalThis?.__utsHacker__
                ?.replaceVueTypes;
            return replaceVueTypes ? replaceVueTypes(path, content) : content;
        };
        // @ts-expect-error 设置重写标识
        tsModule.sys.__rewrited = true;
    }
}

class FormatHost {
    constructor() {
        this.getCanonicalFileName = path__namespace.normalize;
        this.getNewLine = () => tsModule.sys.newLine;
    }
    getCurrentDirectory() {
        return tsModule.sys.getCurrentDirectory();
    }
}
const formatHost = new FormatHost();

function isUTSCompilerError(error) {
    return error.type === 'UTSCompilerError';
}
// function formatDiagnosticFormatted(
//   diagnostic: IDiagnostics,
//   codeFrame: string,
// ) {
//   let color
//   let category
//   switch (diagnostic.category) {
//     case tsModule.DiagnosticCategory.Message:
//       color = white
//       category = ''
//       break
//     case tsModule.DiagnosticCategory.Error:
//       color = red
//       category = 'error'
//       break
//     case tsModule.DiagnosticCategory.Warning:
//     default:
//       color = yellow
//       category = 'warning'
//       break
//   }
//   return `${category} TS${diagnostic.code}: ${color(diagnostic.flatMessage)}
// ${codeFrame}`
// }
function formatDiagnostic(type, diagnostic, map) {
    const entry = {
        flatMessage: tsModule.flattenDiagnosticMessageText(diagnostic.messageText, formatHost.getNewLine()),
        formatted: tsModule.formatDiagnosticsWithColorAndContext([diagnostic], formatHost),
        category: diagnostic.category,
        code: diagnostic.code,
        type,
    };
    if (diagnostic.file && diagnostic.start !== undefined) {
        let { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
        if (map) {
            const mapped = map.originalPositionFor({
                line: line + 1,
                column: character,
                bias: sourceMapJs.SourceMapConsumer.LEAST_UPPER_BOUND,
            });
            if (mapped.line !== null) {
                if (mapped.source) {
                    const content = map.sourceContentFor(mapped.source);
                    if (content) {
                        const { line: endLine, character: endColumn } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start + (diagnostic.length || 0));
                        const end = map.originalPositionFor({
                            line: endLine + 1,
                            column: endColumn,
                        });
                        if (end.line !== null) {
                            const frame = codeFrame.codeFrameColumns(content, {
                                start: {
                                    line: mapped.line,
                                    column: (mapped.column || 0) + 1,
                                },
                                end: {
                                    line: end.line,
                                    column: (end.column || 0) + 1,
                                },
                            });
                            entry.rollupError = createRollupError(diagnostic.file.fileName, entry.flatMessage, line + 1, // 不使用sourcemap之后的line，rollup会自动处理
                            character + 1, frame);
                            entry.finalRollupError = createFinalRollupError(diagnostic.file.fileName, entry.flatMessage, mapped.line, // 不使用sourcemap之后的line，rollup会自动处理
                            mapped.column || 0, frame);
                            entry.utsCompilerError = {
                                type: 'UTSCompilerError',
                                file: pluginutils.normalizePath(path__namespace.relative(process.env.UNI_INPUT_DIR, diagnostic.file.fileName.split('?')[0])),
                                line: mapped.line,
                                column: mapped.column || 0,
                                message: entry.flatMessage,
                                frame,
                            };
                        }
                    }
                }
                line = mapped.line;
            }
        }
        entry.fileLine = `${diagnostic.file.fileName}(${line + 1},${character + 1})`;
    }
    return entry;
}
function convertDiagnostic(type, data, map) {
    return data.map((diagnostic) => {
        return formatDiagnostic(type, diagnostic, map);
    });
}
function printDiagnostics(context, diagnostics, pretty = true) {
    diagnostics.forEach((diagnostic) => {
        let print;
        let color;
        let category;
        switch (diagnostic.category) {
            case tsModule.DiagnosticCategory.Message:
                print = context.info;
                color = safe.white;
                category = '';
                break;
            case tsModule.DiagnosticCategory.Error:
                print = context.error;
                color = safe.red;
                category = 'error';
                break;
            case tsModule.DiagnosticCategory.Warning:
            default:
                print = context.warn;
                color = safe.yellow;
                category = 'warning';
                break;
        }
        const type = diagnostic.type + ' ';
        if (pretty) {
            if (diagnostic.utsCompilerError) {
                return print.call(context, diagnostic.utsCompilerError);
            }
            if (diagnostic.rollupError) {
                return print.call(context, diagnostic.rollupError);
            }
            return print.call(context, `${safe.enabled ? diagnostic.formatted : stripAnsi(diagnostic.formatted)}`);
        }
        if (diagnostic.fileLine !== undefined)
            return print.call(context, `${diagnostic.fileLine}: ${type}${category} TS${diagnostic.code}: ${color(diagnostic.flatMessage)}`);
        return print.call(context, `${type}${category} TS${diagnostic.code}: ${color(diagnostic.flatMessage)}`);
    });
}
const regex = ansiRegex();
// 避免增加新的依赖包
function stripAnsi(string) {
    if (typeof string !== 'string') {
        throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
    }
    // Even though the regex is global, we don't need to reset the `.lastIndex`
    // because unlike `.exec()` and `.test()`, `.replace()` does it automatically
    // and doing it manually has a performance penalty.
    return string.replace(regex, '');
}
// https://github.com/chalk/ansi-regex/blob/main/index.js
function ansiRegex({ onlyFirst = false } = {}) {
    const pattern = [
        '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
        '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))',
    ].join('|');
    return new RegExp(pattern, onlyFirst ? undefined : 'g');
}
function createRollupError(file, message, line, column, frame) {
    const rollupError = {
        id: file,
        message,
        frame,
        loc: {
            file,
            line,
            column,
        },
    };
    return rollupError;
}
function createFinalRollupError(file, message, line, column, frame) {
    const rollupError = new Error(message);
    Object.assign(rollupError, {
        message,
        frame,
        loc: {
            file,
            line,
            column,
        },
    });
    Object.defineProperty(rollupError, 'id', {
        get() {
            return file;
        },
        set(_v) { },
    });
    return rollupError;
}

var VerbosityLevel;
(function (VerbosityLevel) {
    VerbosityLevel[VerbosityLevel["Error"] = 0] = "Error";
    VerbosityLevel[VerbosityLevel["Warning"] = 1] = "Warning";
    VerbosityLevel[VerbosityLevel["Info"] = 2] = "Info";
    VerbosityLevel[VerbosityLevel["Debug"] = 3] = "Debug";
})(VerbosityLevel || (VerbosityLevel = {}));
function getText(message) {
    return typeof message === 'string' ? message : message();
}
/** cannot be used in options hook (which does not have this.warn and this.error), but can be in other hooks */
class RollupContext {
    constructor(verbosity, bail, context, prefix = '') {
        this.verbosity = verbosity;
        this.bail = bail;
        this.context = context;
        this.prefix = prefix;
    }
    warn(message) {
        if (this.verbosity < VerbosityLevel.Warning)
            return;
        this.context.warn(`${getText(message)}`);
    }
    error(message) {
        if (this.verbosity < VerbosityLevel.Error)
            return;
        if (this.bail) {
            // abortOnError
            if (typeof message === 'string' || typeof message === 'function') {
                this.context.error(`${getText(message)}`);
            }
            else {
                this.context.error(message);
            }
        }
        else {
            if (isUTSCompilerError(message)) {
                console.warn(`warning: ${message.message}`);
                console.warn(`at ${message.file}:${message.line}:${message.column}`);
                console.log(message.frame);
            }
            else if (typeof message === 'string' || typeof message === 'function') {
                this.context.warn(`${getText(message)}`);
            }
            else {
                this.context.warn(message);
            }
        }
    }
    info(message) {
        if (this.verbosity < VerbosityLevel.Info)
            return;
        console.log(`${this.prefix}${getText(message)}`);
    }
    debug(message) {
        if (this.verbosity < VerbosityLevel.Debug)
            return;
        console.log(`${this.prefix}${getText(message)}`);
    }
}

function getOptionsOverrides({ useTsconfigDeclarationDir, cacheRoot }, preParsedTsconfig) {
    const overrides = {
        noEmitHelpers: false,
        importHelpers: true,
        noResolve: false,
        noEmit: false,
        noEmitOnError: false,
        inlineSourceMap: false,
        outDir: pluginutils.normalizePath(`${cacheRoot}/placeholder`),
        allowNonTsExtensions: true,
    };
    if (!preParsedTsconfig)
        return overrides;
    if (preParsedTsconfig.options.moduleResolution ===
        tsModule.ModuleResolutionKind.Classic)
        overrides.moduleResolution = tsModule.ModuleResolutionKind.Node10;
    if (preParsedTsconfig.options.module === undefined)
        overrides.module = tsModule.ModuleKind.ES2015;
    // only set declarationDir if useTsconfigDeclarationDir is enabled
    if (!useTsconfigDeclarationDir)
        overrides.declarationDir = undefined;
    // unsetting sourceRoot if sourceMap is not enabled (in case original tsconfig had inlineSourceMap set that is being unset and would cause TS5051)
    const sourceMap = preParsedTsconfig.options.sourceMap;
    if (!sourceMap)
        overrides.sourceRoot = undefined;
    return overrides;
}
function expandIncludeWithDirs(include, dirs) {
    const newDirs = [];
    dirs.forEach((root) => {
        if (include instanceof Array)
            include.forEach((x) => newDirs.push(pluginutils.normalizePath(path__namespace.join(root, x))));
        else
            newDirs.push(pluginutils.normalizePath(path__namespace.join(root, include)));
    });
    return newDirs;
}
function createFilter(context, pluginOptions, parsedConfig) {
    let included = pluginOptions.include;
    let excluded = pluginOptions.exclude;
    if (parsedConfig.options.rootDirs) {
        included = expandIncludeWithDirs(included, parsedConfig.options.rootDirs);
        excluded = expandIncludeWithDirs(excluded, parsedConfig.options.rootDirs);
    }
    if (parsedConfig.projectReferences) {
        included = expandIncludeWithDirs(included, parsedConfig.projectReferences.map((x) => x.path)).concat(included);
        excluded = expandIncludeWithDirs(excluded, parsedConfig.projectReferences.map((x) => x.path)).concat(excluded);
    }
    context.debug(() => `included:\n${JSON.stringify(included, undefined, 4)}`);
    context.debug(() => `excluded:\n${JSON.stringify(excluded, undefined, 4)}`);
    return pluginutils.createFilter(included, excluded, {
        resolve: parsedConfig.options.rootDir,
    });
}

class LanguageServiceHost {
    constructor(parsedConfig, transformers, cwd) {
        this.parsedConfig = parsedConfig;
        this.transformers = transformers;
        this.cwd = cwd;
        this.snapshots = {};
        this.versions = {};
        this.customParser = {};
        this.getScriptFileNames = () => Array.from(this.fileNames.values());
        this.getCompilationSettings = () => this.parsedConfig.options;
        this.getTypeRootsVersion = () => 0;
        this.getCurrentDirectory = () => this.cwd;
        this.useCaseSensitiveFileNames = () => tsModule.sys.useCaseSensitiveFileNames;
        this.getDefaultLibFileName = tsModule.getDefaultLibFilePath; // confusing naming: https://github.com/microsoft/TypeScript/issues/35318
        this.readDirectory = tsModule.sys.readDirectory;
        this.readFile = tsModule.sys.readFile;
        this.fileExists = tsModule.sys.fileExists;
        this.directoryExists = tsModule.sys.directoryExists;
        this.getDirectories = tsModule.sys.getDirectories;
        this.realpath = tsModule.sys.realpath; // this exists in the default implementation: https://github.com/microsoft/TypeScript/blob/ab2523bbe0352d4486f67b73473d2143ad64d03d/src/compiler/sys.ts#L1288
        this.trace = console.log;
        this.fileNames = new Set(parsedConfig.fileNames);
    }
    reset() {
        this.snapshots = {};
        this.versions = {};
    }
    setLanguageService(service) {
        // 补充辅助方法
        service.shouldTransform = (fileName) => {
            if (!fileName) {
                return false;
            }
            return (isUTSFile(fileName) ||
                // uts2js 要用
                fileName.endsWith('.json.ts') ||
                fileName.endsWith('.d.ts'));
        };
        service.isVueFile = isVueFile;
        this.service = service;
        // // 初始化service时，初始化transformers，仅初始化一次
        if (!this.customTransformers) {
            this.initTransformers(this.transformers || []);
        }
    }
    setSnapshot(fileName, source) {
        fileName = pluginutils.normalizePath(fileName);
        if (fileName.endsWith('.uts')) {
            this.setSnapshot(fileName.replace(/\.uts$/, '.ts'), source);
        }
        const snapshot = tsModule.ScriptSnapshot.fromString(source);
        this.snapshots[fileName] = snapshot;
        this.versions[fileName] = (this.versions[fileName] || 0) + 1;
        this.fileNames.add(fileName);
        return snapshot;
    }
    getScriptSnapshot(fileName) {
        fileName = pluginutils.normalizePath(fileName);
        if (fileName in this.snapshots)
            return this.snapshots[fileName];
        const source = tsModule.sys.readFile(fileName);
        if (source != null)
            return this.setSnapshot(fileName, source);
        return undefined;
    }
    getScriptVersion(fileName) {
        fileName = pluginutils.normalizePath(fileName);
        return (this.versions[fileName] || 0).toString();
    }
    initTransformers(transformers) {
        if (this.service === undefined ||
            transformers === undefined ||
            this.transformers.length === 0)
            return undefined;
        const transformer = {
            before: [],
            after: [],
            afterDeclarations: [],
        };
        for (const creator of transformers) {
            const factory = creator(this.service);
            if (factory.parser) {
                this.customParser = factory.parser;
            }
            if (factory.before)
                transformer.before = transformer.before.concat(factory.before);
            if (factory.after)
                transformer.after = transformer.after.concat(factory.after);
            if (factory.afterDeclarations)
                transformer.afterDeclarations = transformer.afterDeclarations.concat(factory.afterDeclarations);
        }
        this.customTransformers = transformer;
        globalThis.__utsParser__ = this.customParser;
        return transformer;
    }
    getCustomTransformers() {
        return this.customTransformers;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setCompilerHost(host) {
        // TODO: implement
    }
}

function parseTsConfig(context, pluginOptions) {
    const fileName = tsModule.findConfigFile(pluginOptions.cwd, tsModule.sys.fileExists, pluginOptions.tsconfig);
    // if the value was provided, but no file, fail hard
    if (pluginOptions.tsconfig !== undefined && !fileName)
        context.error(`failed to open '${pluginOptions.tsconfig}'`);
    let loadedConfig = {};
    let baseDir = pluginOptions.cwd;
    let configFileName;
    let pretty = true;
    if (fileName) {
        const text = tsModule.sys.readFile(fileName); // readFile only returns undefined when the file doesn't exist, which we already checked above
        const result = tsModule.parseConfigFileTextToJson(fileName, text);
        pretty = result.config?.pretty ?? pretty;
        if (result.error !== undefined) {
            printDiagnostics(context, convertDiagnostic('config', [result.error]), pretty);
            context.error(`failed to parse '${fileName}'`);
        }
        loadedConfig = result.config;
        baseDir = path.dirname(fileName);
        configFileName = fileName;
    }
    const mergedConfig = {};
    ___namespace.merge(mergedConfig, pluginOptions.tsconfigDefaults, loadedConfig, pluginOptions.tsconfigOverride);
    const preParsedTsConfig = tsModule.parseJsonConfigFileContent(mergedConfig, tsModule.sys, baseDir, getOptionsOverrides(pluginOptions), configFileName);
    const compilerOptionsOverride = getOptionsOverrides(pluginOptions, preParsedTsConfig);
    const parsedTsConfig = tsModule.parseJsonConfigFileContent(mergedConfig, tsModule.sys, baseDir, compilerOptionsOverride, configFileName);
    const module = parsedTsConfig.options.module;
    if (module !== tsModule.ModuleKind.ES2015 &&
        module !== tsModule.ModuleKind.ES2020 &&
        module !== tsModule.ModuleKind.ES2022 &&
        module !== tsModule.ModuleKind.ESNext)
        context.error(`Incompatible tsconfig option. Module resolves to '${tsModule.ModuleKind[module]}'. This is incompatible with Rollup, please use 'module: "ES2015"', 'module: "ES2020"', 'module: "ES2022"', or 'module: "ESNext"'.`);
    printDiagnostics(context, convertDiagnostic('config', parsedTsConfig.errors), pretty);
    context.debug(`built-in options overrides: ${JSON.stringify(compilerOptionsOverride, undefined, 4)}`);
    context.debug(`parsed tsconfig: ${JSON.stringify(parsedTsConfig, undefined, 4)}`);
    return { parsedTsConfig, fileName };
}

/**
 * Saves data in new cache folder or reads it from old one.
 * Avoids perpetually growing cache and situations when things need to consider changed and then reverted data to be changed.
 */
class RollingCache {
    /** @param cacheRoot: root folder for the cache */
    constructor(cacheRoot) {
        this.cacheRoot = cacheRoot;
        this.rolled = false;
        this.oldCacheRoot = `${this.cacheRoot}/cache`;
        this.newCacheRoot = `${this.cacheRoot}/cache_`;
        fs$1.emptyDirSync(this.newCacheRoot);
    }
    /** @returns true if name exists in either old cache or new cache */
    exists(name) {
        if (this.rolled)
            return false;
        if (fs.existsSync(`${this.newCacheRoot}/${name}`))
            return true;
        return fs.existsSync(`${this.oldCacheRoot}/${name}`);
    }
    path(name) {
        return `${this.oldCacheRoot}/${name}`;
    }
    /** @returns true if old cache contains all names and nothing more */
    match(names) {
        if (this.rolled)
            return false;
        if (!fs.existsSync(this.oldCacheRoot))
            return names.length === 0; // empty folder matches
        return ___namespace.isEqual(fs.readdirSync(this.oldCacheRoot).sort(), names.sort());
    }
    /** @returns data for name, must exist in either old cache or new cache */
    read(name) {
        if (fs.existsSync(`${this.newCacheRoot}/${name}`))
            return fs$1.readJsonSync(`${this.newCacheRoot}/${name}`, {
                encoding: 'utf8',
                throws: false,
            });
        return fs$1.readJsonSync(`${this.oldCacheRoot}/${name}`, {
            encoding: 'utf8',
            throws: false,
        });
    }
    write(name, data) {
        if (this.rolled)
            return;
        if (data === undefined)
            return;
        fs$1.writeJsonSync(`${this.newCacheRoot}/${name}`, data);
    }
    touch(name) {
        if (this.rolled)
            return;
        fs$1.ensureFileSync(`${this.newCacheRoot}/${name}`);
    }
    /** clears old cache and moves new in its place */
    roll() {
        if (this.rolled)
            return;
        this.rolled = true;
        fs$1.removeSync(this.oldCacheRoot);
        if (fs.existsSync(this.newCacheRoot)) {
            fs.renameSync(this.newCacheRoot, this.oldCacheRoot);
        }
    }
}

function convertEmitOutput(output, references, uniExtApis) {
    const out = { code: '', references, uniExtApis };
    output.outputFiles.forEach((e) => {
        if (e.name.endsWith('.d.ts'))
            out.dts = e;
        else if (e.name.endsWith('.d.ts.map'))
            out.dtsmap = e;
        else if (e.name.endsWith('.map'))
            out.map = e.text;
        else
            out.code = e.text;
    });
    return out;
}
function getAllReferences(importer, snapshot, options) {
    if (!snapshot)
        return [];
    const info = tsModule.preProcessFile(snapshot.getText(0, snapshot.getLength()), true, true);
    return ___namespace.compact(info.referencedFiles.concat(info.importedFiles).map((reference) => {
        const resolved = tsModule.nodeModuleNameResolver(reference.fileName, importer, options, tsModule.sys);
        const resolvedFileName = resolved.resolvedModule?.resolvedFileName;
        if (resolvedFileName &&
            utsFileNames.has(pluginutils.normalizePath(resolvedFileName)) &&
            resolvedFileName.endsWith('.ts')) {
            return resolvedFileName.replace(/.ts$/, '.uts');
        }
        return resolvedFileName;
    }));
}
class TsCache {
    constructor(noCache, runClean, hashIgnoreUnknown, host, cacheRoot, options, rootFilenames, context) {
        this.noCache = noCache;
        this.host = host;
        this.cacheRoot = cacheRoot;
        this.options = options;
        this.context = context;
        this.cacheVersion = '9';
        this.cachePrefix = 'uts_';
        this.ambientTypesDirty = false;
        // fixed by xxxxxx add const
        this.hashOptions = { algorithm: 'sha1', ignoreUnknown: false };
        this.dependencyTree = new graphlib.Graph({ directed: true });
        this.dependencyTree.setDefaultNodeLabel(() => ({ dirty: false }));
        if (runClean)
            this.clean();
        if (noCache)
            return;
        this.hashOptions.ignoreUnknown = hashIgnoreUnknown;
        this.cacheDir = `${this.cacheRoot}/${this.cachePrefix}${objHash({
            version: this.cacheVersion,
            rootFilenames,
            options: this.options,
            tsVersion: tsModule.version,
        }, this.hashOptions)}`;
        this.init();
        const automaticTypes = tsModule
            .getAutomaticTypeDirectiveNames(options, tsModule.sys)
            .map((entry) => tsModule.resolveTypeReferenceDirective(entry, undefined, options, tsModule.sys))
            .filter((entry) => entry.resolvedTypeReferenceDirective?.resolvedFileName)
            .map((entry) => entry.resolvedTypeReferenceDirective.resolvedFileName);
        this.ambientTypes = rootFilenames
            .filter((file) => file.endsWith('.d.ts'))
            .concat(automaticTypes)
            .map((id) => ({ id, snapshot: this.host.getScriptSnapshot(id) }));
        this.checkAmbientTypes();
    }
    clean() {
        if (!fs__namespace$1.pathExistsSync(this.cacheRoot))
            return;
        const entries = fs__namespace$1.readdirSync(this.cacheRoot);
        entries.forEach((e) => {
            const dir = `${this.cacheRoot}/${e}`;
            /* istanbul ignore if -- this is a safety check, but shouldn't happen when using a dedicated cache dir */
            if (!e.startsWith(this.cachePrefix)) {
                this.context.debug(`skipping cleaning '${dir}' as it does not have prefix '${this.cachePrefix}'`);
                return;
            }
            /* istanbul ignore if -- this is a safety check, but should never happen in normal usage */
            if (!fs__namespace$1.statSync(dir).isDirectory) {
                this.context.debug(`skipping cleaning '${dir}' as it is not a directory`);
                return;
            }
            this.context.info(safe.blue(`cleaning cache: ${dir}`));
            fs__namespace$1.removeSync(`${dir}`);
        });
    }
    setDependency(importee, importer) {
        // importee -> importer
        this.context.debug(`${safe.blue('dependency')} '${importee}'`);
        this.context.debug(`    imported by '${importer}'`);
        this.dependencyTree.setEdge(importer, importee);
    }
    walkTree(cb) {
        if (graphlib.alg.isAcyclic(this.dependencyTree))
            return graphlib.alg.topsort(this.dependencyTree).forEach((id) => cb(id));
        this.context.info(safe.yellow('import tree has cycles'));
        this.dependencyTree.nodes().forEach((id) => cb(id));
    }
    done() {
        if (this.noCache)
            return;
        this.context.info(safe.blue('rolling caches'));
        this.codeCache.roll();
        this.semanticDiagnosticsCache.roll();
        this.syntacticDiagnosticsCache.roll();
        this.typesCache.roll();
    }
    getCompiled(id, snapshot, transform) {
        this.context.info(`${safe.blue('transpiling')} '${id}'`);
        // if !isolatedModules, compiled JS code can change if its imports do (e.g. enums). also, declarations can change based on imports as well
        return this.getCached(this.codeCache, id, snapshot, Boolean(!this.options.isolatedModules || this.options.declaration), transform);
    }
    getSyntacticDiagnostics(id, snapshot, check, map) {
        return this.getDiagnostics('syntax', this.syntacticDiagnosticsCache, id, snapshot, check, map);
    }
    getSemanticDiagnostics(id, snapshot, check, map) {
        return this.getDiagnostics('semantic', this.semanticDiagnosticsCache, id, snapshot, check, map);
    }
    checkAmbientTypes() {
        this.context.debug(safe.blue('Ambient types:'));
        const typeHashes = this.ambientTypes
            .filter((snapshot) => snapshot.snapshot !== undefined)
            .map((snapshot) => {
            this.context.debug(`    ${snapshot.id}`);
            return this.createHash(snapshot.id, snapshot.snapshot);
        });
        // types dirty if any d.ts changed, added or removed
        this.ambientTypesDirty = !this.typesCache.match(typeHashes);
        if (this.ambientTypesDirty)
            this.context.info(safe.yellow('ambient types changed, redoing all semantic diagnostics'));
        typeHashes.forEach(this.typesCache.touch, this.typesCache);
    }
    getDiagnostics(type, cache, id, snapshot, check, map) {
        // don't need to check imports for syntactic diagnostics (per https://github.com/microsoft/TypeScript/wiki/Using-the-Language-Service-API#design-goals)
        return this.getCached(cache, id, snapshot, type === 'semantic', () => convertDiagnostic(type, check(), map));
    }
    getCached(cache, id, snapshot, checkImports, convert) {
        if (this.noCache)
            return convert();
        const hash = this.createHash(id, snapshot);
        this.context.debug(`    cache: '${cache.path(hash)}'`);
        if (cache.exists(hash) && !this.isDirty(id, checkImports)) {
            this.context.debug(safe.green('    cache hit'));
            const data = cache.read(hash);
            if (data) {
                cache.write(hash, data);
                return data;
            } /* istanbul ignore next -- should only happen when corrupted cache */
            else
                this.context.warn(safe.yellow('    cache broken, discarding'));
        }
        this.context.debug(safe.yellow('    cache miss'));
        const convertedData = convert();
        cache.write(hash, convertedData);
        this.markAsDirty(id);
        return convertedData;
    }
    init() {
        this.codeCache = new RollingCache(`${this.cacheDir}/code`);
        this.typesCache = new RollingCache(`${this.cacheDir}/types`);
        this.syntacticDiagnosticsCache = new RollingCache(`${this.cacheDir}/syntacticDiagnostics`);
        this.semanticDiagnosticsCache = new RollingCache(`${this.cacheDir}/semanticDiagnostics`);
    }
    markAsDirty(id) {
        this.dependencyTree.setNode(id, { dirty: true });
    }
    /** @returns true if node, any of its imports, or any ambient types changed */
    isDirty(id, checkImports) {
        const label = this.dependencyTree.node(id);
        if (!label)
            return false;
        if (!checkImports || label.dirty)
            return label.dirty;
        if (this.ambientTypesDirty)
            return true;
        const dependencies = graphlib.alg.dijkstra(this.dependencyTree, id);
        return Object.keys(dependencies).some((node) => {
            const dependency = dependencies[node];
            if (!node || dependency.distance === Infinity)
                return false;
            const l = this.dependencyTree.node(node);
            const dirty = l === undefined ? true : l.dirty;
            if (dirty)
                this.context.debug(`    import changed: ${node}`);
            return dirty;
        });
    }
    /** @returns an FS-safe hash string for use as a path to the cached content */
    createHash(id, snapshot) {
        const data = snapshot.getText(0, snapshot.getLength());
        return objHash({
            data,
            id,
            compilerVersion: process.env.HX_Version || process.env.UNI_COMPILER_VERSION,
        }, this.hashOptions);
    }
}

// The injected id for helpers.
const TSLIB = 'tslib';
const TSLIB_VIRTUAL = '\0tslib.js';

// const debugUTS2JS = debug('uts2js')
// these use globals during testing and are substituted by rollup-plugin-re during builds
const TS_VERSION_RANGE = ">=5.0.0";
const ROLLUP_VERSION_RANGE = ">=3.0.0";
const ROLLUP_PLUGIN_UTS_VERSION = "1.0.0";
function buildEasycomsDts(usedEasycom) {
    let importVueCode = '';
    let declareInstanceCode = '';
    usedEasycom.forEach((easycom, easycomCompName) => {
        const easycomName = _.kebabCase(easycomCompName);
        const easycomPath = easycomName.replace(easycom.pattern, easycom.replacement);
        importVueCode += `import ${easycomCompName} from '${easycomPath}'\n`;
        declareInstanceCode += `  type ${easycomCompName}ComponentPublicInstance = InstanceType<typeof ${easycomCompName}>\n`;
    });
    return `${importVueCode}
declare global {
${declareInstanceCode}
}`;
}
function filterEasycoms(easycoms, easycomUsage) {
    const usedEasycom = new Map();
    easycomUsage.forEach((_$1, easycomCompName) => {
        const easycomName = _.kebabCase(easycomCompName);
        const easycom = easycoms.find((easycom) => {
            /**
             * 由组件名并不能准确推导出匹配的easycom，如
             * test-type-1 => TestType1
             * test-type1 => TestType1
             * 此处稍微兼容了上面的场景，但是并不完善
             */
            return (easycom.pattern.test(easycomName) ||
                _.upperFirst(_.camelCase(easycom.name)) === easycomCompName);
        });
        easycom && usedEasycom.set(easycomCompName, easycom);
    });
    return usedEasycom;
}
class Uts2jsSourceCodeMap extends events.EventEmitter {
    constructor() {
        super();
        this._codeMap = new Map();
        this._easycomUsage = new Map();
        this._easycoms = [];
    }
    has(key) {
        return this._codeMap.has(pluginutils.normalizePath(key));
    }
    set(key, value) {
        const realKey = pluginutils.normalizePath(key);
        const content = this.get(realKey);
        if (content === value) {
            return;
        }
        this._codeMap.set(key, value);
        this.emit('change', { fileName: realKey, source: value });
    }
    get(key) {
        return this._codeMap.get(pluginutils.normalizePath(key));
    }
    forEach(callback) {
        this._codeMap.forEach(callback);
    }
    initUts2jsEasycom(easycoms = this._easycoms) {
        this._easycoms = easycoms || [];
        this.set('/__uts2js_vfs__/shim-uni-easycom.d.ts', buildEasycomsDts(filterEasycoms(this._easycoms, this._easycomUsage)));
    }
    setEasycomUsage(fileName, easycomCompNames = []) {
        fileName = pluginutils.normalizePath(fileName);
        // 移除可能存在的旧引用
        this._easycomUsage.forEach((value, key) => {
            if (!easycomCompNames.includes(key)) {
                value.delete(fileName);
                if (value.size === 0) {
                    this._easycomUsage.delete(key);
                }
            }
        });
        for (let i = 0; i < easycomCompNames.length; i++) {
            const easycomCompName = easycomCompNames[i];
            if (!this._easycomUsage.has(easycomCompName)) {
                this._easycomUsage.set(easycomCompName, new Set([fileName]));
            }
            else {
                this._easycomUsage.get(easycomCompName)?.add(fileName);
            }
        }
        this.initUts2jsEasycom();
    }
}
const typescript = (options) => {
    let watchMode = false;
    let supportsThisLoad = false;
    let generateRound = 0;
    let rollupOptions;
    let context;
    let filter;
    let parsedConfig;
    let tsConfigPath;
    let servicesHost;
    let service;
    let documentRegistry; // keep the same DocumentRegistry between watch cycles
    let cache;
    let noErrors = true;
    let transformedFiles;
    const declarations = {};
    const checkedFiles = new Set();
    const getDiagnostics = (id, snapshot, map) => {
        return cache
            .getSyntacticDiagnostics(id, snapshot, () => {
            return service.getSyntacticDiagnostics(id);
        }, map)
            .concat(cache.getSemanticDiagnostics(id, snapshot, () => {
            return service.getSemanticDiagnostics(id);
        }, map));
    };
    const typecheckFile = (id, snapshot, tcContext, map) => {
        if (!snapshot)
            return;
        id = pluginutils.normalizePath(id);
        checkedFiles.add(id); // must come before print, as that could bail
        const diagnostics = getDiagnostics(id, snapshot, map);
        printDiagnostics(tcContext, diagnostics, parsedConfig.options.pretty !== false);
        if (diagnostics.length > 0)
            noErrors = false;
    };
    const addDeclaration = (id, result) => {
        if (!result.dts)
            return;
        const key = pluginutils.normalizePath(id);
        declarations[key] = { type: result.dts, map: result.dtsmap };
        context.debug(() => `${safe.blue('generated declarations')} for '${key}'`);
    };
    /** common resolution check -- only resolve files that aren't declarations and pass `filter` */
    const shouldResolve = (id) => {
        if (id.endsWith('.d.ts') || id.endsWith('.d.cts') || id.endsWith('.d.mts'))
            return false;
        if (!filter(id))
            return false;
        return true;
    };
    /** to be called at the end of Rollup's build phase, before output generation */
    const buildDone = () => {
        if (!watchMode && !noErrors)
            context.info(safe.yellow('there were errors or warnings.'));
        cache?.done(); // if there's an initialization error in `buildStart`, such as a `tsconfig` error, the cache may not exist yet
    };
    const pluginOptions = Object.assign({}, {
        check: true,
        verbosity: VerbosityLevel.Warning,
        clean: false,
        cacheRoot: findCacheDir({ name: 'rollup-plugin-uts' }),
        include: ['*.(|u)ts+(|x)', '**/*.(|u)ts+(|x)', '**/*.cts', '**/*.mts'],
        exclude: ['*.d.ts', '**/*.d.ts', '**/*.d.cts', '**/*.d.mts'],
        abortOnError: false,
        rollupCommonJSResolveHack: false,
        tsconfig: undefined,
        useTsconfigDeclarationDir: false,
        tsconfigOverride: {},
        transformers: [],
        tsconfigDefaults: {},
        objectHashIgnoreUnknownHack: false,
        cwd: process.cwd(),
    }, options);
    if (!pluginOptions.typescript) {
        pluginOptions.typescript = require('typescript');
    }
    setTypescriptModule(pluginOptions.typescript, options.modules);
    globalThis.uts2jsSourceCodeMap = new Uts2jsSourceCodeMap();
    const self = {
        name: 'uts',
        options(config) {
            rollupOptions = { ...config };
            return config;
        },
        configureServer(server) {
            server.watcher.addListener('all', (event, filePath) => {
                if (event === 'add' || event === 'unlink') {
                    const key = pluginutils.normalizePath(filePath);
                    if (fsExistsMap.has(key)) {
                        fsExistsMap.delete(key);
                    }
                }
            });
        },
        buildStart() {
            // 调整到 buildStart 中，确保每次都是全新的 documentRegistry
            // 这样可以确保每次 transform 时 getEmitOutput 获取到最新的代码，否则会出现缓存的问题
            // 因为 typescript 内部的 documentRegistry 使用 buckets 做了跨 languageService 的 sourceFile 缓存
            // 标准的 rollup-plugin-typescript2 插件，在 buildStart 时，创建了新的 languageService，当启用 check 时
            // 会在 buildStart 阶段，触发一遍 sourceFile 的构建，此时 version 为 1，然后 transform 阶段 setSnapshot 时
            // version 会变为 2，接着热更新时，会使用新的 languageService，该 service 会使用
            // version 1 与 buckets 中缓存的 version 2 作比较，不一致，则更新为最新的 sourceFile
            // 在 uvue 编译中，uvue 文件在 buildStart 阶段不会触发 version 变化，所以一直是 1，导致二次更新比较失败，始终使用了
            // 首次的缓存信息，故，目前先启用全新 documentRegistry，确保不使用缓存，但会影响速度，
            // 后续将该插件调整为官方@rollup/plugin-typescript?
            // eslint-disable-next-line prefer-const
            documentRegistry = tsModule.createDocumentRegistry();
            context = new RollupContext(pluginOptions.verbosity, pluginOptions.abortOnError, this, 'uts: ');
            watchMode = process.env.ROLLUP_WATCH === 'true' || !!this.meta.watchMode // meta.watchMode was added in 2.14.0 to capture watch via Rollup API (i.e. no env var) (c.f. https://github.com/rollup/rollup/blob/master/CHANGELOG.md#2140)
            ;
            ({ parsedTsConfig: parsedConfig, fileName: tsConfigPath } =
                parseTsConfig(context, pluginOptions));
            // print out all versions and configurations
            context.info(`typescript version: ${tsModule.version}`);
            context.info(`tslib version: ${pluginOptions.utsOptions.tslibVersion}`);
            context.info(`rollup version: ${this.meta.rollupVersion}`);
            if (!semver.satisfies(tsModule.version, TS_VERSION_RANGE, {
                includePrerelease: true,
            }))
                context.error(`Installed TypeScript version '${tsModule.version}' is outside of supported range '${TS_VERSION_RANGE}'`);
            if (!semver.satisfies(this.meta.rollupVersion, ROLLUP_VERSION_RANGE, {
                includePrerelease: true,
            }))
                context.error(`Installed Rollup version '${this.meta.rollupVersion}' is outside of supported range '${ROLLUP_VERSION_RANGE}'`);
            supportsThisLoad = semver.satisfies(this.meta.rollupVersion, '>=2.60.0', {
                includePrerelease: true,
            }); // this.load is 2.60.0+ only (c.f. https://github.com/rollup/rollup/blob/master/CHANGELOG.md#2600)
            if (!supportsThisLoad)
                context.warn(() => `${safe.yellow("You are using a Rollup version '<2.60.0'")}. This may result in type-only files being ignored.`);
            context.info(`rollup-plugin-uts version: ${ROLLUP_PLUGIN_UTS_VERSION}`);
            context.debug(() => `plugin options:\n${JSON.stringify(pluginOptions, (key, value) => key === 'typescript'
                ? `version ${value.version}`
                : value, 4)}`);
            context.debug(() => `rollup config:\n${JSON.stringify(rollupOptions, undefined, 4)}`);
            context.debug(() => `tsconfig path: ${tsConfigPath}`);
            if (pluginOptions.objectHashIgnoreUnknownHack)
                context.warn(() => `${safe.yellow("You are using 'objectHashIgnoreUnknownHack' option")}. If you enabled it because of async functions, try disabling it now.`);
            if (pluginOptions.rollupCommonJSResolveHack)
                context.warn(() => `${safe.yellow("You are using 'rollupCommonJSResolveHack' option")}. This is no longer needed, try disabling it now.`);
            if (watchMode)
                context.info(`running in watch mode`);
            filter = createFilter(context, pluginOptions, parsedConfig);
            servicesHost = new LanguageServiceHost(parsedConfig, pluginOptions.transformers, pluginOptions.cwd);
            globalThis.uts2jsSourceCodeMap.forEach((source, fileName) => {
                servicesHost.setSnapshot(fileName, source);
            });
            servicesHost.setSnapshot(TSLIB, pluginOptions.utsOptions.tslibSource);
            globalThis.uts2jsSourceCodeMap.on('change', function (options) {
                const { fileName, source } = options || {};
                servicesHost.setSnapshot(fileName, source);
            });
            service = tsModule.createLanguageService(servicesHost, documentRegistry);
            servicesHost.setLanguageService(service);
            const runClean = pluginOptions.clean;
            const noCache = pluginOptions.noCache || pluginOptions.clean;
            cache = new TsCache(noCache, runClean, pluginOptions.objectHashIgnoreUnknownHack, servicesHost, pluginOptions.cacheRoot, parsedConfig.options, parsedConfig.fileNames, context);
            // reset transformedFiles Set on each watch cycle
            transformedFiles = new Set();
            // printing compiler option errors
            if (pluginOptions.check) {
                const diagnostics = convertDiagnostic('options', service.getCompilerOptionsDiagnostics());
                printDiagnostics(context, diagnostics, parsedConfig.options.pretty !== false);
                if (diagnostics.length > 0)
                    noErrors = false;
            }
        },
        watchChange(id, change) {
            const key = pluginutils.normalizePath(id);
            delete declarations[key];
            checkedFiles.delete(key);
            // 此处仅在被依赖的文件变动时触发，不如devServer watch内准确，比如.d.ts文件变动不会触发。编译安卓、iOS时无法使用devServer回退为此方案
            if (process.env.UNI_UTS_PLATFORM === 'web') {
                return;
            }
            const { event } = change || {};
            if (event === 'create' || event === 'delete') {
                if (fsExistsMap.has(key)) {
                    fsExistsMap.delete(key);
                }
            }
        },
        resolveId(importee, importer) {
            if (importee === TSLIB)
                return TSLIB_VIRTUAL;
            if (!importer)
                return;
            importer = pluginutils.normalizePath(importer);
            // TODO: use module resolution cache
            const result = tsModule.nodeModuleNameResolver(importee, importer, parsedConfig.options, tsModule.sys);
            let resolved = result.resolvedModule?.resolvedFileName;
            if (!resolved)
                return;
            if (utsFileNames.has(pluginutils.normalizePath(resolved))) {
                resolved = resolved.replace('.ts', '.uts');
            }
            if (/.u?vue.ts$/.test(resolved)) {
                resolved = resolved.replace(/.ts$/, '');
                return path.normalize(resolved);
            }
            if (!shouldResolve(resolved))
                return;
            cache.setDependency(resolved, importer);
            context.debug(() => `${safe.blue('resolving')} '${importee}' imported by '${importer}'`);
            context.debug(() => `    to '${resolved}'`);
            return path.normalize(resolved); // use host OS separators to fix Windows issue: https://github.com/ezolenko/rollup-plugin-typescript2/pull/251
        },
        load(id) {
            if (id === TSLIB_VIRTUAL)
                return pluginOptions.utsOptions.tslibSource;
            return null;
        },
        async transform(code, id) {
            transformedFiles.add(id); // note: this does not need normalization as we only compare Rollup <-> Rollup, and not Rollup <-> TS
            // 检索文件中使用到的easycom
            const easycomMatches = code.matchAll(/([a-zA-Z0-9]+)ComponentPublicInstance/g);
            const easycomCompNames = [];
            for (const match of easycomMatches) {
                easycomCompNames.push(match[1]);
            }
            easycomCompNames.length > 0 &&
                globalThis.uts2jsSourceCodeMap.setEasycomUsage(pluginutils.normalizePath(id), easycomCompNames);
            let transformId = id;
            if (transformId.endsWith('.json')) {
                transformId = transformId.replace(/.json$/, '.uts');
            }
            if (!filter(transformId))
                return undefined;
            // const start = Date.now()
            const snapshot = servicesHost.setSnapshot(transformId, code);
            // getting compiled file from cache or from ts
            const result = cache.getCompiled(transformId, snapshot, () => {
                let output;
                // 输出uts (带类型)
                const sourceFile = service.getProgram()?.getSourceFile(transformId);
                if (pluginOptions.utsOptions.emitType === 'uts') {
                    const outputFiles = [];
                    if (!sourceFile) {
                        this.error(new Error(`Could not find source file: '${id}'.`));
                    }
                    else {
                        const printer = tsModule.createPrinter({});
                        const result = printer.printSourceFile(sourceFile, {
                            host: formatHost,
                            map: {
                                file: pluginutils.normalizePath(path.relative(pluginOptions.utsOptions.inputDir ?? '', id)),
                                sourceRoot: '',
                                sourcesDirectoryPath: pluginOptions.utsOptions.inputDir ?? '',
                            },
                        });
                        if (result.code) {
                            outputFiles.push({
                                name: '',
                                writeByteOrderMark: false,
                                text: result.code,
                            });
                        }
                        if (result.map) {
                            outputFiles.push({
                                name: '.map',
                                writeByteOrderMark: false,
                                text: result.map,
                            });
                        }
                    }
                    output = {
                        outputFiles,
                        emitSkipped: false,
                    };
                }
                else {
                    // 输出 js
                    try {
                        output = service.getEmitOutput(transformId);
                    }
                    catch (e) {
                        // 拦截 transform 阶段主动 throw 出来的错误
                        if (e instanceof Error && e.diagnostic) {
                            const diagnostics = convertDiagnostic('transform', [e.diagnostic], new sourceMapJs.SourceMapConsumer(this.getCombinedSourcemap()));
                            // web平台内部会再走一遍sourcemap解析，其他平台不会走，需要自行处理
                            const errorKey = pluginOptions.utsOptions.platform === 'web'
                                ? 'rollupError'
                                : 'finalRollupError';
                            if (diagnostics[0][errorKey]) {
                                this.error(diagnostics[0][errorKey]);
                            }
                        }
                        throw e;
                    }
                }
                if (output.emitSkipped) {
                    noErrors = false;
                    // always checking on fatal errors, even if options.check is set to false
                    typecheckFile(transformId, snapshot, context, options?.abortOnError
                        ? undefined
                        : new sourceMapJs.SourceMapConsumer(this.getCombinedSourcemap()));
                    // since no output was generated, aborting compilation
                    this.error(safe.red(`Emit skipped for '${id}'. See https://github.com/microsoft/TypeScript/issues/49790 for potential reasons why this may occur`));
                }
                const references = getAllReferences(transformId, snapshot, parsedConfig.options);
                return convertEmitOutput(output, references, [
                    ...(sourceFile?.__utsMeta?.uniExtApis || []),
                ]);
            });
            if (pluginOptions.check)
                typecheckFile(transformId, snapshot, context, new sourceMapJs.SourceMapConsumer(this.getCombinedSourcemap()));
            if (!result)
                return undefined;
            if (watchMode && result.references) {
                if (tsConfigPath)
                    this.addWatchFile(tsConfigPath);
                result.references.map(this.addWatchFile, this);
                context.debug(() => `${safe.green('    watching')}: ${result.references.join('\nuts:               ')}`);
            }
            addDeclaration(id, result);
            // handle all type-only imports by resolving + loading all of TS's references
            // Rollup can't see these otherwise, because they are "emit-less" and produce no JS
            if (result.references && supportsThisLoad) {
                for (const ref of result.references) {
                    // pre-emptively filter out files that we don't resolve ourselves (e.g. declarations). don't add new files to Rollup's pipeline if we can't resolve them
                    if (!shouldResolve(ref))
                        continue;
                    const module = await this.resolve(ref, id);
                    if (!module || transformedFiles.has(module.id))
                        // check for circular references (per https://rollupjs.org/guide/en/#thisload)
                        continue;
                    // wait for all to be loaded (otherwise, as this is async, some may end up only loading after `generateBundle`)
                    await this.load({ id: module.id });
                }
            }
            // if a user sets this compilerOption, they probably want another plugin (e.g. Babel, ESBuild) to transform their TS instead, while rpt2 just type-checks and/or outputs declarations
            // note that result.code is non-existent if emitDeclarationOnly per https://github.com/ezolenko/rollup-plugin-typescript2/issues/268
            if (parsedConfig.options.emitDeclarationOnly) {
                context.debug(() => `${safe.blue('emitDeclarationOnly')} enabled, not transforming TS`);
                return undefined;
            }
            const transformResult = {
                code: result.code,
                map: { mappings: '' },
                meta: {
                    uniExtApis: result.uniExtApis ? [...result.uniExtApis] : [],
                },
            };
            if (result.map) {
                pluginOptions.sourceMapCallback?.(id, result.map);
                const map = JSON.parse(result.map);
                if (map.sourceRoot) {
                    map.sources = map.sources.map((source) => {
                        if (!path.isAbsolute(source)) {
                            return map.sourceRoot + source;
                        }
                        return source;
                    });
                }
                transformResult.map = map;
            }
            // debugUTS2JS(`${Date.now() - start}ms ${id}`)
            return transformResult;
        },
        buildEnd(err) {
            generateRound = 0; // in watch mode, buildEnd resets generate count just before generateBundle for each output
            if (err) {
                buildDone();
                this.error(err);
            }
            if (!pluginOptions.check)
                return buildDone();
            // walkTree once on each cycle when in watch mode
            if (watchMode) {
                cache.walkTree((id) => {
                    if (!filter(id))
                        return;
                    const snapshot = servicesHost.getScriptSnapshot(id);
                    typecheckFile(id, snapshot, context);
                });
            }
            // type-check missed files as well
            parsedConfig.fileNames.forEach((name) => {
                const key = pluginutils.normalizePath(name);
                if (checkedFiles.has(key) || !filter(key))
                    // don't duplicate if it's already been checked
                    return;
                context.debug(() => `type-checking missed '${key}'`);
                const snapshot = servicesHost.getScriptSnapshot(key);
                typecheckFile(key, snapshot, context);
            });
            buildDone();
        },
        generateBundle(_output) {
            context.debug(() => `generating target ${generateRound + 1}`);
            generateRound++;
            if (!parsedConfig.options.declaration)
                return;
            parsedConfig.fileNames.forEach((name) => {
                const key = pluginutils.normalizePath(name);
                if (key in declarations || !filter(key))
                    return;
                context.debug(() => `generating missed declarations for '${key}'`);
                const out = convertEmitOutput(service.getEmitOutput(key, true));
                addDeclaration(key, out);
            });
            const emitDeclaration = (key, extension, entry) => {
                if (!entry)
                    return;
                let fileName = entry.name;
                if (fileName.includes('?'))
                    // HACK for rollup-plugin-vue, it creates virtual modules in form 'file.vue?rollup-plugin-vue=script.ts'
                    fileName = fileName.split('?', 1) + extension;
                // If 'useTsconfigDeclarationDir' is in plugin options, directly write to 'declarationDir'.
                // This may not be under Rollup's output directory, and thus can't be emitted as an asset.
                if (pluginOptions.useTsconfigDeclarationDir) {
                    context.debug(() => `${safe.blue('emitting declarations')} for '${key}' to '${fileName}'`);
                    tsModule.sys.writeFile(fileName, entry.text, entry.writeByteOrderMark);
                    return;
                }
                // don't mutate the entry because generateBundle gets called multiple times
                let entryText = entry.text;
                const cachePlaceholder = `${pluginOptions.cacheRoot}/placeholder`;
                // modify declaration map sources to correct relative path (only if outputting)
                if (extension === '.d.ts.map' && (_output?.file || _output?.dir)) {
                    const declarationDir = (_output.file ? path.dirname(_output.file) : _output.dir);
                    const parsedText = JSON.parse(entryText);
                    // invert back to absolute, then make relative to declarationDir
                    parsedText.sources = parsedText.sources.map((source) => {
                        const absolutePath = path.resolve(cachePlaceholder, source);
                        return pluginutils.normalizePath(path.relative(declarationDir, absolutePath));
                    });
                    entryText = JSON.stringify(parsedText);
                }
                const relativePath = pluginutils.normalizePath(path.relative(cachePlaceholder, fileName));
                context.debug(() => `${safe.blue('emitting declarations')} for '${key}' to '${relativePath}'`);
                this.emitFile({
                    type: 'asset',
                    source: entryText,
                    fileName: relativePath,
                });
            };
            Object.keys(declarations).forEach((key) => {
                const { type, map } = declarations[key];
                emitDeclaration(key, '.d.ts', type);
                emitDeclaration(key, '.d.ts.map', map);
            });
        },
    };
    return self;
};

const __url = url.pathToFileURL(__filename).href;
const __dirname$1 = path.dirname(url.fileURLToPath(__url));
const require$1 = module$1.createRequire(__url);
let hacked = false;
function uts2js({ inputDir, modules, ...options }) {
    if (!hacked) {
        hacked = true;
        globalThis.__utsHacker__ = {
            ...globalThis.__utsHacker__,
            ...hacker,
        };
    }
    const include = options.include ?? [
        '**/*.uts',
        '**/*.ts',
        // '**/*.uvue',
        // '**/*.vue',
    ];
    const ts = options.typescript ?? require$1('typescript');
    const rputsOptions = {
        ...options,
        modules: modules || {},
        include,
        typescript: ts,
        transformers: [
            parseTransformer(ts, transformers, {
                platform: options.platform,
                targetLanguage: 'JavaScript',
                setParentRecursive: true,
                transformCreateWorker: {
                    extname: options.workers?.extname,
                    resolveWorkers: options.workers?.resolve || (() => ({})),
                },
            }),
        ],
        utsOptions: {
            platform: options.platform,
            tslibSource: fs.readFileSync(path.resolve(__dirname$1, '../lib/runtime/index.js'), 'utf8'),
        },
    };
    if (!rputsOptions.tsconfigOverride) {
        rputsOptions.tsconfigOverride = {
            compilerOptions: {},
        };
    }
    if (!rputsOptions.tsconfigOverride.compilerOptions) {
        rputsOptions.tsconfigOverride.compilerOptions = {};
    }
    const overrideCompilerOptions = rputsOptions.tsconfigOverride.compilerOptions;
    const defaultCompilerOptions = {
        baseUrl: inputDir
            ? path.basename(inputDir) === 'src'
                ? path.dirname(inputDir)
                : inputDir
            : '.',
        moduleResolution: 'Bundler',
        importHelpers: true,
        mapRoot: overrideCompilerOptions.sourceMap ? inputDir : undefined,
        target: 'ES2016',
    };
    for (const key in defaultCompilerOptions) {
        if (!overrideCompilerOptions.hasOwnProperty(key)) {
            overrideCompilerOptions[key] = defaultCompilerOptions[key];
        }
    }
    return [typescript(rputsOptions)];
}

exports.uts2js = uts2js;
