"use strict";var e=require("debug");require("fs"),require("path");const r=e("uts:transformer:importAndExportDeclaration"),t=[e=>{function t(t){const{factory:i}=t;function a(e){if(e.endsWith(".uts")||e.endsWith(".ts"))return e.replace(/.u?ts$/,"")}function s(n){if(e.isImportDeclaration(n)&&n.moduleSpecifier&&e.isStringLiteral(n.moduleSpecifier)){const e=a(n.moduleSpecifier.text);if(e)return r.enabled&&r(n.moduleSpecifier.text,`${e} at ${n.getSourceFile().fileName}`),i.updateImportDeclaration(n,n.modifiers,n.importClause,i.createStringLiteral(e),n.assertClause)}else if(e.isExportDeclaration(n)&&n.moduleSpecifier&&e.isStringLiteral(n.moduleSpecifier)){const e=a(n.moduleSpecifier.text);if(e)return r.enabled&&r(n.moduleSpecifier.text,`${e} at ${n.getSourceFile().fileName}`),i.updateExportDeclaration(n,n.modifiers,n.isTypeOnly,n.exportClause,i.createStringLiteral(e),n.assertClause)}return e.visitEachChild(n,s,t)}return r=>e.visitNode(r,s)}return{parser:{SourceFile:e=>t(e)},afterDeclarations:t}}];var i;function a(e,r,t,i,a,s,n){return{code:e,category:r,key:t,message:i,reportsUnnecessary:a,elidedInCompatabilityPyramid:s,reportsDeprecated:n}}function s(e,r,t,i){return a=>{const s=t(a);return t=>{const n=e.isSourceFile(t);return a.fileName||n&&(a.fileName=t.fileName),r.shouldTransform(a.fileName)?(n&&!t.isUTSFile&&(t.isUTSFile=!0,r.isVueFile?.(a.fileName)&&(t.isVueFile=!0)),n&&"parser"===i&&t.statements.length&&(t.statements[0].parent||e.setParentRecursive(t,!0)),s(t)):t}}}function n(e,r){return r&&r!==e&&!Array.isArray(r)&&(r.__parsedByUtsParser=!0,r.parent=e.parent),r}let o;function l(e,r,t){return function(e){if(!e.ObjectFlags.UTSType){const{Class:r,Interface:t,Reference:i,Anonymous:a,ArrayLiteral:s}=e.ObjectFlags;e.ObjectFlags.UTSType=r|t|i|a|s}if(!e.TypeFlags.UTSType){const{Any:r,String:t,Number:i,Boolean:a,Enum:s,StringLiteral:n,NumberLiteral:o,BooleanLiteral:l,EnumLiteral:c,Void:u,Null:p,Object:f,Union:m,TemplateLiteral:d}=e.TypeFlags;e.TypeFlags.UTSType=r|t|i|a|s|n|o|l|c|u|p|f|m|d,e.TypeFlags.UTSStringLike=t|n|d,e.TypeFlags.UTSNumberLike=i|o}}(e),i=>{const a={},l=[],c=[],u=[];return r.forEach((r=>{let p=r(e,i,t);if("function"==typeof p)l.push(s(e,i,p,"before"));else{if(p.parser){const l=r(function(e){if(o)return o;o={...e};const{visitNode:r,visitEachChild:t}=e;return o.visitNode=(e,t)=>r(e,(e=>n(e,t(e)))),o.visitEachChild=(e,r,i)=>t(e,(e=>n(e,r(e))),i),o}(e),i,t);l.parser&&function(e,r,t,i){i.TypeAliasDeclaration&&(t.TypeAliasDeclaration||(t.TypeAliasDeclaration=[])).push(s(e,r,(e=>{const r=i.TypeAliasDeclaration(e);return e=>n(e,r(e))}),"parser")),i.SourceFile&&(t.SourceFile||(t.SourceFile=[])).push(s(e,r,i.SourceFile,"parser"))}(e,i,a,l.parser)}p.before&&l.push(s(e,i,p.before,"before")),p.after&&c.push(s(e,i,p.after,"after")),p.afterDeclarations&&u.push(s(e,i,p.afterDeclarations,"afterDeclarations"))}})),{parser:a,before:l,after:c,afterDeclarations:u}}}!function(e){e[e.Warning=0]="Warning",e[e.Error=1]="Error",e[e.Suggestion=2]="Suggestion",e[e.Message=3]="Message"}(i||(i={})),a(1e5,i.Error,"Type_literal_property_must_have_a_type_annotation_100000","Type literal property must have a type annotation."),a(100001,i.Error,"Only_one_extends_heritage_clause_is_allowed_for_interface_100001","Only one extends heritage clause is allowed for interface"),a(100002,i.Error,"Variable_declaration_must_have_initializer_100002","Variable declaration must have initializer."),a(100003,i.Error,"Nested_type_literal_is_not_supported_100003","Nested type literal is not supported."),a(100004,i.Error,"Invalid_generic_type_which_can_not_be_constructed_100004","Invalid generic type which can not be constructed."),a(100005,i.Error,"script_setup_cannot_contain_ES_module_exports_100005","`<script setup>` cannot contain ES module exports."),e("uts:transformer:autoImport"),e("uts:transformer:arguments"),e("uts:transformer:generics"),e("uts:transformer:keyof"),e("uts:transformer:narrowType"),e("uts:transformer:objectLiteral"),e("uts:transformer:returnType"),e("uts:transformer:UTSJSONObject"),exports.emitDeclaration=function({typescript:e,inputDir:r,rootFiles:i,compilerOptions:a={}}){const s=e.createCompilerHost(a),n=new Map;s.fileExists=t=>{if(n.has(t))return!0;if(t.startsWith(r))if(t.endsWith(".uts.ts")){const r=t.slice(0,-3);if(e.sys.fileExists(r))return n.set(t,r),!0}else if(t.endsWith(".ts")){const r=t.slice(0,-3)+".uts";if(e.sys.fileExists(r))return n.set(t,r),!0}return e.sys.fileExists(t)},s.readFile=r=>{const t=n.get(r);return t?e.sys.readFile(t):e.sys.readFile(r)};const o=e.createProgram(i,{...a,declaration:!0,emitDeclarationOnly:!0,emitUTS:!0,allowNonTsExtensions:!0,listEmittedFiles:!0},s),{afterDeclarations:c}=l(e,t,{targetLanguage:"Kotlin",setParentRecursive:!1})({getProgram:()=>o,isUTSDeclarationFile:e=>!0,shouldTransform:e=>e.startsWith(r),isVueFile:()=>!1});return o.emit(void 0,void 0,void 0,!0,{afterDeclarations:c},!1===a.noEmitOnError)};
